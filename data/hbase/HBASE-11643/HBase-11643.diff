diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java
index 68018c4..ae3c990 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java
@@ -28,4 +28,7 @@
   public static final byte VISIBILITY_TAG_TYPE = (byte) 2;
   public static final byte LOG_REPLAY_TAG_TYPE = (byte) 3;
   public static final byte VISIBILITY_EXP_SERIALIZATION_TAG_TYPE = (byte)4;
+
+  // mob tags
+  public static final byte MOB_REFERENCE_TAG_TYPE = (byte) 5;
 }
diff --git a/hbase-common/src/main/resources/hbase-default.xml b/hbase-common/src/main/resources/hbase-default.xml
index a4e6578..0b8400d 100644
--- a/hbase-common/src/main/resources/hbase-default.xml
+++ b/hbase-common/src/main/resources/hbase-default.xml
@@ -1364,4 +1364,12 @@ possible configurations would overwhelm and obscure the important.
     <name>hbase.http.staticuser.user</name>
     <value>dr.stack</value>
   </property>
+  <!-- Mob properties. -->
+  <property>
+    <description>
+      How many files could be cached for each region server.
+    </description>
+    <name>hbase.mob.file.cache.size</name>
+    <value>1000</value>
+  </property>
 </configuration>
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/CachedMobFile.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/CachedMobFile.java
new file mode 100644
index 0000000..50acbbb
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/CachedMobFile.java
@@ -0,0 +1,122 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.regionserver.StoreFileScanner;
+
+/**
+ * Cached mob file.
+ */
+@InterfaceAudience.Private
+public class CachedMobFile extends MobFile implements Comparable<CachedMobFile> {
+
+  private long accessTime;
+  private MobFile file;
+  private AtomicLong reference = new AtomicLong(0);
+
+  public CachedMobFile(MobFile file) {
+    this.file = file;
+  }
+
+  public static CachedMobFile create(FileSystem fs, Path path, Configuration conf,
+      MobCacheConfig cacheConf) throws IOException {
+    MobFile file = MobFile.create(fs, path, conf, cacheConf);
+    return new CachedMobFile(file);
+  }
+
+  public void access(long time) {
+    this.accessTime = time;
+  }
+
+  public int compareTo(CachedMobFile that) {
+    if (this.accessTime == that.accessTime)
+      return 0;
+    return this.accessTime < that.accessTime ? 1 : -1;
+  }
+
+  /**
+   * Opens the mob file and increases the reference.
+   */
+  @Override
+  public void open() throws IOException {
+    file.open();
+    reference.incrementAndGet();
+  }
+
+  /**
+   * Closes the mob file and decreases the reference.
+   * This underlying reader isn't closed until the reference is 0.
+   */
+  @Override
+  public void close() throws IOException {
+    long refs = reference.decrementAndGet();
+    if (refs == 0) {
+      this.file.close();
+    }
+  }
+
+  /**
+   * Reads a cell from the mob file.
+   * @param search The cell need to be searched in the mob file.
+   * @param cacheMobBlocks Whether should this scanner cache blocks.
+   * @return The cell in the mob file.
+   * @throws IOException
+   */
+  @Override
+  public Cell readCell(Cell search, boolean cacheMobBlocks) throws IOException {
+    return file.readCell(search, cacheMobBlocks);
+  }
+
+  /**
+   * Gets the file name.
+   * @return The file name.
+   */
+  @Override
+  public String getName() {
+    return file.getName();
+  }
+
+  /**
+   * Internal use only. This is used by the sweeper.
+   *
+   * @return The store file scanner.
+   * @throws IOException
+   */
+  @Override
+  public StoreFileScanner getScanner() throws IOException {
+    return file.getScanner();
+  }
+
+  /**
+   * Gets the reference of the current mob file.
+   *
+   * @return The reference of the current mob file.
+   */
+  public long getReference() {
+    return this.reference.longValue();
+  }
+}
\ No newline at end of file
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobCacheConfig.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobCacheConfig.java
new file mode 100644
index 0000000..e95e601
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobCacheConfig.java
@@ -0,0 +1,54 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.io.hfile.CacheConfig;
+
+/**
+ * The cache configuration for the mob.
+ */
+public class MobCacheConfig extends CacheConfig {
+
+  private static MobFileCache mobFileCache;
+
+  public MobCacheConfig(Configuration conf, HColumnDescriptor family) {
+    super(conf, family);
+    instantiateMobFileCache(conf);
+  }
+
+  /**
+   * Instantiates the MobFileCache.
+   * @param conf The current configuration.
+   */
+  public static synchronized void instantiateMobFileCache(Configuration conf) {
+    if (mobFileCache == null) {
+      mobFileCache = new MobFileCache(conf);
+    }
+  }
+
+  /**
+   * Gets the MobFileCache.
+   * @return The MobFileCache.
+   */
+  public MobFileCache getMobFileCache() {
+    return mobFileCache;
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobConstants.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobConstants.java
new file mode 100644
index 0000000..6945228
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobConstants.java
@@ -0,0 +1,46 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.hbase.util.Bytes;
+
+/**
+ * The constants used in mob.
+ */
+@InterfaceAudience.Public
+public class MobConstants {
+
+  public static final String IS_MOB = "isMob";
+  public static final String SIZE_TAG = "mobSize";
+
+  public static final String MOB_SCAN_RAW = "hbase.mob.scan.raw";
+  public static final String MOB_CACHE_BLOCKS = "hbase.mob.cache.blocks";
+
+  public static final String MOB_FILE_CACHE_SIZE_KEY = "hbase.mob.file.cache.size";
+  public static final int DEFAULT_MOB_FILE_CACHE_SIZE = 1000;
+
+  public static final String MOB_DIR_NAME = "mobdir";
+  public static final String MOB_REGION_NAME = ".mob";
+  public static final byte[] MOB_REGION_NAME_BYTES = Bytes.toBytes(MOB_REGION_NAME);
+
+  private MobConstants() {
+
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobFile.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobFile.java
new file mode 100644
index 0000000..0c1e341
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobFile.java
@@ -0,0 +1,144 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.io.hfile.CacheConfig;
+import org.apache.hadoop.hbase.regionserver.BloomType;
+import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFileScanner;
+
+/**
+ * The mob file.
+ */
+@InterfaceAudience.Private
+public class MobFile {
+
+  private StoreFile sf;
+
+  // internal use only for sub classes
+  protected MobFile() {
+  }
+
+  protected MobFile(StoreFile sf) {
+    this.sf = sf;
+  }
+
+  /**
+   * Internal use only. This is used by the sweeper.
+   *
+   * @return The store file scanner.
+   * @throws IOException
+   */
+  public StoreFileScanner getScanner() throws IOException {
+    List<StoreFile> sfs = new ArrayList<StoreFile>();
+    sfs.add(sf);
+    sf.createReader();
+    List<StoreFileScanner> sfScanners = StoreFileScanner.getScannersForStoreFiles(sfs, false, true,
+        false, null, sf.getMaxMemstoreTS());
+
+    if (!sfScanners.isEmpty()) {
+      return sfScanners.get(0);
+    }
+    return null;
+  }
+
+  /**
+   * Reads a cell from the mob file.
+   * @param search The cell need to be searched in the mob file.
+   * @param cacheMobBlocks Whether should this scanner cache blocks.
+   * @return The cell in the mob file.
+   * @throws IOException
+   */
+  public Cell readCell(Cell search, boolean cacheMobBlocks) throws IOException {
+    Cell result = null;
+    StoreFileScanner scanner = null;
+    List<StoreFile> sfs = new ArrayList<StoreFile>();
+    sfs.add(sf);
+    try {
+      sf.createReader();
+      List<StoreFileScanner> sfScanners = StoreFileScanner.getScannersForStoreFiles(sfs,
+          cacheMobBlocks, true, false, null, sf.getMaxMemstoreTS());
+      if (!sfScanners.isEmpty()) {
+        scanner = sfScanners.get(0);
+        if (scanner.seek(search)) {
+          result = scanner.peek();
+        }
+      }
+    } finally {
+      if (scanner != null) {
+        scanner.close();
+      }
+    }
+    return result;
+  }
+
+  /**
+   * Gets the file name.
+   * @return The file name.
+   */
+  public String getName() {
+    return sf.getPath().getName();
+  }
+
+  /**
+   * Opens the underlying reader.
+   * @throws IOException
+   */
+  public void open() throws IOException {
+    if (sf.getReader() == null) {
+      sf.createReader();
+    }
+  }
+
+  /**
+   * Closes the underlying reader, but do no evict blocks belonging to this file.
+   *
+   * @throws IOException
+   */
+  public void close() throws IOException {
+    if (null != sf) {
+      sf.closeReader(false);
+      sf = null;
+    }
+  }
+
+  /**
+   * Creates an instance of the MobFile.
+   * @param fs The file system.
+   * @param path The path of the underlying StoreFile.
+   * @param conf The configuration.
+   * @param cacheConf The CacheConfig.
+   * @return An instance of the MobFile.
+   * @throws IOException
+   */
+  public static MobFile create(FileSystem fs, Path path, Configuration conf, CacheConfig cacheConf)
+      throws IOException {
+    StoreFile sf = new StoreFile(fs, path, conf, cacheConf, BloomType.NONE);
+    return new MobFile(sf);
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobFileCache.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobFileCache.java
new file mode 100644
index 0000000..ea063bf
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobFileCache.java
@@ -0,0 +1,246 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.util.IdLock;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+
+/**
+ * The cache for mob files.
+ * This cache doesn't cache the mob file blocks. It only caches the references of mob files.
+ */
+@InterfaceAudience.Private
+public class MobFileCache {
+
+  private static final Log LOG = LogFactory.getLog(MobFileCache.class);
+
+  /*
+   * Eviction and statistics thread. Periodically run to print the statistics and
+   * evict the lru cached mob files when the count of the cached files is larger
+   * than the threshold.
+   */
+  static class EvictionThread extends Thread {
+    MobFileCache lru;
+
+    public EvictionThread(MobFileCache lru) {
+      super("MobFileCache.EvictionThread");
+      setDaemon(true);
+      this.lru = lru;
+    }
+
+    @Override
+    public void run() {
+      lru.evict();
+    }
+  }
+
+  private Map<String, CachedMobFile> map = null;
+  /* Cache access count (sequential ID) */
+  private final AtomicLong count;
+  private final AtomicLong miss;
+
+  private final ReentrantLock evictionLock = new ReentrantLock(true);
+
+  private IdLock keyLock = new IdLock();
+
+  private final ScheduledExecutorService scheduleThreadPool = Executors.newScheduledThreadPool(1,
+      new ThreadFactoryBuilder().setNameFormat("MobFileCache #%d").setDaemon(true).build());
+  private Configuration conf;
+
+  private static final float DEFAULT_EVICT_REMAIN_RATIO = 0.5f;
+
+  // the count of the cached references to mob files
+  private int mobFileCacheSize;
+  private boolean isCacheEnabled = false;
+  private float evictRemainRatio;
+
+  public MobFileCache(Configuration conf) {
+    this.conf = conf;
+    this.mobFileCacheSize = conf.getInt(MobConstants.MOB_FILE_CACHE_SIZE_KEY,
+        MobConstants.DEFAULT_MOB_FILE_CACHE_SIZE);
+    isCacheEnabled = (mobFileCacheSize > 0);
+    map = new ConcurrentHashMap<String, CachedMobFile>(mobFileCacheSize);
+    this.count = new AtomicLong(0);
+    this.miss = new AtomicLong(0);
+    if (isCacheEnabled) {
+      long period = conf.getInt("hbase.mob.cache.evict.period", 3600); // in seconds
+      evictRemainRatio = conf.getFloat("hbase.mob.cache.evict.remain.ratio",
+          DEFAULT_EVICT_REMAIN_RATIO);
+      this.scheduleThreadPool.scheduleAtFixedRate(new EvictionThread(this), period, period,
+          TimeUnit.SECONDS);
+    }
+    LOG.info("MobFileCache is initialized, and the cache size is " + mobFileCacheSize);
+  }
+
+  /**
+   * Evicts the lru cached mob files when the count of the cached files is larger
+   * than the threshold.
+   */
+  public void evict() {
+    if (isCacheEnabled) {
+      // Ensure only one eviction at a time
+      printStatistics();
+      if (!evictionLock.tryLock()) {
+        return;
+      }
+      try {
+        if (map.size() <= mobFileCacheSize) {
+          return;
+        }
+        List<CachedMobFile> files = new ArrayList<CachedMobFile>(map.size());
+        for (CachedMobFile file : map.values()) {
+          files.add(file);
+        }
+        Collections.sort(files);
+        int start = (int) (mobFileCacheSize * evictRemainRatio);
+        for (int i = start; i < files.size(); i++) {
+          String name = files.get(i).getName();
+          CachedMobFile deletedFile = map.remove(name);
+          if (null != deletedFile) {
+            try {
+              deletedFile.close();
+            } catch (IOException e) {
+              LOG.error(e.getMessage(), e);
+            }
+          }
+        }
+      } finally {
+        evictionLock.unlock();
+      }
+    }
+  }
+
+  /**
+   * Evicts the cached file by the name.
+   * @param fileName The name of a cached file.
+   */
+  public void evictFile(String fileName) {
+    if (isCacheEnabled) {
+      IdLock.Entry lockEntry = null;
+      try {
+        lockEntry = keyLock.getLockEntry(fileName.hashCode());
+        CachedMobFile deletedFile = map.remove(fileName);
+        if (null != deletedFile) {
+          deletedFile.close();
+        }
+      } catch (IOException e) {
+        LOG.error("Fail to evict the file " + fileName, e);
+      } finally {
+        if (lockEntry != null) {
+          keyLock.releaseLockEntry(lockEntry);
+        }
+      }
+    }
+  }
+
+  /**
+   * Opens a mob file.
+   * @param fs The current file system.
+   * @param path The file path.
+   * @param cacheConf The current MobCacheConfig
+   * @return A opened mob file.
+   * @throws IOException
+   */
+  public MobFile openFile(FileSystem fs, Path path, MobCacheConfig cacheConf) throws IOException {
+    if (!isCacheEnabled) {
+      return MobFile.create(fs, path, conf, cacheConf);
+    } else {
+      String fileName = path.getName();
+      CachedMobFile cached = map.get(fileName);
+      IdLock.Entry lockEntry = keyLock.getLockEntry(fileName.hashCode());
+      try {
+        if (null == cached) {
+          cached = map.get(fileName);
+          if (null == cached) {
+            if (map.size() > mobFileCacheSize) {
+              evict();
+            }
+            cached = CachedMobFile.create(fs, path, conf, cacheConf);
+            cached.open();
+            map.put(fileName, cached);
+          }
+          miss.incrementAndGet();
+        }
+        cached.open();
+        cached.access(count.incrementAndGet());
+      } finally {
+        keyLock.releaseLockEntry(lockEntry);
+      }
+      return cached;
+    }
+  }
+
+  /**
+   * Closes a mob file.
+   * @param file The mob file that needs to be closed.
+   */
+  public void closeFile(MobFile file) {
+    IdLock.Entry lockEntry = null;
+    try {
+      lockEntry = keyLock.getLockEntry(file.getName().hashCode());
+      file.close();
+    } catch (IOException e) {
+      LOG.error("MobFileCache, Exception happen during close " + file.getName(), e);
+    } finally {
+      if (lockEntry != null) {
+        keyLock.releaseLockEntry(lockEntry);
+      }
+    }
+  }
+
+  /**
+   * Gets the count of cached mob files.
+   * @return The count of the cached mob files.
+   */
+  public int getCacheSize() {
+    return map == null ? 0 : map.size();
+  }
+
+  /**
+   * Prints the statistics.
+   */
+  public void printStatistics() {
+    long access = count.get();
+    long missed = miss.get();
+    LOG.info("MobFileCache Statistics, access: " + access + ", miss: " + missed + ", hit: "
+        + (access - missed) + ", hit rate: "
+        + ((access == 0) ? 0 : ((access - missed) * 100 / access)) + "%");
+
+  }
+
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobFileName.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobFileName.java
new file mode 100644
index 0000000..1d9d48d
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobFileName.java
@@ -0,0 +1,181 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import java.security.InvalidParameterException;
+
+import org.apache.hadoop.hbase.util.Bytes;
+
+/**
+ * The mob file name.
+ * It consists of a checksum of a start key, a date and an uuid.
+ * It looks like checksum(start) + date + uuid.
+ * <ol>
+ * <li>0-7 characters: checksum of a start key. Since the length of the start key is not
+ * fixed, have to use the checksum instead which has a fix length.</li>
+ * <li>8-15 characters: a string of a date with format yyyymmdd. The date is the latest timestamp
+ * of cells in this file</li>
+ * <li>the remaining characters: the uuid.</li>
+ * </ol>
+ */
+public class MobFileName {
+
+  private final String date;
+  private final int startKey;
+  private final String uuid;
+  private String fileName;
+
+  private final static char[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a',
+      'b', 'c', 'd', 'e', 'f' };
+
+  /**
+   * @param startKey
+   *          The checksum of the start key.
+   * @param date
+   *          The string of the latest timestamp of cells in this file, the format is yyyymmdd.
+   * @param uuid
+   *          The uuid
+   */
+  private MobFileName(int startKey, String date, String uuid) {
+    this.startKey = startKey;
+    this.uuid = uuid;
+    this.date = date;
+    this.fileName = int2HexString(startKey) + date + uuid;
+  }
+
+  /**
+   * Creates an instance of MobFileName
+   * 
+   * @param startKey
+   *          The start key.
+   * @param date
+   *          The string of the latest timestamp of cells in this file, the format is yyyymmdd.
+   * @param uuid The uuid.
+   * @return An instance of a MobFileName.
+   */
+  public static MobFileName create(String startKey, String date, String uuid) {
+    return new MobFileName(hexString2Int(startKey), date, uuid);
+  }
+
+  /**
+   * Creates an instance of MobFileName.
+   * @param fileName The string format of a file name.
+   * @return An instance of a MobFileName.
+   */
+  public static MobFileName create(String fileName) {
+    int startKey = hexString2Int(fileName.substring(0, 8));
+    String date = fileName.substring(8, 16);
+    String uuid = fileName.substring(16);
+    return new MobFileName(startKey, date, uuid);
+  }
+
+  /**
+   * Converts an integer to a hex string.
+   * @param i An integer.
+   * @return A hex string.
+   */
+  public static String int2HexString(int i) {
+    int shift = 4;
+    char[] buf = new char[8];
+
+    int charPos = 8;
+    int mask = 15;
+    do {
+      buf[--charPos] = digits[i & mask];
+      i >>>= shift;
+    } while (charPos > 0);
+
+    return new String(buf);
+  }
+
+  /**
+   * Converts a hex string to an integer.
+   * @param hex A hex string.
+   * @return An integer.
+   */
+  static int hexString2Int(String hex) {
+    byte[] buffer = Bytes.toBytes(hex);
+    if (buffer.length != 8) {
+      throw new InvalidParameterException("hexString2Int length not valid");
+    }
+
+    for (int i = 0; i < buffer.length; i++) {
+      byte ch = buffer[i];
+      if (ch >= 'a' && ch <= 'f') {
+        buffer[i] = (byte) (ch - 'a' + 10);
+      } else {
+        buffer[i] = (byte) (ch - '0');
+      }
+    }
+
+    buffer[0] = (byte) ((buffer[0] << 4) ^ buffer[1]);
+    buffer[1] = (byte) ((buffer[2] << 4) ^ buffer[3]);
+    buffer[2] = (byte) ((buffer[4] << 4) ^ buffer[5]);
+    buffer[3] = (byte) ((buffer[6] << 4) ^ buffer[7]);
+    return Bytes.toInt(buffer, 0, 4);
+  }
+
+  /**
+   * Gets the hex string of the checksum for a start key.
+   * @return The hex string of the checksum for a start key.
+   */
+  public String getStartKey() {
+    return int2HexString(startKey);
+  }
+
+  /**
+   * Gets the date string. Its format is yyyymmdd.
+   * @return The date string.
+   */
+  public String getDate() {
+    return this.date;
+  }
+
+  @Override
+  public int hashCode() {
+    StringBuilder builder = new StringBuilder();
+    builder.append(startKey);
+    builder.append(date);
+    builder.append(uuid);
+    return builder.toString().hashCode();
+  }
+
+  @Override
+  public boolean equals(Object anObject) {
+    if (this == anObject) {
+      return true;
+    }
+    if (anObject instanceof MobFileName) {
+      MobFileName another = (MobFileName) anObject;
+      if (this.startKey == another.startKey && this.date.equals(another.date)
+          && this.uuid.equals(another.uuid)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Gets the file name.
+   * @return The file name.
+   */
+  public String getFileName() {
+    return this.fileName;
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java
new file mode 100644
index 0000000..c09c868
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java
@@ -0,0 +1,202 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.Tag;
+import org.apache.hadoop.hbase.TagType;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.Strings;
+
+/**
+ * The mob utilities
+ */
+@InterfaceAudience.Private
+public class MobUtils {
+
+  private static final ThreadLocal<SimpleDateFormat> LOCAL_FORMAT = new ThreadLocal<SimpleDateFormat>() {
+    @Override
+    protected SimpleDateFormat initialValue() {
+      return new SimpleDateFormat("yyyyMMdd");
+    }
+  };
+
+  /**
+   * Indicates whether the column family is a mob one.
+   * @param hcd The descriptor of a column family.
+   * @return True if this column family is a mob one, false if it's not.
+   */
+  public static boolean isMobFamily(HColumnDescriptor hcd) {
+    String isMob = hcd.getValue(MobConstants.IS_MOB);
+    return isMob != null && Boolean.parseBoolean(isMob);
+  }
+
+  /**
+   * Gets the mob size threshold.
+   * If the size of a cell value is not less than this threshold, it's regarded as a mob.
+   * @param hcd The descriptor of a column family.
+   * @return The threshold.
+   */
+  public static long getMobSizeThreshold(HColumnDescriptor hcd) {
+    String threshold = hcd.getValue(MobConstants.SIZE_TAG);
+    return Strings.isEmpty(threshold) ? 0 : Integer.parseInt(threshold);
+  }
+
+  /**
+   * Formats a date to a string.
+   * @param date The date.
+   * @return The string format of the date, it's yyyymmdd.
+   */
+  public static String formatDate(Date date) {
+    return LOCAL_FORMAT.get().format(date);
+  }
+
+  /**
+   * Parses the string to a date.
+   * @param dateString The string format of a date, it's yyyymmdd.
+   * @return A date.
+   * @throws ParseException
+   */
+  public static Date parseDate(String dateString) throws ParseException {
+    return LOCAL_FORMAT.get().parse(dateString);
+  }
+
+  /**
+   * Whether the current cell is a mob reference cell.
+   * @param cell The current cell.
+   * @return True if the cell has a mob reference tag, false if it doesn't.
+   */
+  public static boolean isMobReferenceCell(Cell cell) {
+    List<Tag> tags = Tag.asList(cell.getTagsArray(), cell.getTagsOffset(), cell.getTagsLength());
+    return hasMobReferenceTag(tags);
+  }
+
+  /**
+   * Whether the tag list has a mob reference tag.
+   * @param tags The tag list.
+   * @return True if the list has a mob reference tag, false if it doesn't.
+   */
+  public static boolean hasMobReferenceTag(List<Tag> tags) {
+    boolean isMob = false;
+    if (!tags.isEmpty()) {
+      for (Tag tag : tags) {
+        if (tag.getType() == TagType.MOB_REFERENCE_TAG_TYPE) {
+          isMob = true;
+          break;
+        }
+      }
+    }
+    return isMob;
+  }
+
+  /**
+   * Indicates whether it's a raw scan.
+   * The information is set in the attribute "hbase.mob.scan.raw" of scan.
+   * For a mob cell, in a normal scan the scanners retrieves the mob cell from the mob file.
+   * In a raw scan, the scanner directly returns cell in HBase without retrieve the one in
+   * the mob file.
+   * @param scan The current scan.
+   * @return True if it's a raw scan.
+   */
+  public static boolean isRawMobScan(Scan scan) {
+    byte[] raw = scan.getAttribute(MobConstants.MOB_SCAN_RAW);
+    try {
+      return raw != null && Bytes.toBoolean(raw);
+    } catch (IllegalArgumentException e) {
+      return false;
+    }
+  }
+
+  /**
+   * Indicates whether the scan contains the information of caching blocks.
+   * The information is set in the attribute "hbase.mob.cache.blocks" of scan.
+   * @param scan The current scan.
+   * @return True if the scan contains the information of caching blocks.
+   */
+  public static boolean isCacheMobBlocks(Scan scan) {
+    byte[] cache = scan.getAttribute(MobConstants.MOB_CACHE_BLOCKS);
+    try {
+      return cache != null && Bytes.toBoolean(cache);
+    } catch (IllegalArgumentException e) {
+      return false;
+    }
+  }
+
+  /**
+   * Sets the attribute of caching blocks in the scan.
+   * 
+   * @param scan
+   *          The current scan.
+   * @param cacheBlocks
+   *          True, set the attribute of caching blocks into the scan, the scanner with this scan
+   *          caches blocks.
+   */
+  public static void setCacheMobBlocks(Scan scan, boolean cacheBlocks) {
+    scan.setAttribute(MobConstants.MOB_CACHE_BLOCKS, Bytes.toBytes(cacheBlocks));
+  }
+
+  /**
+   * Gets the root dir of the mob files.
+   * It's {HBASE_DIR}/mobdir.
+   * @param conf The current configuration.
+   * @return the root dir of the mob file.
+   */
+  public static Path getMobHome(Configuration conf) {
+    Path hbaseDir = new Path(conf.get(HConstants.HBASE_DIR));
+    return new Path(hbaseDir, MobConstants.MOB_DIR_NAME);
+  }
+
+  /**
+   * Gets the region dir of the mob files.
+   * It's {HBASE_DIR}/mobdir/{namespace}/{tableName}/.mob.
+   * @param conf The current configuration.
+   * @param tableName The current table name.
+   * @return The region dir of the mob files.
+   */
+  public static Path getMobRegionPath(Configuration conf, TableName tableName) {
+    Path tablePath = new Path(MobUtils.getMobHome(conf), new Path(tableName.getNamespaceAsString(),
+        tableName.getQualifierAsString()));
+    return new Path(tablePath, MobConstants.MOB_REGION_NAME);
+  }
+
+  /**
+   * Gets the absolute path according to the root path and file name.
+   * 
+   * @param rootPath
+   *          The root path.
+   * @param The
+   *          file name.
+   * @return The absolute file path.
+   */
+  public static Path getAbsolutePath(Path rootPath, String fileName) {
+    return new Path(rootPath, fileName);
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DefaultMobStoreFlusher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DefaultMobStoreFlusher.java
new file mode 100644
index 0000000..3ddcdb3
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DefaultMobStoreFlusher.java
@@ -0,0 +1,213 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValueUtil;
+import org.apache.hadoop.hbase.Tag;
+import org.apache.hadoop.hbase.TagType;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.monitoring.MonitoredTask;
+import org.apache.hadoop.hbase.util.Bytes;
+
+/**
+ * An implementation of the StoreFlusher. It extends the DefaultStoreFlusher.
+ * If the store is not a mob store, the flusher flushes the MemStore the same with
+ * DefaultStoreFlusher, 
+ * If the store is a mob store, the flusher flushes the MemStore into two places.
+ * One is the store files of HBase, the other is the mob files.
+ * <ol>
+ * <li>Cells that are not PUT type or have the delete mark will be directly flushed to HBase.</li>
+ * <li>If the size of a cell value is larger than or equal with a threshold, it'll be flushed
+ * to a mob file, another cell with the path of this file will be flushed to HBase.</li>
+ * <li>If the size of a cell value is smaller than a threshold, it'll be flushed to HBase
+ * directly.</li>
+ * </ol>
+ * 
+ */
+public class DefaultMobStoreFlusher extends DefaultStoreFlusher {
+
+  private static final Log LOG = LogFactory.getLog(DefaultMobStoreFlusher.class);
+  private final Object flushLock = new Object();
+  private boolean isMob = false;
+  private long mobCellValueSizeThreshold = 0;
+  private Path targetPath;
+  private MobFileStore mobFileStore;
+  private Object lock = new Object();
+
+  public DefaultMobStoreFlusher(Configuration conf, Store store) {
+    super(conf, store);
+    isMob = MobUtils.isMobFamily(store.getFamily());
+    mobCellValueSizeThreshold = MobUtils.getMobSizeThreshold(store.getFamily());
+    this.targetPath = new Path(MobUtils.getMobRegionPath(conf, store.getTableName()),
+        store.getColumnFamilyName());
+  }
+
+  /**
+   * Flushes the snapshot of the MemStore. 
+   * If this store is not a mob store, flush the cells in the snapshot to store files of HBase. 
+   * If the store is a mob one, the flusher flushes the MemStore into two places.
+   * One is the store files of HBase, the other is the mob files.
+   * <ol>
+   * <li>Cells that are not PUT type or have the delete mark will be directly flushed to HBase.</li>
+   * <li>If the size of a cell value is larger than or equal with a threshold, it'll be
+   * flushed to a mob file,
+   * another cell with the path of this file will be flushed to HBase.</li>
+   * <li>If the size of a cell value is smaller than a threshold, it'll be flushed to HBase
+   * directly.</li>
+   * </ol>
+   */
+  @Override
+  public List<Path> flushSnapshot(MemStoreSnapshot snapshot, long cacheFlushId,
+      MonitoredTask status) throws IOException {
+    ArrayList<Path> result = new ArrayList<Path>();
+    int cellsCount = snapshot.getCellsCount();
+    if (cellsCount == 0) return result; // don't flush if there are no entries
+
+    // Use a store scanner to find which rows to flush.
+    long smallestReadPoint = store.getSmallestReadPoint();
+    InternalScanner scanner = createScanner(snapshot.getScanner(), smallestReadPoint);
+    if (scanner == null) {
+      return result; // NULL scanner returned from coprocessor hooks means skip normal processing
+    }
+    StoreFile.Writer writer;
+    try {
+      // TODO: We can fail in the below block before we complete adding this flush to
+      // list of store files. Add cleanup of anything put on filesystem if we fail.
+      synchronized (flushLock) {
+        status.setStatus("Flushing " + store + ": creating writer");
+        // Write the map out to the disk
+        writer = store.createWriterInTmp(cellsCount, store.getFamily().getCompression(),
+            false, true, true);
+        writer.setTimeRangeTracker(snapshot.getTimeRangeTracker());
+        try {
+          if (!isMob) {
+            // It's not a mob store, flush the cells in a normal way
+            performFlush(scanner, writer, smallestReadPoint);
+          } else {
+            mobFileStore = currentMobFileStore();
+            StoreFile.Writer mobFileWriter = null;
+            int compactionKVMax = conf.getInt(HConstants.COMPACTION_KV_MAX,
+                HConstants.COMPACTION_KV_MAX_DEFAULT);
+            long time = snapshot.getTimeRangeTracker().getMaximumTimestamp();
+            mobFileWriter = mobFileStore.createWriterInTmp(new Date(time), cellsCount, store
+                .getFamily().getCompression(), store.getRegionInfo().getStartKey());
+            // the target path is {tableName}/.mob/{cfName}/mobFiles
+            // the relative path is mobFiles
+            String relativePath = mobFileWriter.getPath().getName();
+            byte[] referenceValue = Bytes.toBytes(relativePath);
+            try {
+              List<Cell> kvs = new ArrayList<Cell>();
+              boolean hasMore;
+              do {
+                hasMore = scanner.next(kvs, compactionKVMax);
+                if (!kvs.isEmpty()) {
+                  for (Cell c : kvs) {
+                    // If we know that this KV is going to be included always, then let us
+                    // set its memstoreTS to 0. This will help us save space when writing to
+                    // disk.
+                    KeyValue kv = KeyValueUtil.ensureKeyValue(c);
+                    if (kv.getValueLength() <= mobCellValueSizeThreshold
+                        || MobUtils.isMobReferenceCell(kv)
+                        || kv.getTypeByte() != KeyValue.Type.Put.getCode()) {
+                      writer.append(kv);
+                    } else {
+                      // append the original keyValue in the mob file.
+                      mobFileWriter.append(kv);
+
+                      // append the tags to the KeyValue.
+                      // The key is same, the value is the filename of the mob file
+                      List<Tag> existingTags = Tag.asList(kv.getTagsArray(), kv.getTagsOffset(),
+                          kv.getTagsLength());
+                      if (existingTags.isEmpty()) {
+                        existingTags = new ArrayList<Tag>();
+                      }
+                      Tag mobRefTag = new Tag(TagType.MOB_REFERENCE_TAG_TYPE,
+                          HConstants.EMPTY_BYTE_ARRAY);
+                      existingTags.add(mobRefTag);
+                      long valueLength = kv.getValueLength();
+                      byte[] newValue = Bytes.add(Bytes.toBytes(valueLength), referenceValue);
+                      KeyValue reference = new KeyValue(kv.getRowArray(), kv.getRowOffset(),
+                          kv.getRowLength(), kv.getFamilyArray(), kv.getFamilyOffset(),
+                          kv.getFamilyLength(), kv.getQualifierArray(), kv.getQualifierOffset(),
+                          kv.getQualifierLength(), kv.getTimestamp(), KeyValue.Type.Put,
+                          newValue, 0, newValue.length, existingTags);
+                      reference.setSequenceId(kv.getSequenceId());
+                      writer.append(reference);
+                    }
+                  }
+                  kvs.clear();
+                }
+              } while (hasMore);
+            } finally {
+              status.setStatus("Flushing mob file " + store + ": appending metadata");
+              mobFileWriter.appendMetadata(cacheFlushId, false);
+              status.setStatus("Flushing mob file " + store + ": closing flushed file");
+              mobFileWriter.close();
+            }
+
+            // commit the mob file from temp folder to target folder.
+            mobFileStore.commitFile(mobFileWriter.getPath(), targetPath);
+          }
+        } finally {
+          finalizeWriter(writer, cacheFlushId, status);
+        }
+      }
+    } finally {
+      scanner.close();
+    }
+    LOG.info("Flushed, sequenceid=" + cacheFlushId + ", memsize="
+        + snapshot.getSize() + ", hasBloomFilter=" + writer.hasGeneralBloom()
+        + ", into tmp file " + writer.getPath());
+    result.add(writer.getPath());
+    return result;
+  }
+
+  /**
+   * Gets the current MobFileStore.
+   * 
+   * @return The current MobFileStore.
+   * @throws IOException
+   */
+  private MobFileStore currentMobFileStore() throws IOException {
+    if (null == mobFileStore) {
+      synchronized (lock) {
+        if (null == mobFileStore) {
+          if (!this.store.getFileSystem().exists(targetPath)) {
+            this.store.getFileSystem().mkdirs(targetPath);
+          }
+          mobFileStore = MobFileStore.create(conf, this.store.getFileSystem(),
+              this.store.getTableName(), this.store.getFamily());
+        }
+      }
+    }
+    return mobFileStore;
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HMobStore.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HMobStore.java
new file mode 100644
index 0000000..bb79b99
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HMobStore.java
@@ -0,0 +1,72 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver;
+
+import java.io.IOException;
+import java.util.NavigableSet;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.client.Scan;
+
+/**
+ * The store implementation to save MOBs (medium objects), it extends the HStore.
+ * When a descriptor of a column family has the value "is_mob", it means this column family
+ * is a mob one. When a HRegion instantiate a store for this column family, the HMobStore is
+ * created.
+ * HMobStore is almost the same with the HStore except using different types of scanners.
+ * In the method of getScanner, the MobStoreScanner and MobReversedStoreScanner are returned.
+ * In these scanners, a additional seeks in the mob files should be performed after the seek
+ * in HBase is done.
+ */
+public class HMobStore extends HStore {
+
+  private MobFileStore mobFileStore;
+
+  public HMobStore(final HRegion region, final HColumnDescriptor family,
+      final Configuration confParam) throws IOException {
+    super(region, family, confParam);
+    mobFileStore = MobFileStore.create(region.conf, region.getFilesystem(), this.getTableName(),
+        this.getFamily());
+  }
+
+  /**
+   * Gets the MobStoreScanner or MobReversedStoreScanner. In these scanners, a additional seeks in
+   * the mob files should be performed after the seek in HBase is done.
+   */
+  @Override
+  public KeyValueScanner getScanner(Scan scan, NavigableSet<byte[]> targetCols, long readPt)
+      throws IOException {
+    lock.readLock().lock();
+    try {
+      KeyValueScanner scanner = null;
+      if (this.getCoprocessorHost() != null) {
+        scanner = this.getCoprocessorHost().preStoreScannerOpen(this, scan, targetCols);
+      }
+      if (scanner == null) {
+        scanner = scan.isReversed() ? new MobReversedStoreScanner(this, getScanInfo(), scan,
+            targetCols, readPt, mobFileStore) : new MobStoreScanner(this, getScanInfo(), scan,
+            targetCols, readPt, mobFileStore);
+      }
+      return scanner;
+    } finally {
+      lock.readLock().unlock();
+    }
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
index 98c32b0..7043a6f 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
@@ -112,6 +112,7 @@
 import org.apache.hadoop.hbase.ipc.CallerDisconnectedException;
 import org.apache.hadoop.hbase.ipc.RpcCallContext;
 import org.apache.hadoop.hbase.ipc.RpcServer;
+import org.apache.hadoop.hbase.mob.MobUtils;
 import org.apache.hadoop.hbase.monitoring.MonitoredTask;
 import org.apache.hadoop.hbase.monitoring.TaskMonitor;
 import org.apache.hadoop.hbase.protobuf.ProtobufUtil;
@@ -3493,6 +3494,9 @@ private static boolean isZeroLengthThenDelete(final FileSystem fs, final Path p)
   }
 
   protected HStore instantiateHStore(final HColumnDescriptor family) throws IOException {
+    if (MobUtils.isMobFamily(family)) {
+      return new HMobStore(this, family, this.conf);
+    }
     return new HStore(this, family, this.conf);
   }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MobFileStore.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MobFileStore.java
new file mode 100644
index 0000000..1c0ec1b
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MobFileStore.java
@@ -0,0 +1,321 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver;
+
+import java.io.IOException;
+import java.util.Date;
+import java.util.UUID;
+import java.util.zip.CRC32;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValue.Type;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.io.compress.Compression;
+import org.apache.hadoop.hbase.io.encoding.DataBlockEncoding;
+import org.apache.hadoop.hbase.io.hfile.CacheConfig;
+import org.apache.hadoop.hbase.io.hfile.HFile;
+import org.apache.hadoop.hbase.io.hfile.HFileContext;
+import org.apache.hadoop.hbase.io.hfile.HFileContextBuilder;
+import org.apache.hadoop.hbase.mob.MobCacheConfig;
+import org.apache.hadoop.hbase.mob.MobFile;
+import org.apache.hadoop.hbase.mob.MobFileName;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.util.Bytes;
+
+/**
+ * A manager of mob files.
+ * It provides the information of the MOB column family in HBase, validates the mob files and
+ * reads the MOB cells from the MOB files.
+ */
+public class MobFileStore {
+
+  private static final Log LOG = LogFactory.getLog(MobFileStore.class);
+  private Configuration conf;
+  private FileSystem fs;
+  private Path homePath;
+  private MobCacheConfig cacheConf;
+  private TableName tableName;
+  private HColumnDescriptor family;
+  private String familyAsString;
+  private Path mobFamilyPath;
+  private final static String TMP = ".tmp";
+
+  private MobFileStore(Configuration conf, FileSystem fs, TableName tableName,
+      HColumnDescriptor family) {
+    this.fs = fs;
+    this.homePath = MobUtils.getMobHome(conf);
+    this.conf = conf;
+    this.cacheConf = new MobCacheConfig(conf, family);
+    this.tableName = tableName;
+    this.family = family;
+    this.familyAsString = family.getNameAsString();
+    this.mobFamilyPath = new Path(MobUtils.getMobRegionPath(conf, tableName),
+        family.getNameAsString());
+  }
+
+  /**
+   * Creates an instance of MobFileStore.
+   * @param conf The current configuration.
+   * @param fs The current file system.
+   * @param tableName The table name.
+   * @param family The column family.
+   * @return An instance of MobFileStore.
+   * @throws IOException
+   */
+  public static MobFileStore create(Configuration conf, FileSystem fs, TableName tableName,
+      HColumnDescriptor family) throws IOException {
+    if (null == family) {
+      LOG.warn("fail to create the MobFileStore because the family is null in table [" + tableName
+          + "]!");
+      return null;
+    }
+    String familyName = family.getNameAsString();
+    if (!MobUtils.isMobFamily(family)) {
+      LOG.warn("failed to create the MobFileStore because the family [" + familyName
+          + "] in table [" + tableName + "] is not a mob one!");
+      return null;
+    }
+    return new MobFileStore(conf, fs, tableName, family);
+  }
+
+  /**
+   * Gets the current MobCacheConfig.
+   * @return A MobCacheConfig
+   */
+  public MobCacheConfig getCacheConfig() {
+    return this.cacheConf;
+  }
+
+  /**
+   * Gets the current column descriptor.
+   * @return A descriptor.
+   */
+  public HColumnDescriptor getColumnDescriptor() {
+    return this.family;
+  }
+
+  /**
+   * Gets the mob file path.
+   * @return The mob file path.
+   */
+  public Path getPath() {
+    return mobFamilyPath;
+  }
+
+  /**
+   * Gets the temp directory.
+   * @return The temp directory.
+   */
+  private Path getTmpDir() {
+    return new Path(homePath, TMP);
+  }
+
+  /**
+   * Gets the table name.
+   * @return A table name.
+   */
+  public TableName getTableName() {
+    return tableName;
+  }
+
+  /**
+   * Gets the family name.
+   * @return The family name.
+   */
+  public String getFamilyName() {
+    return familyAsString;
+  }
+
+  /**
+   * Gets the current configuration.
+   * @return The current configuration.
+   */
+  public Configuration getConfiguration() {
+    return this.conf;
+  }
+
+  /**
+   * Gets the current file system.
+   * @return The current file system.
+   */
+  public FileSystem getFileSystem() {
+    return fs;
+  }
+
+  /**
+   * Creates the temp directory of mob files for flushing.
+   * @param date The latest date of cells in the flushing.
+   * @param maxKeyCount The key count.
+   * @param compression The compression algorithm.
+   * @param startKey The start key.
+   * @return The writer for the mob file.
+   * @throws IOException
+   */
+  public StoreFile.Writer createWriterInTmp(Date date, long maxKeyCount,
+      Compression.Algorithm compression, byte[] startKey) throws IOException {
+    if (null == startKey) {
+      startKey = HConstants.EMPTY_START_ROW;
+    }
+
+    CRC32 crc = new CRC32();
+    crc.update(startKey);
+    int checksum = (int) crc.getValue();
+    return createWriterInTmp(date, maxKeyCount, compression, MobFileName.int2HexString(checksum));
+  }
+
+  /**
+   * Creates the temp directory of mob files for flushing.
+   * @param date The latest date of cells in the flushing.
+   * @param maxKeyCount The key count.
+   * @param compression The compression algorithm.
+   * @param startKey The hex string of the checksum for the start key.
+   * @return The writer for the mob file.
+   * @throws IOException
+   */
+  public StoreFile.Writer createWriterInTmp(Date date, long maxKeyCount,
+      Compression.Algorithm compression, String startKey) throws IOException {
+    Path path = getTmpDir();
+    return createWriterInTmp(MobUtils.formatDate(date), path, maxKeyCount, compression, startKey);
+  }
+
+  /**
+   * Creates the temp directory of mob files for flushing.
+   * @param date The date string, its format is yyyymmmdd.
+   * @param basePath The basic path for a temp directory.
+   * @param maxKeyCount The key count.
+   * @param compression The compression algorithm.
+   * @param startKey The hex string of the checksum for the start key.
+   * @return The writer for the mob file.
+   * @throws IOException
+   */
+  public StoreFile.Writer createWriterInTmp(String date, Path basePath, long maxKeyCount,
+      Compression.Algorithm compression, String startKey) throws IOException {
+    MobFileName mobFileName = MobFileName.create(startKey, date, UUID.randomUUID()
+        .toString().replaceAll("-", ""));
+    final CacheConfig writerCacheConf = cacheConf;
+    HFileContext hFileContext = new HFileContextBuilder().withCompression(compression)
+        .withIncludesMvcc(false).withIncludesTags(true)
+        .withChecksumType(HFile.DEFAULT_CHECKSUM_TYPE)
+        .withBytesPerCheckSum(HFile.DEFAULT_BYTES_PER_CHECKSUM)
+        .withBlockSize(family.getBlocksize())
+        .withHBaseCheckSum(true).withDataBlockEncoding(DataBlockEncoding.NONE).build();
+
+    StoreFile.Writer w = new StoreFile.WriterBuilder(conf, writerCacheConf, fs)
+        .withFilePath(MobUtils.getAbsolutePath(mobFamilyPath, mobFileName.getFileName()))
+        .withComparator(KeyValue.COMPARATOR).withBloomType(BloomType.NONE)
+        .withMaxKeyCount(maxKeyCount).withFileContext(hFileContext).build();
+    return w;
+  }
+
+  /**
+   * Commits the mob file.
+   * @param sourceFile The source file.
+   * @param targetPath The directory path where the source file is renamed to.
+   * @throws IOException
+   */
+  public void commitFile(final Path sourceFile, Path targetPath) throws IOException {
+    if (sourceFile == null) {
+      return;
+    }
+    Path dstPath = new Path(targetPath, sourceFile.getName());
+    validateMobFile(sourceFile);
+    String msg = "Renaming flushed file from " + sourceFile + " to " + dstPath;
+    LOG.info(msg);
+    Path parent = dstPath.getParent();
+    if (!fs.exists(parent)) {
+      fs.mkdirs(parent);
+    }
+    if (!fs.rename(sourceFile, dstPath)) {
+      LOG.warn("Unable to rename " + sourceFile + " to " + dstPath);
+    }
+  }
+
+  /**
+   * Validates a mob file by opening and closing it.
+   *
+   * @param path the path to the mob file
+   */
+  private void validateMobFile(Path path) throws IOException {
+    StoreFile storeFile = null;
+    try {
+      storeFile = new StoreFile(this.fs, path, conf, this.cacheConf, BloomType.NONE);
+      storeFile.createReader();
+    } catch (IOException e) {
+      LOG.error("Fail to open mob store file[" + path + "], keeping it in tmp location["
+          + getTmpDir() + "].", e);
+      throw e;
+    } finally {
+      if (storeFile != null) {
+        storeFile.closeReader(false);
+      }
+    }
+  }
+
+  /**
+   * Reads the cell from the mob file.
+   * @param reference The cell found in the HBase, its value is a path to a mob file.
+   * @param cacheBlocks Whether the scanner should cache blocks.
+   * @return The cell found in the mob file.
+   * @throws IOException
+   */
+  public Cell resolve(Cell reference, boolean cacheBlocks) throws IOException {
+    Cell result = null;
+    if (reference.getValueLength() > Bytes.SIZEOF_LONG) {
+      String fileName = Bytes.toString(reference.getValueArray(), reference.getValueOffset()
+          + Bytes.SIZEOF_LONG, reference.getValueLength() - Bytes.SIZEOF_LONG);
+      Path targetPath = new Path(mobFamilyPath, fileName);
+      MobFile file = null;
+      try {
+        file = cacheConf.getMobFileCache().openFile(fs, targetPath, cacheConf);
+        result = file.readCell(reference, cacheBlocks);
+      } catch (IOException e) {
+        LOG.error("Fail to open/read the mob file " + targetPath.toString(), e);
+      } catch (NullPointerException e) {
+        // When delete the file during the scan, the hdfs getBlockRange will
+        // throw NullPointerException, catch it and manage it.
+        LOG.error("Fail to read the mob file " + targetPath.toString(), e);
+      } finally {
+        if (file != null) {
+          cacheConf.getMobFileCache().closeFile(file);
+        }
+      }
+    }
+
+    if (result == null) {
+      LOG.warn("The KeyValue result is null, assemble a new KeyValue with the same row,family,"
+          + "qualifier,timestamp,type and tags but with an empty value to return.");
+      result = new KeyValue(reference.getRowArray(), reference.getRowOffset(),
+          reference.getRowLength(), reference.getFamilyArray(), reference.getFamilyOffset(),
+          reference.getFamilyLength(), reference.getQualifierArray(),
+          reference.getQualifierOffset(), reference.getQualifierLength(), reference.getTimestamp(),
+          Type.codeToType(reference.getTypeByte()), HConstants.EMPTY_BYTE_ARRAY,
+          reference.getValueOffset(), 0, reference.getTagsArray(), reference.getTagsOffset(),
+          reference.getTagsLength());
+    }
+    return result;
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MobReversedStoreScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MobReversedStoreScanner.java
new file mode 100644
index 0000000..738640a
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MobReversedStoreScanner.java
@@ -0,0 +1,68 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.NavigableSet;
+
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.mob.MobUtils;
+
+/**
+ * MobReversedStoreScanner extends from ReversedStoreScanner, and is used to support
+ * reversed scanning in both the memstore and the MOB store.
+ *
+ */
+public class MobReversedStoreScanner extends ReversedStoreScanner {
+
+  private boolean cacheMobBlocks = false;
+  private MobFileStore mobFileStore;
+
+  MobReversedStoreScanner(Store store, ScanInfo scanInfo, Scan scan, NavigableSet<byte[]> columns,
+      long readPt, MobFileStore mobFileStore) throws IOException {
+    super(store, scanInfo, scan, columns, readPt);
+    cacheMobBlocks = MobUtils.isCacheMobBlocks(scan);
+    this.mobFileStore = mobFileStore;
+  }
+
+  /**
+   * Firstly reads the cells from the HBase. If the cell are a reference cell (which has the
+   * reference tag), the scanner need seek this cell from the mob file, and use the cell found
+   * from the mob file as the result.
+   */
+  @Override
+  public boolean next(List<Cell> outResult, int limit) throws IOException {
+    boolean result = super.next(outResult, limit);
+    if (!MobUtils.isRawMobScan(scan)) {
+      // retrieve the mob data
+      if (outResult.isEmpty()) {
+        return result;
+      }
+      for (int i = 0; i < outResult.size(); i++) {
+        Cell cell = outResult.get(i);
+        if (MobUtils.isMobReferenceCell(cell)) {
+          outResult.set(i, mobFileStore.resolve(cell, cacheMobBlocks));
+        }
+      }
+    }
+    return result;
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MobStoreScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MobStoreScanner.java
new file mode 100644
index 0000000..76144c7
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MobStoreScanner.java
@@ -0,0 +1,69 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.NavigableSet;
+
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.mob.MobUtils;
+
+/**
+ * Scanner scans both the memstore and the MOB Store. Coalesce KeyValue stream into List<KeyValue>
+ * for a single row.
+ *
+ */
+public class MobStoreScanner extends StoreScanner {
+
+  private boolean cacheMobBlocks = false;
+  private MobFileStore mobFileStore;
+
+  public MobStoreScanner(Store store, ScanInfo scanInfo, Scan scan,
+      final NavigableSet<byte[]> columns, long readPt, MobFileStore mobFileStore)
+      throws IOException {
+    super(store, scanInfo, scan, columns, readPt);
+    cacheMobBlocks = MobUtils.isCacheMobBlocks(scan);
+    this.mobFileStore = mobFileStore;
+  }
+
+  /**
+   * Firstly reads the cells from the HBase. If the cell are a reference cell (which has the
+   * reference tag), the scanner need seek this cell from the mob file, and use the cell found
+   * from the mob file as the result.
+   */
+  @Override
+  public boolean next(List<Cell> outResult, int limit) throws IOException {
+    boolean result = super.next(outResult, limit);
+    if (!MobUtils.isRawMobScan(scan)) {
+      // retrieve the mob data
+      if (outResult.isEmpty()) {
+        return result;
+      }
+      for (int i = 0; i < outResult.size(); i++) {
+        Cell cell = outResult.get(i);
+        if (MobUtils.isMobReferenceCell(cell)) {
+          outResult.set(i, mobFileStore.resolve(cell, cacheMobBlocks));
+        }
+      }
+    }
+    return result;
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/MobTestUtil.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/MobTestUtil.java
new file mode 100644
index 0000000..5231252
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/MobTestUtil.java
@@ -0,0 +1,68 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import java.io.IOException;
+import java.util.Random;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.util.Bytes;
+
+public class MobTestUtil {
+  protected static final char FIRST_CHAR = 'a';
+  protected static final char LAST_CHAR = 'z';
+
+  protected static String generateRandomString(int demoLength) {
+    String base = "abcdefghijklmnopqrstuvwxyz";
+    Random random = new Random();
+    StringBuffer sb = new StringBuffer();
+    for (int i = 0; i < demoLength; i++) {
+      int number = random.nextInt(base.length());
+      sb.append(base.charAt(number));
+    }
+    return sb.toString();
+  }
+  protected static void writeStoreFile(final StoreFile.Writer writer, String caseName) throws IOException {
+    writeStoreFile(writer, Bytes.toBytes(caseName), Bytes.toBytes(caseName));
+  }
+
+  /*
+   * Writes HStoreKey and ImmutableBytes data to passed writer and then closes
+   * it.
+   *
+   * @param writer
+   *
+   * @throws IOException
+   */
+  private static void writeStoreFile(final StoreFile.Writer writer, byte[] fam,
+      byte[] qualifier) throws IOException {
+    long now = System.currentTimeMillis();
+    try {
+      for (char d = FIRST_CHAR; d <= LAST_CHAR; d++) {
+        for (char e = FIRST_CHAR; e <= LAST_CHAR; e++) {
+          byte[] b = new byte[] { (byte) d, (byte) e };
+          writer.append(new KeyValue(b, fam, qualifier, now, b));
+        }
+      }
+    } finally {
+      writer.close();
+    }
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestCachedMobFile.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestCachedMobFile.java
new file mode 100644
index 0000000..d6cfd16
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestCachedMobFile.java
@@ -0,0 +1,175 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.HBaseTestCase;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValue.Type;
+import org.apache.hadoop.hbase.KeyValueUtil;
+import org.apache.hadoop.hbase.SmallTests;
+import org.apache.hadoop.hbase.io.hfile.CacheConfig;
+import org.apache.hadoop.hbase.io.hfile.HFileContext;
+import org.apache.hadoop.hbase.io.hfile.HFileContextBuilder;
+import org.apache.hadoop.hbase.regionserver.BloomType;
+import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(SmallTests.class)
+public class TestCachedMobFile extends HBaseTestCase {
+  static final Log LOG = LogFactory.getLog(TestCachedMobFile.class);
+  private CacheConfig cacheConf = new CacheConfig(conf);
+  private final String TABLE = "tableName";
+  private final String FAMILY = "familyName";
+  private final String FAMILY1 = "familyName1";
+  private final String FAMILY2 = "familyName2";
+  private final long EXPECTED_REFERENCE_ZERO = 0;
+  private final long EXPECTED_REFERENCE_ONE = 1;
+  private final long EXPECTED_REFERENCE_TWO = 2;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+  }
+  
+  @Test
+  public void testOpenClose() throws Exception {
+    String caseName = getName();
+    Path outputDir = new Path(new Path(this.testDir, TABLE),
+        FAMILY);
+    HFileContext meta = new HFileContextBuilder().withBlockSize(8*1024).build();
+    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    .withOutputDir(outputDir)
+    .withFileContext(meta)
+    .build();
+    MobTestUtil.writeStoreFile(writer, caseName);
+    CachedMobFile cachedMobFile = new CachedMobFile(new MobFile(
+        new StoreFile(this.fs, writer.getPath(), conf, cacheConf,
+            BloomType.NONE)));
+    
+    assertEquals(EXPECTED_REFERENCE_ZERO, cachedMobFile.getReference());
+    cachedMobFile.open();
+    assertEquals(EXPECTED_REFERENCE_ONE, cachedMobFile.getReference());
+    cachedMobFile.open();
+    assertEquals(EXPECTED_REFERENCE_TWO, cachedMobFile.getReference());
+    cachedMobFile.close();
+    assertEquals(EXPECTED_REFERENCE_ONE, cachedMobFile.getReference());
+    cachedMobFile.close();
+    assertEquals(EXPECTED_REFERENCE_ZERO, cachedMobFile.getReference());
+  }
+
+  @Test
+  public void testCompare() throws Exception {
+    String caseName = getName();
+    Path outputDir1 = new Path(new Path(this.testDir, TABLE),
+        FAMILY1);
+    HFileContext meta = new HFileContextBuilder().withBlockSize(8*1024).build();
+    StoreFile.Writer writer1 = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    .withOutputDir(outputDir1)
+    .withFileContext(meta)
+    .build();
+    MobTestUtil.writeStoreFile(writer1, caseName);
+    CachedMobFile cachedMobFile1 = new CachedMobFile(new MobFile(
+        new StoreFile(this.fs, writer1.getPath(), conf, cacheConf,
+            BloomType.NONE)));
+
+    Path outputDir2 = new Path(new Path(this.testDir, TABLE),
+        FAMILY2);
+    StoreFile.Writer writer2 = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    .withOutputDir(outputDir2)
+    .withFileContext(meta)
+    .build();
+    MobTestUtil.writeStoreFile(writer2, caseName);
+    CachedMobFile cachedMobFile2 = new CachedMobFile(new MobFile(
+        new StoreFile(this.fs, writer2.getPath(), conf, cacheConf,
+            BloomType.NONE)));
+    cachedMobFile1.access(1);
+    cachedMobFile2.access(2);
+    assertEquals(cachedMobFile1.compareTo(cachedMobFile2), 1);
+    assertEquals(cachedMobFile2.compareTo(cachedMobFile1), -1);
+    assertEquals(cachedMobFile1.compareTo(cachedMobFile1), 0);
+  }
+
+  @Test
+  public void testReadKeyValue() throws Exception {
+    Path outputDir = new Path(new Path(this.testDir, TABLE), "familyname");
+    HFileContext meta = new HFileContextBuilder().withBlockSize(8*1024).build();
+    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+    .withOutputDir(outputDir)
+    .withFileContext(meta)
+    .build();
+    String caseName = getName();
+    MobTestUtil.writeStoreFile(writer, caseName);
+    MobFile mobFile = new MobFile(new StoreFile(this.fs, writer.getPath(),
+        conf, cacheConf, BloomType.NONE));
+    CachedMobFile cachedMobFile = new CachedMobFile(mobFile);
+    
+    byte[] family = Bytes.toBytes(caseName);
+    byte[] qualify = Bytes.toBytes(caseName);
+    
+    // Test the start key
+    byte[] startKey = Bytes.toBytes("aa");  // The start key bytes
+    KeyValue expectedKey = new KeyValue(startKey, family, qualify, Long.MAX_VALUE, Type.Put, startKey);
+    KeyValue seekKey = expectedKey.createKeyOnly(false);
+    KeyValue kv = KeyValueUtil.ensureKeyValue(cachedMobFile.readCell(seekKey, false));
+    assertKeyValuesEquals(expectedKey, kv);
+    
+    // Test the end key
+    byte[] endKey = Bytes.toBytes("zz");  // The end key bytes
+    expectedKey = new KeyValue(endKey, family, qualify, Long.MAX_VALUE, Type.Put, endKey);
+    seekKey = expectedKey.createKeyOnly(false);
+    kv = KeyValueUtil.ensureKeyValue(cachedMobFile.readCell(seekKey, false));
+    assertKeyValuesEquals(expectedKey, kv);
+    
+    // Test the random key
+    byte[] randomKey = Bytes.toBytes(MobTestUtil.generateRandomString(2)); 
+    expectedKey = new KeyValue(randomKey, family, qualify, Long.MAX_VALUE, Type.Put, randomKey);
+    seekKey = expectedKey.createKeyOnly(false);
+    kv = KeyValueUtil.ensureKeyValue(cachedMobFile.readCell(seekKey, false));
+    assertKeyValuesEquals(expectedKey, kv);
+    
+    // Test the key which is less than the start key
+    byte[] lowerKey = Bytes.toBytes("a1"); // Smaller than "aa"
+    expectedKey = new KeyValue(startKey, family, qualify, Long.MAX_VALUE, Type.Put, startKey);
+    seekKey = new KeyValue(lowerKey, family, qualify, Long.MAX_VALUE, Type.Put, lowerKey);
+    kv = KeyValueUtil.ensureKeyValue(cachedMobFile.readCell(seekKey, false));
+    assertKeyValuesEquals(expectedKey, kv);
+    
+    // Test the key which is more than the end key
+    byte[] upperKey = Bytes.toBytes("z{"); // Bigger than "zz"
+    seekKey = new KeyValue(upperKey, family, qualify, Long.MAX_VALUE, Type.Put, upperKey);
+    kv = KeyValueUtil.ensureKeyValue(cachedMobFile.readCell(seekKey, false));
+    assertNull(kv);
+  }
+
+  /**
+   * Compare two KeyValue only for their row family qualifier value
+   */
+  private void assertKeyValuesEquals(KeyValue firstKeyValue,
+      KeyValue secondKeyValue) {
+    assertEquals(firstKeyValue.getRow(), secondKeyValue.getRow());
+    assertEquals(firstKeyValue.getFamily(), secondKeyValue.getFamily());
+    assertEquals(firstKeyValue.getQualifier(), secondKeyValue.getQualifier());
+    assertEquals(firstKeyValue.getValue(), secondKeyValue.getValue());
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestMobFile.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestMobFile.java
new file mode 100644
index 0000000..6727512
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestMobFile.java
@@ -0,0 +1,126 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.HBaseTestCase;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValue.Type;
+import org.apache.hadoop.hbase.KeyValueUtil;
+import org.apache.hadoop.hbase.SmallTests;
+import org.apache.hadoop.hbase.io.hfile.CacheConfig;
+import org.apache.hadoop.hbase.io.hfile.HFileContext;
+import org.apache.hadoop.hbase.io.hfile.HFileContextBuilder;
+import org.apache.hadoop.hbase.regionserver.BloomType;
+import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFileScanner;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(SmallTests.class)
+public class TestMobFile extends HBaseTestCase {
+  static final Log LOG = LogFactory.getLog(TestMobFile.class);
+  private static final HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
+  private CacheConfig cacheConf =  new CacheConfig(TEST_UTIL.getConfiguration());
+  private final String TABLE = "tableName";
+  private final String FAMILY = "familyName";
+
+  @Test
+  public void testReadKeyValue() throws Exception {
+    Path outputDir = new Path(new Path(this.testDir, TABLE), FAMILY);
+    HFileContext meta = new HFileContextBuilder().withBlockSize(8*1024).build();
+    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+            .withOutputDir(outputDir)
+            .withFileContext(meta)
+            .build();
+    String caseName = getName();
+    MobTestUtil.writeStoreFile(writer, caseName);
+
+    MobFile mobFile = new MobFile(new StoreFile(this.fs, writer.getPath(),
+        conf, cacheConf, BloomType.NONE));
+    byte[] family = Bytes.toBytes(caseName);
+    byte[] qualify = Bytes.toBytes(caseName);
+
+    // Test the start key
+    byte[] startKey = Bytes.toBytes("aa");  // The start key bytes
+    KeyValue expectedKey = new KeyValue(startKey, family, qualify, Long.MAX_VALUE, Type.Put, startKey);
+    KeyValue seekKey = expectedKey.createKeyOnly(false);
+    KeyValue kv = KeyValueUtil.ensureKeyValue(mobFile.readCell(seekKey, false));
+    assertKeyValuesEquals(expectedKey, kv);
+
+    // Test the end key
+    byte[] endKey = Bytes.toBytes("zz");  // The end key bytes
+    expectedKey = new KeyValue(endKey, family, qualify, Long.MAX_VALUE, Type.Put, endKey);
+    seekKey = expectedKey.createKeyOnly(false);
+    kv = KeyValueUtil.ensureKeyValue(mobFile.readCell(seekKey, false));
+    assertKeyValuesEquals(expectedKey, kv);
+
+    // Test the random key
+    byte[] randomKey = Bytes.toBytes(MobTestUtil.generateRandomString(2));
+    expectedKey = new KeyValue(randomKey, family, qualify, Long.MAX_VALUE, Type.Put, randomKey);
+    seekKey = expectedKey.createKeyOnly(false);
+    kv = KeyValueUtil.ensureKeyValue(mobFile.readCell(seekKey, false));
+    assertKeyValuesEquals(expectedKey, kv);
+
+    // Test the key which is less than the start key
+    byte[] lowerKey = Bytes.toBytes("a1"); // Smaller than "aa"
+    expectedKey = new KeyValue(startKey, family, qualify, Long.MAX_VALUE, Type.Put, startKey);
+    seekKey = new KeyValue(lowerKey, family, qualify, Long.MAX_VALUE, Type.Put, lowerKey);
+    kv = KeyValueUtil.ensureKeyValue(mobFile.readCell(seekKey, false));
+    assertKeyValuesEquals(expectedKey, kv);
+
+    // Test the key which is more than the end key
+    byte[] upperKey = Bytes.toBytes("z{"); // Bigger than "zz"
+    seekKey = new KeyValue(upperKey, family, qualify, Long.MAX_VALUE, Type.Put, upperKey);
+    kv = KeyValueUtil.ensureKeyValue(mobFile.readCell(seekKey, false));
+    assertNull(kv);
+  }
+
+  /**
+   * Compare two KeyValue only for their row family qualifier value
+   */
+  @SuppressWarnings("deprecation")
+  private void assertKeyValuesEquals(KeyValue firstKeyValue,
+      KeyValue secondKeyValue) {
+    assertEquals(firstKeyValue.getRow(), secondKeyValue.getRow());
+    assertEquals(firstKeyValue.getFamily(), secondKeyValue.getFamily());
+    assertEquals(firstKeyValue.getQualifier(), secondKeyValue.getQualifier());
+    assertEquals(firstKeyValue.getValue(), secondKeyValue.getValue());
+  }
+
+  @Test
+  public void testGetScanner() throws Exception {
+    Path outputDir = new Path(new Path(this.testDir, TABLE), FAMILY);
+    HFileContext meta = new HFileContextBuilder().withBlockSize(8*1024).build();
+    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs)
+            .withOutputDir(outputDir)
+            .withFileContext(meta)
+            .build();
+    MobTestUtil.writeStoreFile(writer, getName());
+
+    MobFile mobFile = new MobFile(new StoreFile(this.fs, writer.getPath(),
+        conf, cacheConf, BloomType.NONE));
+    assertNotNull(mobFile.getScanner());
+    assertTrue(mobFile.getScanner() instanceof StoreFileScanner);
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestMobFileCache.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestMobFileCache.java
new file mode 100644
index 0000000..2a6706f
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestMobFileCache.java
@@ -0,0 +1,189 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import java.io.IOException;
+import java.util.Date;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.HBaseTestCase;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.SmallTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.regionserver.MobFileStore;
+import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(SmallTests.class)
+public class TestMobFileCache extends HBaseTestCase {
+  static final Log LOG = LogFactory.getLog(TestMobFileCache.class);
+  private MobCacheConfig mobCacheConf;
+  private MobFileCache mobFileCache;
+  private Date currentDate = new Date();
+  private final String TEST_CACHE_SIZE = "2";
+  private final int EXPECTED_CACHE_SIZE_ZERO = 0;
+  private final int EXPECTED_CACHE_SIZE_ONE = 1;
+  private final int EXPECTED_CACHE_SIZE_TWO = 2;
+  private final int EXPECTED_CACHE_SIZE_THREE = 3;
+  private final long EXPECTED_REFERENCE_ONE = 1;
+  private final long EXPECTED_REFERENCE_TWO = 2;
+  
+  private final String TABLE = "tableName";
+  private final String FAMILY1 = "family1";
+  private final String FAMILY2 = "family2";
+  private final String FAMILY3 = "family3";
+  
+  private final byte[] ROW = Bytes.toBytes("row");
+  private final byte[] ROW2 = Bytes.toBytes("row2");
+  private final byte[] VALUE = Bytes.toBytes("value");
+  private final byte[] VALUE2 = Bytes.toBytes("value2");
+  private final byte[] QF1 = Bytes.toBytes("qf1");
+  private final byte[] QF2 = Bytes.toBytes("qf2");
+  private final byte[] QF3 = Bytes.toBytes("qf3");
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+  }
+
+  /**
+   * Create the mob store file.
+   * @param family
+   */
+  private Path createMobStoreFile(String family) throws IOException {
+    return createMobStoreFile(HBaseConfiguration.create(), family);
+  }
+
+  /**
+   * Create the mob store file
+   * @param conf
+   * @param family
+   */
+  private Path createMobStoreFile(Configuration conf, String family) throws IOException {
+    HColumnDescriptor hcd = new HColumnDescriptor(family);
+    hcd.setMaxVersions(4);
+    hcd.setValue(MobConstants.IS_MOB, "true");
+    mobCacheConf = new MobCacheConfig(conf, hcd);
+    return createMobStoreFile(conf, hcd);
+  }
+
+  /**
+   * Create the mob store file
+   * @param conf
+   * @param hcd
+   */
+  private Path createMobStoreFile(Configuration conf, HColumnDescriptor hcd)
+      throws IOException {
+    // Setting up a Store
+    Path basedir = this.testDir;
+    fs = FileSystem.get(conf);
+
+    HTableDescriptor htd = new HTableDescriptor(TABLE);
+    htd.addFamily(hcd);
+    Path homePath = new Path(basedir, TABLE + Path.SEPARATOR
+        + Bytes.toString(hcd.getName()));
+    MobFileStore mobFileStore = MobFileStore.create(conf, fs,
+        TableName.valueOf(TABLE), hcd);
+    if (mobFileStore == null) {
+      fs.mkdirs(homePath);
+      mobFileStore = MobFileStore.create(conf, fs, TableName.valueOf(TABLE), hcd);
+    }
+
+    KeyValue key1 = new KeyValue(ROW, hcd.getName(), QF1, 1, VALUE);
+    KeyValue key2 = new KeyValue(ROW, hcd.getName(), QF2, 1, VALUE);
+    KeyValue key3 = new KeyValue(ROW2, hcd.getName(), QF3, 1, VALUE2);
+    KeyValue[] keys = new KeyValue[] { key1, key2, key3 };
+    int maxKeyCount = keys.length;
+    HRegionInfo regionStartKey = new HRegionInfo();
+    StoreFile.Writer mobWriter = mobFileStore.createWriterInTmp(currentDate, 
+        maxKeyCount, hcd.getCompactionCompression(), regionStartKey.getStartKey());
+    Path mobFilePath = mobWriter.getPath();
+    String fileName = mobFilePath.getName();
+    mobWriter.append(key1);
+    mobWriter.append(key2);
+    mobWriter.append(key3);
+    mobWriter.close();
+    String targetPathName = MobUtils.formatDate(currentDate);
+    Path targetPath = new Path(mobFileStore.getPath(), targetPathName);
+    mobFileStore.commitFile(mobFilePath, targetPath);
+    return new Path(targetPath, fileName);
+  }
+
+  @Test
+  public void testMobFileCache() throws Exception {
+    conf.set(MobConstants.MOB_FILE_CACHE_SIZE_KEY, TEST_CACHE_SIZE);
+    mobFileCache = new MobFileCache(conf);
+    Path file1Path = createMobStoreFile(FAMILY1);
+    Path file2Path = createMobStoreFile(FAMILY2);
+    Path file3Path = createMobStoreFile(FAMILY3);
+    
+    // Before open one file by the MobFileCache
+    assertEquals(EXPECTED_CACHE_SIZE_ZERO, mobFileCache.getCacheSize());
+    // Open one file by the MobFileCache
+    CachedMobFile cachedMobFile1 = (CachedMobFile) mobFileCache.openFile(
+        this.fs, file1Path, mobCacheConf);
+    assertEquals(EXPECTED_CACHE_SIZE_ONE, mobFileCache.getCacheSize());
+    assertNotNull(cachedMobFile1);
+    assertEquals(EXPECTED_REFERENCE_TWO, cachedMobFile1.getReference());
+    
+    // The evict is also managed by a schedule thread pool.
+    // And its check period is set as 3600 seconds by default.
+    // This evict should get the lock at the most time
+    mobFileCache.evict();  // Cache not full, evict it
+    assertEquals(EXPECTED_CACHE_SIZE_ONE, mobFileCache.getCacheSize());
+    assertEquals(EXPECTED_REFERENCE_TWO, cachedMobFile1.getReference());
+    
+    mobFileCache.evictFile(file1Path.getName());  // Evict one file
+    assertEquals(EXPECTED_CACHE_SIZE_ZERO, mobFileCache.getCacheSize());
+    assertEquals(EXPECTED_REFERENCE_ONE, cachedMobFile1.getReference());
+    
+    cachedMobFile1.close();  // Close the cached mob file
+    
+    // Reopen three cached file
+    cachedMobFile1 = (CachedMobFile) mobFileCache.openFile(
+        this.fs, file1Path, mobCacheConf);
+    assertEquals(EXPECTED_CACHE_SIZE_ONE, mobFileCache.getCacheSize());
+    CachedMobFile cachedMobFile2 = (CachedMobFile) mobFileCache.openFile(
+        this.fs, file2Path, mobCacheConf);
+    assertEquals(EXPECTED_CACHE_SIZE_TWO, mobFileCache.getCacheSize());
+    CachedMobFile cachedMobFile3 = (CachedMobFile) mobFileCache.openFile(
+        this.fs, file3Path, mobCacheConf);
+    // Before the evict
+    // Evict the cache, should clost the first file 1
+    assertEquals(EXPECTED_CACHE_SIZE_THREE, mobFileCache.getCacheSize());
+    assertEquals(EXPECTED_REFERENCE_TWO, cachedMobFile1.getReference());
+    assertEquals(EXPECTED_REFERENCE_TWO, cachedMobFile2.getReference());
+    assertEquals(EXPECTED_REFERENCE_TWO, cachedMobFile3.getReference());
+    mobFileCache.evict();
+    assertEquals(EXPECTED_CACHE_SIZE_ONE, mobFileCache.getCacheSize());
+    assertEquals(EXPECTED_REFERENCE_ONE, cachedMobFile1.getReference());
+    assertEquals(EXPECTED_REFERENCE_ONE, cachedMobFile2.getReference());
+    assertEquals(EXPECTED_REFERENCE_TWO, cachedMobFile3.getReference());
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestMobFileName.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestMobFileName.java
new file mode 100644
index 0000000..28a9f0c
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/TestMobFileName.java
@@ -0,0 +1,99 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob;
+
+import java.util.Date;
+import java.util.Random;
+import java.util.UUID;
+
+import junit.framework.TestCase;
+
+import org.apache.hadoop.hbase.SmallTests;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(SmallTests.class)
+public class TestMobFileName extends TestCase {
+
+  private String uuid;
+  private Date date;
+  private String dateStr;
+  private int startKey;
+
+  public void setUp() {
+    Random random = new Random();
+    uuid = UUID.randomUUID().toString().replaceAll("-", "");
+    date = new Date();
+    dateStr = MobUtils.formatDate(date);
+    startKey = random.nextInt();
+  }
+
+  @Test
+  public void testHashCode() {
+    assertEquals(
+      MobFileName.create(MobFileName.int2HexString(startKey),
+        dateStr, uuid).hashCode(),
+      MobFileName.create(MobFileName.int2HexString(startKey),
+        dateStr, uuid).hashCode());
+    assertNotSame(
+      MobFileName.create(MobFileName.int2HexString(startKey),
+        dateStr, uuid).hashCode(),
+      MobFileName.create(MobFileName.int2HexString(startKey),
+        dateStr, uuid).hashCode());
+  }
+
+  @Test
+  public void testCreate() {
+    MobFileName mobFileName = MobFileName.create(
+      MobFileName.int2HexString(startKey), dateStr, uuid);
+    assertEquals(mobFileName,
+      MobFileName.create(mobFileName.getFileName()));
+  }
+
+  @Test
+  public void testSwitchHexStringInt() {
+    int[] ints = { -1, 0, 123, Integer.MIN_VALUE, Integer.MAX_VALUE };
+    for (int i = 0; i < ints.length; i++) {
+      assertEquals(ints[i],
+        MobFileName.hexString2Int(MobFileName.int2HexString(ints[i])));
+    }
+  }
+
+  @Test
+  public void testGet() {
+    MobFileName mobFileName = MobFileName.create(
+      MobFileName.int2HexString(startKey), dateStr, uuid);
+    assertEquals(MobFileName.int2HexString(startKey),
+      mobFileName.getStartKey()); // getStartKey
+    assertEquals(dateStr, mobFileName.getDate()); // getDate
+    assertEquals(
+      mobFileName.getFileName(),
+         MobFileName.int2HexString(startKey) + dateStr + uuid); // getFileName
+  }
+
+  @Test
+  public void testEquals() {
+    MobFileName mobFileName = MobFileName.create(
+      MobFileName.int2HexString(startKey), dateStr, uuid);
+    assertTrue(mobFileName.equals(mobFileName));
+    assertFalse(mobFileName.equals(this));
+    assertTrue(mobFileName.equals(MobFileName.create(
+      MobFileName.int2HexString(startKey), dateStr, uuid)));
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestDefaultMobStoreFlusher.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestDefaultMobStoreFlusher.java
new file mode 100644
index 0000000..2f009de
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestDefaultMobStoreFlusher.java
@@ -0,0 +1,197 @@
+/**
+*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package org.apache.hadoop.hbase.regionserver;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.MasterNotRunningException;
+import org.apache.hadoop.hbase.ZooKeeperConnectionException;
+import org.apache.hadoop.hbase.client.HBaseAdmin;
+import org.apache.hadoop.hbase.client.HTable;
+import org.apache.hadoop.hbase.client.Put;
+import org.apache.hadoop.hbase.client.Result;
+import org.apache.hadoop.hbase.client.ResultScanner;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class TestDefaultMobStoreFlusher {
+
+ private final static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
+ private final static byte [] row1 = Bytes.toBytes("row1");
+ private final static byte [] row2 = Bytes.toBytes("row2");
+ private final static byte [] family = Bytes.toBytes("family");
+ private final static byte [] qf1 = Bytes.toBytes("qf1");
+ private final static byte [] qf2 = Bytes.toBytes("qf2");
+ private final static byte [] value1 = Bytes.toBytes("value1");
+ private final static byte [] value2 = Bytes.toBytes("value2");
+
+ @BeforeClass
+ public static void setUpBeforeClass() throws Exception {
+   TEST_UTIL.getConfiguration().setInt("hbase.master.info.port", 0);
+   TEST_UTIL.getConfiguration().setBoolean("hbase.regionserver.info.port.auto", true);
+   // Set the DefaultMobStoreFlusher as the default store flush
+   TEST_UTIL.getConfiguration().setClass(
+       DefaultStoreEngine.DEFAULT_STORE_FLUSHER_CLASS_KEY,
+       DefaultMobStoreFlusher.class, StoreFlusher.class);
+
+   TEST_UTIL.startMiniCluster(1);
+ }
+ 
+ @AfterClass
+ public static void tearDownAfterClass() throws Exception {
+   TEST_UTIL.shutdownMiniCluster();
+ }
+ 
+ @SuppressWarnings("deprecation")
+ @Test
+ public void testFlushNonMobFile() throws InterruptedException {
+   String TN = "testFlushNonMobFile";
+   HTable table = null;
+   HBaseAdmin admin = null;
+   
+   try {
+     HTableDescriptor desc = new HTableDescriptor(TN);
+     HColumnDescriptor hcd = new HColumnDescriptor(family);
+     hcd.setMaxVersions(4);
+     desc.addFamily(hcd);
+     
+     admin = new HBaseAdmin(TEST_UTIL.getConfiguration());
+     admin.createTable(desc);
+     table = new HTable(TEST_UTIL.getConfiguration(), TN);
+     
+     //Put data
+     Put put0 = new Put(row1);
+     KeyValue kv1 = new KeyValue(row1, family, qf1, 1, KeyValue.Type.Put, value1);
+     put0.add(kv1);
+     table.put(put0);
+
+     //Put more data
+     Put put1 = new Put(row2);
+     KeyValue kv2 = new KeyValue(row2, family, qf2, 1, KeyValue.Type.Put, value2);
+     put1.add(kv2);
+     table.put(put1);
+
+     //Flush
+     table.flushCommits();
+     admin.flush(TN);
+
+     Scan scan = new Scan();
+     scan.addColumn(family, qf1);
+     scan.setMaxVersions(4);
+     ResultScanner scanner = table.getScanner(scan);
+
+     //Compare
+     Result result = scanner.next();
+     int size = 0;
+     while (result != null) {
+       size++;
+       List<Cell> cells = result.getColumnCells(family, qf1);
+       // Verify the cell size
+       Assert.assertEquals(1, cells.size());
+       // Verify the value
+       Assert.assertEquals(Bytes.toString(value1), Bytes.toString(cells.get(0).getValue()));
+       result = scanner.next();
+     }
+     scanner.close();
+     Assert.assertEquals(1, size);
+     admin.close();
+   } catch (MasterNotRunningException e1) {
+     e1.printStackTrace();
+   } catch (ZooKeeperConnectionException e2) {
+     e2.printStackTrace();
+   } catch (IOException e3) {
+     e3.printStackTrace();
+   }
+ }
+ 
+ @SuppressWarnings("deprecation")
+ @Test
+ public void testFlushMobFile() throws InterruptedException {
+   String TN = "testFlushMobFile";
+   HTable table = null;
+   HBaseAdmin admin = null;
+   
+   try {
+     HTableDescriptor desc = new HTableDescriptor(TN);
+     HColumnDescriptor hcd = new HColumnDescriptor(family);
+     hcd.setValue(MobConstants.IS_MOB, "true");
+     hcd.setMaxVersions(4);
+     desc.addFamily(hcd);
+     
+     admin = new HBaseAdmin(TEST_UTIL.getConfiguration());
+     admin.createTable(desc);
+     table = new HTable(TEST_UTIL.getConfiguration(), TN);
+
+     //put data
+     Put put0 = new Put(row1);
+     KeyValue kv1 = new KeyValue(row1, family, qf1, 1, KeyValue.Type.Put, value1);
+     put0.add(kv1);
+     table.put(put0);
+
+     //put more data
+     Put put1 = new Put(row2);
+     KeyValue kv2 = new KeyValue(row2, family, qf2, 1, KeyValue.Type.Put, value2);
+     put1.add(kv2);
+     table.put(put1);
+
+     //flush
+     table.flushCommits();
+     admin.flush(TN);
+
+     //Scan
+     Scan scan = new Scan();
+     scan.addColumn(family, qf1);
+     scan.setMaxVersions(4);
+     ResultScanner scanner = table.getScanner(scan);
+
+     //Compare
+     Result result = scanner.next();
+     int size = 0;
+     while (result != null) {
+       size++;
+       List<Cell> cells = result.getColumnCells(family, qf1);
+       // Verify the the cell size
+       Assert.assertEquals(1, cells.size());
+       // Verify the value
+       Assert.assertEquals(Bytes.toString(value1), Bytes.toString(cells.get(0).getValue()));
+       result = scanner.next();
+     }
+     scanner.close();
+     Assert.assertEquals(1, size);
+     admin.close();
+   } catch (MasterNotRunningException e1) {
+     e1.printStackTrace();
+   } catch (ZooKeeperConnectionException e2) {
+     e2.printStackTrace();
+   } catch (IOException e3) {
+     e3.printStackTrace();
+   }
+ }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHMobStore.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHMobStore.java
new file mode 100644
index 0000000..da3ba71
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHMobStore.java
@@ -0,0 +1,406 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NavigableSet;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.MediumTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.Get;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.monitoring.MonitoredTask;
+import org.apache.hadoop.hbase.regionserver.wal.HLog;
+import org.apache.hadoop.hbase.regionserver.wal.HLogFactory;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.FSUtils;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.junit.rules.TestName;
+import org.mockito.Mockito;
+
+@Category(MediumTests.class)
+public class TestHMobStore {
+  public static final Log LOG = LogFactory.getLog(TestHMobStore.class);
+  @Rule public TestName name = new TestName();
+
+  HMobStore store;
+  byte [] table = Bytes.toBytes("table");
+  byte [] family = Bytes.toBytes("family");
+
+  byte [] row = Bytes.toBytes("row");
+  byte [] row2 = Bytes.toBytes("row2");
+  byte [] qf1 = Bytes.toBytes("qf1");
+  byte [] qf2 = Bytes.toBytes("qf2");
+  byte [] qf3 = Bytes.toBytes("qf3");
+  byte [] qf4 = Bytes.toBytes("qf4");
+  byte [] qf5 = Bytes.toBytes("qf5");
+  byte [] qf6 = Bytes.toBytes("qf6");
+
+  byte[] value = Bytes.toBytes("value");
+  
+  HColumnDescriptor hcd;
+  FileSystem fs;
+
+  NavigableSet<byte[]> qualifiers =
+    new ConcurrentSkipListSet<byte[]>(Bytes.BYTES_COMPARATOR);
+
+  List<Cell> expected = new ArrayList<Cell>();
+  List<Cell> results = new ArrayList<Cell>();
+
+  long id = System.currentTimeMillis();
+  Get get = new Get(row);
+
+  private final static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
+  private final String DIR = TEST_UTIL.getDataTestDir("TestHMobStore").toString();
+
+  /**
+   * Setup
+   * @throws Exception
+   */
+  @Before
+  public void setUp() throws Exception {
+    qualifiers.add(qf1);
+    qualifiers.add(qf3);
+    qualifiers.add(qf5);
+
+    Iterator<byte[]> iter = qualifiers.iterator();
+    while(iter.hasNext()){
+      byte [] next = iter.next();
+      expected.add(new KeyValue(row, family, next, 1, value));
+      get.addColumn(family, next);
+      get.setMaxVersions(); // all versions.
+    }
+  }
+
+  private void init(String methodName, Configuration conf)
+  throws IOException {
+    hcd = new HColumnDescriptor(family);
+    hcd.setValue(MobConstants.IS_MOB, "true");
+    hcd.setMaxVersions(4);
+    init(methodName, conf, hcd);
+  }
+
+  private void init(String methodName, Configuration conf,
+      HColumnDescriptor hcd) throws IOException {
+    HTableDescriptor htd = new HTableDescriptor(TableName.valueOf(table));
+    init(methodName, conf, htd, hcd);
+  }
+
+  @SuppressWarnings("deprecation")
+  private void init(String methodName, Configuration conf, HTableDescriptor htd,
+      HColumnDescriptor hcd) throws IOException {
+    //Setting up a Store
+    Path basedir = new Path(DIR+methodName);
+    Path tableDir = FSUtils.getTableDir(basedir, htd.getTableName());
+    String logName = "logs";
+    Path logdir = new Path(basedir, logName);
+    FileSystem fs = FileSystem.get(conf);
+    fs.delete(logdir, true);
+
+    htd.addFamily(hcd);
+    HRegionInfo info = new HRegionInfo(htd.getTableName(), null, null, false);
+    HLog hlog = HLogFactory.createHLog(fs, basedir, logName, conf);
+    HRegion region = new HRegion(tableDir, hlog, fs, conf, info, htd, null);
+    store = new HMobStore(region, hcd, conf);
+  }
+
+  /**
+   * Getting data from memstore
+   * @throws IOException
+   */
+  @Test
+  public void testGetFromMemStore() throws IOException {
+    final Configuration conf = HBaseConfiguration.create();
+    conf.setClass(DefaultStoreEngine.DEFAULT_STORE_FLUSHER_CLASS_KEY,
+        DefaultMobStoreFlusher.class, StoreFlusher.class);
+    init(name.getMethodName(), conf);
+
+    //Put data in memstore
+    this.store.add(new KeyValue(row, family, qf1, 1, value));
+    this.store.add(new KeyValue(row, family, qf2, 1, value));
+    this.store.add(new KeyValue(row, family, qf3, 1, value));
+    this.store.add(new KeyValue(row, family, qf4, 1, value));
+    this.store.add(new KeyValue(row, family, qf5, 1, value));
+    this.store.add(new KeyValue(row, family, qf6, 1, value));
+
+    Scan scan = new Scan(get);
+    InternalScanner scanner = (InternalScanner) store.getScanner(scan,
+        scan.getFamilyMap().get(store.getFamily().getName()),
+        0);
+
+    List<Cell> results = new ArrayList<Cell>();
+    scanner.next(results);
+    Collections.sort(results, KeyValue.COMPARATOR);
+    scanner.close();
+
+    //Compare
+    Assert.assertEquals(expected.size(), results.size());
+    for(int i=0; i<results.size(); i++) {
+      // Verify the values
+      Assert.assertEquals(expected.get(i), results.get(i));
+    }
+  }
+
+  /**
+   * Getting MOB data from files
+   * @throws IOException
+   */
+  @Test
+  public void testGetFromFiles() throws IOException {
+    final Configuration conf = TEST_UTIL.getConfiguration();
+    conf.setClass(DefaultStoreEngine.DEFAULT_STORE_FLUSHER_CLASS_KEY,
+        DefaultMobStoreFlusher.class, StoreFlusher.class);
+    init(name.getMethodName(), conf);
+
+    //Put data in memstore
+    this.store.add(new KeyValue(row, family, qf1, 1, value));
+    this.store.add(new KeyValue(row, family, qf2, 1, value));
+    //flush
+    flush(1);
+
+    //Add more data
+    this.store.add(new KeyValue(row, family, qf3, 1, value));
+    this.store.add(new KeyValue(row, family, qf4, 1, value));
+    //flush
+    flush(2);
+
+    //Add more data
+    this.store.add(new KeyValue(row, family, qf5, 1, value));
+    this.store.add(new KeyValue(row, family, qf6, 1, value));
+    //flush
+    flush(3);
+
+    Scan scan = new Scan(get);
+    InternalScanner scanner = (InternalScanner) store.getScanner(scan,
+        scan.getFamilyMap().get(store.getFamily().getName()),
+        0);
+
+    List<Cell> results = new ArrayList<Cell>();
+    scanner.next(results);
+    Collections.sort(results, KeyValue.COMPARATOR);
+    scanner.close();
+
+    //Compare
+    Assert.assertEquals(expected.size(), results.size());
+    for(int i=0; i<results.size(); i++) {
+      Assert.assertEquals(expected.get(i), results.get(i));
+    }
+  }
+
+  /**
+   * Getting the reference data from files
+   * @throws IOException
+   */
+  @Test
+  public void testGetReferencesFromFiles() throws IOException {
+    final Configuration conf = HBaseConfiguration.create();
+    conf.setClass(DefaultStoreEngine.DEFAULT_STORE_FLUSHER_CLASS_KEY,
+        DefaultMobStoreFlusher.class, StoreFlusher.class);
+    init(name.getMethodName(), conf);
+
+    //Put data in memstore
+    this.store.add(new KeyValue(row, family, qf1, 1, value));
+    this.store.add(new KeyValue(row, family, qf2, 1, value));
+    //flush
+    flush(1);
+
+    //Add more data
+    this.store.add(new KeyValue(row, family, qf3, 1, value));
+    this.store.add(new KeyValue(row, family, qf4, 1, value));
+    //flush
+    flush(2);
+
+    //Add more data
+    this.store.add(new KeyValue(row, family, qf5, 1, value));
+    this.store.add(new KeyValue(row, family, qf6, 1, value));
+    //flush
+    flush(3);
+
+    Scan scan = new Scan(get);
+    scan.setAttribute(MobConstants.MOB_SCAN_RAW, Bytes.toBytes(Boolean.TRUE));
+    InternalScanner scanner = (InternalScanner) store.getScanner(scan,
+      scan.getFamilyMap().get(store.getFamily().getName()),
+      0);
+
+    List<Cell> results = new ArrayList<Cell>();
+    scanner.next(results);
+    Collections.sort(results, KeyValue.COMPARATOR);
+    scanner.close();
+
+    //Compare
+    Assert.assertEquals(expected.size(), results.size());
+    for(int i=0; i<results.size(); i++) {
+      Cell cell = results.get(i);
+      Assert.assertTrue(MobUtils.isMobReferenceCell(cell));
+    }
+  }
+
+  /**
+   * Getting data from memstore and files
+   * @throws IOException
+   */
+  @Test
+  public void testGetFromMemStoreAndFiles() throws IOException {
+
+    final Configuration conf = HBaseConfiguration.create();
+    conf.setClass(DefaultStoreEngine.DEFAULT_STORE_FLUSHER_CLASS_KEY,
+        DefaultMobStoreFlusher.class, StoreFlusher.class);
+    init(name.getMethodName(), conf);
+
+    //Put data in memstore
+    this.store.add(new KeyValue(row, family, qf1, 1, value));
+    this.store.add(new KeyValue(row, family, qf2, 1, value));
+    //flush
+    flush(1);
+
+    //Add more data
+    this.store.add(new KeyValue(row, family, qf3, 1, value));
+    this.store.add(new KeyValue(row, family, qf4, 1, value));
+    //flush
+    flush(2);
+
+    //Add more data
+    this.store.add(new KeyValue(row, family, qf5, 1, value));
+    this.store.add(new KeyValue(row, family, qf6, 1, value));
+
+    Scan scan = new Scan(get);
+    InternalScanner scanner = (InternalScanner) store.getScanner(scan,
+        scan.getFamilyMap().get(store.getFamily().getName()),
+        0);
+
+    List<Cell> results = new ArrayList<Cell>();
+    scanner.next(results);
+    Collections.sort(results, KeyValue.COMPARATOR);
+    scanner.close();
+
+    System.out.println(expected);
+    System.out.println(results);
+    //Compare
+    Assert.assertEquals(expected.size(), results.size());
+    for(int i=0; i<results.size(); i++) {
+      Assert.assertEquals(expected.get(i), results.get(i));
+    }
+  }
+
+  /**
+   * Getting data from memstore and files
+   * @throws IOException
+   */
+  @Test
+  public void testMobCellSizeThreshold() throws IOException {
+
+    final Configuration conf = HBaseConfiguration.create();
+    conf.setClass(DefaultStoreEngine.DEFAULT_STORE_FLUSHER_CLASS_KEY,
+        DefaultMobStoreFlusher.class, StoreFlusher.class);
+    
+    HColumnDescriptor hcd;
+    hcd = new HColumnDescriptor(family);
+    hcd.setValue(MobConstants.IS_MOB, "true");
+    hcd.setValue(MobConstants.SIZE_TAG, "100");
+    hcd.setMaxVersions(4);
+    init(name.getMethodName(), conf, hcd);
+
+    //Put data in memstore
+    this.store.add(new KeyValue(row, family, qf1, 1, value));
+    this.store.add(new KeyValue(row, family, qf2, 1, value));
+    //flush
+    flush(1);
+
+    //Add more data
+    this.store.add(new KeyValue(row, family, qf3, 1, value));
+    this.store.add(new KeyValue(row, family, qf4, 1, value));
+    //flush
+    flush(2);
+
+    //Add more data
+    this.store.add(new KeyValue(row, family, qf5, 1, value));
+    this.store.add(new KeyValue(row, family, qf6, 1, value));
+    //flush
+    flush(3);
+
+    Scan scan = new Scan(get);
+    scan.setAttribute(MobConstants.MOB_SCAN_RAW, Bytes.toBytes(Boolean.TRUE));
+    InternalScanner scanner = (InternalScanner) store.getScanner(scan,
+      scan.getFamilyMap().get(store.getFamily().getName()),
+      0);
+
+    List<Cell> results = new ArrayList<Cell>();
+    scanner.next(results);
+    Collections.sort(results, KeyValue.COMPARATOR);
+    scanner.close();
+
+    //Compare
+    Assert.assertEquals(expected.size(), results.size());
+    for(int i=0; i<results.size(); i++) {
+      Cell cell = results.get(i);
+      //this is not mob reference cell.
+      Assert.assertFalse(MobUtils.isMobReferenceCell(cell));
+      Assert.assertEquals(expected.get(i), results.get(i));
+      Assert.assertEquals(100, MobUtils.getMobSizeThreshold(store.getFamily()));
+    }
+  }
+
+  /**
+   * Flush the memstore
+   * @param storeFilesSize
+   * @throws IOException
+   */
+  private void flush(int storeFilesSize) throws IOException{
+    this.store.snapshot();
+    flushStore(store, id++);
+    Assert.assertEquals(storeFilesSize, this.store.getStorefiles().size());
+    Assert.assertEquals(0, ((DefaultMemStore)this.store.memstore).kvset.size());
+  }
+
+  /**
+   * Flush the memstore
+   * @param store
+   * @param id
+   * @throws IOException
+   */
+  private static void flushStore(HMobStore store, long id) throws IOException {
+    StoreFlushContext storeFlushCtx = store.createFlushContext(id);
+    storeFlushCtx.prepare();
+    storeFlushCtx.flushCache(Mockito.mock(MonitoredTask.class));
+    storeFlushCtx.commit(Mockito.mock(MonitoredTask.class));
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMobFileStore.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMobFileStore.java
new file mode 100644
index 0000000..49c09f8
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMobFileStore.java
@@ -0,0 +1,150 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver;
+
+import java.io.IOException;
+import java.util.Date;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.HBaseTestCase;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.SmallTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(SmallTests.class)
+public class TestMobFileStore extends HBaseTestCase {
+  public static final Log LOG = LogFactory.getLog(TestMobFileStore.class);
+
+  private MobFileStore mobFileStore;
+  private Path mobFilePath;
+  private FileSystem fs;
+  private KeyValue seekKey1;
+  private KeyValue seekKey2;
+  private KeyValue seekKey3;
+  private Date currentDate = new Date();
+
+  private final byte[] TABLE = Bytes.toBytes("table");
+  private final byte[] FAMILY = Bytes.toBytes("family");
+
+  private final byte[] ROW = Bytes.toBytes("row");
+  private final byte[] ROW2 = Bytes.toBytes("row2");
+  private final byte[] VALUE = Bytes.toBytes("value");
+  private final byte[] VALUE2 = Bytes.toBytes("value2");
+  private final byte[] QF1 = Bytes.toBytes("qf1");
+  private final byte[] QF2 = Bytes.toBytes("qf2");
+  private final byte[] QF3 = Bytes.toBytes("qf3");
+
+  private void init(String methodName) throws IOException {
+    init(methodName, HBaseConfiguration.create());
+  }
+
+  private void init(String methodName, Configuration conf) throws IOException {
+    HColumnDescriptor hcd = new HColumnDescriptor(FAMILY);
+    hcd.setMaxVersions(4);
+    hcd.setValue(MobConstants.IS_MOB, "true");
+    init(methodName, conf, hcd);
+  }
+
+  private void init(String methodName, Configuration conf, HColumnDescriptor hcd)
+      throws IOException {
+    // Setting up a Store
+    Path basedir = this.testDir;
+    fs = FileSystem.get(conf);
+
+    HTableDescriptor htd = new HTableDescriptor(TABLE);
+    htd.addFamily(hcd);
+    Path homePath = new Path(basedir, Bytes.toString(TABLE) + Path.SEPARATOR
+        + Bytes.toString(FAMILY));
+    fs.mkdirs(homePath);
+    mobFileStore = MobFileStore.create(conf, fs, TableName.valueOf(TABLE), hcd);
+
+    KeyValue key1 = new KeyValue(ROW, FAMILY, QF1, 1, VALUE);
+    KeyValue key2 = new KeyValue(ROW, FAMILY, QF2, 1, VALUE);
+    KeyValue key3 = new KeyValue(ROW2, FAMILY, QF3, 1, VALUE2);
+    KeyValue[] keys = new KeyValue[] { key1, key2, key3 };
+    int maxKeyCount = keys.length;
+    HRegionInfo regionStartKey = new HRegionInfo();
+    StoreFile.Writer mobWriter = mobFileStore.createWriterInTmp(currentDate,
+        maxKeyCount, hcd.getCompactionCompression(), regionStartKey.getStartKey());
+    mobFilePath = mobWriter.getPath();
+
+    mobWriter.append(key1);
+    mobWriter.append(key2);
+    mobWriter.append(key3);
+    mobWriter.close();
+    String targetPathName = MobUtils.formatDate(currentDate);
+
+    long valueLength1 = key1.getValueLength();
+    long valueLength2 = key2.getValueLength();
+    long valueLength3 = key3.getValueLength();
+    byte[] referenceValue =
+            Bytes.toBytes(targetPathName + Path.SEPARATOR
+                + mobFilePath.getName());
+    byte[] newReferenceValue1 = Bytes.add(Bytes.toBytes(valueLength1), referenceValue);
+    byte[] newReferenceValue2 = Bytes.add(Bytes.toBytes(valueLength2), referenceValue);
+    byte[] newReferenceValue3 = Bytes.add(Bytes.toBytes(valueLength3), referenceValue);
+    seekKey1 = new KeyValue(ROW, FAMILY, QF1, Long.MAX_VALUE, newReferenceValue1);
+    seekKey2 = new KeyValue(ROW, FAMILY, QF2, Long.MAX_VALUE, newReferenceValue2);
+    seekKey3 = new KeyValue(ROW2, FAMILY, QF3, Long.MAX_VALUE, newReferenceValue3);
+  }
+
+  @Test
+  public void testCommitFile() throws Exception {
+    init(getName());
+    String targetPathName = MobUtils.formatDate(new Date());
+    Path targetPath = new Path(mobFileStore.getPath(), (targetPathName
+        + Path.SEPARATOR + mobFilePath.getName()));
+    fs.delete(targetPath);
+    assertFalse(fs.exists(targetPath));
+    //commit file
+    mobFileStore.commitFile(mobFilePath, targetPath);
+    assertTrue(fs.exists(targetPath));
+  }
+
+  @Test
+  @SuppressWarnings("deprecation")
+  public void testResolve() throws Exception {
+    init(getName());
+    String targetPathName = MobUtils.formatDate(currentDate);
+    Path targetPath = new Path(mobFileStore.getPath(), targetPathName);
+    mobFileStore.commitFile(mobFilePath, targetPath);
+    //resolve
+    Cell resultKey1 = mobFileStore.resolve(seekKey1, false);
+    Cell resultKey2 = mobFileStore.resolve(seekKey2, false);
+    Cell resultKey3 = mobFileStore.resolve(seekKey3, false);
+    //compare
+    assertEquals(VALUE, resultKey1.getValue());
+    assertEquals(VALUE, resultKey2.getValue());
+    assertEquals(VALUE2, resultKey3.getValue());
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMobReversedStoreScanner.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMobReversedStoreScanner.java
new file mode 100644
index 0000000..daf1b17
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMobReversedStoreScanner.java
@@ -0,0 +1,301 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.MasterNotRunningException;
+import org.apache.hadoop.hbase.MediumTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.ZooKeeperConnectionException;
+import org.apache.hadoop.hbase.client.HBaseAdmin;
+import org.apache.hadoop.hbase.client.HTable;
+import org.apache.hadoop.hbase.client.Put;
+import org.apache.hadoop.hbase.client.Result;
+import org.apache.hadoop.hbase.client.ResultScanner;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(MediumTests.class)
+public class TestMobReversedStoreScanner {
+
+  private final static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
+  private final static String TN = "testMobReversedStoreScanner";
+  private final static byte [] row1 = Bytes.toBytes("row1");
+  private final static byte [] row2 = Bytes.toBytes("row2");
+  private final static byte [] family = Bytes.toBytes("family");
+  private final static byte [] qf1 = Bytes.toBytes("qualifier1");
+  private final static byte [] qf2 = Bytes.toBytes("qualifier2");
+  protected final byte[] qf3 = Bytes.toBytes("qualifier3");
+  protected final byte[] qf4 = Bytes.toBytes("qualifier4");
+  protected final byte[] qf5 = Bytes.toBytes("qualifier5");
+  protected final byte[] qf6 = Bytes.toBytes("qualifier6");
+  private final static byte [] value1 = Bytes.toBytes("value1");
+  private final static byte [] value2 = Bytes.toBytes("value2");
+  private final static byte [] value3 = Bytes.toBytes("value3");
+  private final static byte [] value4 = Bytes.toBytes("value4");
+  private final static byte [] value5 = Bytes.toBytes("value5");
+  private final static byte [] value6 = Bytes.toBytes("value6");
+  private static HTable table;
+  private static HBaseAdmin admin;
+  private static HColumnDescriptor hcd; 
+  private static HTableDescriptor desc;
+
+  @BeforeClass
+  public static void setUpBeforeClass() throws Exception {
+    TEST_UTIL.getConfiguration().setInt("hbase.master.info.port", 0);
+    TEST_UTIL.getConfiguration().setBoolean("hbase.regionserver.info.port.auto", true);
+    TEST_UTIL.getConfiguration().setClass(
+        DefaultStoreEngine.DEFAULT_STORE_FLUSHER_CLASS_KEY,
+        DefaultMobStoreFlusher.class, StoreFlusher.class);
+
+    TEST_UTIL.startMiniCluster(1);
+  }
+  
+  @AfterClass
+  public static void tearDownAfterClass() throws Exception {
+    TEST_UTIL.shutdownMiniCluster();
+  }
+  
+  @SuppressWarnings("deprecation")
+  @Before
+  public void setUp() throws Exception {
+    desc = new HTableDescriptor(TN);
+    hcd = new HColumnDescriptor(family);
+    hcd.setValue(MobConstants.IS_MOB, "true");
+    hcd.setMaxVersions(4);
+    desc.addFamily(hcd);
+    
+    admin = new HBaseAdmin(TEST_UTIL.getConfiguration());
+    admin.createTable(desc);
+    table = new HTable(TEST_UTIL.getConfiguration(), TN);
+  }
+  
+  @After
+  public void tearDown() throws Exception {
+    admin.disableTable(TN);
+    admin.deleteTable(TN);
+    admin.close();
+  }
+  
+  @SuppressWarnings("deprecation")
+  @Test
+  public void testMobReversedStoreScannerGetFromFiles() throws InterruptedException {
+    try {
+      
+      long ts1 = 1; // System.currentTimeMillis();
+      long ts2 = ts1 + 1;
+      long ts3 = ts1 + 2;
+      
+      KeyValue kv13 = new KeyValue(row1, family, qf1, ts3, KeyValue.Type.Put, value1);
+      KeyValue kv12 = new KeyValue(row1, family, qf2, ts2, KeyValue.Type.Put, value2);
+      KeyValue kv11 = new KeyValue(row1, family, qf3, ts1, KeyValue.Type.Put, value3);
+
+      KeyValue kv23 = new KeyValue(row2, family, qf4, ts3, KeyValue.Type.Put, value4);
+      KeyValue kv22 = new KeyValue(row2, family, qf5, ts2, KeyValue.Type.Put, value5);
+      KeyValue kv21 = new KeyValue(row2, family, qf6, ts1, KeyValue.Type.Put, value6);
+      // Put data to table
+      Put put1 = new Put(row1);
+      put1.add(kv13);
+      put1.add(kv12);
+      put1.add(kv11);
+      table.put(put1);
+      // Put more data to table
+      Put put2 = new Put(row2);
+      put2.add(kv23);
+      put2.add(kv22);
+      put2.add(kv21);
+      table.put(put2);
+      // Flush
+      table.flushCommits();
+      admin.flush(TN);
+      
+      Scan scan = new Scan();
+      // Set this scan is a reversed one
+      scan.setReversed(true);
+      scan.addColumn(family, qf2);
+      scan.setMaxVersions(4);
+      ResultScanner scanner = table.getScanner(scan);
+
+      Result result = scanner.next();
+      int size = 0;
+      while (result != null) {
+        size++;
+        List<Cell> cells = result.getColumnCells(family, qf2);
+        Assert.assertEquals(1, cells.size());
+        Assert.assertEquals(Bytes.toString(value2), Bytes.toString(cells.get(0).getValue()));
+        result = scanner.next();
+      }
+      scanner.close();
+      Assert.assertEquals(1, size);
+    } catch (MasterNotRunningException e) {
+      e.printStackTrace();
+    } catch (ZooKeeperConnectionException e) {
+      e.printStackTrace();
+    } catch (IOException e) {
+      e.printStackTrace();
+    }
+  }
+  
+  @SuppressWarnings("deprecation")
+  @Test
+  public void testMobReversedStoreScannerGetFromMemStore() throws InterruptedException {
+    try {
+      
+      long ts1 = 1; // System.currentTimeMillis();
+      long ts2 = ts1 + 1;
+      long ts3 = ts1 + 2;
+      
+      KeyValue kv13 = new KeyValue(row1, family, qf1, ts3, KeyValue.Type.Put, value1);
+      KeyValue kv12 = new KeyValue(row1, family, qf2, ts2, KeyValue.Type.Put, value2);
+      KeyValue kv11 = new KeyValue(row1, family, qf3, ts1, KeyValue.Type.Put, value3);
+
+      KeyValue kv23 = new KeyValue(row2, family, qf4, ts3, KeyValue.Type.Put, value4);
+      KeyValue kv22 = new KeyValue(row2, family, qf5, ts2, KeyValue.Type.Put, value5);
+      KeyValue kv21 = new KeyValue(row2, family, qf6, ts1, KeyValue.Type.Put, value6);
+      // Put data to table
+      Put put1 = new Put(row1);
+      put1.add(kv13);
+      put1.add(kv12);
+      put1.add(kv11);
+      table.put(put1);
+      // Put more data to table
+      Put put2 = new Put(row2);
+      put2.add(kv23);
+      put2.add(kv22);
+      put2.add(kv21);
+      table.put(put2);
+      
+      Scan scan = new Scan();
+      // Set this scan is a reversed one
+      scan.setReversed(true);
+      scan.addColumn(family, qf2);
+      scan.setMaxVersions(4);
+      ResultScanner scanner = table.getScanner(scan);
+
+      Result result = scanner.next();
+      int size = 0;
+      while (result != null) {
+        size++;
+        List<Cell> cells = result.getColumnCells(family, qf2);
+        Assert.assertEquals(1, cells.size());
+        Assert.assertEquals(Bytes.toString(value2), Bytes.toString(cells.get(0).getValue()));
+        result = scanner.next();
+      }
+      scanner.close();
+      Assert.assertEquals(1, size);
+    } catch (MasterNotRunningException e) {
+      e.printStackTrace();
+    } catch (ZooKeeperConnectionException e) {
+      e.printStackTrace();
+    } catch (IOException e) {
+      e.printStackTrace();
+    }
+  }
+  
+  @SuppressWarnings("deprecation")
+  @Test
+  public void testMobReversedStoreScannerGetReferences() throws InterruptedException {
+    try {
+      
+      long ts1 = 1; // System.currentTimeMillis();
+      long ts2 = ts1 + 1;
+      long ts3 = ts1 + 2;
+      
+      KeyValue kv13 = new KeyValue(row1, family, qf1, ts3, KeyValue.Type.Put, value1);
+      KeyValue kv12 = new KeyValue(row1, family, qf2, ts2, KeyValue.Type.Put, value2);
+      KeyValue kv11 = new KeyValue(row1, family, qf3, ts1, KeyValue.Type.Put, value3);
+
+      KeyValue kv23 = new KeyValue(row2, family, qf4, ts3, KeyValue.Type.Put, value4);
+      KeyValue kv22 = new KeyValue(row2, family, qf5, ts2, KeyValue.Type.Put, value5);
+      KeyValue kv21 = new KeyValue(row2, family, qf6, ts1, KeyValue.Type.Put, value6);
+      // Put data to table
+      Put put1 = new Put(row1);
+      put1.add(kv13);
+      put1.add(kv12);
+      put1.add(kv11);
+      table.put(put1);
+      // Put more data to table
+      Put put2 = new Put(row2);
+      put2.add(kv23);
+      put2.add(kv22);
+      put2.add(kv21);
+      table.put(put2);
+      // Flush
+      table.flushCommits();
+      admin.flush(TN);
+      
+      Scan scan = new Scan();
+      // Set this scan is a reversed one
+      scan.setReversed(true);
+      scan.addColumn(family, qf2);
+      scan.setMaxVersions(4);
+      //set the scan attribute
+      scan.setAttribute(MobConstants.MOB_SCAN_RAW, Bytes.toBytes(Boolean.TRUE));
+      ResultScanner scanner = table.getScanner(scan);
+
+      Result result = scanner.next();
+      int size = 0;
+      while (result != null) {
+        size++;
+        List<Cell> cells = result.getColumnCells(family, qf2);
+        Assert.assertEquals(1, cells.size());
+        Assert.assertEquals(Bytes.toString(row1), Bytes.toString(cells.get(0).getRow()));
+        Assert.assertEquals(Bytes.toString(family), Bytes.toString(cells.get(0).getFamily()));
+        Assert.assertFalse(Bytes.toString(value2).equals(Bytes.toString(cells.get(0).getValue())));
+        
+        byte[] referenceValue = cells.get(0).getValue();
+        String fileName = Bytes.toString(referenceValue, 8, referenceValue.length-8);
+        Path mobFamilyPath;
+        mobFamilyPath = new Path(MobUtils.getMobRegionPath(TEST_UTIL.getConfiguration(),
+            TableName.valueOf(TN)), hcd.getNameAsString());
+        Path targetPath = new Path(mobFamilyPath, fileName);
+          FileSystem fs = FileSystem.get(TEST_UTIL.getConfiguration());
+        Assert.assertTrue(fs.exists(targetPath));
+        
+        result = scanner.next();
+      }
+      scanner.close();
+      Assert.assertEquals(1, size);
+    } catch (MasterNotRunningException e) {
+      e.printStackTrace();
+    } catch (ZooKeeperConnectionException e) {
+      e.printStackTrace();
+    } catch (IOException e) {
+      e.printStackTrace();
+    }
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMobStoreScanner.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMobStoreScanner.java
new file mode 100644
index 0000000..338a0b2
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMobStoreScanner.java
@@ -0,0 +1,295 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.MasterNotRunningException;
+import org.apache.hadoop.hbase.MediumTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.ZooKeeperConnectionException;
+import org.apache.hadoop.hbase.client.HBaseAdmin;
+import org.apache.hadoop.hbase.client.HTable;
+import org.apache.hadoop.hbase.client.Put;
+import org.apache.hadoop.hbase.client.Result;
+import org.apache.hadoop.hbase.client.ResultScanner;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(MediumTests.class)
+public class TestMobStoreScanner {
+
+  private final static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
+  private final static String TN = "testMobStoreScanner";
+  private final static byte [] row1 = Bytes.toBytes("row1");
+  private final static byte [] row2 = Bytes.toBytes("row2");
+  private final static byte [] family = Bytes.toBytes("family");
+  private final static byte [] qf1 = Bytes.toBytes("qualifier1");
+  private final static byte [] qf2 = Bytes.toBytes("qualifier2");
+  protected final byte[] qf3 = Bytes.toBytes("qualifier3");
+  protected final byte[] qf4 = Bytes.toBytes("qualifier4");
+  protected final byte[] qf5 = Bytes.toBytes("qualifier5");
+  protected final byte[] qf6 = Bytes.toBytes("qualifier6");
+  private final static byte [] value1 = Bytes.toBytes("value1");
+  private final static byte [] value2 = Bytes.toBytes("value2");
+  private final static byte [] value3 = Bytes.toBytes("value3");
+  private final static byte [] value4 = Bytes.toBytes("value4");
+  private final static byte [] value5 = Bytes.toBytes("value5");
+  private final static byte [] value6 = Bytes.toBytes("value6");
+  private static HTable table;
+  private static HBaseAdmin admin;
+  private static HColumnDescriptor hcd; 
+  private static HTableDescriptor desc;
+
+  @BeforeClass
+  public static void setUpBeforeClass() throws Exception {
+    TEST_UTIL.getConfiguration().setInt("hbase.master.info.port", 0);
+    TEST_UTIL.getConfiguration().setBoolean("hbase.regionserver.info.port.auto", true);
+    TEST_UTIL.getConfiguration().setClass(
+        DefaultStoreEngine.DEFAULT_STORE_FLUSHER_CLASS_KEY,
+        DefaultMobStoreFlusher.class, StoreFlusher.class);
+
+    TEST_UTIL.startMiniCluster(1);
+  }
+  
+  @AfterClass
+  public static void tearDownAfterClass() throws Exception {
+    TEST_UTIL.shutdownMiniCluster();
+  }
+  
+  @SuppressWarnings("deprecation")
+  @Before
+  public void setUp() throws Exception {
+    desc = new HTableDescriptor(TN);
+    hcd = new HColumnDescriptor(family);
+    hcd.setValue(MobConstants.IS_MOB, "true");
+    hcd.setMaxVersions(4);
+    desc.addFamily(hcd);
+    
+    admin = new HBaseAdmin(TEST_UTIL.getConfiguration());
+    admin.createTable(desc);
+    table = new HTable(TEST_UTIL.getConfiguration(), TN);
+  }
+  
+  @After
+  public void tearDown() throws Exception {
+    admin.disableTable(TN);
+    admin.deleteTable(TN);
+    admin.close();
+  }
+  
+  @SuppressWarnings("deprecation")
+  @Test
+  public void testMobStoreScannerGetFromFiles() throws InterruptedException {
+    try {
+      
+      long ts1 = 1; // System.currentTimeMillis();
+      long ts2 = ts1 + 1;
+      long ts3 = ts1 + 2;
+      
+      KeyValue kv13 = new KeyValue(row1, family, qf1, ts3, KeyValue.Type.Put, value1);
+      KeyValue kv12 = new KeyValue(row1, family, qf2, ts2, KeyValue.Type.Put, value2);
+      KeyValue kv11 = new KeyValue(row1, family, qf3, ts1, KeyValue.Type.Put, value3);
+
+      KeyValue kv23 = new KeyValue(row2, family, qf4, ts3, KeyValue.Type.Put, value4);
+      KeyValue kv22 = new KeyValue(row2, family, qf5, ts2, KeyValue.Type.Put, value5);
+      KeyValue kv21 = new KeyValue(row2, family, qf6, ts1, KeyValue.Type.Put, value6);
+      
+      Put put1 = new Put(row1);
+      put1.add(kv13);
+      put1.add(kv12);
+      put1.add(kv11);
+      table.put(put1);
+      
+      Put put2 = new Put(row2);
+      put2.add(kv23);
+      put2.add(kv22);
+      put2.add(kv21);
+      table.put(put2);
+
+      table.flushCommits();
+      admin.flush(TN);
+      
+      Scan scan = new Scan();
+      scan.addColumn(family, qf2);
+      scan.setMaxVersions(4);
+      ResultScanner scanner = table.getScanner(scan);
+
+      Result result = scanner.next();
+      int size = 0;
+      while (result != null) {
+        size++;
+        List<Cell> cells = result.getColumnCells(family, qf2);
+        Assert.assertEquals(1, cells.size());
+        Assert.assertEquals(Bytes.toString(value2), Bytes.toString(cells.get(0).getValue()));
+        result = scanner.next();
+      }
+      scanner.close();
+      Assert.assertEquals(1, size);
+    } catch (MasterNotRunningException e) {
+      e.printStackTrace();
+    } catch (ZooKeeperConnectionException e) {
+      e.printStackTrace();
+    } catch (IOException e) {
+      e.printStackTrace();
+    }
+  }
+  
+  @SuppressWarnings("deprecation")
+  @Test
+  public void testMobStoreScannerGetFromMemStore() throws InterruptedException {
+    try {
+      
+      long ts1 = 1; // System.currentTimeMillis();
+      long ts2 = ts1 + 1;
+      long ts3 = ts1 + 2;
+      
+      KeyValue kv13 = new KeyValue(row1, family, qf1, ts3, KeyValue.Type.Put, value1);
+      KeyValue kv12 = new KeyValue(row1, family, qf2, ts2, KeyValue.Type.Put, value2);
+      KeyValue kv11 = new KeyValue(row1, family, qf3, ts1, KeyValue.Type.Put, value3);
+
+      KeyValue kv23 = new KeyValue(row2, family, qf4, ts3, KeyValue.Type.Put, value4);
+      KeyValue kv22 = new KeyValue(row2, family, qf5, ts2, KeyValue.Type.Put, value5);
+      KeyValue kv21 = new KeyValue(row2, family, qf6, ts1, KeyValue.Type.Put, value6);
+      
+      Put put1 = new Put(row1);
+      put1.add(kv13);
+      put1.add(kv12);
+      put1.add(kv11);
+      table.put(put1);
+      
+      Put put2 = new Put(row2);
+      put2.add(kv23);
+      put2.add(kv22);
+      put2.add(kv21);
+      table.put(put2);
+      
+      Scan scan = new Scan();
+      scan.addColumn(family, qf2);
+      scan.setMaxVersions(4);
+      ResultScanner scanner = table.getScanner(scan);
+
+      Result result = scanner.next();
+      int size = 0;
+      while (result != null) {
+        size++;
+        List<Cell> cells = result.getColumnCells(family, qf2);
+        Assert.assertEquals(1, cells.size());
+        Assert.assertEquals(Bytes.toString(value2), Bytes.toString(cells.get(0).getValue()));
+        result = scanner.next();
+      }
+      scanner.close();
+      Assert.assertEquals(1, size);
+    } catch (MasterNotRunningException e) {
+      e.printStackTrace();
+    } catch (ZooKeeperConnectionException e) {
+      e.printStackTrace();
+    } catch (IOException e) {
+      e.printStackTrace();
+    }
+  }
+  
+  @SuppressWarnings("deprecation")
+  @Test
+  public void testMobStoreScannerGetReferences() throws InterruptedException {
+    try {
+      
+      long ts1 = 1; // System.currentTimeMillis();
+      long ts2 = ts1 + 1;
+      long ts3 = ts1 + 2;
+      
+      KeyValue kv13 = new KeyValue(row1, family, qf1, ts3, KeyValue.Type.Put, value1);
+      KeyValue kv12 = new KeyValue(row1, family, qf2, ts2, KeyValue.Type.Put, value2);
+      KeyValue kv11 = new KeyValue(row1, family, qf3, ts1, KeyValue.Type.Put, value3);
+
+      KeyValue kv23 = new KeyValue(row2, family, qf4, ts3, KeyValue.Type.Put, value4);
+      KeyValue kv22 = new KeyValue(row2, family, qf5, ts2, KeyValue.Type.Put, value5);
+      KeyValue kv21 = new KeyValue(row2, family, qf6, ts1, KeyValue.Type.Put, value6);
+      
+      Put put1 = new Put(row1);
+      put1.add(kv13);
+      put1.add(kv12);
+      put1.add(kv11);
+      table.put(put1);
+      
+      Put put2 = new Put(row2);
+      put2.add(kv23);
+      put2.add(kv22);
+      put2.add(kv21);
+      table.put(put2);
+      
+      table.flushCommits();
+      admin.flush(TN);
+      
+      Scan scan = new Scan();
+      scan.addColumn(family, qf2);
+      scan.setMaxVersions(4);
+      //set the scan attribute
+      scan.setAttribute(MobConstants.MOB_SCAN_RAW, Bytes.toBytes(Boolean.TRUE));
+      ResultScanner scanner = table.getScanner(scan);
+
+      Result result = scanner.next();
+      int size = 0;
+      while (result != null) {
+        size++;
+        List<Cell> cells = result.getColumnCells(family, qf2);
+        Assert.assertEquals(1, cells.size());
+        Assert.assertEquals(Bytes.toString(row1), Bytes.toString(cells.get(0).getRow()));
+        Assert.assertEquals(Bytes.toString(family), Bytes.toString(cells.get(0).getFamily()));
+        Assert.assertFalse(Bytes.toString(value2).equals(Bytes.toString(cells.get(0).getValue())));
+        
+        byte[] referenceValue = cells.get(0).getValue();
+        String fileName = Bytes.toString(referenceValue, 8, referenceValue.length-8);
+        Path mobFamilyPath;
+        mobFamilyPath = new Path(MobUtils.getMobRegionPath(TEST_UTIL.getConfiguration(),
+            TableName.valueOf(TN)), hcd.getNameAsString());
+        Path targetPath = new Path(mobFamilyPath, fileName);
+          FileSystem fs = FileSystem.get(TEST_UTIL.getConfiguration());
+        Assert.assertTrue(fs.exists(targetPath));
+        
+        result = scanner.next();
+      }
+      scanner.close();
+      Assert.assertEquals(1, size);
+    } catch (MasterNotRunningException e) {
+      e.printStackTrace();
+    } catch (ZooKeeperConnectionException e) {
+      e.printStackTrace();
+    } catch (IOException e) {
+      e.printStackTrace();
+    }
+  }
+}