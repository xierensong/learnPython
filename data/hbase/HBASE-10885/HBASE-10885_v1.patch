diff --git hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java
index 24ce293..f89fe17 100644
--- hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java
+++ hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java
@@ -265,6 +265,32 @@ public class Delete extends Mutation implements Comparable<Row> {
   }
 
   /**
+   * Add the specified KeyValue to this Delete operation.  Operation assumes that
+   * the passed Cell is immutable and its backing array will not be modified
+   * for the duration of this Delete. Internal usage only.
+   * @param kv individual Cell
+   * @return this
+   * @throws java.io.IOException e
+   */
+  public Delete delete(Cell kv) throws IOException {
+    byte[] family = CellUtil.cloneFamily(kv);
+    List<Cell> list = getCellList(family);
+    // Checking that the row of the kv is the same as the put
+    if (!KeyValue.isDelete(kv.getTypeByte())) {
+      throw new WrongRowIOException("The cell " + kv.toString() + "is not of Delete type");
+    }
+    int res = Bytes.compareTo(this.row, 0, row.length, kv.getRowArray(), kv.getRowOffset(),
+        kv.getRowLength());
+    if (res != 0) {
+      throw new WrongRowIOException("The row in " + kv.toString()
+          + " doesn't match the original one " + Bytes.toStringBinary(this.row));
+    }
+    list.add(kv);
+    familyMap.put(family, list);
+    return this;
+  }
+
+  /**
    * Delete the latest version of the specified column.
    * This is an expensive call in that on the server-side, it first does a
    * get to find the latest versions timestamp.  Then it adds a delete using
diff --git hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java
index 1ffb12b..b3c5f83 100644
--- hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java
+++ hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java
@@ -404,6 +404,14 @@ public final class CellUtil {
     return cell.getTypeByte() == Type.DeleteFamilyVersion.getCode();
   }
 
+  public static boolean isDeleteColumns(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteColumn.getCode();
+  }
+
+  public static boolean isDeleteColumn(final Cell cell) {
+    return cell.getTypeByte() == Type.Delete.getCode();
+  }
+
   /**
    * @param cell
    * @return Estimate of the <code>cell</code> size in bytes.
diff --git hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java
index 6c43c78..6e79038 100644
--- hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java
+++ hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java
@@ -27,4 +27,5 @@ public final class TagType {
   public static final byte ACL_TAG_TYPE = (byte) 1;
   public static final byte VISIBILITY_TAG_TYPE = (byte) 2;
   public static final byte LOG_REPLAY_TAG_TYPE = (byte) 3;
+  public static final byte VISBILITY_EXP_SERIALIZATION_FORMAT = (byte)4;
 }
diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/BaseRegionObserver.java hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/BaseRegionObserver.java
index c861192..e5c01a0 100644
--- hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/BaseRegionObserver.java
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/BaseRegionObserver.java
@@ -311,6 +311,12 @@ public abstract class BaseRegionObserver implements RegionObserver {
   }
 
   @Override
+  public void prePrepareTimeStampForDeleteVersion(
+      final ObserverContext<RegionCoprocessorEnvironment> e, final Mutation delete,
+      final Cell cell, final byte[] byteNow, final byte[] family, final Get get) throws IOException {
+  }
+
+  @Override
   public void postDelete(final ObserverContext<RegionCoprocessorEnvironment> e,
       final Delete delete, final WALEdit edit, final Durability durability)
       throws IOException {
@@ -340,6 +346,15 @@ public abstract class BaseRegionObserver implements RegionObserver {
   }
 
   @Override
+  public boolean preCheckAndPutAfterRowLock(
+      final ObserverContext<RegionCoprocessorEnvironment> e,
+      final byte[] row, final byte[] family, final byte[] qualifier, final CompareOp compareOp,
+      final ByteArrayComparable comparator, final Put put,
+      final boolean result) throws IOException {
+    return result;
+  }
+
+  @Override
   public boolean postCheckAndPut(final ObserverContext<RegionCoprocessorEnvironment> e,
       final byte [] row, final byte [] family, final byte [] qualifier,
       final CompareOp compareOp, final ByteArrayComparable comparator,
@@ -356,6 +371,15 @@ public abstract class BaseRegionObserver implements RegionObserver {
   }
 
   @Override
+  public boolean preCheckAndDeleteAfterRowLock(
+      final ObserverContext<RegionCoprocessorEnvironment> e,
+      final byte[] row, final byte[] family, final byte[] qualifier, final CompareOp compareOp,
+      final ByteArrayComparable comparator, final Delete delete,
+      final boolean result) throws IOException {
+    return result;
+  }
+
+  @Override
   public boolean postCheckAndDelete(final ObserverContext<RegionCoprocessorEnvironment> e,
       final byte [] row, final byte [] family, final byte [] qualifier,
       final CompareOp compareOp, final ByteArrayComparable comparator,
@@ -370,6 +394,12 @@ public abstract class BaseRegionObserver implements RegionObserver {
   }
 
   @Override
+  public Result preAppendAfterRowLock(final ObserverContext<RegionCoprocessorEnvironment> e,
+      final Append append) throws IOException {
+    return null;
+  }
+
+  @Override
   public Result postAppend(final ObserverContext<RegionCoprocessorEnvironment> e,
       final Append append, final Result result) throws IOException {
     return result;
@@ -397,6 +427,12 @@ public abstract class BaseRegionObserver implements RegionObserver {
   }
 
   @Override
+  public Result preIncrementAfterRowLock(final ObserverContext<RegionCoprocessorEnvironment> e,
+      final Increment increment) throws IOException {
+    return null;
+  }
+
+  @Override
   public Result postIncrement(final ObserverContext<RegionCoprocessorEnvironment> e,
       final Increment increment, final Result result) throws IOException {
     return result;
diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java
index 96cc3bd..e9853d2 100644
--- hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java
@@ -587,6 +587,25 @@ public interface RegionObserver extends Coprocessor {
   void preDelete(final ObserverContext<RegionCoprocessorEnvironment> c, 
       final Delete delete, final WALEdit edit, final Durability durability)
     throws IOException;
+/**
+ * Called before the server updates the timestamp for delete Columns with latest timestamp.
+ * <p>
+ * Call CoprocessorEnvironment#bypass to skip default actions
+ * <p>
+ * Call CoprocessorEnvironment#complete to skip any subsequent chained
+ * coprocessors
+ * @param c the environment provided by the region server
+ * @param mutation - the parent mutation associated with this delete cell
+ * @param cell - The deleteColumn with latest version cell
+ * @param byteNow - timestamp bytes
+ * @param family - family bytes
+ * @param get - the get formed using the current cell's row.
+ * Note that the get does not specify the family and qualifier
+ * @throws IOException
+ */
+  void prePrepareTimeStampForDeleteVersion(final ObserverContext<RegionCoprocessorEnvironment> c,
+      final Mutation mutation, final Cell cell, final byte[] byteNow, final byte[] family,
+      final Get get) throws IOException;
 
   /**
    * Called after the client deletes a value.
@@ -657,7 +676,7 @@ public interface RegionObserver extends Coprocessor {
       MiniBatchOperationInProgress<Mutation> miniBatchOp, final boolean success) throws IOException;
 
   /**
-   * Called before checkAndPut
+   * Called before checkAndPut.
    * <p>
    * Call CoprocessorEnvironment#bypass to skip default actions
    * <p>
@@ -682,6 +701,33 @@ public interface RegionObserver extends Coprocessor {
     throws IOException;
 
   /**
+   * Called before checkAndPut but after acquiring rowlock.
+   * Note: Caution to be taken for not doing any long time operation in this hook. Row will be
+   * locked for longer time. Trying to acquire lock on another row, within this, can lead to
+   * potential deadlock.
+   * <p>
+   * Call CoprocessorEnvironment#bypass to skip default actions
+   * <p>
+   * Call CoprocessorEnvironment#complete to skip any subsequent chained
+   * coprocessors
+   * @param c the environment provided by the region server
+   * @param row row to check
+   * @param family column family
+   * @param qualifier column qualifier
+   * @param compareOp the comparison operation
+   * @param comparator the comparator
+   * @param put data to put if check succeeds
+   * @param result 
+   * @return the return value to return to client if bypassing default
+   * processing
+   * @throws IOException if an error occurred on the coprocessor
+   */
+  boolean preCheckAndPutAfterRowLock(final ObserverContext<RegionCoprocessorEnvironment> c,
+      final byte[] row, final byte[] family, final byte[] qualifier, final CompareOp compareOp,
+      final ByteArrayComparable comparator, final Put put, 
+      final boolean result) throws IOException;
+
+  /**
    * Called after checkAndPut
    * <p>
    * Call CoprocessorEnvironment#complete to skip any subsequent chained
@@ -704,7 +750,7 @@ public interface RegionObserver extends Coprocessor {
     throws IOException;
 
   /**
-   * Called before checkAndDelete
+   * Called before checkAndDelete.
    * <p>
    * Call CoprocessorEnvironment#bypass to skip default actions
    * <p>
@@ -728,6 +774,32 @@ public interface RegionObserver extends Coprocessor {
     throws IOException;
 
   /**
+   * Called before checkAndDelete but after acquiring rowock.
+   * Note: Caution to be taken for not doing any long time operation in this hook. Row will be
+   * locked for longer time. Trying to acquire lock on another row, within this, can lead to
+   * potential deadlock.
+   * <p>
+   * Call CoprocessorEnvironment#bypass to skip default actions
+   * <p>
+   * Call CoprocessorEnvironment#complete to skip any subsequent chained
+   * coprocessors
+   * @param c the environment provided by the region server
+   * @param row row to check
+   * @param family column family
+   * @param qualifier column qualifier
+   * @param compareOp the comparison operation
+   * @param comparator the comparator
+   * @param delete delete to commit if check succeeds
+   * @param result 
+   * @return the value to return to client if bypassing default processing
+   * @throws IOException if an error occurred on the coprocessor
+   */
+  boolean preCheckAndDeleteAfterRowLock(final ObserverContext<RegionCoprocessorEnvironment> c,
+      final byte[] row, final byte[] family, final byte[] qualifier, final CompareOp compareOp,
+      final ByteArrayComparable comparator, final Delete delete,
+      final boolean result) throws IOException;
+
+  /**
    * Called after checkAndDelete
    * <p>
    * Call CoprocessorEnvironment#complete to skip any subsequent chained
@@ -795,7 +867,7 @@ public interface RegionObserver extends Coprocessor {
     throws IOException;
 
   /**
-   * Called before Append
+   * Called before Append.
    * <p>
    * Call CoprocessorEnvironment#bypass to skip default actions
    * <p>
@@ -811,6 +883,24 @@ public interface RegionObserver extends Coprocessor {
     throws IOException;
 
   /**
+   * Called before Append but after acquiring rowlock.
+   * Note: Caution to be taken for not doing any long time operation in this hook. Row will be
+   * locked for longer time. Trying to acquire lock on another row, within this, can lead to
+   * potential deadlock.
+   * <p>
+   * Call CoprocessorEnvironment#bypass to skip default actions
+   * <p>
+   * Call CoprocessorEnvironment#complete to skip any subsequent chained
+   * coprocessors
+   * @param c the environment provided by the region server
+   * @param append Append object
+   * @return result to return to the client if bypassing default processing
+   * @throws IOException if an error occurred on the coprocessor
+   */
+  Result preAppendAfterRowLock(final ObserverContext<RegionCoprocessorEnvironment> c,
+      final Append append) throws IOException;
+
+  /**
    * Called after Append
    * <p>
    * Call CoprocessorEnvironment#complete to skip any subsequent chained
@@ -826,7 +916,7 @@ public interface RegionObserver extends Coprocessor {
     throws IOException;
 
   /**
-   * Called before Increment
+   * Called before Increment.
    * <p>
    * Call CoprocessorEnvironment#bypass to skip default actions
    * <p>
@@ -842,6 +932,27 @@ public interface RegionObserver extends Coprocessor {
     throws IOException;
 
   /**
+   * Called before Increment but after acquiring rowlock. 
+   * Note: Caution to be taken for not doing any long time operation in this hook. Row will be
+   * locked for longer time. Trying to acquire lock on another row, within this, can lead to
+   * potential deadlock.
+   * <p>
+   * Call CoprocessorEnvironment#bypass to skip default actions
+   * <p>
+   * Call CoprocessorEnvironment#complete to skip any subsequent chained coprocessors
+   * 
+   * @param c
+   *          the environment provided by the region server
+   * @param increment
+   *          increment object
+   * @return result to return to the client if bypassing default processing
+   * @throws IOException
+   *           if an error occurred on the coprocessor
+   */
+  Result preIncrementAfterRowLock(final ObserverContext<RegionCoprocessorEnvironment> c,
+      final Increment increment) throws IOException;
+
+  /**
    * Called after increment
    * <p>
    * Call CoprocessorEnvironment#complete to skip any subsequent chained
@@ -1111,8 +1222,8 @@ public interface RegionObserver extends Coprocessor {
   Cell postMutationBeforeWAL(ObserverContext<RegionCoprocessorEnvironment> ctx,
       MutationType opType, Mutation mutation, Cell oldCell, Cell newCell) throws IOException;
 
-  /**
-   * Called after the ScanQueryMatcher creates ScanDeleteTracker. Implementing
+
+   /* Called after the ScanQueryMatcher creates ScanDeleteTracker. Implementing
    * this hook would help in creating customised DeleteTracker and returning
    * the newly created DeleteTracker
    *
diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/LabelExpander.java hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/LabelExpander.java
index 0c133f6..6370d22 100644
--- hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/LabelExpander.java
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/LabelExpander.java
@@ -31,6 +31,7 @@ import java.util.Map;
 
 import org.apache.hadoop.classification.InterfaceAudience;
 import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.Tag;
@@ -71,8 +72,8 @@ public class LabelExpander {
 
   // TODO : The code repeats from that in Visibility Controller.. Refactoring
   // may be needed
-  public List<Tag> createVisibilityTags(String visibilityLabelsExp) throws IOException,
-      BadTsvLineException {
+  public List<Tag> createVisibilityTags(String visibilityLabelsExp)
+      throws IOException, BadTsvLineException {
     ExpressionNode node = null;
     try {
       node = parser.parse(visibilityLabelsExp);
@@ -83,6 +84,8 @@ public class LabelExpander {
     List<Tag> tags = new ArrayList<Tag>();
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     DataOutputStream dos = new DataOutputStream(baos);
+    tags.add(new Tag(VisibilityUtils.VISBILITY_EXP_SERIALIZATION_FORMAT,
+        HConstants.EMPTY_BYTE_ARRAY));
     if (node.isSingleNode()) {
       writeLabelOrdinalsToStream(node, dos);
       tags.add(new Tag(VisibilityUtils.VISIBILITY_TAG_TYPE, baos.toByteArray()));
@@ -92,7 +95,8 @@ public class LabelExpander {
       if (nlNode.getOperator() == Operator.OR) {
         for (ExpressionNode child : nlNode.getChildExps()) {
           writeLabelOrdinalsToStream(child, dos);
-          tags.add(new Tag(VisibilityUtils.VISIBILITY_TAG_TYPE, baos.toByteArray()));
+          tags.add(new Tag(VisibilityUtils.VISIBILITY_TAG_TYPE,
+              baos.toByteArray()));
           baos.reset();
         }
       } else {
diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DeleteTracker.java hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DeleteTracker.java
index 514628d..469d451 100644
--- hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DeleteTracker.java
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DeleteTracker.java
@@ -45,7 +45,7 @@ public interface DeleteTracker {
   /**
    * Check if the specified cell buffer has been deleted by a previously
    * seen delete.
-   * @param cell - current cell to check if deleted by a previously deleted cell
+   * @param cell - current cell to check if deleted by a previously seen delete
    * @return deleteResult The result tells whether the KeyValue is deleted and why
    */
   DeleteResult isDeleted(Cell cell);
diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
index dea1e81..6085c0e 100644
--- hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
@@ -2030,10 +2030,14 @@ public class HRegion implements HeapSize { // , Writable{
   /**
    * Setup correct timestamps in the KVs in Delete object.
    * Caller should have the row and region locks.
+   * @param mutation
+   * @param familyMap
+   * @param byteNow
+   * @param isInReplay 
    * @throws IOException
    */
-  void prepareDeleteTimestamps(Map<byte[], List<Cell>> familyMap, byte[] byteNow)
-      throws IOException {
+  void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> familyMap, 
+      byte[] byteNow) throws IOException {
     for (Map.Entry<byte[], List<Cell>> e : familyMap.entrySet()) {
 
       byte[] family = e.getKey();
@@ -2059,20 +2063,14 @@ public class HRegion implements HeapSize { // , Writable{
           Get get = new Get(CellUtil.cloneRow(kv));
           get.setMaxVersions(count);
           get.addColumn(family, qual);
-
-          List<Cell> result = get(get, false);
-
-          if (result.size() < count) {
-            // Nothing to delete
-            kv.updateLatestStamp(byteNow);
-            continue;
-          }
-          if (result.size() > count) {
-            throw new RuntimeException("Unexpected size: " + result.size());
+          if (coprocessorHost != null) {
+            if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell, byteNow,
+                family, get)) {
+              updateDeleteLatestVersionTimeStamp(kv, get, count, byteNow);
+            }
+          } else {
+            updateDeleteLatestVersionTimeStamp(kv, get, count, byteNow);
           }
-          KeyValue getkv = KeyValueUtil.ensureKeyValue(result.get(count - 1));
-          Bytes.putBytes(kv.getBuffer(), kv.getTimestampOffset(),
-              getkv.getBuffer(), getkv.getTimestampOffset(), Bytes.SIZEOF_LONG);
         } else {
           kv.updateLatestStamp(byteNow);
         }
@@ -2080,6 +2078,23 @@ public class HRegion implements HeapSize { // , Writable{
     }
   }
 
+  void updateDeleteLatestVersionTimeStamp(KeyValue kv, Get get, int count, byte[] byteNow)
+      throws IOException {
+    List<Cell> result = get(get, false);
+
+    if (result.size() < count) {
+      // Nothing to delete
+      kv.updateLatestStamp(byteNow);
+      return;
+    }
+    if (result.size() > count) {
+      throw new RuntimeException("Unexpected size: " + result.size());
+    }
+    KeyValue getkv = KeyValueUtil.ensureKeyValue(result.get(count - 1));
+    Bytes.putBytes(kv.getBuffer(), kv.getTimestampOffset(), getkv.getBuffer(),
+        getkv.getTimestampOffset(), Bytes.SIZEOF_LONG);
+  }
+
   /**
    * @throws IOException
    */
@@ -2452,7 +2467,9 @@ public class HRegion implements HeapSize { // , Writable{
           updateKVTimestamps(familyMaps[i].values(), byteNow);
           noOfPuts++;
         } else {
-          prepareDeleteTimestamps(familyMaps[i], byteNow);
+          if (!isInReplay) {
+            prepareDeleteTimestamps(mutation, familyMaps[i], byteNow);
+          }
           noOfDeletes++;
         }
       }
@@ -2712,9 +2729,21 @@ public class HRegion implements HeapSize { // , Writable{
       RowLock rowLock = getRowLock(get.getRow());
       // wait for all previous transactions to complete (with lock held)
       mvcc.completeMemstoreInsert(mvcc.beginMemstoreInsert());
-      List<Cell> result;
       try {
-        result = get(get, false);
+        if (this.getCoprocessorHost() != null) {
+          Boolean processed = null;
+          if (w instanceof Put) {
+            processed = this.getCoprocessorHost().preCheckAndPutAfterRowLock(row, family, 
+                qualifier, compareOp, comparator, (Put) w);
+          } else if (w instanceof Delete) {
+            processed = this.getCoprocessorHost().preCheckAndDeleteAfterRowLock(row, family,
+                qualifier, compareOp, comparator, (Delete) w);
+          }
+          if (processed != null) {
+            return processed;
+          }
+        }
+        List<Cell> result = get(get, false);
 
         boolean valueIsNull = comparator.getValue() == null ||
           comparator.getValue().length == 0;
@@ -4724,7 +4753,7 @@ public class HRegion implements HeapSize { // , Writable{
    * @param withCoprocessor invoke coprocessor or not. We don't want to
    * always invoke cp for this private method.
    */
-  private List<Cell> get(Get get, boolean withCoprocessor)
+  public List<Cell> get(Get get, boolean withCoprocessor)
   throws IOException {
 
     List<Cell> results = new ArrayList<Cell>();
@@ -5033,12 +5062,18 @@ public class HRegion implements HeapSize { // , Writable{
       rowLock = getRowLock(row);
       try {
         lock(this.updatesLock.readLock());
-        // wait for all prior MVCC transactions to finish - while we hold the row lock
-        // (so that we are guaranteed to see the latest state)
-        mvcc.completeMemstoreInsert(mvcc.beginMemstoreInsert());
-        // now start my own transaction
-        w = mvcc.beginMemstoreInsert();
         try {
+          // wait for all prior MVCC transactions to finish - while we hold the row lock
+          // (so that we are guaranteed to see the latest state)
+          mvcc.completeMemstoreInsert(mvcc.beginMemstoreInsert());
+          if (this.coprocessorHost != null) {
+            Result r = this.coprocessorHost.preAppendAfterRowLock(append);
+            if(r!= null) {
+              return r;
+            }
+          }
+          // now start my own transaction
+          w = mvcc.beginMemstoreInsert();
           long now = EnvironmentEdgeManager.currentTimeMillis();
           // Process each family
           for (Map.Entry<byte[], List<Cell>> family : append.getFamilyCellMap().entrySet()) {
@@ -5221,12 +5256,18 @@ public class HRegion implements HeapSize { // , Writable{
       RowLock rowLock = getRowLock(row);
       try {
         lock(this.updatesLock.readLock());
-        // wait for all prior MVCC transactions to finish - while we hold the row lock
-        // (so that we are guaranteed to see the latest state)
-        mvcc.completeMemstoreInsert(mvcc.beginMemstoreInsert());
-        // now start my own transaction
-        w = mvcc.beginMemstoreInsert();
         try {
+          // wait for all prior MVCC transactions to finish - while we hold the row lock
+          // (so that we are guaranteed to see the latest state)
+          mvcc.completeMemstoreInsert(mvcc.beginMemstoreInsert());
+          if (this.coprocessorHost != null) {
+            Result r = this.coprocessorHost.preIncrementAfterRowLock(increment);
+            if (r != null) {
+              return r;
+            }
+          }
+          // now start my own transaction
+          w = mvcc.beginMemstoreInsert();
           long now = EnvironmentEdgeManager.currentTimeMillis();
           // Process each family
           for (Map.Entry<byte [], List<Cell>> family:
diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MultiRowMutationProcessor.java hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MultiRowMutationProcessor.java
index 847e6cb..9cfa326 100644
--- hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MultiRowMutationProcessor.java
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MultiRowMutationProcessor.java
@@ -27,9 +27,9 @@ import org.apache.hadoop.hbase.DoNotRetryIOException;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.client.Delete;
+import org.apache.hadoop.hbase.client.Durability;
 import org.apache.hadoop.hbase.client.Mutation;
 import org.apache.hadoop.hbase.client.Put;
-import org.apache.hadoop.hbase.client.Durability;
 import org.apache.hadoop.hbase.protobuf.generated.MultiRowMutationProtos.MultiRowMutationProcessorRequest;
 import org.apache.hadoop.hbase.protobuf.generated.MultiRowMutationProtos.MultiRowMutationProcessorResponse;
 import org.apache.hadoop.hbase.regionserver.wal.WALEdit;
@@ -80,7 +80,7 @@ MultiRowMutationProcessorResponse> {
       } else if (m instanceof Delete) {
         Delete d = (Delete) m;
         region.prepareDelete(d);
-        region.prepareDeleteTimestamps(d.getFamilyCellMap(), byteNow);
+        region.prepareDeleteTimestamps(d, d.getFamilyCellMap(), byteNow);
       } else {
         throw new DoNotRetryIOException(
             "Action must be Put or Delete. But was: "
diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.java hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.java
index 177f153..dbcbaf2 100644
--- hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.java
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.java
@@ -1135,6 +1135,45 @@ public class RegionCoprocessorHost
   }
 
   /**
+   * @param mutation - the current mutation
+   * @param kv - the current cell
+   * @param byteNow - current timestamp in bytes
+   * @param family -  the current family
+   * @param get - the get that could be used
+   * Note that the get only does not specify the family and qualifier that should be used
+   * @return true if default processing should be bypassed
+   * @exception IOException
+   *              Exception
+   */
+  public boolean prePrepareTimeStampForDeleteVersion(Mutation mutation,
+      Cell kv, byte[] byteNow, byte[] family, Get get) throws IOException {
+    boolean bypass = false;
+    ObserverContext<RegionCoprocessorEnvironment> ctx = null;
+    for (RegionEnvironment env : coprocessors) {
+      if (env.getInstance() instanceof RegionObserver) {
+        ctx = ObserverContext.createAndPrepare(env, ctx);
+        Thread currentThread = Thread.currentThread();
+        ClassLoader cl = currentThread.getContextClassLoader();
+        try {
+          currentThread.setContextClassLoader(env.getClassLoader());
+          ((RegionObserver) env.getInstance())
+              .prePrepareTimeStampForDeleteVersion(ctx, mutation, kv,
+                  byteNow, family, get);
+        } catch (Throwable e) {
+          handleCoprocessorThrowable(env, e);
+        } finally {
+          currentThread.setContextClassLoader(cl);
+        }
+        bypass |= ctx.shouldBypass();
+        if (ctx.shouldComplete()) {
+          break;
+        }
+      }
+    }
+    return bypass;
+  }
+
+  /**
    * @param put The Put object
    * @param edit The WALEdit object.
    * @param durability The durability used
@@ -1356,6 +1395,46 @@ public class RegionCoprocessorHost
    * @param compareOp the comparison operation
    * @param comparator the comparator
    * @param put data to put if check succeeds
+   * @return true or false to return to client if default processing should
+   * be bypassed, or null otherwise
+   * @throws IOException e
+   */
+  public Boolean preCheckAndPutAfterRowLock(final byte[] row, final byte[] family,
+      final byte[] qualifier, final CompareOp compareOp, final ByteArrayComparable comparator,
+      final Put put) throws IOException {
+    boolean bypass = false;
+    boolean result = false;
+    ObserverContext<RegionCoprocessorEnvironment> ctx = null;
+    for (RegionEnvironment env : coprocessors) {
+      if (env.getInstance() instanceof RegionObserver) {
+        ctx = ObserverContext.createAndPrepare(env, ctx);
+        Thread currentThread = Thread.currentThread();
+        ClassLoader cl = currentThread.getContextClassLoader();
+        try {
+          currentThread.setContextClassLoader(env.getClassLoader());
+          result = ((RegionObserver) env.getInstance()).preCheckAndPutAfterRowLock(ctx, row,
+              family, qualifier, compareOp, comparator, put, result);
+        } catch (Throwable e) {
+          handleCoprocessorThrowable(env, e);
+        } finally {
+          currentThread.setContextClassLoader(cl);
+        }
+        bypass |= ctx.shouldBypass();
+        if (ctx.shouldComplete()) {
+          break;
+        }
+      }
+    }
+    return bypass ? result : null;
+  }
+
+  /**
+   * @param row row to check
+   * @param family column family
+   * @param qualifier column qualifier
+   * @param compareOp the comparison operation
+   * @param comparator the comparator
+   * @param put data to put if check succeeds
    * @throws IOException e
    */
   public boolean postCheckAndPut(final byte [] row, final byte [] family,
@@ -1434,6 +1513,46 @@ public class RegionCoprocessorHost
    * @param compareOp the comparison operation
    * @param comparator the comparator
    * @param delete delete to commit if check succeeds
+   * @return true or false to return to client if default processing should
+   * be bypassed, or null otherwise
+   * @throws IOException e
+   */
+  public Boolean preCheckAndDeleteAfterRowLock(final byte[] row, final byte[] family,
+      final byte[] qualifier, final CompareOp compareOp, final ByteArrayComparable comparator,
+      final Delete delete) throws IOException {
+    boolean bypass = false;
+    boolean result = false;
+    ObserverContext<RegionCoprocessorEnvironment> ctx = null;
+    for (RegionEnvironment env : coprocessors) {
+      if (env.getInstance() instanceof RegionObserver) {
+        ctx = ObserverContext.createAndPrepare(env, ctx);
+        Thread currentThread = Thread.currentThread();
+        ClassLoader cl = currentThread.getContextClassLoader();
+        try {
+          currentThread.setContextClassLoader(env.getClassLoader());
+          result = ((RegionObserver) env.getInstance()).preCheckAndDeleteAfterRowLock(ctx, row,
+              family, qualifier, compareOp, comparator, delete, result);
+        } catch (Throwable e) {
+          handleCoprocessorThrowable(env, e);
+        } finally {
+          currentThread.setContextClassLoader(cl);
+        }
+        bypass |= ctx.shouldBypass();
+        if (ctx.shouldComplete()) {
+          break;
+        }
+      }
+    }
+    return bypass ? result : null;
+  }
+
+  /**
+   * @param row row to check
+   * @param family column family
+   * @param qualifier column qualifier
+   * @param compareOp the comparison operation
+   * @param comparator the comparator
+   * @param delete delete to commit if check succeeds
    * @throws IOException e
    */
   public boolean postCheckAndDelete(final byte [] row, final byte [] family,
@@ -1496,6 +1615,38 @@ public class RegionCoprocessorHost
   }
 
   /**
+   * @param append append object
+   * @return result to return to client if default operation should be
+   * bypassed, null otherwise
+   * @throws IOException if an error occurred on the coprocessor
+   */
+  public Result preAppendAfterRowLock(final Append append) throws IOException {
+    boolean bypass = false;
+    Result result = null;
+    ObserverContext<RegionCoprocessorEnvironment> ctx = null;
+    for (RegionEnvironment env : coprocessors) {
+      if (env.getInstance() instanceof RegionObserver) {
+        ctx = ObserverContext.createAndPrepare(env, ctx);
+        Thread currentThread = Thread.currentThread();
+        ClassLoader cl = currentThread.getContextClassLoader();
+        try {
+          currentThread.setContextClassLoader(env.getClassLoader());
+          result = ((RegionObserver) env.getInstance()).preAppendAfterRowLock(ctx, append);
+        } catch (Throwable e) {
+          handleCoprocessorThrowable(env, e);
+        } finally {
+          currentThread.setContextClassLoader(cl);
+        }
+        bypass |= ctx.shouldBypass();
+        if (ctx.shouldComplete()) {
+          break;
+        }
+      }
+    }
+    return bypass ? result : null;
+  }
+
+  /**
    * @param increment increment object
    * @return result to return to client if default operation should be
    * bypassed, null otherwise
@@ -1528,6 +1679,38 @@ public class RegionCoprocessorHost
   }
 
   /**
+   * @param increment increment object
+   * @return result to return to client if default operation should be
+   * bypassed, null otherwise
+   * @throws IOException if an error occurred on the coprocessor
+   */
+  public Result preIncrementAfterRowLock(final Increment increment) throws IOException {
+    boolean bypass = false;
+    Result result = null;
+    ObserverContext<RegionCoprocessorEnvironment> ctx = null;
+    for (RegionEnvironment env : coprocessors) {
+      if (env.getInstance() instanceof RegionObserver) {
+        ctx = ObserverContext.createAndPrepare(env, ctx);
+        Thread currentThread = Thread.currentThread();
+        ClassLoader cl = currentThread.getContextClassLoader();
+        try {
+          currentThread.setContextClassLoader(env.getClassLoader());
+          result = ((RegionObserver) env.getInstance()).preIncrementAfterRowLock(ctx, increment);
+        } catch (Throwable e) {
+          handleCoprocessorThrowable(env, e);
+        } finally {
+          currentThread.setContextClassLoader(cl);
+        }
+        bypass |= ctx.shouldBypass();
+        if (ctx.shouldComplete()) {
+          break;
+        }
+      }
+    }
+    return bypass ? result : null;
+  }
+
+  /**
    * @param append Append object
    * @param result the result returned by the append
    * @throws IOException if an error occurred on the coprocessor
diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ScanDeleteTracker.java hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ScanDeleteTracker.java
index 6a767e8..668e3db 100644
--- hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ScanDeleteTracker.java
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ScanDeleteTracker.java
@@ -45,14 +45,14 @@ import org.apache.hadoop.hbase.util.Bytes;
 @InterfaceAudience.Private
 public class ScanDeleteTracker implements DeleteTracker {
 
-  private boolean hasFamilyStamp = false;
-  private long familyStamp = 0L;
-  private SortedSet<Long> familyVersionStamps = new TreeSet<Long>();
-  private byte [] deleteBuffer = null;
-  private int deleteOffset = 0;
-  private int deleteLength = 0;
-  private byte deleteType = 0;
-  private long deleteTimestamp = 0L;
+  protected boolean hasFamilyStamp = false;
+  protected long familyStamp = 0L;
+  protected SortedSet<Long> familyVersionStamps = new TreeSet<Long>();
+  protected byte [] deleteBuffer = null;
+  protected int deleteOffset = 0;
+  protected int deleteLength = 0;
+  protected byte deleteType = 0;
+  protected long deleteTimestamp = 0L;
 
   /**
    * Constructor for ScanDeleteTracker
@@ -65,7 +65,7 @@ public class ScanDeleteTracker implements DeleteTracker {
    * Add the specified KeyValue to the list of deletes to check against for
    * this row operation.
    * <p>
-   * This is called when a Delete is encountered in a StoreFile.
+   * This is called when a Delete is encountered.
    * @param cell - the delete cell
    */
   @Override
diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java
index a152fcc..17bec07 100644
--- hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java
@@ -30,6 +30,7 @@ import java.io.DataOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.BitSet;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
@@ -75,6 +76,7 @@ import org.apache.hadoop.hbase.coprocessor.RegionObserver;
 import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessorEnvironment;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.filter.Filter;
+import org.apache.hadoop.hbase.filter.FilterBase;
 import org.apache.hadoop.hbase.filter.FilterList;
 import org.apache.hadoop.hbase.io.hfile.HFile;
 import org.apache.hadoop.hbase.io.util.StreamUtils;
@@ -93,6 +95,7 @@ import org.apache.hadoop.hbase.protobuf.generated.VisibilityLabelsProtos.Visibil
 import org.apache.hadoop.hbase.protobuf.generated.VisibilityLabelsProtos.VisibilityLabelsResponse;
 import org.apache.hadoop.hbase.protobuf.generated.VisibilityLabelsProtos.VisibilityLabelsService;
 import org.apache.hadoop.hbase.regionserver.BloomType;
+import org.apache.hadoop.hbase.regionserver.DeleteTracker;
 import org.apache.hadoop.hbase.regionserver.DisabledRegionSplitPolicy;
 import org.apache.hadoop.hbase.regionserver.HRegion;
 import org.apache.hadoop.hbase.regionserver.InternalScanner;
@@ -688,10 +691,8 @@ public class VisibilityController extends BaseRegionObserver implements MasterOb
             new OperationStatus(SANITY_CHECK_FAILURE, de.getMessage()));
         continue;
       }
-      if (m instanceof Put) {
-        Put p = (Put) m;
         boolean sanityFailure = false;
-        for (CellScanner cellScanner = p.cellScanner(); cellScanner.advance();) {
+        for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {
           if (!checkForReservedVisibilityTagPresence(cellScanner.current())) {
             miniBatchOp.setOperationStatus(i, new OperationStatus(SANITY_CHECK_FAILURE,
                 "Mutation contains cell with reserved type tag"));
@@ -717,7 +718,7 @@ public class VisibilityController extends BaseRegionObserver implements MasterOb
             if (visibilityTags != null) {
               labelCache.put(labelsExp, visibilityTags);
               List<Cell> updatedCells = new ArrayList<Cell>();
-              for (CellScanner cellScanner = p.cellScanner(); cellScanner.advance();) {
+              for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {
                 Cell cell = cellScanner.current();
                 List<Tag> tags = Tag.asList(cell.getTagsArray(), cell.getTagsOffset(),
                     cell.getTagsLength());
@@ -730,22 +731,68 @@ public class VisibilityController extends BaseRegionObserver implements MasterOb
                     cell.getValueLength(), tags);
                 updatedCells.add(updatedCell);
               }
-              p.getFamilyCellMap().clear();
-              // Clear and add new Cells to the Mutation.
-              for (Cell cell : updatedCells) {
+            m.getFamilyCellMap().clear();
+            // Clear and add new Cells to the Mutation.
+            for (Cell cell : updatedCells) {
+              if (m instanceof Put) {
+                Put p = (Put) m;
                 p.add(cell);
+              } else if (m instanceof Delete) {
+                // Should we fail any delete without CellVisibility?
+                Delete d = (Delete) m;
+                d.delete(cell);
               }
             }
           }
         }
-      } else if (cellVisibility != null) {
-        // CellVisibility in a Delete is not legal! Fail the operation
-        miniBatchOp.setOperationStatus(i, new OperationStatus(SANITY_CHECK_FAILURE,
-            "CellVisibility cannot be set on Delete mutation"));
       }
     }
   }
+  
+  @Override
+  public void prePrepareTimeStampForDeleteVersion(
+      ObserverContext<RegionCoprocessorEnvironment> ctx, Mutation delete, Cell cell,
+      byte[] byteNow, byte[] family, Get get) throws IOException {
+    KeyValue kv = KeyValueUtil.ensureKeyValue(cell);
+    CellVisibility cellVisibility = null;
+    try {
+      cellVisibility = delete.getCellVisibility();
+    } catch (DeserializationException de) {
+      throw new RuntimeException("Invalid cell visibility specified " + delete);
+    }
+    for (CellScanner cellScanner = delete.cellScanner(); cellScanner.advance();) {
+      if (!checkForReservedVisibilityTagPresence(cellScanner.current())) {
+        throw new RuntimeException("Reserved visibility type used " + cellVisibility.toString());
+      }
+    }
+    List<Tag> visibilityTags = new ArrayList<Tag>();
+    if (cellVisibility != null) {
+      String labelsExp = cellVisibility.getExpression();
+      try {
+        visibilityTags = createVisibilityTags(labelsExp);
+      } catch (ParseException e) {
+        throw new RuntimeException("Invalid cell visibility expression " + labelsExp);
+      } catch (InvalidLabelException e) {
+        throw new RuntimeException("Invalid cell visibility specified " + labelsExp);
+      }
+    }
+    get.setFilter(new DeleteVersionVisibilityExpressionFilter(visibilityTags));
+    List<Cell> result = ctx.getEnvironment().getRegion().get(get, false);
 
+    if (result.size() < get.getMaxVersions()) {
+      // Nothing to delete
+      kv.updateLatestStamp(Bytes.toBytes(Long.MIN_VALUE));
+      return;
+    }
+    if (result.size() > get.getMaxVersions()) {
+      throw new RuntimeException("Unexpected size: " + result.size());
+    }
+    KeyValue getkv = KeyValueUtil.ensureKeyValue(result.get(get.getMaxVersions() - 1));
+    Bytes.putBytes(kv.getBuffer(), kv.getTimestampOffset(), getkv.getBuffer(),
+        getkv.getTimestampOffset(), Bytes.SIZEOF_LONG);
+    ctx.bypass();
+  }
+  
   @Override
   public void postBatchMutate(ObserverContext<RegionCoprocessorEnvironment> c,
       MiniBatchOperationInProgress<Mutation> miniBatchOp) throws IOException {
@@ -844,36 +891,54 @@ public class VisibilityController extends BaseRegionObserver implements MasterOb
     return true;
   }
 
-  private List<Tag> createVisibilityTags(String visibilityLabelsExp) throws IOException,
-      ParseException, InvalidLabelException {
+  private List<Tag> createVisibilityTags(String visibilityLabelsExp)
+      throws IOException, ParseException, InvalidLabelException {
     ExpressionNode node = null;
     node = this.expressionParser.parse(visibilityLabelsExp);
     node = this.expressionExpander.expand(node);
     List<Tag> tags = new ArrayList<Tag>();
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     DataOutputStream dos = new DataOutputStream(baos);
+    List<Integer> labelOrdinals = new ArrayList<Integer>();
+    // Add new tag type
+    tags.add(new Tag(VisibilityUtils.VISBILITY_EXP_SERIALIZATION_FORMAT,
+        HConstants.EMPTY_BYTE_ARRAY));
     if (node.isSingleNode()) {
-      writeLabelOrdinalsToStream(node, dos);
+      getLabelOrdinals(node, labelOrdinals);
+      writeLabelOrdinalsToStream(labelOrdinals, dos);
       tags.add(new Tag(VisibilityUtils.VISIBILITY_TAG_TYPE, baos.toByteArray()));
       baos.reset();
     } else {
       NonLeafExpressionNode nlNode = (NonLeafExpressionNode) node;
       if (nlNode.getOperator() == Operator.OR) {
         for (ExpressionNode child : nlNode.getChildExps()) {
-          writeLabelOrdinalsToStream(child, dos);
-          tags.add(new Tag(VisibilityUtils.VISIBILITY_TAG_TYPE, baos.toByteArray()));
+          getLabelOrdinals(child, labelOrdinals);
+          writeLabelOrdinalsToStream(labelOrdinals, dos);
+          tags.add(new Tag(VisibilityUtils.VISIBILITY_TAG_TYPE,
+              baos.toByteArray()));
           baos.reset();
+          labelOrdinals.clear();
         }
       } else {
-        writeLabelOrdinalsToStream(nlNode, dos);
-        tags.add(new Tag(VisibilityUtils.VISIBILITY_TAG_TYPE, baos.toByteArray()));
+        getLabelOrdinals(nlNode, labelOrdinals);
+        writeLabelOrdinalsToStream(labelOrdinals, dos);
+        tags.add(new Tag(VisibilityUtils.VISIBILITY_TAG_TYPE,
+            baos.toByteArray()));
         baos.reset();
       }
     }
     return tags;
   }
 
-  private void writeLabelOrdinalsToStream(ExpressionNode node, DataOutputStream dos)
+  private void writeLabelOrdinalsToStream(List<Integer> labelOrdinals, DataOutputStream dos)
+      throws IOException {
+    Collections.sort(labelOrdinals);
+    for (Integer labelOrdinal : labelOrdinals) {
+      StreamUtils.writeRawVInt32(dos, labelOrdinal);
+    }
+  }
+
+  private void getLabelOrdinals(ExpressionNode node, List<Integer> labelOrdinals)
       throws IOException, InvalidLabelException {
     if (node.isSingleNode()) {
       String identifier = null;
@@ -896,11 +961,11 @@ public class VisibilityController extends BaseRegionObserver implements MasterOb
       if (labelOrdinal == 0) {
         throw new InvalidLabelException("Invalid visibility label " + identifier);
       }
-      StreamUtils.writeRawVInt32(dos, labelOrdinal);
+      labelOrdinals.add(labelOrdinal);
     } else {
       List<ExpressionNode> childExps = ((NonLeafExpressionNode) node).getChildExps();
       for (ExpressionNode child : childExps) {
-        writeLabelOrdinalsToStream(child, dos);
+        getLabelOrdinals(child, labelOrdinals);
       }
     }
   }
@@ -942,6 +1007,17 @@ public class VisibilityController extends BaseRegionObserver implements MasterOb
   }
 
   @Override
+  public DeleteTracker postInstantiateDeleteTracker(
+      ObserverContext<RegionCoprocessorEnvironment> ctx, DeleteTracker delTracker)
+      throws IOException {
+    HRegion region = ctx.getEnvironment().getRegion();
+    TableName table = region.getRegionInfo().getTable();
+    if (table.isSystemTable() || table.equals(LABELS_TABLE_NAME)) {
+      return delTracker;
+    }
+    return new VisibilityScanDeleteTracker();
+  }
+  @Override
   public RegionScanner postScannerOpen(final ObserverContext<RegionCoprocessorEnvironment> c,
       final Scan scan, final RegionScanner s) throws IOException {
     User user = getActiveUser();
@@ -1409,4 +1485,22 @@ public class VisibilityController extends BaseRegionObserver implements MasterOb
       }
     }
   }
+
+  static class DeleteVersionVisibilityExpressionFilter extends FilterBase {
+    private List<Tag> visibilityTags;
+
+    public DeleteVersionVisibilityExpressionFilter(List<Tag> visibilityTags) {
+      this.visibilityTags = visibilityTags;
+    }
+
+    @Override
+    public ReturnCode filterKeyValue(Cell kv) throws IOException {
+      boolean matchFound = VisibilityUtils.checkForMatchingVisibilityTags(kv, visibilityTags, true);
+      if (matchFound) {
+        return ReturnCode.INCLUDE;
+      } else {
+        return ReturnCode.SKIP;
+      }
+    }
+  }
 }
diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityScanDeleteTracker.java hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityScanDeleteTracker.java
new file mode 100644
index 0000000..e74695f
--- /dev/null
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityScanDeleteTracker.java
@@ -0,0 +1,272 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.security.visibility;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValue.Type;
+import org.apache.hadoop.hbase.Tag;
+import org.apache.hadoop.hbase.regionserver.ScanDeleteTracker;
+import org.apache.hadoop.hbase.util.Bytes;
+
+/**
+ * Similar to ScanDeletTracker but tracks the visibility expression also before
+ * deciding if a Cell can be considered deleted
+ */
+public class VisibilityScanDeleteTracker extends ScanDeleteTracker {
+
+  // Its better to track the visibility tags in delete based on each type.  Create individual
+  // data structures for tracking each of them.  This would ensure that there is no tracking based
+  // on time and also would handle all cases where deletefamily or deletecolumns is specified with
+  // Latest_timestamp.  In such cases the ts in the delete marker and the masking
+  // put will not be same. So going with individual data structures for different delete
+  // type would solve this problem and also ensure that the combination of different type 
+  // of deletes with diff ts would also work fine
+  private List<Tag> visibilityTagsDeleteFamily;
+  private List<Tag> visibilityTagsDeleteFamilyVersion;
+  private List<Tag> visibilityTagsDeleteColumns;
+  private List<Tag> visiblityTagsDeleteColumn;
+
+  public VisibilityScanDeleteTracker() {
+    super();
+  }
+
+  @Override
+  public void add(Cell delCell) {
+    //Cannot call super.add because need to find if the delete needs to be considered
+    long timestamp = delCell.getTimestamp();
+    int qualifierOffset = delCell.getQualifierOffset();
+    int qualifierLength = delCell.getQualifierLength();
+    byte type = delCell.getTypeByte();
+    if (!hasFamilyStamp || timestamp > familyStamp) {
+      if (type == KeyValue.Type.DeleteFamily.getCode()) {
+        hasFamilyStamp = true;
+        familyStamp = timestamp;
+        extractDeleteTags(delCell, KeyValue.Type.DeleteFamily);
+        return;
+      } else if (type == KeyValue.Type.DeleteFamilyVersion.getCode()) {
+        familyVersionStamps.add(timestamp);
+        extractDeleteTags(delCell, KeyValue.Type.DeleteFamilyVersion);
+        return;
+      }
+
+      if (deleteBuffer != null && type < deleteType) {
+        // same column, so ignore less specific delete
+        if (Bytes.equals(deleteBuffer, deleteOffset, deleteLength,
+            delCell.getQualifierArray(), qualifierOffset, qualifierLength)){
+          return;
+        }
+      }
+      // new column, or more general delete type
+      deleteBuffer = delCell.getQualifierArray();
+      deleteOffset = qualifierOffset;
+      deleteLength = qualifierLength;
+      deleteType = type;
+      deleteTimestamp = timestamp;
+      extractDeleteTags(delCell, KeyValue.Type.codeToType(type));
+    }
+  }
+
+  private void extractDeleteTags(Cell delCell, Type type) {
+    // If tag is present in the delete
+    if (delCell.getTagsLength() > 0) {
+      switch (type) {
+      case DeleteFamily:
+        visibilityTagsDeleteFamily = new ArrayList<Tag>();
+        VisibilityUtils.getVisibilityTags(delCell, visibilityTagsDeleteFamily);
+        if(visibilityTagsDeleteFamily.isEmpty()) {
+          visibilityTagsDeleteFamily = null;
+        }
+        break;
+      case DeleteFamilyVersion:
+        visibilityTagsDeleteFamilyVersion = new ArrayList<Tag>();
+        VisibilityUtils.getVisibilityTags(delCell, visibilityTagsDeleteFamilyVersion);
+        if(visibilityTagsDeleteFamilyVersion.isEmpty()) {
+          visibilityTagsDeleteFamilyVersion = null;
+        }
+        break;
+      case DeleteColumn:
+        visibilityTagsDeleteColumns = new ArrayList<Tag>();
+        VisibilityUtils.getVisibilityTags(delCell, visibilityTagsDeleteColumns);
+        if(visibilityTagsDeleteColumns.isEmpty()) {
+          visibilityTagsDeleteColumns = null;
+        }
+        break;
+      case Delete:
+        visiblityTagsDeleteColumn = new ArrayList<Tag>();
+        VisibilityUtils.getVisibilityTags(delCell, visiblityTagsDeleteColumn);
+        if(visiblityTagsDeleteColumn.isEmpty()) {
+          visiblityTagsDeleteColumn = null;
+        }
+        break;
+      default:
+          throw new IllegalArgumentException("Invalid delete type");
+      }
+    } else {
+      switch (type) {
+      case DeleteFamily:
+        visibilityTagsDeleteFamily = null;
+        break;
+      case DeleteFamilyVersion:
+        visibilityTagsDeleteFamilyVersion = null;
+        break;
+      case DeleteColumn:
+        visibilityTagsDeleteColumns = null;
+        break;
+      case Delete:
+        visiblityTagsDeleteColumn = null;
+        break;
+      default:
+        throw new IllegalArgumentException("Invalid delete type");  
+      }
+    }
+  }
+
+  @Override
+  public DeleteResult isDeleted(Cell cell) {
+    long timestamp = cell.getTimestamp();
+    int qualifierOffset = cell.getQualifierOffset();
+    int qualifierLength = cell.getQualifierLength();
+    if (hasFamilyStamp && timestamp <= familyStamp) {
+      if (visibilityTagsDeleteFamily != null) {
+        boolean matchFound = VisibilityUtils.checkForMatchingVisibilityTags(cell,
+            visibilityTagsDeleteFamily, false);
+        if (matchFound) {
+          // Should we return FAMILY_VERSION_DELETED or FAMILY_DELETED here
+           return DeleteResult.FAMILY_VERSION_DELETED;
+        } else {
+          return DeleteResult.NOT_DELETED;
+        }
+
+      } else {
+        List<Tag> tags = new ArrayList<Tag>();
+        VisibilityUtils.getVisibilityTags(cell, tags);
+        if (tags.size() > 0) {
+          return DeleteResult.NOT_DELETED;
+        } else {
+          // No tags
+          return DeleteResult.FAMILY_DELETED;
+        }
+      }
+    }
+
+    if (familyVersionStamps.contains(Long.valueOf(timestamp))) {
+      if (visibilityTagsDeleteFamilyVersion != null) {
+        boolean matchFound = VisibilityUtils.checkForMatchingVisibilityTags(cell,
+            visibilityTagsDeleteFamilyVersion, false);
+        if (matchFound) {
+          return DeleteResult.FAMILY_VERSION_DELETED;
+        } else {
+          return DeleteResult.NOT_DELETED;
+        }
+
+      } else {
+        List<Tag> tags = new ArrayList<Tag>();
+        VisibilityUtils.getVisibilityTags(cell, tags);
+        if (tags.size() > 0) {
+          return DeleteResult.NOT_DELETED;
+        } else {
+          // No tags
+          return DeleteResult.FAMILY_VERSION_DELETED;
+        }
+      }
+    }
+
+    if (deleteBuffer != null) {
+      int ret = Bytes.compareTo(deleteBuffer, deleteOffset, deleteLength, cell.getQualifierArray(),
+          qualifierOffset, qualifierLength);
+
+      if (ret == 0) {
+        if (deleteType == KeyValue.Type.DeleteColumn.getCode()) {
+          if (visibilityTagsDeleteColumns != null) {
+            boolean matchFound = VisibilityUtils.checkForMatchingVisibilityTags(cell,
+                visibilityTagsDeleteColumns, false);
+            if (matchFound) {
+              // Should we return COLUMN_DELETED or VERSION_DELETED
+              return DeleteResult.VERSION_DELETED;
+            } else {
+              return DeleteResult.NOT_DELETED;
+            }
+
+          } else {
+            List<Tag> tags = new ArrayList<Tag>();
+            VisibilityUtils.getVisibilityTags(cell, tags);
+            if (tags.size() > 0) {
+              return DeleteResult.NOT_DELETED;
+            } else {
+              // No tags
+              return DeleteResult.COLUMN_DELETED;
+            }
+          }
+        }
+        // Delete (aka DeleteVersion)
+        // If the timestamp is the same, keep this one
+        if (timestamp == deleteTimestamp) {
+          if (visiblityTagsDeleteColumn != null) {
+            boolean matchFound = VisibilityUtils.checkForMatchingVisibilityTags(cell,
+                visiblityTagsDeleteColumn, false);
+            if (matchFound) {
+              return DeleteResult.VERSION_DELETED;
+            } else {
+              return DeleteResult.NOT_DELETED;
+            }
+          } else {
+            List<Tag> tags = new ArrayList<Tag>();
+            VisibilityUtils.getVisibilityTags(cell, tags);
+            if (tags.size() > 0) {
+              return DeleteResult.NOT_DELETED;
+            } else {
+              // No tags
+              return DeleteResult.VERSION_DELETED;
+            }
+          }
+        }
+        // use assert or not?
+        assert timestamp < deleteTimestamp;
+
+        // different timestamp, let's clear the buffer.
+        deleteBuffer = null;
+        visiblityTagsDeleteColumn = null;
+      } else if (ret < 0) {
+        // Next column case.
+        deleteBuffer = null;
+        visibilityTagsDeleteColumns = null;
+        visiblityTagsDeleteColumn = null;
+      } else {
+        throw new IllegalStateException("isDelete failed: deleteBuffer="
+            + Bytes.toStringBinary(deleteBuffer, deleteOffset, deleteLength) + ", qualifier="
+            + Bytes.toStringBinary(cell.getQualifierArray(), qualifierOffset, qualifierLength)
+            + ", timestamp=" + timestamp + ", comparison result: " + ret);
+      }
+    }
+    return DeleteResult.NOT_DELETED;
+  }
+
+  @Override
+  public void reset() {
+    super.reset();
+    visibilityTagsDeleteColumns = null;
+    visibilityTagsDeleteFamily = null;
+    visibilityTagsDeleteFamilyVersion = null;
+    visiblityTagsDeleteColumn = null;
+  }
+}
diff --git hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java
index 0c7764f..1fd30db 100644
--- hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java
+++ hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java
@@ -19,25 +19,32 @@ package org.apache.hadoop.hbase.security.visibility;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
-import com.google.protobuf.HBaseZeroCopyByteString;
-
 import org.apache.commons.lang.StringUtils;
 import org.apache.hadoop.classification.InterfaceAudience;
 import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagType;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
+import org.apache.hadoop.hbase.io.util.StreamUtils;
 import org.apache.hadoop.hbase.protobuf.ProtobufUtil;
 import org.apache.hadoop.hbase.protobuf.generated.VisibilityLabelsProtos.MultiUserAuthorizations;
 import org.apache.hadoop.hbase.protobuf.generated.VisibilityLabelsProtos.UserAuthorizations;
 import org.apache.hadoop.hbase.protobuf.generated.VisibilityLabelsProtos.VisibilityLabel;
 import org.apache.hadoop.hbase.protobuf.generated.VisibilityLabelsProtos.VisibilityLabelsRequest;
 import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.Pair;
 import org.apache.hadoop.util.ReflectionUtils;
 
+import com.google.protobuf.HBaseZeroCopyByteString;
 import com.google.protobuf.InvalidProtocolBufferException;
 
 /**
@@ -46,9 +53,10 @@ import com.google.protobuf.InvalidProtocolBufferException;
 @InterfaceAudience.Private
 public class VisibilityUtils {
 
-  public static final String VISIBILITY_LABEL_GENERATOR_CLASS = 
+  public static final String VISIBILITY_LABEL_GENERATOR_CLASS =
       "hbase.regionserver.scan.visibility.label.generator.class";
   public static final byte VISIBILITY_TAG_TYPE = TagType.VISIBILITY_TAG_TYPE;
+  public static final byte VISBILITY_EXP_SERIALIZATION_FORMAT = TagType.VISBILITY_EXP_SERIALIZATION_FORMAT;
   public static final String SYSTEM_LABEL = "system";
   private static final String COMMA = ",";
 
@@ -156,4 +164,149 @@ public class VisibilityUtils {
     }
     return slgs;
   }
+
+  public static boolean getVisibilityTags(Cell cell, List<Tag> tags) {
+    boolean sortedOrder = false;
+    byte[] tagBytes = CellUtil.getTagArray(cell);
+    Iterator<Tag> tagsIterator = CellUtil.tagsIterator(tagBytes, 0, tagBytes.length);
+    while (tagsIterator.hasNext()) {
+      Tag tag = tagsIterator.next();
+      if(tag.getType() == VisibilityUtils.VISBILITY_EXP_SERIALIZATION_FORMAT) {
+        sortedOrder = true;
+        continue;
+      }
+      if (tag.getType() == VisibilityUtils.VISIBILITY_TAG_TYPE) {
+        tags.add(tag);
+      }
+    }
+    return sortedOrder;
+  }
+
+  public static boolean checkForMatchingVisibilityTags(Cell cell,
+      List<Tag> visibilityTagsInDeleteCell, boolean newTagPresentInDelete) {
+    List<Tag> tags = new ArrayList<Tag>();
+    boolean sortedTags = getVisibilityTags(cell, tags);
+    if (tags.size() == 0) {
+      // Early out if there are no tags in the cell
+      return false;
+    }
+    if (sortedTags) {
+      return checkForMatchingVisibilityTagsWithSortedOrder(cell.getTagsLength(),
+          visibilityTagsInDeleteCell, tags, newTagPresentInDelete);
+    } else {
+      try {
+        return checkForMatchingVisibilityTagsWithOutSortedOrder(cell, visibilityTagsInDeleteCell);
+      } catch (Exception e) {
+        // Should not happen
+        throw new RuntimeException("Exception while sorting the tags from the cell");
+      }
+    }
+  }
+
+  private static boolean checkForMatchingVisibilityTagsWithOutSortedOrder(Cell cell,
+      List<Tag> visibilityTagsInDeleteCell) throws IOException {
+    List<List<Integer>> sortedDeleteTags = sortTagsBasedOnOrdinal(
+        visibilityTagsInDeleteCell);
+    List<List<Integer>> sortedTags = sortedTagsBasedOnOrdinal(cell);
+    return compareTagsOrdinals(sortedDeleteTags, sortedTags);
+  }
+
+  private static boolean checkForMatchingVisibilityTagsWithSortedOrder(short tagsLength,
+      List<Tag> visibilityTagsInDeleteCell, List<Tag> tags, boolean newTagPresentInDelete) {
+    boolean matchFound = false;
+    if (tagsLength > 0) {
+      // the tags in visibility delete cell will also include the new type of tag
+      if (newTagPresentInDelete) {
+        if ((visibilityTagsInDeleteCell.size() - 1) != tags.size()) {
+          // If the size does not match. Definitely we are not comparing the
+          // equal
+          // tags.
+          // Return false in that case.
+          return matchFound;
+        }
+      } else {
+        if ((visibilityTagsInDeleteCell.size()) != tags.size()) {
+          // If the size does not match. Definitely we are not comparing the
+          // equal
+          // tags.
+          // Return false in that case.
+          return matchFound;
+        }
+      }
+      for (Tag tag : visibilityTagsInDeleteCell) {
+        matchFound = false;
+        for (Tag givenTag : tags) {
+          if (Bytes.equals(tag.getBuffer(), tag.getTagOffset(), tag.getTagLength(),
+              givenTag.getBuffer(), givenTag.getTagOffset(), givenTag.getTagLength())) {
+            matchFound = true;
+            break;
+          }
+        }
+      }
+    }
+    return matchFound;
+  }
+
+  private static List<List<Integer>> sortedTagsBasedOnOrdinal(Cell cell)
+      throws IOException {
+    Iterator<Tag> tagsItr = CellUtil.tagsIterator(cell.getTagsArray(), cell.getTagsOffset(),
+        cell.getTagsLength());
+    List<List<Integer>> fullTagsList = new ArrayList<List<Integer>>();
+    List<Integer> tagsOrdinalInSortedOrder = new ArrayList<Integer>();
+    while (tagsItr.hasNext()) {
+      Tag tag = tagsItr.next();
+      getSortedTagOrdinals(fullTagsList, tagsOrdinalInSortedOrder, tag);
+    }
+    return fullTagsList;
+  }
+
+  private static List<List<Integer>> sortTagsBasedOnOrdinal(List<Tag> tags)
+      throws IOException {
+    List<List<Integer>> fullTagsList = new ArrayList<List<Integer>>();
+    List<Integer> tagsOrdinalInSortedOrder = new ArrayList<Integer>();
+    for (Tag tag : tags) {
+      getSortedTagOrdinals(fullTagsList, tagsOrdinalInSortedOrder, tag);
+    }
+    return fullTagsList;
+  }
+
+  private static void getSortedTagOrdinals(List<List<Integer>> fullTagsList,
+      List<Integer> tagsOrdinalInSortedOrder, Tag tag) throws IOException {
+    if (tag.getType() == VisibilityUtils.VISIBILITY_TAG_TYPE) {
+      int offset = tag.getTagOffset();
+      int endOffset = offset + tag.getTagLength();
+      while (offset < endOffset) {
+        Pair<Integer, Integer> result = StreamUtils.readRawVarint32(tag.getBuffer(), offset);
+        tagsOrdinalInSortedOrder.add(result.getFirst());
+        offset += result.getSecond();
+      }
+      Collections.sort(tagsOrdinalInSortedOrder);
+      fullTagsList.add(cloneList(tagsOrdinalInSortedOrder));
+      tagsOrdinalInSortedOrder.clear();
+    }
+  }
+
+  private static boolean compareTagsOrdinals(List<List<Integer>> tagsInDeletes,
+      List<List<Integer>> tags) {
+    boolean matchFound = false;
+    if (tagsInDeletes.size() != tags.size()) {
+      return matchFound;
+    } else {
+      for (List<Integer> deleteTagOrdinals : tagsInDeletes) {
+        matchFound = false;
+        for (List<Integer> tagOrdinals : tags) {
+          if (deleteTagOrdinals.containsAll(tagOrdinals)) {
+            matchFound = true;
+            break;
+          }
+        }
+      }
+      return matchFound;
+    }
+  }
+
+  private static List<Integer> cloneList(List<Integer> tagsOrdinalList) {
+    List<Integer> clone = new LinkedList<Integer>(tagsOrdinalList);
+    return clone;
+  }
 }
diff --git hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsWithDeletes.java hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsWithDeletes.java
new file mode 100644
index 0000000..d5d778a
--- /dev/null
+++ hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsWithDeletes.java
@@ -0,0 +1,1858 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.security.visibility;
+
+import static org.apache.hadoop.hbase.security.visibility.VisibilityConstants.LABELS_TABLE_NAME;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.security.PrivilegedExceptionAction;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.*;
+import org.apache.hadoop.hbase.client.*;
+import org.apache.hadoop.hbase.protobuf.generated.VisibilityLabelsProtos.VisibilityLabelsResponse;
+import org.apache.hadoop.hbase.security.User;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.junit.*;
+import org.junit.experimental.categories.Category;
+import org.junit.rules.TestName;
+
+/**
+ * Tests visibility labels with deletes 
+ */
+@Category(MediumTests.class)
+public class TestVisibilityLabelsWithDeletes {
+  private static final String TOPSECRET = "TOPSECRET";
+  private static final String PUBLIC = "PUBLIC";
+  private static final String PRIVATE = "PRIVATE";
+  private static final String CONFIDENTIAL = "CONFIDENTIAL";
+  private static final String SECRET = "SECRET";
+  public static final HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
+  private static final byte[] row1 = Bytes.toBytes("row1");
+  private static final byte[] row2 = Bytes.toBytes("row2");
+  private final static byte[] fam = Bytes.toBytes("info");
+  private final static byte[] qual = Bytes.toBytes("qual");
+  private final static byte[] qual1 = Bytes.toBytes("qual1");
+  private final static byte[] qual2 = Bytes.toBytes("qual2");
+  private final static byte[] value = Bytes.toBytes("value");
+  public static Configuration conf;
+
+  @Rule
+  public final TestName TEST_NAME = new TestName();
+  public static User SUPERUSER;
+
+  @BeforeClass
+  public static void setupBeforeClass() throws Exception {
+    // setup configuration
+    conf = TEST_UTIL.getConfiguration();
+    conf.setBoolean(HConstants.DISTRIBUTED_LOG_REPLAY_KEY, false);
+    conf.setBoolean("hbase.online.schema.update.enable", true);
+    conf.setInt("hfile.format.version", 3);
+    conf.set("hbase.coprocessor.master.classes", VisibilityController.class.getName());
+    conf.set("hbase.coprocessor.region.classes", VisibilityController.class.getName());
+    conf.setClass(VisibilityUtils.VISIBILITY_LABEL_GENERATOR_CLASS, SimpleScanLabelGenerator.class,
+        ScanLabelGenerator.class);
+    conf.set("hbase.superuser", "admin");
+    TEST_UTIL.startMiniCluster(2);
+    SUPERUSER = User.createUserForTesting(conf, "admin", new String[] { "supergroup" });
+
+    // Wait for the labels table to become available
+    TEST_UTIL.waitTableEnabled(LABELS_TABLE_NAME.getName(), 50000);
+    addLabels();
+  }
+
+  @AfterClass
+  public static void tearDownAfterClass() throws Exception {
+    TEST_UTIL.shutdownMiniCluster();
+  }
+
+  @After
+  public void tearDown() throws Exception {
+  }
+
+  @Test
+  public void testVisibilityLabelsWithDeleteColumns() throws Throwable {
+    PrivilegedExceptionAction<VisibilityLabelsResponse> action = 
+        new PrivilegedExceptionAction<VisibilityLabelsResponse>() {
+      public VisibilityLabelsResponse run() throws Exception {
+        try {
+          return VisibilityClient.setAuths(conf, new String[] { CONFIDENTIAL, PRIVATE, SECRET },
+              SUPERUSER.getShortName());
+        } catch (Throwable e) {
+        }
+        return null;
+      }
+    };
+    VisibilityLabelsResponse response = SUPERUSER.runAs(action);
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    final HTable table = createTableAndWriteDataWithLabels(tableName, SECRET + "&" + TOPSECRET,
+        SECRET);
+    try {
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(TOPSECRET + "&" + SECRET));
+            d.deleteColumns(fam, qual);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 1);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testVisibilityLabelsWithDeleteFamily() throws Exception {
+    PrivilegedExceptionAction<VisibilityLabelsResponse> action =
+        new PrivilegedExceptionAction<VisibilityLabelsResponse>() {
+      public VisibilityLabelsResponse run() throws Exception {
+        try {
+          return VisibilityClient.setAuths(conf, new String[] { CONFIDENTIAL, PRIVATE, SECRET },
+              SUPERUSER.getShortName());
+        } catch (Throwable e) {
+        }
+        return null;
+      }
+    };
+    VisibilityLabelsResponse response = SUPERUSER.runAs(action);
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    final HTable table = createTableAndWriteDataWithLabels(tableName, SECRET, CONFIDENTIAL + "|"
+        + TOPSECRET);
+    try {
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row2);
+            d.setCellVisibility(new CellVisibility(TOPSECRET + "|" + CONFIDENTIAL));
+            d.deleteFamily(fam);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 1);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testVisibilityLabelsWithDeleteFamilyVersion() throws Exception {
+    PrivilegedExceptionAction<VisibilityLabelsResponse> action =
+        new PrivilegedExceptionAction<VisibilityLabelsResponse>() {
+      public VisibilityLabelsResponse run() throws Exception {
+        try {
+          return VisibilityClient.setAuths(conf, new String[] { CONFIDENTIAL, PRIVATE, SECRET },
+              SUPERUSER.getShortName());
+        } catch (Throwable e) {
+        }
+        return null;
+      }
+    };
+    VisibilityLabelsResponse response = SUPERUSER.runAs(action);
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    long[] ts = new long[] { 123l, 125l };
+    final HTable table = createTableAndWriteDataWithLabels(tableName, ts, CONFIDENTIAL + "|"
+        + TOPSECRET, SECRET);
+    try {
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(TOPSECRET + "|" + CONFIDENTIAL));
+            d.deleteFamilyVersion(fam, 123l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 1);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testVisibilityLabelsWithDeleteColumnExactVersion() throws Exception {
+    PrivilegedExceptionAction<VisibilityLabelsResponse> action =
+        new PrivilegedExceptionAction<VisibilityLabelsResponse>() {
+      public VisibilityLabelsResponse run() throws Exception {
+        try {
+          return VisibilityClient.setAuths(conf, new String[] { CONFIDENTIAL, PRIVATE, SECRET },
+              SUPERUSER.getShortName());
+        } catch (Throwable e) {
+        }
+        return null;
+      }
+    };
+    VisibilityLabelsResponse response = SUPERUSER.runAs(action);
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    long[] ts = new long[] { 123l, 125l };
+    final HTable table = createTableAndWriteDataWithLabels(tableName, ts, CONFIDENTIAL + "|"
+        + TOPSECRET, SECRET);
+    try {
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(TOPSECRET + "|" + CONFIDENTIAL));
+            d.deleteColumn(fam, qual, 123l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 1);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testVisibilityLabelsWithDeleteColumnsWithMultipleVersions() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPuts(tableName);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility("(" + PRIVATE + "&" + CONFIDENTIAL + ")|(" + 
+                SECRET + "&" + TOPSECRET+")"));
+            d.deleteColumns(fam, qual, 125l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  private HTable doPuts(TableName tableName) throws IOException, InterruptedIOException,
+      RetriesExhaustedWithDetailsException, InterruptedException {
+    HTable table;
+    HBaseAdmin hBaseAdmin = TEST_UTIL.getHBaseAdmin();
+    HColumnDescriptor colDesc = new HColumnDescriptor(fam);
+    colDesc.setMaxVersions(5);
+    HTableDescriptor desc = new HTableDescriptor(tableName);
+    desc.addFamily(colDesc);
+    hBaseAdmin.createTable(desc);
+    table = new HTable(conf, tableName);
+    Put put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 123l, value);
+    put.setCellVisibility(new CellVisibility(CONFIDENTIAL));
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 124l, value);
+    put.setCellVisibility(new CellVisibility("(" + CONFIDENTIAL + "&" + PRIVATE + ")|("
+    + TOPSECRET + "&" + SECRET+")"));
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 125l, value);
+    put.setCellVisibility(new CellVisibility(SECRET + "&" + TOPSECRET));
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 126l, value);
+    put.setCellVisibility(new CellVisibility("(" + CONFIDENTIAL + "&" + PRIVATE + ")|("
+        + TOPSECRET + "&" + SECRET+")"));
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 127l, value);
+    put.setCellVisibility(new CellVisibility("(" + CONFIDENTIAL + "&" + PRIVATE + ")|("
+        + TOPSECRET + "&" + SECRET+")"));
+    table.put(put);
+    TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+    put = new Put(Bytes.toBytes("row2"));
+    put.add(fam, qual, 127l, value);
+    put.setCellVisibility(new CellVisibility("(" + CONFIDENTIAL + "&" + PRIVATE + ")|(" + TOPSECRET
+        + "&" + SECRET + ")"));
+    table.put(put);
+    return table;
+  }
+
+  private HTable doPutsWithDiffCols(TableName tableName) throws IOException,
+      InterruptedIOException, RetriesExhaustedWithDetailsException, InterruptedException {
+    HTable table;
+    HBaseAdmin hBaseAdmin = TEST_UTIL.getHBaseAdmin();
+    HColumnDescriptor colDesc = new HColumnDescriptor(fam);
+    colDesc.setMaxVersions(5);
+    HTableDescriptor desc = new HTableDescriptor(tableName);
+    desc.addFamily(colDesc);
+    hBaseAdmin.createTable(desc);
+    table = new HTable(conf, tableName);
+    Put put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 123l, value);
+    put.setCellVisibility(new CellVisibility(CONFIDENTIAL));
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 124l, value);
+    put.setCellVisibility(new CellVisibility("(" + CONFIDENTIAL + "&" + PRIVATE + ")|("
+    + TOPSECRET + "&" + SECRET+")"));
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 125l, value);
+    put.setCellVisibility(new CellVisibility(SECRET + "&" + TOPSECRET));
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual1, 126l, value);
+    put.setCellVisibility(new CellVisibility(SECRET + "&" + TOPSECRET));
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual2, 127l, value);
+    put.setCellVisibility(new CellVisibility("(" + CONFIDENTIAL + "&" + PRIVATE + ")|("
+        + TOPSECRET + "&" + SECRET+")"));
+    table.put(put);
+    return table;
+  }
+
+  private HTable doPutsWithoutVisibility(TableName tableName) throws IOException,
+      InterruptedIOException, RetriesExhaustedWithDetailsException, InterruptedException {
+    HTable table;
+    HBaseAdmin hBaseAdmin = TEST_UTIL.getHBaseAdmin();
+    HColumnDescriptor colDesc = new HColumnDescriptor(fam);
+    colDesc.setMaxVersions(5);
+    HTableDescriptor desc = new HTableDescriptor(tableName);
+    desc.addFamily(colDesc);
+    hBaseAdmin.createTable(desc);
+    table = new HTable(conf, tableName);
+    Put put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 123l, value);
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 124l, value);
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 125l, value);
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 126l, value);
+    table.put(put);
+    put = new Put(Bytes.toBytes("row1"));
+    put.add(fam, qual, 127l, value);
+    table.put(put);
+    TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+    put = new Put(Bytes.toBytes("row2"));
+    put.add(fam, qual, 127l, value);
+    table.put(put);
+    return table;
+  }
+
+
+  @Test
+  public void testDeleteColumnWithSpecificTimeStampUsingMultipleVersionsUnMatchingVisExpression()
+      throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPuts(tableName);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility("(" + PRIVATE + "&" + CONFIDENTIAL + ")|(" +
+                SECRET + "&" + TOPSECRET+")"));
+            d.deleteColumn(fam, qual, 125l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testDeleteColumnWithLatestTimeStampUsingMultipleVersions() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPuts(tableName);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(SECRET + "&" + TOPSECRET));
+            d.deleteColumn(fam, qual);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+
+  @Test (timeout=1800000)
+  public void testDeleteColumnWithLatestTimeStampWhenNoVersionMatches() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPuts(tableName);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Put put = new Put(Bytes.toBytes("row1"));
+      put.add(fam, qual, 128l, value);
+      put.setCellVisibility(new CellVisibility(TOPSECRET));
+      table.put(put);
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(SECRET ));
+            d.deleteColumn(fam, qual);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+      
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 128l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+      
+      put = new Put(Bytes.toBytes("row1"));
+      put.add(fam, qual, 129l, value);
+      put.setCellVisibility(new CellVisibility(SECRET));
+      table.put(put);
+      table.flushCommits();
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      scanner = table.getScanner(s);
+      next = scanner.next(3);
+      assertTrue(next.length == 2);
+      cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 129l);
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+  @Test
+  public void testDeleteColumnWithLatestTimeStampUsingMultipleVersionsAfterCompaction()
+      throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPuts(tableName);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(SECRET + "&" + TOPSECRET));
+            d.deleteColumn(fam, qual);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Put put = new Put(Bytes.toBytes("row3"));
+      put.add(fam, qual, 127l, value);
+      put.setCellVisibility(new CellVisibility(CONFIDENTIAL + "&" + PRIVATE));
+      table.put(put);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      TEST_UTIL.getHBaseAdmin().majorCompact(tableName.getNameAsString());
+      // Sleep to ensure compaction happens. Need to do it in a better way
+      Thread.sleep(5000);
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 3);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testDeleteFamilyLatestTimeStampWithMulipleVersions() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPuts(tableName);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(SECRET + "&" + TOPSECRET));
+            d.deleteFamily(fam);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testDeleteColumnswithMultipleColumnsWithMultipleVersions() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPutsWithDiffCols(tableName);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(SECRET + "&" + TOPSECRET));
+            d.deleteColumns(fam, qual, 125l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 1);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertTrue(Bytes.equals(current.getQualifierArray(), current.getQualifierOffset(),
+          current.getQualifierLength(), qual1, 0, qual1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      assertTrue(Bytes.equals(current.getQualifierArray(), current.getQualifierOffset(),
+          current.getQualifierLength(), qual2, 0, qual2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testDeleteFamilyWithoutCellVisibilityWithMulipleVersions() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPutsWithoutVisibility(tableName);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.deleteFamily(fam);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 1);
+      // All cells wrt row1 should be deleted as we are not passing the Cell Visibility
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testDeleteFamilyLatestTimeStampWithMulipleVersionsWithoutCellVisibilityInPuts()
+      throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPutsWithoutVisibility(tableName);
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(SECRET + "&" + TOPSECRET));
+            d.deleteFamily(fam);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+  @Test
+  public void testDeleteFamilySpecificTimeStampWithMulipleVersions() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPuts(tableName);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility("(" + PRIVATE + "&" + CONFIDENTIAL + ")|(" +
+                SECRET + "&" + TOPSECRET+")"));
+            d.deleteFamily(fam, 126l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(6);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testScanAfterCompaction() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPuts(tableName);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility("(" + PRIVATE + "&" + CONFIDENTIAL + ")|(" +
+                SECRET + "&" + TOPSECRET+")"));
+            d.deleteFamily(fam, 126l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Put put = new Put(Bytes.toBytes("row3"));
+      put.add(fam, qual, 127l, value);
+      put.setCellVisibility(new CellVisibility(CONFIDENTIAL + "&" + PRIVATE));
+      table.put(put);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      TEST_UTIL.getHBaseAdmin().compact(tableName.getNameAsString());
+      Thread.sleep(5000);
+      // Sleep to ensure compaction happens. Need to do it in a better way
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 3);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testDeleteFamilySpecificTimeStampWithMulipleVersionsDoneTwice() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      // Do not flush here.
+      table = doPuts(tableName);
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility("(" + PRIVATE + "&" + CONFIDENTIAL + ")|("
+                + TOPSECRET + "&" + SECRET+")"));
+            d.deleteFamily(fam, 125l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+
+      // Issue 2nd delete
+      actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility("(" + CONFIDENTIAL + "&" + PRIVATE + ")|("
+                + TOPSECRET + "&" + SECRET+")"));
+            d.deleteFamily(fam, 127l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+      s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      scanner = table.getScanner(s);
+      next = scanner.next(3);
+      assertTrue(next.length == 2);
+      cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+      assertEquals(current.getTimestamp(), 127l);
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testDeleteColumnSpecificTimeStampWithMulipleVersionsDoneTwice() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      // Do not flush here.
+      table = doPuts(tableName);
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(SECRET + "&" + TOPSECRET));
+            d.deleteColumn(fam, qual, 125l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+
+      // Issue 2nd delete
+      actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility("(" + CONFIDENTIAL + "&" + PRIVATE + ")|("
+                + TOPSECRET + "&" + SECRET+")"));
+            d.deleteColumn(fam, qual, 127l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+      s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      scanner = table.getScanner(s);
+      next = scanner.next(3);
+      assertTrue(next.length == 2);
+      cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+      assertEquals(current.getTimestamp(), 127l);
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testDeleteColumnSpecificTimeStampWithMulipleVersionsDoneTwice1() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      // Do not flush here.
+      table = doPuts(tableName);
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility("(" + CONFIDENTIAL + "&" + PRIVATE + ")" +
+            		"|(" + TOPSECRET + "&" + SECRET + ")"));
+            d.deleteColumn(fam, qual, 127l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+      
+      // Issue 2nd delete
+      actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(SECRET + "&" + TOPSECRET));
+            d.deleteColumn(fam, qual, 127l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+      s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      scanner = table.getScanner(s);
+      next = scanner.next(3);
+      assertTrue(next.length == 2);
+      cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+      assertEquals(current.getTimestamp(), 127l);
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testDeleteColumnAndDeleteFamilylSpecificTimeStampWithMulipleVersion()
+      throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      // Do not flush here.
+      table = doPuts(tableName);
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility(SECRET + "&" + TOPSECRET));
+            d.deleteColumn(fam, qual, 125l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+
+      // Issue 2nd delete
+      actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility("(" + CONFIDENTIAL + "&" + PRIVATE + ")|("
+                + TOPSECRET + "&" + SECRET+")"));
+            d.deleteFamily(fam, 124l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+      s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      scanner = table.getScanner(s);
+      next = scanner.next(3);
+      assertTrue(next.length == 2);
+      cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+      assertEquals(current.getTimestamp(), 127l);
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  private void setAuths() throws IOException, InterruptedException {
+    PrivilegedExceptionAction<VisibilityLabelsResponse> action =
+        new PrivilegedExceptionAction<VisibilityLabelsResponse>() {
+      public VisibilityLabelsResponse run() throws Exception {
+        try {
+          return VisibilityClient.setAuths(conf, new String[] { CONFIDENTIAL, PRIVATE, SECRET,
+              TOPSECRET }, SUPERUSER.getShortName());
+        } catch (Throwable e) {
+        }
+        return null;
+      }
+    };
+    SUPERUSER.runAs(action);
+  }
+
+  @Test
+  public void testDiffDeleteTypesForTheSameCellUsingMultipleVersions() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      // Do not flush here.
+      table = doPuts(tableName);
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility("(" + PRIVATE + "&" + CONFIDENTIAL + ")|("
+                + TOPSECRET + "&" + SECRET+")"));
+            d.deleteColumns(fam, qual, 125l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+
+      // Issue 2nd delete
+      actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.setCellVisibility(new CellVisibility("(" + CONFIDENTIAL + "&" + PRIVATE + ")|(" 
+                + TOPSECRET + "&" + SECRET+")"));
+            d.deleteColumn(fam, qual, 127l);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+      s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      scanner = table.getScanner(s);
+      next = scanner.next(3);
+      assertTrue(next.length == 2);
+      cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+  @Test
+  public void testDeleteColumnLatestWithNoCellVisibility() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      table = doPuts(tableName);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.deleteColumn(fam, qual);
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 2);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 127l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 126l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 125l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+      cellScanner = next[1].cellScanner();
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row2, 0, row2.length));
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  @Test
+  public void testVisibilityExpressionWithNotEqualORCondition() throws Exception {
+    setAuths();
+    TableName tableName = TableName.valueOf(TEST_NAME.getMethodName());
+    HTable table = null;
+    try {
+      HBaseAdmin hBaseAdmin = TEST_UTIL.getHBaseAdmin();
+      HColumnDescriptor colDesc = new HColumnDescriptor(fam);
+      colDesc.setMaxVersions(5);
+      HTableDescriptor desc = new HTableDescriptor(tableName);
+      desc.addFamily(colDesc);
+      hBaseAdmin.createTable(desc);
+      table = new HTable(conf, tableName);
+      Put put = new Put(Bytes.toBytes("row1"));
+      put.add(fam, qual, 123l, value);
+      put.setCellVisibility(new CellVisibility(CONFIDENTIAL));
+      table.put(put);
+      put = new Put(Bytes.toBytes("row1"));
+      put.add(fam, qual, 124l, value);
+      put.setCellVisibility(new CellVisibility(CONFIDENTIAL + "|" + PRIVATE));
+      table.put(put);
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      PrivilegedExceptionAction<Void> actiona = new PrivilegedExceptionAction<Void>() {
+        public Void run() throws Exception {
+          try {
+            HTable table = new HTable(conf, TEST_NAME.getMethodName());
+            Delete d = new Delete(row1);
+            d.deleteColumn(fam, qual, 124l);
+            d.setCellVisibility(new CellVisibility(PRIVATE ));
+            table.delete(d);
+          } catch (Throwable t) {
+            throw new IOException(t);
+          }
+          return null;
+        }
+      };
+      SUPERUSER.runAs(actiona);
+
+      TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+      Scan s = new Scan();
+      s.setMaxVersions(5);
+      s.setAuthorizations(new Authorizations(SECRET, PRIVATE, CONFIDENTIAL, TOPSECRET));
+      ResultScanner scanner = table.getScanner(s);
+      Result[] next = scanner.next(3);
+      assertTrue(next.length == 1);
+      CellScanner cellScanner = next[0].cellScanner();
+      cellScanner.advance();
+      Cell current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 124l);
+      cellScanner.advance();
+      current = cellScanner.current();
+      assertTrue(Bytes.equals(current.getRowArray(), current.getRowOffset(),
+          current.getRowLength(), row1, 0, row1.length));
+      assertEquals(current.getTimestamp(), 123l);
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+  }
+
+  public static HTable createTableAndWriteDataWithLabels(TableName tableName, String... labelExps)
+      throws Exception {
+    HTable table = null;
+    try {
+      table = TEST_UTIL.createTable(tableName, fam);
+      int i = 1;
+      List<Put> puts = new ArrayList<Put>();
+      for (String labelExp : labelExps) {
+        Put put = new Put(Bytes.toBytes("row" + i));
+        put.add(fam, qual, HConstants.LATEST_TIMESTAMP, value);
+        put.setCellVisibility(new CellVisibility(labelExp));
+        puts.add(put);
+        table.put(put);
+        i++;
+      }
+      // table.put(puts);
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+    return table;
+  }
+
+  public static HTable createTableAndWriteDataWithLabels(TableName tableName, long[] timestamp,
+      String... labelExps) throws Exception {
+    HTable table = null;
+    try {
+      table = TEST_UTIL.createTable(tableName, fam);
+      int i = 1;
+      List<Put> puts = new ArrayList<Put>();
+      for (String labelExp : labelExps) {
+        Put put = new Put(Bytes.toBytes("row" + i));
+        put.add(fam, qual, timestamp[i - 1], value);
+        put.setCellVisibility(new CellVisibility(labelExp));
+        puts.add(put);
+        table.put(put);
+        TEST_UTIL.getHBaseAdmin().flush(tableName.getNameAsString());
+        i++;
+      }
+    } finally {
+      if (table != null) {
+        table.close();
+      }
+    }
+    return table;
+  }
+
+  public static void addLabels() throws Exception {
+    PrivilegedExceptionAction<VisibilityLabelsResponse> action =
+        new PrivilegedExceptionAction<VisibilityLabelsResponse>() {
+      public VisibilityLabelsResponse run() throws Exception {
+        String[] labels = { SECRET, TOPSECRET, CONFIDENTIAL, PUBLIC, PRIVATE };
+        try {
+          VisibilityClient.addLabels(conf, labels);
+        } catch (Throwable t) {
+          throw new IOException(t);
+        }
+        return null;
+      }
+    };
+    SUPERUSER.runAs(action);
+  }
+}
