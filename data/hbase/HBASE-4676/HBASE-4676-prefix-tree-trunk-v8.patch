diff --git a/conf/hbase-env.sh b/conf/hbase-env.sh
index dd68155..f31c003 100644
--- a/conf/hbase-env.sh
+++ b/conf/hbase-env.sh
@@ -22,7 +22,7 @@
 # Set environment variables here.
 
 # The java implementation to use.  Java 1.6 required.
-# export JAVA_HOME=/usr/java/jdk1.6.0/
+export JAVA_HOME=/hpdev/jdk6
 
 # Extra Java CLASSPATH elements.  Optional.
 # export HBASE_CLASSPATH=
diff --git a/conf/hbase-site.xml b/conf/hbase-site.xml
index c516ac7..3e462ad 100644
--- a/conf/hbase-site.xml
+++ b/conf/hbase-site.xml
@@ -21,4 +21,32 @@
  */
 -->
 <configuration>
+  <property>
+    <name>hbase.cluster.distributed</name>
+    <value>true</value>
+    <description>The mode the cluster will be in. Possible values are
+      false: standalone and pseudo-distributed setups with managed Zookeeper
+      true: fully-distributed with unmanaged Zookeeper Quorum (see hbase-env.sh)
+    </description>
+  </property>
+  <property>
+    <name>hbase.rootdir</name>
+    <!--<value>file:////hpdev/hbase-latest/data/</value>-->
+	<value>hdfs://localhost:9000/data/</value>
+    <description>The directory shared by region servers.
+    </description>
+  </property>
+  <property>
+    <name>hbase.tmp.dir</name>
+    <value>//hpdev/tmpHbase</value>
+    <description>Temporary directory on the local filesystem.</description>
+  </property>
+  <property>
+    <name>hbase.hregion.memstore.flush.size</name>
+    <value>268435456</value>
+  </property>
+  <property>
+    <name>hbase.zookeeper.quorum</name>
+    <value>roy</value>
+   </property>
 </configuration>
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DataBlockEncoder.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DataBlockEncoder.java
index b2ce35a..b181266 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DataBlockEncoder.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DataBlockEncoder.java
@@ -24,6 +24,7 @@ import org.apache.hadoop.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.io.compress.Compression.Algorithm;
 import org.apache.hadoop.io.RawComparator;
+import org.apache.hbase.Cell;
 
 /**
  * Encoding of KeyValue. It aims to be fast and efficient using assumptions:
@@ -170,9 +171,13 @@ public interface DataBlockEncoder {
      *         timestamp.
      */
     public KeyValue getKeyValue();
+    
+    public Cell getCurrentCell();
 
     /** Set position to beginning of given block */
     public void rewind();
+    
+    public boolean nextCell();
 
     /**
      * Move to next position
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DataBlockEncoding.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DataBlockEncoding.java
index cba3d36..a2a82d6 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DataBlockEncoding.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DataBlockEncoding.java
@@ -38,7 +38,10 @@ public enum DataBlockEncoding {
   // id 1 is reserved for the BITSET algorithm to be added later
   PREFIX(2, createEncoder("org.apache.hadoop.hbase.io.encoding.PrefixKeyDeltaEncoder")),
   DIFF(3, createEncoder("org.apache.hadoop.hbase.io.encoding.DiffKeyDeltaEncoder")),
-  FAST_DIFF(4, createEncoder("org.apache.hadoop.hbase.io.encoding.FastDiffDeltaEncoder"));
+  FAST_DIFF(4, createEncoder("org.apache.hadoop.hbase.io.encoding.FastDiffDeltaEncoder")),
+  //COPY_KEY is for benchmarking only
+  COPY_KEY(5, createEncoder("org.apache.hadoop.hbase.io.encoding.CopyKeyDataBlockEncoder")),
+  PREFIX_TREE(6, createEncoder("org.apache.hbase.codec.prefixtree.PrefixTreeCodec"));
 
   private final short id;
   private final byte[] idInBytes;
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/test/RedundantKVGenerator.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/test/RedundantKVGenerator.java
index 51932e0..0e45455 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/test/RedundantKVGenerator.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/test/RedundantKVGenerator.java
@@ -28,12 +28,15 @@ import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.util.ByteBufferUtils;
 import org.apache.hadoop.io.WritableUtils;
 
+import com.google.common.primitives.Bytes;
+
 /**
  * Generate list of key values which are very useful to test data block encoding
  * and compression.
  */
 public class RedundantKVGenerator {
   // row settings
+  static byte[] DEFAULT_COMMON_PREFIX = new byte[0];
   static int DEFAULT_NUMBER_OF_ROW_PREFIXES = 10;
   static int DEFAULT_AVERAGE_PREFIX_LENGTH = 6;
   static int DEFAULT_PREFIX_LENGTH_VARIANCE = 3;
@@ -107,6 +110,7 @@ public class RedundantKVGenerator {
       ) {
     this.randomizer = randomizer;
 
+    this.commonPrefix = DEFAULT_COMMON_PREFIX;
     this.numberOfRowPrefixes = numberOfRowPrefixes;
     this.averagePrefixLength = averagePrefixLength;
     this.prefixLengthVariance = prefixLengthVariance;
@@ -115,7 +119,7 @@ public class RedundantKVGenerator {
     this.numberOfRows = numberOfRows;
 
     this.chanceForSameQualifier = chanceForSameQualifier;
-    this.chanceForSimiliarQualifier = chanceForSimiliarQualifier;
+    this.chanceForSimilarQualifier = chanceForSimiliarQualifier;
     this.averageQualifierLength = averageQualifierLength;
     this.qualifierLengthVariance = qualifierLengthVariance;
 
@@ -131,6 +135,7 @@ public class RedundantKVGenerator {
   private Random randomizer;
 
   // row settings
+  private byte[] commonPrefix;//global prefix before rowPrefixes
   private int numberOfRowPrefixes;
   private int averagePrefixLength = 6;
   private int prefixLengthVariance = 3;
@@ -138,9 +143,12 @@ public class RedundantKVGenerator {
   private int suffixLengthVariance = 3;
   private int numberOfRows = 500;
 
+  //family
+  private byte[] family;
+
   // qualifier
   private float chanceForSameQualifier = 0.5f;
-  private float chanceForSimiliarQualifier = 0.4f;
+  private float chanceForSimilarQualifier = 0.4f;
   private int averageQualifierLength = 9;
   private int qualifierLengthVariance = 3;
 
@@ -161,7 +169,8 @@ public class RedundantKVGenerator {
           prefixLengthVariance;
       byte[] newPrefix = new byte[prefixLength];
       randomizer.nextBytes(newPrefix);
-      prefixes.add(newPrefix);
+      byte[] newPrefixWithCommon = newPrefix;
+      prefixes.add(newPrefixWithCommon);
     }
 
     // generate rest of the row
@@ -173,7 +182,8 @@ public class RedundantKVGenerator {
       int randomPrefix = randomizer.nextInt(prefixes.size());
       byte[] row = new byte[prefixes.get(randomPrefix).length +
                             suffixLength];
-      rows.add(row);
+      byte[] rowWithCommonPrefix = Bytes.concat(commonPrefix, row);
+      rows.add(rowWithCommonPrefix);
     }
 
     return rows;
@@ -188,20 +198,22 @@ public class RedundantKVGenerator {
     List<KeyValue> result = new ArrayList<KeyValue>();
 
     List<byte[]> rows = generateRows();
-    Map<Integer, List<byte[]>> rowsToQualifier =
-        new HashMap<Integer, List<byte[]>>();
+    Map<Integer, List<byte[]>> rowsToQualifier = new HashMap<Integer, List<byte[]>>();
 
-    byte[] family = new byte[columnFamilyLength];
-    randomizer.nextBytes(family);
+    if(family==null){
+      family = new byte[columnFamilyLength];
+      randomizer.nextBytes(family);
+    }
 
-    long baseTimestamp = Math.abs(randomizer.nextLong()) /
-        baseTimestampDivide;
+    long baseTimestamp = Math.abs(randomizer.nextLong()) / baseTimestampDivide;
 
     byte[] value = new byte[valueLength];
 
     for (int i = 0; i < howMany; ++i) {
-      long timestamp = baseTimestamp + randomizer.nextInt(
-          timestampDiffSize);
+      long timestamp = baseTimestamp;
+      if(timestampDiffSize > 0){
+        timestamp += randomizer.nextInt(timestampDiffSize);
+      }
       Integer rowId = randomizer.nextInt(rows.size());
       byte[] row = rows.get(rowId);
 
@@ -209,13 +221,11 @@ public class RedundantKVGenerator {
       // occasionally completely different
       byte[] qualifier;
       float qualifierChance = randomizer.nextFloat();
-      if (!rowsToQualifier.containsKey(rowId) ||
-          qualifierChance > chanceForSameQualifier +
-          chanceForSimiliarQualifier) {
+      if (!rowsToQualifier.containsKey(rowId)
+          || qualifierChance > chanceForSameQualifier + chanceForSimilarQualifier) {
         int qualifierLength = averageQualifierLength;
-        qualifierLength +=
-            randomizer.nextInt(2 * qualifierLengthVariance + 1) -
-            qualifierLengthVariance;
+        qualifierLength += randomizer.nextInt(2 * qualifierLengthVariance + 1)
+            - qualifierLengthVariance;
         qualifier = new byte[qualifierLength];
         randomizer.nextBytes(qualifier);
 
@@ -227,8 +237,8 @@ public class RedundantKVGenerator {
       } else if (qualifierChance > chanceForSameQualifier) {
         // similar qualifier
         List<byte[]> previousQualifiers = rowsToQualifier.get(rowId);
-        byte[] originalQualifier = previousQualifiers.get(
-            randomizer.nextInt(previousQualifiers.size()));
+        byte[] originalQualifier = previousQualifiers.get(randomizer.nextInt(previousQualifiers
+            .size()));
 
         qualifier = new byte[originalQualifier.length];
         int commonPrefix = randomizer.nextInt(qualifier.length);
@@ -241,8 +251,7 @@ public class RedundantKVGenerator {
       } else {
         // same qualifier
         List<byte[]> previousQualifiers = rowsToQualifier.get(rowId);
-        qualifier = previousQualifiers.get(
-            randomizer.nextInt(previousQualifiers.size()));
+        qualifier = previousQualifiers.get(randomizer.nextInt(previousQualifiers.size()));
       }
 
       if (randomizer.nextFloat() < chanceForZeroValue) {
@@ -286,5 +295,99 @@ public class RedundantKVGenerator {
 
     return result;
   }
+  
+  
+  /************************ get/set ***********************************/
+  
+  public RedundantKVGenerator setCommonPrefix(byte[] prefix){
+    this.commonPrefix = prefix;
+    return this;
+  }
+
+  public RedundantKVGenerator setRandomizer(Random randomizer) {
+    this.randomizer = randomizer;
+    return this;
+  }
+
+  public RedundantKVGenerator setNumberOfRowPrefixes(int numberOfRowPrefixes) {
+    this.numberOfRowPrefixes = numberOfRowPrefixes;
+    return this;
+  }
+
+  public RedundantKVGenerator setAveragePrefixLength(int averagePrefixLength) {
+    this.averagePrefixLength = averagePrefixLength;
+    return this;
+  }
 
+  public RedundantKVGenerator setPrefixLengthVariance(int prefixLengthVariance) {
+    this.prefixLengthVariance = prefixLengthVariance;
+    return this;
+  }
+
+  public RedundantKVGenerator setAverageSuffixLength(int averageSuffixLength) {
+    this.averageSuffixLength = averageSuffixLength;
+    return this;
+  }
+
+  public RedundantKVGenerator setSuffixLengthVariance(int suffixLengthVariance) {
+    this.suffixLengthVariance = suffixLengthVariance;
+    return this;
+  }
+
+  public RedundantKVGenerator setNumberOfRows(int numberOfRows) {
+    this.numberOfRows = numberOfRows;
+    return this;
+  }
+
+  public RedundantKVGenerator setChanceForSameQualifier(float chanceForSameQualifier) {
+    this.chanceForSameQualifier = chanceForSameQualifier;
+    return this;
+  }
+
+  public RedundantKVGenerator setChanceForSimilarQualifier(float chanceForSimiliarQualifier) {
+    this.chanceForSimilarQualifier = chanceForSimiliarQualifier;
+    return this;
+  }
+
+  public RedundantKVGenerator setAverageQualifierLength(int averageQualifierLength) {
+    this.averageQualifierLength = averageQualifierLength;
+    return this;
+  }
+
+  public RedundantKVGenerator setQualifierLengthVariance(int qualifierLengthVariance) {
+    this.qualifierLengthVariance = qualifierLengthVariance;
+    return this;
+  }
+
+  public RedundantKVGenerator setColumnFamilyLength(int columnFamilyLength) {
+    this.columnFamilyLength = columnFamilyLength;
+    return this;
+  }
+
+  public RedundantKVGenerator setFamily(byte[] family) {
+    this.family = family;
+    this.columnFamilyLength = family.length;
+    return this;
+  }
+
+  public RedundantKVGenerator setValueLength(int valueLength) {
+    this.valueLength = valueLength;
+    return this;
+  }
+
+  public RedundantKVGenerator setChanceForZeroValue(float chanceForZeroValue) {
+    this.chanceForZeroValue = chanceForZeroValue;
+    return this;
+  }
+
+  public RedundantKVGenerator setBaseTimestampDivide(int baseTimestampDivide) {
+    this.baseTimestampDivide = baseTimestampDivide;
+    return this;
+  }
+
+  public RedundantKVGenerator setTimestampDiffSize(int timestampDiffSize) {
+    this.timestampDiffSize = timestampDiffSize;
+    return this;
+  }
+  
 }
diff --git a/hbase-common/src/main/java/org/apache/hbase/cell/CellComparator.java b/hbase-common/src/main/java/org/apache/hbase/cell/CellComparator.java
index 19d6b54..ce9d063 100644
--- a/hbase-common/src/main/java/org/apache/hbase/cell/CellComparator.java
+++ b/hbase-common/src/main/java/org/apache/hbase/cell/CellComparator.java
@@ -79,22 +79,39 @@ public class CellComparator implements Comparator<Cell>, Serializable{
   /**************** equals ****************************/
 
   public static boolean equals(Cell a, Cell b){
-    if (!areKeyLengthsEqual(a, b)) {
-      return false;
-    }
-    //TODO compare byte[]'s in reverse since later bytes more likely to differ
-    return 0 == compareStatic(a, b);
+    return equalsRow(a, b)
+        && equalsFamily(a, b)
+        && equalsQualifier(a, b)
+        && equalsTimestamp(a, b)
+        && equalsType(a, b);
   }
 
   public static boolean equalsRow(Cell a, Cell b){
-    if(!areRowLengthsEqual(a, b)){
-      return false;
-    }
-    return 0 == Bytes.compareTo(
+    return Bytes.equals(
       a.getRowArray(), a.getRowOffset(), a.getRowLength(),
       b.getRowArray(), b.getRowOffset(), b.getRowLength());
   }
 
+  public static boolean equalsFamily(Cell a, Cell b){
+    return Bytes.equals(
+      a.getFamilyArray(), a.getFamilyOffset(), a.getFamilyLength(),
+      b.getFamilyArray(), b.getFamilyOffset(), b.getFamilyLength());
+  }
+
+  public static boolean equalsQualifier(Cell a, Cell b){
+    return Bytes.equals(
+      a.getQualifierArray(), a.getQualifierOffset(), a.getQualifierLength(),
+      b.getQualifierArray(), b.getQualifierOffset(), b.getQualifierLength());
+  }
+
+  public static boolean equalsTimestamp(Cell a, Cell b){
+    return a.getTimestamp() == b.getTimestamp();
+  }
+
+  public static boolean equalsType(Cell a, Cell b){
+    return a.getTypeByte() == b.getTypeByte();
+  }
+
 
   /********************* hashCode ************************/
 
diff --git a/hbase-common/src/main/java/org/apache/hbase/cell/CellOutputStream.java b/hbase-common/src/main/java/org/apache/hbase/cell/CellOutputStream.java
index fcaf27e..6d46ec5 100644
--- a/hbase-common/src/main/java/org/apache/hbase/cell/CellOutputStream.java
+++ b/hbase-common/src/main/java/org/apache/hbase/cell/CellOutputStream.java
@@ -18,6 +18,8 @@
 
 package org.apache.hbase.cell;
 
+import java.io.IOException;
+
 import org.apache.hadoop.classification.InterfaceAudience;
 import org.apache.hadoop.classification.InterfaceStability;
 import org.apache.hbase.Cell;
@@ -45,6 +47,6 @@ public interface CellOutputStream {
    * that can then be read from the implementation to be sent to disk, put in the block cache, or
    * sent over the network.
    */
-  void flush();
+  void flush() throws IOException;
 
 }
diff --git a/hbase-prefix-tree/pom.xml b/hbase-prefix-tree/pom.xml
new file mode 100644
index 0000000..76965f1
--- /dev/null
+++ b/hbase-prefix-tree/pom.xml
@@ -0,0 +1,203 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<!--
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <artifactId>hbase</artifactId>
+    <groupId>org.apache.hbase</groupId>
+    <version>0.95-SNAPSHOT</version>
+    <relativePath>..</relativePath>
+  </parent>
+
+  <artifactId>hbase-prefix-tree</artifactId>
+  <name>HBase - Prefix Tree</name>
+  <description>Prefix Tree Data Block Encoder</description>
+
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-surefire-plugin</artifactId>
+        <!-- Always skip the second part executions, since we only run
+        simple unit tests in this module. -->
+        <executions>
+          <execution>
+            <id>secondPartTestsExecution</id>
+            <phase>test</phase>
+            <goals>
+              <goal>test</goal>
+            </goals>
+            <configuration>
+              <skip>true</skip>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.hbase</groupId>
+      <artifactId>hbase-common</artifactId>
+    </dependency>
+  </dependencies>
+
+  <profiles>
+    <!-- Skip the tests in this module -->
+    <profile>
+      <id>skip-common-tests</id>
+      <activation>
+        <property>
+          <name>skip-common-tests</name>
+        </property>
+      </activation>
+      <properties>
+        <surefire.skipFirstPart>true</surefire.skipFirstPart>
+      </properties>
+    </profile>
+
+    <!-- profile against Hadoop 1.0.x: This is the default. It has to have the same
+    activation property as the parent Hadoop 1.0.x profile to make sure it gets run at
+    the same time. -->
+    <profile>
+      <id>hadoop-1.0</id>
+      <activation>
+        <property>
+          <name>!hadoop.profile</name>
+        </property>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>org.apache.hadoop</groupId>
+          <artifactId>hadoop-core</artifactId>
+        </dependency>
+        <dependency>
+          <groupId>org.apache.hadoop</groupId>
+          <artifactId>hadoop-test</artifactId>
+        </dependency>
+      </dependencies>
+    </profile>
+
+    <!--
+      profile for building against Hadoop 2.0.0-alpha. Activate using:
+       mvn -Dhadoop.profile=2.0
+    -->
+    <profile>
+      <id>hadoop-2.0</id>
+      <activation>
+        <property>
+          <name>hadoop.profile</name>
+          <value>2.0</value>
+        </property>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>org.apache.hadoop</groupId>
+          <artifactId>hadoop-client</artifactId>
+        </dependency>
+        <dependency>
+          <groupId>org.apache.hadoop</groupId>
+          <artifactId>hadoop-annotations</artifactId>
+        </dependency>
+        <dependency>
+          <groupId>org.apache.hadoop</groupId>
+          <artifactId>hadoop-minicluster</artifactId>
+        </dependency>
+      </dependencies>
+      <build>
+        <plugins>
+          <plugin>
+            <artifactId>maven-dependency-plugin</artifactId>
+            <executions>
+              <execution>
+                <id>create-mrapp-generated-classpath</id>
+                <phase>generate-test-resources</phase>
+                <goals>
+                  <goal>build-classpath</goal>
+                </goals>
+                <configuration>
+                  <!-- needed to run the unit test for DS to generate
+                  the required classpath that is required in the env
+                  of the launch container in the mini mr/yarn cluster
+                  -->
+                  <outputFile>${project.build.directory}/test-classes/mrapp-generated-classpath</outputFile>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+
+    <!--
+      profile for building against Hadoop 3.0.x. Activate using:
+       mvn -Dhadoop.profile=3.0
+    -->
+    <profile>
+      <id>hadoop-3.0</id>
+      <activation>
+        <property>
+          <name>hadoop.profile</name>
+          <value>3.0</value>
+        </property>
+      </activation>
+      <properties>
+        <hadoop.version>3.0-SNAPSHOT</hadoop.version>
+      </properties>
+      <dependencies>
+        <dependency>
+          <groupId>org.apache.hadoop</groupId>
+          <artifactId>hadoop-common</artifactId>
+        </dependency>
+        <dependency>
+          <groupId>org.apache.hadoop</groupId>
+          <artifactId>hadoop-annotations</artifactId>
+        </dependency>
+        <dependency>
+          <groupId>org.apache.hadoop</groupId>
+          <artifactId>hadoop-minicluster</artifactId>
+        </dependency>
+      </dependencies>
+      <build>
+        <plugins>
+          <plugin>
+            <artifactId>maven-dependency-plugin</artifactId>
+            <executions>
+              <execution>
+                <id>create-mrapp-generated-classpath</id>
+                <phase>generate-test-resources</phase>
+                <goals>
+                  <goal>build-classpath</goal>
+                </goals>
+                <configuration>
+                  <!-- needed to run the unit test for DS to generate
+                  the required classpath that is required in the env
+                  of the launch container in the mini mr/yarn cluster
+                  -->
+                  <outputFile>${project.build.directory}/test-classes/mrapp-generated-classpath</outputFile>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
+</project>
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/PrefixTreeBlockMeta.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/PrefixTreeBlockMeta.java
new file mode 100644
index 0000000..ec4bdd7
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/PrefixTreeBlockMeta.java
@@ -0,0 +1,858 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+
+import org.apache.hadoop.hbase.util.ByteBufferUtils;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.encode.other.LongEncoder;
+import org.apache.hbase.util.vint.UVIntTool;
+import org.apache.hbase.util.vint.UVLongTool;
+
+/**
+ * Information about the block.  Stored at the beginning of the byte[].  Contains things
+ * like minimum timestamp and width of FInts in the row tree.
+ *
+ * Most fields stored in VInts that get decoded on the first access of each new block.
+ */
+public class PrefixTreeBlockMeta {
+
+  /******************* static fields ********************/
+
+  public static final int VERSION = 0;
+
+  public static final int MAX_FAMILY_LENGTH = Byte.MAX_VALUE;// hard-coded in KeyValue
+
+  public static final int
+	  NUM_LONGS = 2,
+    NUM_INTS = 22,
+    NUM_SHORTS = 0,//keyValueTypeWidth not persisted
+    NUM_SINGLE_BYTES = 2,
+    MAX_BYTES = Bytes.SIZEOF_LONG * NUM_LONGS
+        + Bytes.SIZEOF_SHORT * NUM_SHORTS
+        + Bytes.SIZEOF_INT * NUM_INTS
+        + NUM_SINGLE_BYTES;
+
+
+  /**************** transient fields *********************/
+
+  protected int arrayOffset;
+  protected int bufferOffset;
+
+
+  /**************** persisted fields **********************/
+
+  // PrefixTree version to allow future format modifications
+  protected int version;
+  protected int numMetaBytes;
+  protected int numKeyValueBytes;
+  protected boolean includesMvccVersion;//probably don't need this explicitly, but only 1 byte
+
+  // split the byte[] into 6 sections for the different data types
+  protected int numRowBytes;
+  protected int numFamilyBytes;
+  protected int numQualifierBytes;
+  protected int numTimestampBytes;
+  protected int numMvccVersionBytes;
+  protected int numValueBytes;
+
+  // number of bytes in each section of fixed width VInts
+  protected int nextNodeOffsetWidth;
+  protected int familyOffsetWidth;
+  protected int qualifierOffsetWidth;
+  protected int timestampIndexWidth;
+  protected int mvccVersionIndexWidth;
+  protected int valueOffsetWidth;
+  protected int valueLengthWidth;
+
+  // used to pre-allocate structures for reading
+  protected int rowTreeDepth;
+  protected int maxRowLength;
+  protected int maxQualifierLength;
+
+  // the timestamp from which the deltas are calculated
+  protected long minTimestamp;
+  protected int timestampDeltaWidth;
+  protected long minMvccVersion;
+  protected int mvccVersionDeltaWidth;
+
+  protected boolean allSameType;
+  protected byte allTypes;
+
+  protected int numUniqueRows;
+  protected int numUniqueFamilies;
+  protected int numUniqueQualifiers;
+
+
+  /***************** constructors ********************/
+
+  public PrefixTreeBlockMeta() {
+  }
+
+  public PrefixTreeBlockMeta(InputStream is) {
+    this.version = VERSION;
+    this.arrayOffset = 0;
+    this.bufferOffset = 0;
+    readVariableBytesFromInputStream(is);
+  }
+
+  public PrefixTreeBlockMeta(ByteBuffer buffer) {// pass in buffer positioned at start of PtBlockMeta
+    initOnBlock(buffer);
+  }
+
+  public void initOnBlock(ByteBuffer buffer) {
+    arrayOffset = buffer.arrayOffset();
+    bufferOffset = buffer.position();
+    readVariableBytesFromArray(buffer.array(), arrayOffset + bufferOffset);
+  }
+
+
+	/**************** operate on each field **********************/
+
+  public int calculateNumMetaBytes(){
+    int numBytes = 0;
+    numBytes += UVIntTool.numBytes(version);
+    numBytes += UVLongTool.numBytes(numMetaBytes);
+    numBytes += UVIntTool.numBytes(numKeyValueBytes);
+    ++numBytes;//os.write(getIncludesMvccVersion());
+
+    numBytes += UVIntTool.numBytes(numRowBytes);
+    numBytes += UVIntTool.numBytes(numFamilyBytes);
+    numBytes += UVIntTool.numBytes(numQualifierBytes);
+    numBytes += UVIntTool.numBytes(numTimestampBytes);
+    numBytes += UVIntTool.numBytes(numMvccVersionBytes);
+    numBytes += UVIntTool.numBytes(numValueBytes);
+
+    numBytes += UVIntTool.numBytes(nextNodeOffsetWidth);
+    numBytes += UVIntTool.numBytes(familyOffsetWidth);
+    numBytes += UVIntTool.numBytes(qualifierOffsetWidth);
+    numBytes += UVIntTool.numBytes(timestampIndexWidth);
+    numBytes += UVIntTool.numBytes(mvccVersionIndexWidth);
+    numBytes += UVIntTool.numBytes(valueOffsetWidth);
+    numBytes += UVIntTool.numBytes(valueLengthWidth);
+
+    numBytes += UVIntTool.numBytes(rowTreeDepth);
+    numBytes += UVIntTool.numBytes(maxRowLength);
+    numBytes += UVIntTool.numBytes(maxQualifierLength);
+
+    numBytes += UVLongTool.numBytes(minTimestamp);
+    numBytes += UVIntTool.numBytes(timestampDeltaWidth);
+    numBytes += UVLongTool.numBytes(minMvccVersion);
+    numBytes += UVIntTool.numBytes(mvccVersionDeltaWidth);
+    ++numBytes;//os.write(getAllSameTypeByte());
+    ++numBytes;//os.write(allTypes);
+
+    numBytes += UVIntTool.numBytes(numUniqueRows);
+    numBytes += UVIntTool.numBytes(numUniqueFamilies);
+    numBytes += UVIntTool.numBytes(numUniqueQualifiers);
+    return numBytes;
+  }
+
+  public void writeVariableBytesToOutputStream(OutputStream os) {
+    try {
+      UVIntTool.writeBytes(version, os);
+      UVIntTool.writeBytes(numMetaBytes, os);
+      UVIntTool.writeBytes(numKeyValueBytes, os);
+      os.write(getIncludesMvccVersionByte());
+
+      UVIntTool.writeBytes(numRowBytes, os);
+      UVIntTool.writeBytes(numFamilyBytes, os);
+      UVIntTool.writeBytes(numQualifierBytes, os);
+      UVIntTool.writeBytes(numTimestampBytes, os);
+      UVIntTool.writeBytes(numMvccVersionBytes, os);
+      UVIntTool.writeBytes(numValueBytes, os);
+
+      UVIntTool.writeBytes(nextNodeOffsetWidth, os);
+      UVIntTool.writeBytes(familyOffsetWidth, os);
+      UVIntTool.writeBytes(qualifierOffsetWidth, os);
+      UVIntTool.writeBytes(timestampIndexWidth, os);
+      UVIntTool.writeBytes(mvccVersionIndexWidth, os);
+      UVIntTool.writeBytes(valueOffsetWidth, os);
+      UVIntTool.writeBytes(valueLengthWidth, os);
+
+      UVIntTool.writeBytes(rowTreeDepth, os);
+      UVIntTool.writeBytes(maxRowLength, os);
+      UVIntTool.writeBytes(maxQualifierLength, os);
+
+      UVLongTool.writeBytes(minTimestamp, os);
+      UVIntTool.writeBytes(timestampDeltaWidth, os);
+      UVLongTool.writeBytes(minMvccVersion, os);
+      UVIntTool.writeBytes(mvccVersionDeltaWidth, os);
+      os.write(getAllSameTypeByte());
+      os.write(allTypes);
+
+      UVIntTool.writeBytes(numUniqueRows, os);
+      UVIntTool.writeBytes(numUniqueFamilies, os);
+      UVIntTool.writeBytes(numUniqueQualifiers, os);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public void readVariableBytesFromInputStream(InputStream is) {
+    try {
+      version = UVIntTool.getInt(is);
+      numMetaBytes = UVIntTool.getInt(is);
+      numKeyValueBytes = UVIntTool.getInt(is);
+      setIncludesMvccVersion((byte) is.read());
+
+      numRowBytes = UVIntTool.getInt(is);
+      numFamilyBytes = UVIntTool.getInt(is);
+      numQualifierBytes = UVIntTool.getInt(is);
+      numTimestampBytes = UVIntTool.getInt(is);
+      numMvccVersionBytes = UVIntTool.getInt(is);
+      numValueBytes = UVIntTool.getInt(is);
+
+      nextNodeOffsetWidth = UVIntTool.getInt(is);
+      familyOffsetWidth = UVIntTool.getInt(is);
+      qualifierOffsetWidth = UVIntTool.getInt(is);
+      timestampIndexWidth = UVIntTool.getInt(is);
+      mvccVersionIndexWidth = UVIntTool.getInt(is);
+      valueOffsetWidth = UVIntTool.getInt(is);
+      valueLengthWidth = UVIntTool.getInt(is);
+
+      rowTreeDepth = UVIntTool.getInt(is);
+      maxRowLength = UVIntTool.getInt(is);
+      maxQualifierLength = UVIntTool.getInt(is);
+
+      minTimestamp = UVLongTool.getLong(is);
+      timestampDeltaWidth = UVIntTool.getInt(is);
+      minMvccVersion = UVLongTool.getLong(is);
+      mvccVersionDeltaWidth = UVIntTool.getInt(is);
+
+      setAllSameType((byte) is.read());
+      allTypes = (byte) is.read();
+
+      numUniqueRows = UVIntTool.getInt(is);
+      numUniqueFamilies = UVIntTool.getInt(is);
+      numUniqueQualifiers = UVIntTool.getInt(is);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public void readVariableBytesFromArray(byte[] bytes, int offset) {
+    int position = offset;
+
+    version = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(version);
+    numMetaBytes = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(numMetaBytes);
+    numKeyValueBytes = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(numKeyValueBytes);
+    setIncludesMvccVersion(bytes[position]);
+    ++position;
+
+    numRowBytes = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(numRowBytes);
+    numFamilyBytes = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(numFamilyBytes);
+    numQualifierBytes = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(numQualifierBytes);
+    numTimestampBytes = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(numTimestampBytes);
+    numMvccVersionBytes = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(numMvccVersionBytes);
+    numValueBytes = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(numValueBytes);
+
+    nextNodeOffsetWidth = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(nextNodeOffsetWidth);
+    familyOffsetWidth = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(familyOffsetWidth);
+    qualifierOffsetWidth = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(qualifierOffsetWidth);
+    timestampIndexWidth = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(timestampIndexWidth);
+    mvccVersionIndexWidth = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(mvccVersionIndexWidth);
+    valueOffsetWidth = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(valueOffsetWidth);
+    valueLengthWidth = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(valueLengthWidth);
+
+    rowTreeDepth = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(rowTreeDepth);
+    maxRowLength = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(maxRowLength);
+    maxQualifierLength = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(maxQualifierLength);
+
+    minTimestamp = UVLongTool.getLong(bytes, position);
+    position += UVLongTool.numBytes(minTimestamp);
+    timestampDeltaWidth = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(timestampDeltaWidth);
+    minMvccVersion = UVLongTool.getLong(bytes, position);
+    position += UVLongTool.numBytes(minMvccVersion);
+    mvccVersionDeltaWidth = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(mvccVersionDeltaWidth);
+
+    setAllSameType(bytes[position]);
+    ++position;
+    allTypes = bytes[position];
+    ++position;
+
+    numUniqueRows = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(numUniqueRows);
+    numUniqueFamilies = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(numUniqueFamilies);
+    numUniqueQualifiers = UVIntTool.getInt(bytes, position);
+    position += UVIntTool.numBytes(numUniqueQualifiers);
+  }
+
+	//TODO method that can read directly from ByteBuffer instead of InputStream
+
+
+  /*************** methods *************************/
+
+  public int getKeyValueTypeWidth() {
+    return allSameType ? 0 : 1;
+  }
+
+  public byte getIncludesMvccVersionByte() {
+    return includesMvccVersion ? (byte) 1 : (byte) 0;
+  }
+
+  public void setIncludesMvccVersion(byte includesMvccVersionByte) {
+    includesMvccVersion = includesMvccVersionByte != 0;
+  }
+
+  public byte getAllSameTypeByte() {
+    return allSameType ? (byte) 1 : (byte) 0;
+  }
+
+  public void setAllSameType(byte allSameTypeByte) {
+    allSameType = allSameTypeByte != 0;
+  }
+
+  public boolean isAllSameTimestamp() {
+    return timestampIndexWidth == 0;
+  }
+
+  public boolean isAllSameMvccVersion() {
+    return mvccVersionIndexWidth == 0;
+  }
+
+  // for debugging
+  public byte[] getMetaBytes() {
+    ByteArrayOutputStream baos = new ByteArrayOutputStream(1000);
+    writeVariableBytesToOutputStream(baos);
+    return baos.toByteArray();
+  }
+
+  public byte[] getNonMetaBytes(ByteBuffer block) {
+    return ByteBufferUtils.toBytes(block, getNumMetaBytes());
+  }
+
+  public int getNumDataRegionBytes(){
+    return numRowBytes
+        + numFamilyBytes
+        + numQualifierBytes
+        + numTimestampBytes
+        + numMvccVersionBytes
+        + numValueBytes;
+  }
+
+  public void setTimestampFields(LongEncoder encoder){
+    this.minTimestamp = encoder.getMin();
+    this.timestampIndexWidth = encoder.getBytesPerIndex();
+    this.timestampDeltaWidth = encoder.getBytesPerDelta();
+    this.numTimestampBytes = encoder.getTotalCompressedBytes();
+  }
+
+  public void setMvccVersionFields(LongEncoder encoder){
+    this.minMvccVersion = encoder.getMin();
+    this.mvccVersionIndexWidth = encoder.getBytesPerIndex();
+    this.mvccVersionDeltaWidth = encoder.getBytesPerDelta();
+    this.numMvccVersionBytes = encoder.getTotalCompressedBytes();
+  }
+
+
+  /*************** Object methods *************************/
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj)
+      return true;
+    if (obj == null)
+      return false;
+    if (getClass() != obj.getClass())
+      return false;
+    PrefixTreeBlockMeta other = (PrefixTreeBlockMeta) obj;
+    if (allSameType != other.allSameType)
+      return false;
+    if (allTypes != other.allTypes)
+      return false;
+    if (arrayOffset != other.arrayOffset)
+      return false;
+    if (bufferOffset != other.bufferOffset)
+      return false;
+    if (valueLengthWidth != other.valueLengthWidth)
+      return false;
+    if (valueOffsetWidth != other.valueOffsetWidth)
+      return false;
+    if (familyOffsetWidth != other.familyOffsetWidth)
+      return false;
+    if (includesMvccVersion != other.includesMvccVersion)
+      return false;
+    if (maxQualifierLength != other.maxQualifierLength)
+      return false;
+    if (maxRowLength != other.maxRowLength)
+      return false;
+    if (mvccVersionDeltaWidth != other.mvccVersionDeltaWidth)
+      return false;
+    if (mvccVersionIndexWidth != other.mvccVersionIndexWidth)
+      return false;
+    if (minMvccVersion != other.minMvccVersion)
+      return false;
+    if (minTimestamp != other.minTimestamp)
+      return false;
+    if (nextNodeOffsetWidth != other.nextNodeOffsetWidth)
+      return false;
+    if (numValueBytes != other.numValueBytes)
+      return false;
+    if (numFamilyBytes != other.numFamilyBytes)
+      return false;
+    if (numMvccVersionBytes != other.numMvccVersionBytes)
+      return false;
+    if (numMetaBytes != other.numMetaBytes)
+      return false;
+    if (numQualifierBytes != other.numQualifierBytes)
+      return false;
+    if (numRowBytes != other.numRowBytes)
+      return false;
+    if (numTimestampBytes != other.numTimestampBytes)
+      return false;
+    if (numUniqueFamilies != other.numUniqueFamilies)
+      return false;
+    if (numUniqueQualifiers != other.numUniqueQualifiers)
+      return false;
+    if (numUniqueRows != other.numUniqueRows)
+      return false;
+    if (numKeyValueBytes != other.numKeyValueBytes)
+      return false;
+    if (qualifierOffsetWidth != other.qualifierOffsetWidth)
+      return false;
+    if (rowTreeDepth != other.rowTreeDepth)
+      return false;
+    if (timestampDeltaWidth != other.timestampDeltaWidth)
+      return false;
+    if (timestampIndexWidth != other.timestampIndexWidth)
+      return false;
+    if (version != other.version)
+      return false;
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + (allSameType ? 1231 : 1237);
+    result = prime * result + allTypes;
+    result = prime * result + arrayOffset;
+    result = prime * result + bufferOffset;
+    result = prime * result + valueLengthWidth;
+    result = prime * result + valueOffsetWidth;
+    result = prime * result + familyOffsetWidth;
+    result = prime * result + (includesMvccVersion ? 1231 : 1237);
+    result = prime * result + maxQualifierLength;
+    result = prime * result + maxRowLength;
+    result = prime * result + mvccVersionDeltaWidth;
+    result = prime * result + mvccVersionIndexWidth;
+    result = prime * result + (int) (minMvccVersion ^ (minMvccVersion >>> 32));
+    result = prime * result + (int) (minTimestamp ^ (minTimestamp >>> 32));
+    result = prime * result + nextNodeOffsetWidth;
+    result = prime * result + numValueBytes;
+    result = prime * result + numFamilyBytes;
+    result = prime * result + numMvccVersionBytes;
+    result = prime * result + numMetaBytes;
+    result = prime * result + numQualifierBytes;
+    result = prime * result + numRowBytes;
+    result = prime * result + numTimestampBytes;
+    result = prime * result + numUniqueFamilies;
+    result = prime * result + numUniqueQualifiers;
+    result = prime * result + numUniqueRows;
+    result = prime * result + numKeyValueBytes;
+    result = prime * result + qualifierOffsetWidth;
+    result = prime * result + rowTreeDepth;
+    result = prime * result + timestampDeltaWidth;
+    result = prime * result + timestampIndexWidth;
+    result = prime * result + version;
+    return result;
+  }
+
+
+  @Override
+  public String toString() {
+    StringBuilder builder = new StringBuilder();
+    builder.append("PtBlockMeta [arrayOffset=");
+    builder.append(arrayOffset);
+    builder.append(", bufferOffset=");
+    builder.append(bufferOffset);
+    builder.append(", version=");
+    builder.append(version);
+    builder.append(", numMetaBytes=");
+    builder.append(numMetaBytes);
+    builder.append(", numKeyValueBytes=");
+    builder.append(numKeyValueBytes);
+    builder.append(", includesMvccVersion=");
+    builder.append(includesMvccVersion);
+    builder.append(", numRowBytes=");
+    builder.append(numRowBytes);
+    builder.append(", numFamilyBytes=");
+    builder.append(numFamilyBytes);
+    builder.append(", numQualifierBytes=");
+    builder.append(numQualifierBytes);
+    builder.append(", numTimestampBytes=");
+    builder.append(numTimestampBytes);
+    builder.append(", numMvccVersionBytes=");
+    builder.append(numMvccVersionBytes);
+    builder.append(", numValueBytes=");
+    builder.append(numValueBytes);
+    builder.append(", nextNodeOffsetWidth=");
+    builder.append(nextNodeOffsetWidth);
+    builder.append(", familyOffsetWidth=");
+    builder.append(familyOffsetWidth);
+    builder.append(", qualifierOffsetWidth=");
+    builder.append(qualifierOffsetWidth);
+    builder.append(", timestampIndexWidth=");
+    builder.append(timestampIndexWidth);
+    builder.append(", mvccVersionIndexWidth=");
+    builder.append(mvccVersionIndexWidth);
+    builder.append(", valueOffsetWidth=");
+    builder.append(valueOffsetWidth);
+    builder.append(", valueLengthWidth=");
+    builder.append(valueLengthWidth);
+    builder.append(", rowTreeDepth=");
+    builder.append(rowTreeDepth);
+    builder.append(", maxRowLength=");
+    builder.append(maxRowLength);
+    builder.append(", maxQualifierLength=");
+    builder.append(maxQualifierLength);
+    builder.append(", minTimestamp=");
+    builder.append(minTimestamp);
+    builder.append(", timestampDeltaWidth=");
+    builder.append(timestampDeltaWidth);
+    builder.append(", minMvccVersion=");
+    builder.append(minMvccVersion);
+    builder.append(", mvccVersionDeltaWidth=");
+    builder.append(mvccVersionDeltaWidth);
+    builder.append(", allSameType=");
+    builder.append(allSameType);
+    builder.append(", allTypes=");
+    builder.append(allTypes);
+    builder.append(", numUniqueRows=");
+    builder.append(numUniqueRows);
+    builder.append(", numUniqueFamilies=");
+    builder.append(numUniqueFamilies);
+    builder.append(", numUniqueQualifiers=");
+    builder.append(numUniqueQualifiers);
+    builder.append("]");
+    return builder.toString();
+  }
+
+
+  /************** absolute getters *******************/
+
+  public int getAbsoluteMetaOffset() {
+    return arrayOffset + bufferOffset;
+  }
+
+  public int getAbsoluteRowOffset() {
+    return getAbsoluteMetaOffset() + numMetaBytes;
+  }
+
+  public int getAbsoluteFamilyOffset() {
+    return getAbsoluteRowOffset() + numRowBytes;
+  }
+
+  public int getAbsoluteQualifierOffset() {
+    return getAbsoluteFamilyOffset() + numFamilyBytes;
+  }
+
+  public int getAbsoluteTimestampOffset() {
+    return getAbsoluteQualifierOffset() + numQualifierBytes;
+  }
+
+  public int getAbsoluteMvccVersionOffset() {
+    return getAbsoluteTimestampOffset() + numTimestampBytes;
+  }
+
+  public int getAbsoluteValueOffset() {
+    return getAbsoluteMvccVersionOffset() + numMvccVersionBytes;
+  }
+
+
+  /*************** get/set ***************************/
+
+  public int getTimestampDeltaWidth() {
+    return timestampDeltaWidth;
+  }
+
+  public void setTimestampDeltaWidth(int timestampDeltaWidth) {
+    this.timestampDeltaWidth = timestampDeltaWidth;
+  }
+
+  public int getValueOffsetWidth() {
+    return valueOffsetWidth;
+  }
+
+  public void setValueOffsetWidth(int dataOffsetWidth) {
+    this.valueOffsetWidth = dataOffsetWidth;
+  }
+
+  public int getValueLengthWidth() {
+    return valueLengthWidth;
+  }
+
+  public void setValueLengthWidth(int dataLengthWidth) {
+    this.valueLengthWidth = dataLengthWidth;
+  }
+
+  public int getMaxRowLength() {
+    return maxRowLength;
+  }
+
+  public void setMaxRowLength(int maxRowLength) {
+    this.maxRowLength = maxRowLength;
+  }
+
+  public long getMinTimestamp() {
+    return minTimestamp;
+  }
+
+  public void setMinTimestamp(long minTimestamp) {
+    this.minTimestamp = minTimestamp;
+  }
+
+  public byte getAllTypes() {
+    return allTypes;
+  }
+
+  public void setAllTypes(byte allTypes) {
+    this.allTypes = allTypes;
+  }
+
+  public boolean isAllSameType() {
+    return allSameType;
+  }
+
+  public void setAllSameType(boolean allSameType) {
+    this.allSameType = allSameType;
+  }
+
+  public int getNextNodeOffsetWidth() {
+    return nextNodeOffsetWidth;
+  }
+
+  public void setNextNodeOffsetWidth(int nextNodeOffsetWidth) {
+    this.nextNodeOffsetWidth = nextNodeOffsetWidth;
+  }
+
+  public int getNumRowBytes() {
+    return numRowBytes;
+  }
+
+  public void setNumRowBytes(int numRowBytes) {
+    this.numRowBytes = numRowBytes;
+  }
+
+  public int getNumTimestampBytes() {
+    return numTimestampBytes;
+  }
+
+  public void setNumTimestampBytes(int numTimestampBytes) {
+    this.numTimestampBytes = numTimestampBytes;
+  }
+
+  public int getNumValueBytes() {
+    return numValueBytes;
+  }
+
+  public void setNumValueBytes(int numValueBytes) {
+    this.numValueBytes = numValueBytes;
+  }
+
+  public int getNumMetaBytes() {
+    return numMetaBytes;
+  }
+
+  public void setNumMetaBytes(int numMetaBytes) {
+    this.numMetaBytes = numMetaBytes;
+  }
+
+  public int getArrayOffset() {
+    return arrayOffset;
+  }
+
+  public void setArrayOffset(int arrayOffset) {
+    this.arrayOffset = arrayOffset;
+  }
+
+  public int getBufferOffset() {
+    return bufferOffset;
+  }
+
+  public void setBufferOffset(int bufferOffset) {
+    this.bufferOffset = bufferOffset;
+  }
+
+  public int getNumKeyValueBytes() {
+    return numKeyValueBytes;
+  }
+
+  public void setNumKeyValueBytes(int numKeyValueBytes) {
+    this.numKeyValueBytes = numKeyValueBytes;
+  }
+
+  public int getRowTreeDepth() {
+    return rowTreeDepth;
+  }
+
+  public void setRowTreeDepth(int rowTreeDepth) {
+    this.rowTreeDepth = rowTreeDepth;
+  }
+
+  public int getNumMvccVersionBytes() {
+    return numMvccVersionBytes;
+  }
+
+  public void setNumMvccVersionBytes(int numMvccVersionBytes) {
+    this.numMvccVersionBytes = numMvccVersionBytes;
+  }
+
+  public int getMvccVersionDeltaWidth() {
+    return mvccVersionDeltaWidth;
+  }
+
+  public void setMvccVersionDeltaWidth(int mvccVersionDeltaWidth) {
+    this.mvccVersionDeltaWidth = mvccVersionDeltaWidth;
+  }
+
+  public long getMinMvccVersion() {
+    return minMvccVersion;
+  }
+
+  public void setMinMvccVersion(long minMvccVersion) {
+    this.minMvccVersion = minMvccVersion;
+  }
+
+  public int getNumFamilyBytes() {
+    return numFamilyBytes;
+  }
+
+  public void setNumFamilyBytes(int numFamilyBytes) {
+    this.numFamilyBytes = numFamilyBytes;
+  }
+
+  public int getFamilyOffsetWidth() {
+    return familyOffsetWidth;
+  }
+
+  public void setFamilyOffsetWidth(int familyOffsetWidth) {
+    this.familyOffsetWidth = familyOffsetWidth;
+  }
+
+  public int getNumUniqueRows() {
+    return numUniqueRows;
+  }
+
+  public void setNumUniqueRows(int numUniqueRows) {
+    this.numUniqueRows = numUniqueRows;
+  }
+
+  public int getNumUniqueFamilies() {
+    return numUniqueFamilies;
+  }
+
+  public void setNumUniqueFamilies(int numUniqueFamilies) {
+    this.numUniqueFamilies = numUniqueFamilies;
+  }
+
+  public int getNumUniqueQualifiers() {
+    return numUniqueQualifiers;
+  }
+
+  public void setNumUniqueQualifiers(int numUniqueQualifiers) {
+    this.numUniqueQualifiers = numUniqueQualifiers;
+  }
+
+  public int getNumQualifierBytes() {
+    return numQualifierBytes;
+  }
+
+  public void setNumQualifierBytes(int numQualifierBytes) {
+    this.numQualifierBytes = numQualifierBytes;
+  }
+
+  public int getQualifierOffsetWidth() {
+    return qualifierOffsetWidth;
+  }
+
+  public void setQualifierOffsetWidth(int qualifierOffsetWidth) {
+    this.qualifierOffsetWidth = qualifierOffsetWidth;
+  }
+
+  public int getMaxQualifierLength() {
+    return maxQualifierLength;
+  }
+
+  public void setMaxQualifierLength(int maxQualifierLength) {
+    this.maxQualifierLength = maxQualifierLength;
+  }
+
+  public int getTimestampIndexWidth() {
+    return timestampIndexWidth;
+  }
+
+  public void setTimestampIndexWidth(int timestampIndexWidth) {
+    this.timestampIndexWidth = timestampIndexWidth;
+  }
+
+  public int getMvccVersionIndexWidth() {
+    return mvccVersionIndexWidth;
+  }
+
+  public void setMvccVersionIndexWidth(int mvccVersionIndexWidth) {
+    this.mvccVersionIndexWidth = mvccVersionIndexWidth;
+  }
+
+  public int getVersion() {
+    return version;
+  }
+
+  public void setVersion(int version) {
+    this.version = version;
+  }
+
+  public boolean isIncludesMvccVersion() {
+    return includesMvccVersion;
+  }
+
+  public void setIncludesMvccVersion(boolean includesMvccVersion) {
+    this.includesMvccVersion = includesMvccVersion;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/PrefixTreeCodec.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/PrefixTreeCodec.java
new file mode 100644
index 0000000..6e8d4a1
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/PrefixTreeCodec.java
@@ -0,0 +1,205 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValue.KeyComparator;
+import org.apache.hadoop.hbase.KeyValue.MetaKeyComparator;
+import org.apache.hadoop.hbase.KeyValue.RootKeyComparator;
+import org.apache.hadoop.hbase.KeyValueTool;
+import org.apache.hadoop.hbase.io.compress.Compression.Algorithm;
+import org.apache.hadoop.hbase.io.encoding.DataBlockEncoder;
+import org.apache.hadoop.hbase.io.encoding.DataBlockEncoding;
+import org.apache.hadoop.hbase.io.encoding.HFileBlockDecodingContext;
+import org.apache.hadoop.hbase.io.encoding.HFileBlockDefaultDecodingContext;
+import org.apache.hadoop.hbase.io.encoding.HFileBlockDefaultEncodingContext;
+import org.apache.hadoop.hbase.io.encoding.HFileBlockEncodingContext;
+import org.apache.hadoop.hbase.io.hfile.BlockType;
+import org.apache.hadoop.hbase.util.ByteBufferUtils;
+import org.apache.hadoop.io.RawComparator;
+import org.apache.hbase.codec.prefixtree.decode.DecoderFactory;
+import org.apache.hbase.codec.prefixtree.decode.PrefixTreeArraySearcher;
+import org.apache.hbase.codec.prefixtree.encode.EncoderFactory;
+import org.apache.hbase.codec.prefixtree.encode.PrefixTreeEncoder;
+import org.apache.hbase.codec.prefixtree.scanner.CellSearcher;
+
+/**
+ * This class created via reflection in DataBlockEncoding enum.  Update the enum if class name or
+ * package changes.
+ *
+ * PrefixTreeDataBlockEncoder implementation of DataBlockEncoder.  This is the primary entry point
+ * for PrefixTree encoding and decoding.  Encoding is delegated to instances of {@link PrefixTreeEncoder},
+ * and decoding is delegated to instances of {@ PtCellSearcher}.  Encoder and decoder instances are
+ * created and recycled by static PtEncoderFactory and PtDecoderFactory.
+ */
+public class PrefixTreeCodec implements DataBlockEncoder{
+
+  /**
+   * no-arg constructor for reflection
+   */
+  public PrefixTreeCodec() {
+  }
+
+  /**
+   * Copied from BufferedDataBlockEncoder. Almost definitely can be improved, but i'm not familiar
+   * enough with the concept of the HFileBlockEncodingContext.
+   */
+  @Override
+  public void encodeKeyValues(ByteBuffer in, boolean includesMemstoreTS,
+      HFileBlockEncodingContext blkEncodingCtx) throws IOException {
+    if (blkEncodingCtx.getClass() != HFileBlockDefaultEncodingContext.class) {
+      throw new IOException(this.getClass().getName() + " only accepts "
+          + HFileBlockDefaultEncodingContext.class.getName() + " as the " + "encoding context.");
+    }
+
+    HFileBlockDefaultEncodingContext encodingCtx = (HFileBlockDefaultEncodingContext) blkEncodingCtx;
+    encodingCtx.prepareEncoding();
+    DataOutputStream dataOut = encodingCtx.getOutputStreamForEncoder();
+    internalEncodeKeyValues(dataOut, in, includesMemstoreTS);
+
+    //do i need to check this, or will it always be DataBlockEncoding.PREFIX_TREE?
+    if (encodingCtx.getDataBlockEncoding() != DataBlockEncoding.NONE) {
+      encodingCtx.postEncoding(BlockType.ENCODED_DATA);
+    } else {
+      encodingCtx.postEncoding(BlockType.DATA);
+    }
+  }
+
+  protected void internalEncodeKeyValues(DataOutputStream encodedOutputStream,
+      ByteBuffer rawKeyValues, boolean includesMemstoreTS) throws IOException {
+    rawKeyValues.rewind();
+    PrefixTreeEncoder builder = EncoderFactory.checkOut(encodedOutputStream, includesMemstoreTS);
+
+    KeyValue kv;
+    while ((kv = KeyValueTool.nextShallowCopy(rawKeyValues, includesMemstoreTS)) != null) {
+      builder.write(kv);
+    }
+
+    builder.flush();
+    EncoderFactory.checkIn(builder);
+  }
+
+
+  @Override
+  public ByteBuffer decodeKeyValues(DataInputStream source, boolean includesMemstoreTS)
+      throws IOException {
+    return decodeKeyValues(source, 0, 0, includesMemstoreTS);
+  }
+
+
+  /**
+   * I don't think this method is called during normal HBase operation, so efficiency is not
+   * important.
+   */
+  @Override
+  public ByteBuffer decodeKeyValues(DataInputStream source, int allocateHeaderLength,
+      int skipLastBytes, boolean includesMemstoreTS) throws IOException {
+    ByteBuffer sourceAsBuffer = ByteBufferUtils.drainInputStreamToBuffer(source);// waste
+    sourceAsBuffer.mark();
+    PrefixTreeBlockMeta blockMeta = new PrefixTreeBlockMeta(sourceAsBuffer);
+    sourceAsBuffer.rewind();
+    int numV1BytesWithHeader = allocateHeaderLength + blockMeta.getNumKeyValueBytes();
+    byte[] keyValueBytesWithHeader = new byte[numV1BytesWithHeader];
+    ByteBuffer result = ByteBuffer.wrap(keyValueBytesWithHeader);
+    result.rewind();
+    CellSearcher searcher = null;
+    try {
+      searcher = DecoderFactory.checkOut(sourceAsBuffer, includesMemstoreTS);
+      while (searcher.next()) {
+        KeyValue currentCell = KeyValueTool.copyToNewKeyValue(searcher.getCurrent());
+        // needs to be modified for DirectByteBuffers. no existing methods to
+        // write VLongs to byte[]
+        int offset = result.arrayOffset() + result.position();
+        KeyValueTool.appendToByteArray(currentCell, result.array(), offset);
+        int keyValueLength = KeyValueTool.length(currentCell);
+        ByteBufferUtils.skip(result, keyValueLength);
+        offset += keyValueLength;
+        if (includesMemstoreTS) {
+          ByteBufferUtils.writeVLong(result, currentCell.getMemstoreTS());
+        }
+      }
+      result.position(result.limit());//make it appear as if we were appending
+      return result;
+    } finally {
+      DecoderFactory.checkIn(searcher);
+    }
+  }
+
+
+  @Override
+  public ByteBuffer getFirstKeyInBlock(ByteBuffer block) {
+    block.rewind();
+    PrefixTreeArraySearcher searcher = null;
+    try {
+      //should i includeMemstoreTS (second argument)?  i think PrefixKeyDeltaEncoder is, so i will
+      searcher = DecoderFactory.checkOut(block, true);
+      if (!searcher.positionAtFirstCell()) {
+        return null;
+      }
+      return KeyValueTool.copyKeyToNewByteBuffer(searcher.getCurrent());
+    } finally {
+      DecoderFactory.checkIn(searcher);
+    }
+  }
+
+  @Override
+  public HFileBlockEncodingContext newDataBlockEncodingContext(Algorithm compressionAlgorithm,
+      DataBlockEncoding encoding, byte[] header) {
+    if(DataBlockEncoding.PREFIX_TREE != encoding){
+      //i'm not sure why encoding is in the interface.  Each encoder implementation should probably
+      //know it's encoding type
+      throw new IllegalArgumentException("only DataBlockEncoding.PREFIX_TREE supported");
+    }
+    return new HFileBlockDefaultEncodingContext(compressionAlgorithm, encoding, header);
+  }
+
+  @Override
+  public HFileBlockDecodingContext newDataBlockDecodingContext(Algorithm compressionAlgorithm) {
+    return new HFileBlockDefaultDecodingContext(compressionAlgorithm);
+  }
+
+  /**
+   * Is this the correct handling of an illegal comparator?  How to prevent that from getting all
+   * the way to this point.
+   */
+  @Override
+  public EncodedSeeker createSeeker(RawComparator<byte[]> comparator, boolean includesMemstoreTS) {
+    if(! (comparator instanceof KeyComparator)){
+      throw new IllegalArgumentException("comparator must be KeyValue.KeyComparator");
+    }
+    if(comparator instanceof MetaKeyComparator){
+      throw new IllegalArgumentException("DataBlockEncoding.PREFIX_TREE not compatible with META "
+          +"table");
+    }
+    if(comparator instanceof RootKeyComparator){
+      throw new IllegalArgumentException("DataBlockEncoding.PREFIX_TREE not compatible with ROOT "
+          +"table");
+    }
+
+    //TODO what should i do with includeMemstoreTS?
+
+    return new PrefixTreeSeeker(includesMemstoreTS);
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/PrefixTreeSeeker.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/PrefixTreeSeeker.java
new file mode 100644
index 0000000..b62258d
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/PrefixTreeSeeker.java
@@ -0,0 +1,213 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree;
+
+import java.nio.ByteBuffer;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValueTool;
+import org.apache.hadoop.hbase.io.encoding.DataBlockEncoder.EncodedSeeker;
+import org.apache.hbase.Cell;
+import org.apache.hbase.cell.CellScannerPosition;
+import org.apache.hbase.cell.CellTool;
+import org.apache.hbase.codec.prefixtree.decode.DecoderFactory;
+import org.apache.hbase.codec.prefixtree.decode.PrefixTreeArraySearcher;
+
+/**
+ * These methods have the same definition as any implementation of the EncodedSeeker.
+ *
+ * In the future, the EncodedSeeker could be modified to work with the Cell interface directly.  It
+ * currently returns a new KeyValue object each time getKeyValue is called.  This is not horrible,
+ * but in order to create a new KeyValue object, we must first allocate a new byte[] and copy in
+ * the data from the PrefixTreeCell.  It is somewhat heavyweight right now.
+ */
+public class PrefixTreeSeeker implements EncodedSeeker {
+
+  protected ByteBuffer block;
+  protected boolean includeMemstoreTS;
+  protected PrefixTreeArraySearcher ptSearcher;
+
+  public PrefixTreeSeeker(boolean includeMemstoreTS) {
+    this.includeMemstoreTS = includeMemstoreTS;
+  }
+
+  @Override
+  public void setCurrentBuffer(ByteBuffer fullBlockBuffer) {
+    block = fullBlockBuffer;
+    ptSearcher = DecoderFactory.checkOut(block, includeMemstoreTS);
+    rewind();
+  }
+
+  /**
+   * Currently unused.
+   * <p/>
+   * TODO performance leak. should reuse the searchers. hbase does not currently have a hook where
+   * this can be called
+   */
+  public void releaseCurrentBuffer(){
+    DecoderFactory.checkIn(ptSearcher);
+  }
+
+
+  @Override
+  public ByteBuffer getKeyDeepCopy() {
+    return KeyValueTool.copyKeyToNewByteBuffer(ptSearcher.getCurrent());
+  }
+
+
+  @Override
+  public ByteBuffer getValueShallowCopy() {
+    return CellTool.getValueBufferShallowCopy(ptSearcher.getCurrent());
+  }
+
+  /**
+   * currently must do deep copy into new array
+   */
+  @Override
+  public ByteBuffer getKeyValueBuffer() {
+    return KeyValueTool.copyToNewByteBuffer(ptSearcher.getCurrent());
+  }
+
+  /**
+   * currently must do deep copy into new array
+   */
+  @Override
+  public KeyValue getKeyValue() {
+    return KeyValueTool.copyToNewKeyValue(ptSearcher.getCurrent());
+  }
+
+  /**
+   * Currently unused.
+   * <p/>
+   * A nice, lightweight reference, though the underlying cell is transient.  This method may return
+   * the same reference to the backing PrefixTreeCell repeatedly, while other implementations may
+   * return a different reference for each Cell.
+   * <p/>
+   * The goal will be to transition the upper layers of HBase, like Filters and KeyValueHeap, to use
+   * this method instead of the getKeyValue() methods above.
+   */
+  @Override
+  public Cell getCurrentCell() {
+    return ptSearcher.getCurrent();
+  }
+
+  @Override
+  public void rewind() {
+    ptSearcher.positionAtFirstCell();
+  }
+
+  @Override
+  public boolean next() {
+    return ptSearcher.next();
+  }
+  
+  //temp method
+  @Override
+  public boolean nextCell() {
+    return ptSearcher.next();
+  }
+
+
+  private static final boolean USE_POSITION_BEFORE_VS_AFTER = false;
+
+  /**
+   * Seek forward only (should be called reseekToKeyInBlock?).
+   * <p/>
+   * If the exact key is found look at the seekBefore variable and:<br/>
+   * - if true: go to the previous key if it's true<br/>
+   * - if false: stay on the exact key
+   * <p/>
+   * If the exact key is not found, then go to the previous key *if possible*, but remember to leave
+   * the scanner in a valid state if possible.
+   * <p/>
+   * @param keyOnlyBytes KeyValue format of a Cell's key at which to position the seeker
+   * @param offset offset into the keyOnlyBytes array
+   * @param length number of bytes of the keyOnlyBytes array to use
+   * @param forceBeforeOnExactMatch if an exact match is found and seekBefore=true, back up one Cell
+   * @return 0 if the seeker is on the exact key<br/>
+   *         1 if the seeker is not on the key for any reason, including seekBefore being true
+   */
+  @Override
+  public int seekToKeyInBlock(byte[] keyOnlyBytes, int offset, int length,
+      boolean forceBeforeOnExactMatch) {
+    if (USE_POSITION_BEFORE_VS_AFTER) {
+      return seekToOrBeforeUsingPositionAtOrBefore(keyOnlyBytes, offset, length,
+        forceBeforeOnExactMatch);
+    }else{
+      return seekToOrBeforeUsingPositionAtOrAfter(keyOnlyBytes, offset, length,
+        forceBeforeOnExactMatch);
+    }
+  }
+
+
+
+  /*
+   * Include both of these options since the underlying PrefixTree supports both.  Possibly
+   * expand the EncodedSeeker to utilize them both.
+   */
+
+  protected int seekToOrBeforeUsingPositionAtOrBefore(byte[] keyOnlyBytes, int offset, int length,
+      boolean forceBeforeOnExactMatch){
+    // this does a deep copy of the key byte[] because the CellSearcher interface wants a Cell
+    KeyValue kv = KeyValue.createKeyValueFromKey(keyOnlyBytes, offset, length);
+
+    //should probably switch this to use the seekForwardToOrBefore method
+    CellScannerPosition position = ptSearcher.seekForwardToOrBefore(kv);
+
+    if(CellScannerPosition.AT == position){
+      if (forceBeforeOnExactMatch) {
+        ptSearcher.previous();
+        return 1;
+      }
+      return 0;
+    }
+
+    return 1;
+  }
+
+
+  protected int seekToOrBeforeUsingPositionAtOrAfter(byte[] keyOnlyBytes, int offset, int length,
+      boolean forceBeforeOnExactMatch){
+    // this does a deep copy of the key byte[] because the CellSearcher interface wants a Cell
+    KeyValue kv = KeyValue.createKeyValueFromKey(keyOnlyBytes, offset, length);
+
+    //should probably switch this to use the seekForwardToOrBefore method
+    CellScannerPosition position = ptSearcher.seekForwardToOrAfter(kv);
+
+    if(CellScannerPosition.AT == position){
+      if (forceBeforeOnExactMatch) {
+        ptSearcher.previous();
+        return 1;
+      }
+      return 0;
+
+    }else if(CellScannerPosition.AFTER == position){
+      if(!ptSearcher.isBeforeFirst()){
+        ptSearcher.previous();
+      }
+      return 1;
+
+    }else if(position == CellScannerPosition.AFTER_LAST){
+      return 1;
+    }
+
+    throw new RuntimeException("unexpected CellScannerPosition:"+position);
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/ArrayBlockSearcherPool.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/ArrayBlockSearcherPool.java
new file mode 100644
index 0000000..f7036dd
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/ArrayBlockSearcherPool.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.decode;
+
+import java.nio.ByteBuffer;
+import java.util.Queue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+
+public class ArrayBlockSearcherPool {
+
+  protected Queue<PrefixTreeArraySearcher> pool = new LinkedBlockingQueue<PrefixTreeArraySearcher>();
+
+  public PrefixTreeArraySearcher checkOut(ByteBuffer buffer, boolean incldueMemstoreTS) {
+    PrefixTreeArraySearcher searcher = pool.poll();
+    searcher = DecoderFactory.ensureArraySearcherValid(buffer, searcher, incldueMemstoreTS);
+    return searcher;
+  }
+
+  public void checkIn(PrefixTreeArraySearcher searcher) {
+    searcher.releaseBlockReference();
+    //TODO limit the pool size
+    pool.offer(searcher);
+  }
+
+  @Override
+  public String toString() {
+    return ("poolSize:" + pool.size());
+  }
+
+}
\ No newline at end of file
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/DecoderFactory.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/DecoderFactory.java
new file mode 100644
index 0000000..db8ef9e
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/DecoderFactory.java
@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.decode;
+
+import java.nio.ByteBuffer;
+
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.scanner.CellSearcher;
+
+public class DecoderFactory {
+
+  protected static ArrayBlockSearcherPool ARRAY_BLOCK_SEARCHER_POOL = new ArrayBlockSearcherPool();
+
+  //TODO will need a PrefixTreeSearcher on top of CellSearcher
+  public static PrefixTreeArraySearcher checkOut(final ByteBuffer buffer, boolean includeMvccVersion) {
+    if (buffer.isDirect()) {
+      throw new IllegalArgumentException("DirectByteBuffers not supported yet");
+      // TODO implement PtByteBufferBlockScanner
+    } else {
+      PrefixTreeArraySearcher searcher = ARRAY_BLOCK_SEARCHER_POOL.checkOut(buffer,
+        includeMvccVersion);
+      return searcher;
+    }
+  }
+
+  public static void checkIn(CellSearcher pSearcher) {
+    if (pSearcher == null) {
+      return;
+    }
+    if (pSearcher instanceof PrefixTreeArraySearcher) {
+      PrefixTreeArraySearcher searcher = (PrefixTreeArraySearcher) pSearcher;
+      ARRAY_BLOCK_SEARCHER_POOL.checkIn(searcher);
+    }
+  }
+
+
+  /**************************** helper ******************************/
+
+  protected static PrefixTreeArraySearcher ensureArraySearcherValid(ByteBuffer buffer,
+      PrefixTreeArraySearcher searcher, boolean includeMvccVersion) {
+    if (searcher == null) {
+      PrefixTreeBlockMeta blockMeta = new PrefixTreeBlockMeta(buffer);
+      searcher = new PrefixTreeArraySearcher(blockMeta, blockMeta.getRowTreeDepth(),
+          blockMeta.getMaxRowLength(), blockMeta.getMaxQualifierLength());
+      searcher.initOnBlock(blockMeta, buffer.array(), includeMvccVersion);
+      return searcher;
+    }
+
+    PrefixTreeBlockMeta blockMeta = searcher.getBlockMeta();
+    blockMeta.initOnBlock(buffer);
+    if (!searcher.areBuffersBigEnough()) {
+      int maxRowTreeStackNodes = Math.max(blockMeta.getRowTreeDepth(),
+        searcher.getMaxRowTreeStackNodes());
+      int rowBufferLength = Math.max(blockMeta.getMaxRowLength(), searcher.getRowBufferLength());
+      int qualifierBufferLength = Math.max(blockMeta.getMaxQualifierLength(),
+        searcher.getQualifierBufferLength());
+      searcher = new PrefixTreeArraySearcher(blockMeta, maxRowTreeStackNodes, rowBufferLength,
+          qualifierBufferLength);
+    }
+    searcher.initOnBlock(blockMeta, buffer.array(), includeMvccVersion);
+    return searcher;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeArrayReversibleScanner.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeArrayReversibleScanner.java
new file mode 100644
index 0000000..584dd95
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeArrayReversibleScanner.java
@@ -0,0 +1,129 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.decode;
+
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.scanner.ReversibleCellScanner;
+
+public class PrefixTreeArrayReversibleScanner extends PrefixTreeArrayScanner implements
+    ReversibleCellScanner {
+
+  /***************** construct ******************************/
+
+  public PrefixTreeArrayReversibleScanner(PrefixTreeBlockMeta blockMeta, int rowTreeDepth,
+      int rowBufferLength, int qualifierBufferLength) {
+    super(blockMeta, rowTreeDepth, rowBufferLength, qualifierBufferLength);
+  }
+
+
+  /***************** methods **********************************/
+
+  @Override
+  public boolean previous() {
+    if (afterLast) {
+      afterLast = false;
+      positionAtLastCell();
+      return true;
+    }
+    if (beforeFirst) {
+      return false;
+    }
+    if (isFirstCellInRow()) {
+      previousRowInternal();
+      if (beforeFirst) {
+        return false;
+      }
+      populateLastNonRowFields();
+      return true;
+    }
+    populatePreviousNonRowFields();
+    return true;
+  }
+
+  @Override
+  public boolean previousRow(boolean endOfRow) {
+    previousRowInternal();
+    if(beforeFirst){
+      return false;
+    }
+    if(endOfRow){
+      populateLastNonRowFields();
+    }else{
+      populateFirstNonRowFields();
+    }
+    return true;
+  }
+
+  public boolean previousRowInternal() {
+    if (beforeFirst) {
+      return false;
+    }
+    if (afterLast) {
+      positionAtLastRow();
+      return true;
+    }
+    if (currentRowNode.hasOccurrences()) {
+      discardCurrentRowNode(false);
+      if(currentRowNode==null){
+        return false;
+      }
+    }
+    while (!beforeFirst) {
+      if (isDirectlyAfterNub()) {//we are about to back up to the nub
+        currentRowNode.resetFanIndex();//sets it to -1, which is before the first leaf
+        nubCellsRemain = true;//this positions us on the nub
+        return true;
+      }
+      if (currentRowNode.hasPreviousFanNodes()) {
+        followPreviousFan();
+        descendToLastRowFromCurrentPosition();
+      } else {// keep going up the stack until we find previous fan positions
+        discardCurrentRowNode(false);
+        if(currentRowNode==null){
+          return false;
+        }
+      }
+      if (currentRowNode.hasOccurrences()) {// escape clause
+        return true;// found some values
+      }
+    }
+    return false;// went past the beginning
+  }
+  
+  protected boolean isDirectlyAfterNub() {
+    return currentRowNode.isNub() && currentRowNode.getFanIndex()==0;
+  }
+
+  protected void positionAtLastRow() {
+    reInitFirstNode();
+    descendToLastRowFromCurrentPosition();
+  }
+
+  protected void descendToLastRowFromCurrentPosition() {
+    while (currentRowNode.hasChildren()) {
+      followLastFan();
+    }
+  }
+
+  protected void positionAtLastCell() {
+    positionAtLastRow();
+    populateLastNonRowFields();
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeArrayScanner.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeArrayScanner.java
new file mode 100644
index 0000000..d0da9ad
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeArrayScanner.java
@@ -0,0 +1,499 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.decode;
+
+import org.apache.hbase.Cell;
+import org.apache.hbase.cell.CellComparator;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.decode.column.ColumnReader;
+import org.apache.hbase.codec.prefixtree.decode.row.RowNodeReader;
+import org.apache.hbase.codec.prefixtree.decode.timestamp.MvccVersionDecoder;
+import org.apache.hbase.codec.prefixtree.decode.timestamp.TimestampDecoder;
+import org.apache.hbase.codec.prefixtree.scanner.CellScanner;
+
+/**
+ * Extends PtCell and manipulates its protected fields.  Could alternatively contain a PtCell and
+ * call get/set methods.
+ *
+ * This is an "Array" scanner to distinguish from a future "ByteBuffer" scanner.  This
+ * implementation requires that the bytes be in a normal java byte[] for performance.  The
+ * alternative ByteBuffer implementation would allow for accessing data in an off-heap ByteBuffer
+ * without copying the whole buffer on-heap.
+ */
+public class PrefixTreeArrayScanner extends PrefixTreeCell implements CellScanner {
+
+  /***************** fields ********************************/
+
+  protected PrefixTreeBlockMeta blockMeta;
+
+  protected boolean beforeFirst;
+  protected boolean afterLast;
+
+  protected RowNodeReader[] rowNodes;
+  protected int rowNodeStackIndex;
+
+  protected RowNodeReader currentRowNode;
+  protected ColumnReader familyReader;
+  protected ColumnReader qualifierReader;
+  protected TimestampDecoder timestampDecoder;
+  protected MvccVersionDecoder mvccVersionDecoder;
+
+  protected boolean nubCellsRemain;
+  protected int currentCellIndex;
+
+
+  /*********************** construct ******************************/
+
+  // pass in blockMeta so we can initialize buffers big enough for all cells in the block
+  public PrefixTreeArrayScanner(PrefixTreeBlockMeta blockMeta, int rowTreeDepth, int rowBufferLength,
+      int qualifierBufferLength) {
+    this.rowNodes = new RowNodeReader[rowTreeDepth];
+    for (int i = 0; i < rowNodes.length; ++i) {
+      rowNodes[i] = new RowNodeReader();
+    }
+    this.rowBuffer = new byte[rowBufferLength];
+    this.familyBuffer = new byte[PrefixTreeBlockMeta.MAX_FAMILY_LENGTH];
+    this.familyReader = new ColumnReader(familyBuffer, true);
+    this.qualifierBuffer = new byte[qualifierBufferLength];
+    this.qualifierReader = new ColumnReader(qualifierBuffer, false);
+    this.timestampDecoder = new TimestampDecoder();
+    this.mvccVersionDecoder = new MvccVersionDecoder();
+  }
+
+
+  /**************** init helpers ***************************************/
+
+  // call when first accessing a block. create entirely new scanner if false
+  public boolean areBuffersBigEnough() {
+    if (rowNodes.length < blockMeta.getRowTreeDepth()) {
+      return false;
+    }
+    if (rowBuffer.length < blockMeta.getMaxRowLength()) {
+      return false;
+    }
+    if (qualifierBuffer.length < blockMeta.getMaxQualifierLength()) {
+      return false;
+    }
+    return true;
+  }
+
+  public void initOnBlock(PrefixTreeBlockMeta blockMeta, byte[] block, boolean includeMemstoreTS) {
+    this.block = block;
+    this.blockMeta = blockMeta;
+    this.familyOffset = familyBuffer.length;
+    this.familyReader.initOnBlock(blockMeta, block);
+    this.qualifierOffset = qualifierBuffer.length;
+    this.qualifierReader.initOnBlock(blockMeta, block);
+    this.timestampDecoder.initOnBlock(blockMeta, block);
+    this.mvccVersionDecoder.initOnBlock(blockMeta, block);
+    this.includeMemstoreTS = includeMemstoreTS;
+    resetToBeforeFirstEntry();
+  }
+
+  @Override
+  public void resetToBeforeFirstEntry() {
+    beforeFirst = true;
+    afterLast = false;
+    rowNodeStackIndex = -1;
+    currentRowNode = null;
+    rowLength = 0;
+    familyOffset = familyBuffer.length;
+    familyLength = 0;
+    qualifierOffset = blockMeta.getMaxQualifierLength();
+    qualifierLength = 0;
+    nubCellsRemain = false;
+    currentCellIndex = -1;
+    timestamp = -1L;
+    type = DEFAULT_TYPE;
+    absoluteValueOffset = 0;//use 0 vs -1 so the cell is valid when value hasn't been initialized
+    valueLength = 0;// had it at -1, but that causes null Cell to add up to the wrong length
+  }
+
+  /**
+   * Call this before putting the scanner back into a pool so it doesn't hold the last used block
+   * in memory.
+   */
+  public void releaseBlockReference(){
+    block = null;
+  }
+
+
+  /********************** CellScanner **********************/
+
+  @Override
+  public PrefixTreeCell getCurrent() {
+    if(isOutOfBounds()){
+      return null;
+    }
+    return this;
+  }
+  
+  
+  /******************* Object methods ************************/
+  
+  /**
+   * Override PrefixTreeCell.toString() with a check to see if the current cell is valid.
+   */
+  @Override
+  public String toString() {
+    PrefixTreeCell currentCell = getCurrent();
+    if(currentCell==null){
+      return "null";
+    }
+    return currentCell.getKeyValueString();
+  }
+
+
+  /******************* advance ***************************/
+  
+  public boolean positionAtFirstCell() {
+    reInitFirstNode();
+    return next();
+  }
+
+  @Override
+  public boolean next() {
+    if (afterLast) {
+      return false;
+    }
+    if (!hasOccurrences()) {
+      resetToBeforeFirstEntry();
+    }
+    if (beforeFirst || isLastCellInRow()) {
+      nextRow();
+      if (afterLast) {
+        return false;
+      }
+    } else {
+      ++currentCellIndex;
+    }
+
+    populateNonRowFields(currentCellIndex);
+    return true;
+  }
+
+
+  public boolean nextRow() {
+    nextRowInternal();
+    if (afterLast) {
+      return false;
+    }
+    populateNonRowFields(currentCellIndex);
+    return true;
+  }
+
+
+  /**
+   * This method is safe to call when the scanner is not on a fully valid row node, as in the case
+   * of a row token miss in the Searcher
+   * @return
+   */
+  protected boolean nextRowInternal() {
+    if (afterLast) {
+      return false;
+    }
+    if (beforeFirst) {
+      initFirstNode();
+      if (currentRowNode.hasOccurrences()) {
+        if (currentRowNode.isNub()) {
+          nubCellsRemain = true;
+        }
+        currentCellIndex = 0;
+        return true;
+      }
+    }
+    if (currentRowNode.isLeaf()) {
+      discardCurrentRowNode(true);
+    }
+    while (!afterLast) {
+      if (nubCellsRemain) {
+        nubCellsRemain = false;
+      }
+      if (currentRowNode.hasMoreFanNodes()) {
+        followNextFan();
+        if (currentRowNode.hasOccurrences()) {
+          currentCellIndex = 0;
+          return true;
+        }// found some values
+      } else {
+        discardCurrentRowNode(true);
+      }
+    }
+    return false;// went past the end
+  }
+
+
+  /**************** secondary traversal methods ******************************/
+
+  protected void reInitFirstNode() {
+    resetToBeforeFirstEntry();
+    initFirstNode();
+  }
+
+  protected void initFirstNode() {
+    int offsetIntoUnderlyingStructure = blockMeta.getAbsoluteRowOffset();
+    rowNodeStackIndex = 0;
+    currentRowNode = rowNodes[0];
+    currentRowNode.initOnBlock(blockMeta, block, offsetIntoUnderlyingStructure);
+    appendToRowBuffer(currentRowNode.getToken());
+    beforeFirst = false;
+  }
+
+  protected void followFirstFan() {
+    followFan(0);
+  }
+
+  protected void followPreviousFan() {
+    int nextFanPosition = currentRowNode.getFanIndex() - 1;
+    followFan(nextFanPosition);
+  }
+
+  protected void followCurrentFan() {
+    int currentFanPosition = currentRowNode.getFanIndex();
+    followFan(currentFanPosition);
+  }
+
+  protected void followNextFan() {
+    int nextFanPosition = currentRowNode.getFanIndex() + 1;
+    followFan(nextFanPosition);
+  }
+
+  protected void followLastFan() {
+    followFan(currentRowNode.getLastFanIndex());
+  }
+
+  protected void followFan(int fanIndex) {
+    currentRowNode.setFanIndex(fanIndex);
+    appendToRowBuffer(currentRowNode.getFanByte(fanIndex));
+
+    int nextOffsetIntoUnderlyingStructure = currentRowNode.getOffset()
+        + currentRowNode.getNextNodeOffset(fanIndex, blockMeta);
+    ++rowNodeStackIndex;
+
+    currentRowNode = rowNodes[rowNodeStackIndex];
+    currentRowNode.initOnBlock(blockMeta, block, nextOffsetIntoUnderlyingStructure);
+
+    //TODO getToken is spewing garbage
+    appendToRowBuffer(currentRowNode.getToken());
+    if (currentRowNode.isNub()) {
+      nubCellsRemain = true;
+    }
+    currentCellIndex = 0;
+  }
+
+  /**
+   * @param forwards: which marker to set if we overflow
+   */
+  protected void discardCurrentRowNode(boolean forwards) {
+    RowNodeReader rowNodeBeingPopped = currentRowNode;
+    --rowNodeStackIndex;// pop it off the stack
+    if (rowNodeStackIndex < 0) {
+      currentRowNode = null;
+      if (forwards) {
+        markAfterLast();
+      } else {
+        markBeforeFirst();
+      }
+      return;
+    }
+    popFromRowBuffer(rowNodeBeingPopped);
+    currentRowNode = rowNodes[rowNodeStackIndex];
+  }
+
+  protected void markBeforeFirst() {
+    beforeFirst = true;
+    afterLast = false;
+    currentRowNode = null;
+  }
+
+  protected void markAfterLast() {
+    beforeFirst = false;
+    afterLast = true;
+    currentRowNode = null;
+  }
+
+
+  /***************** helper methods **************************/
+
+  protected void appendToRowBuffer(byte[] bytes) {
+    System.arraycopy(bytes, 0, rowBuffer, rowLength, bytes.length);
+    rowLength += bytes.length;
+  }
+
+  protected void appendToRowBuffer(byte b) {
+    rowBuffer[rowLength] = b;
+    ++rowLength;
+  }
+
+  protected void popFromRowBuffer(RowNodeReader rowNodeBeingPopped) {
+    rowLength -= rowNodeBeingPopped.getTokenLength();
+    --rowLength; // pop the parent's fan byte
+  }
+
+  protected boolean hasOccurrences() {
+    return currentRowNode != null && currentRowNode.hasOccurrences();
+  }
+  
+  protected boolean isBranch() {
+    return currentRowNode != null && !currentRowNode.hasOccurrences()
+        && currentRowNode.hasChildren();
+  }
+  
+  protected boolean isNub() {
+    return currentRowNode != null && currentRowNode.hasOccurrences()
+        && currentRowNode.hasChildren();
+  }
+  
+  protected boolean isLeaf() {
+    return currentRowNode != null && currentRowNode.hasOccurrences()
+        && !currentRowNode.hasChildren();
+  }
+  
+  //TODO expose this in a PrefixTreeScanner interface
+  public boolean isBeforeFirst(){
+    return beforeFirst;
+  }
+  
+  public boolean isAfterLast(){
+    return afterLast;
+  }
+  
+  protected boolean isOutOfBounds(){
+    return beforeFirst || afterLast;
+  }
+
+  protected boolean isFirstCellInRow() {
+    return currentCellIndex == 0;
+  }
+
+  protected boolean isLastCellInRow() {
+    return currentCellIndex == currentRowNode.getLastCellIndex();
+  }
+
+  protected boolean isOnLastFanOfEveryPreviousRowNode() {
+    // rowNodeStackIndex should skip the top stack element
+    for (int i = 0; i < rowNodeStackIndex; ++i) {
+      if (!rowNodes[i].isOnLastFanNode()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+
+  /********************* fill in family/qualifier/ts/type/value ************/
+
+  protected int populateNonRowFieldsAndCompareTo(int cellNum, Cell key) {
+    populateNonRowFields(cellNum);
+    return CellComparator.compareStatic(this, key);
+  }
+
+  protected void populateFirstNonRowFields() {
+    populateNonRowFields(0);
+  }
+
+  protected void populatePreviousNonRowFields() {
+    populateNonRowFields(currentCellIndex - 1);
+  }
+
+  protected void populateLastNonRowFields() {
+    populateNonRowFields(currentRowNode.getLastCellIndex());
+  }
+
+  protected void populateNonRowFields(int cellIndex) {
+    currentCellIndex = cellIndex;
+    populateFamily();
+    populateQualifier();
+    populateTimestamp();
+    populateMvccVersion();
+    populateType();
+    populateValueOffsets();
+  }
+
+  protected void populateFamily() {
+    int familyTreeIndex = currentRowNode.getFamilyOffset(currentCellIndex, blockMeta);
+    familyOffset = familyReader.populateBuffer(familyTreeIndex).getColumnOffset();
+    familyLength = familyReader.getColumnLength();
+  }
+
+  protected void populateQualifier() {
+    int qualifierTreeIndex = currentRowNode.getColumnOffset(currentCellIndex, blockMeta);
+    qualifierOffset = qualifierReader.populateBuffer(qualifierTreeIndex).getColumnOffset();
+    qualifierLength = qualifierReader.getColumnLength();
+  }
+
+  protected void populateTimestamp() {
+    if (blockMeta.isAllSameTimestamp()) {
+      timestamp = blockMeta.getMinTimestamp();
+    } else {
+      int timestampIndex = currentRowNode.getTimestampIndex(currentCellIndex, blockMeta);
+      timestamp = timestampDecoder.getLong(timestampIndex);
+    }
+  }
+
+  protected void populateMvccVersion() {
+    if (blockMeta.isAllSameMvccVersion()) {
+      mvccVersion = blockMeta.getMinMvccVersion();
+    } else {
+      int mvccVersionIndex = currentRowNode.getMvccVersionIndex(currentCellIndex,
+        blockMeta);
+      mvccVersion = mvccVersionDecoder.getMvccVersion(mvccVersionIndex);
+    }
+  }
+
+  protected void populateType() {
+    int typeInt;
+    if (blockMeta.isAllSameType()) {
+      typeInt = blockMeta.getAllTypes();
+    } else {
+      typeInt = currentRowNode.getType(currentCellIndex, blockMeta);
+    }
+    type = PrefixTreeCell.TYPES[typeInt];
+  }
+
+  protected void populateValueOffsets() {
+    int offsetIntoValueSection = currentRowNode.getValueOffset(currentCellIndex, blockMeta);
+    absoluteValueOffset = blockMeta.getAbsoluteValueOffset() + offsetIntoValueSection;
+    valueLength = currentRowNode.getValueLength(currentCellIndex, blockMeta);
+  }
+
+
+  /**************** get/set ***************************/
+
+  public byte[] getTreeBytes() {
+    return block;
+  }
+
+  public PrefixTreeBlockMeta getBlockMeta() {
+    return blockMeta;
+  }
+
+  public int getMaxRowTreeStackNodes() {
+    return rowNodes.length;
+  }
+
+  public int getRowBufferLength() {
+    return rowBuffer.length;
+  }
+
+  public int getQualifierBufferLength() {
+    return qualifierBuffer.length;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeArraySearcher.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeArraySearcher.java
new file mode 100644
index 0000000..5482aa3
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeArraySearcher.java
@@ -0,0 +1,383 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.decode;
+
+import org.apache.hbase.Cell;
+import org.apache.hbase.cell.CellScannerPosition;
+import org.apache.hbase.cell.CellTool;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.scanner.CellSearcher;
+
+import com.google.common.primitives.UnsignedBytes;
+
+public class PrefixTreeArraySearcher extends PrefixTreeArrayReversibleScanner implements
+    CellSearcher {
+
+  /*************** construct ******************************/
+
+  public PrefixTreeArraySearcher(PrefixTreeBlockMeta blockMeta, int rowTreeDepth,
+      int rowBufferLength, int qualifierBufferLength) {
+    super(blockMeta, rowTreeDepth, rowBufferLength, qualifierBufferLength);
+  }
+
+
+  /********************* CellSearcher methods *******************/
+
+  @Override
+  public boolean positionAt(Cell key) {
+    return CellScannerPosition.AT == positionAtOrAfter(key);
+  }
+
+  @Override
+  public CellScannerPosition positionAtOrBefore(Cell key) {
+    reInitFirstNode();
+    int fanIndex = -1;
+
+    while(true){
+      //detect row mismatch.  break loop if mismatch
+      int currentNodeDepth = rowLength;
+      int rowTokenComparison = compareToCurrentToken(key);
+      if(rowTokenComparison != 0){
+        return fixRowTokenMissReverse(rowTokenComparison);
+      }
+
+      //exact row found, move on to qualifier & ts
+      if(matchesEndOfRow(key)){
+        return positionAtQualifierTimestamp(key, true);
+      }
+
+      //detect dead end (no fan to descend into)
+      if(!currentRowNode.hasFan()){
+        if(hasOccurrences()){//must be leaf or nub
+          populateLastNonRowFields();
+          return CellScannerPosition.BEFORE;
+        }else{
+          //TODO i don't think this case is exercised by any tests
+          return fixRowFanMissReverse(0);
+        }
+      }
+
+      //keep hunting for the rest of the row
+      byte searchForByte = CellTool.getRowByte(key, currentNodeDepth);
+      fanIndex = currentRowNode.whichFanNode(searchForByte);
+      if(fanIndex < 0){//no matching row.  return early
+        int insertionPoint = -fanIndex;
+        return fixRowFanMissReverse(insertionPoint);
+      }
+      //found a match, so dig deeper into the tree
+      followFan(fanIndex);
+    }
+  }
+
+  /**
+   * Identical workflow as positionAtOrBefore, but split them to avoid having ~10 extra
+   * if-statements. Priority on readability and debugability.
+   */
+  @Override
+  public CellScannerPosition positionAtOrAfter(Cell key) {
+    reInitFirstNode();
+    int fanIndex = -1;
+
+    while(true){
+      //detect row mismatch.  break loop if mismatch
+      int currentNodeDepth = rowLength;
+      int rowTokenComparison = compareToCurrentToken(key);
+      if(rowTokenComparison != 0){
+        return fixRowTokenMissForward(rowTokenComparison);
+      }
+
+      //exact row found, move on to qualifier & ts
+      if(matchesEndOfRow(key)){
+        return positionAtQualifierTimestamp(key, false);
+      }
+
+      //detect dead end (no fan to descend into)
+      if(!currentRowNode.hasFan()){
+        if(hasOccurrences()){
+          populateFirstNonRowFields();
+          return CellScannerPosition.AFTER;
+        }else{
+          //TODO i don't think this case is exercised by any tests
+          return fixRowFanMissForward(0);
+        }
+      }
+
+      //keep hunting for the rest of the row
+      byte searchForByte = CellTool.getRowByte(key, currentNodeDepth);
+      fanIndex = currentRowNode.whichFanNode(searchForByte);
+      if(fanIndex < 0){//no matching row.  return early
+        int insertionPoint = -fanIndex;
+        return fixRowFanMissForward(insertionPoint);
+      }
+      //found a match, so dig deeper into the tree
+      followFan(fanIndex);
+    }
+  }
+
+  @Override
+  public boolean seekForwardTo(Cell key) {
+    if(currentPositionIsAfter(key)){
+      //our position is after the requested key, so can't do anything
+      return false;
+    }
+    return positionAt(key);
+  }
+
+  @Override
+  public CellScannerPosition seekForwardToOrBefore(Cell key) {
+    //Do we even need this check or should upper layers avoid this situation.  It's relatively
+    //expensive compared to the rest of the seek operation.
+    if(currentPositionIsAfter(key)){
+      //our position is after the requested key, so can't do anything
+      return CellScannerPosition.AFTER;
+    }
+
+    return positionAtOrBefore(key);
+  }
+
+  @Override
+  public CellScannerPosition seekForwardToOrAfter(Cell key) {
+    //Do we even need this check or should upper layers avoid this situation.  It's relatively
+    //expensive compared to the rest of the seek operation.
+    if(currentPositionIsAfter(key)){
+      //our position is after the requested key, so can't do anything
+      return CellScannerPosition.AFTER;
+    }
+
+    return positionAtOrAfter(key);
+  }
+
+  /**
+   * The content of the buffers doesn't matter here, only that afterLast=true and beforeFirst=false
+   */
+  @Override
+  public void positionAfterLastCell() {
+    resetToBeforeFirstEntry();
+    beforeFirst = false;
+    afterLast = true;
+  }
+
+
+  /****************** internal methods ************************/
+
+  protected boolean currentPositionIsAfter(Cell cell){
+    return compareTo(cell) > 0;
+  }
+
+  protected CellScannerPosition positionAtQualifierTimestamp(Cell key, boolean beforeOnMiss) {
+    int minIndex = 0;
+    int maxIndex = currentRowNode.getLastCellIndex();
+    int diff;
+    while (true) {
+      int midIndex = (maxIndex + minIndex) / 2;//don't worry about overflow
+      diff = populateNonRowFieldsAndCompareTo(midIndex, key);
+
+      if (diff == 0) {// found exact match
+        return CellScannerPosition.AT;
+      } else if (minIndex == maxIndex) {// even termination case
+        break;
+      } else if ((minIndex + 1) == maxIndex) {// odd termination case
+        diff = populateNonRowFieldsAndCompareTo(maxIndex, key);
+        if(diff > 0){
+          diff = populateNonRowFieldsAndCompareTo(minIndex, key);
+        }
+        break;
+      } else if (diff < 0) {// keep going forward
+        minIndex = currentCellIndex;
+      } else {// went past it, back up
+        maxIndex = currentCellIndex;
+      }
+    }
+
+    if (diff == 0) {
+      return CellScannerPosition.AT;
+
+    } else if (diff < 0) {// we are before key
+      if (beforeOnMiss) {
+        return CellScannerPosition.BEFORE;
+      }
+      if (next()) {
+        return CellScannerPosition.AFTER;
+      }
+      return CellScannerPosition.AFTER_LAST;
+
+    } else {// we are after key
+      if (!beforeOnMiss) {
+        return CellScannerPosition.AFTER;
+      }
+      if (previous()) {
+        return CellScannerPosition.BEFORE;
+      }
+      return CellScannerPosition.BEFORE_FIRST;
+    }
+  }
+
+  /**
+   * compare this.row to key.row but starting at the current rowLength
+   * @param key Cell being searched for
+   * @return true if row buffer contents match key.row
+   */
+  protected boolean matchesEndOfRow(Cell key) {
+    if (!currentRowNode.hasOccurrences()) {
+      return false;
+    }
+    int thisRowLength = rowLength;
+    int thatRowLength = key.getRowLength();
+    if (thisRowLength != thatRowLength) {
+      return false;
+    }
+    // TODO oops - is this missing the comparison of tail bytes?
+    return true;
+  }
+
+	//TODO move part of this to Cell comparator?
+	/**
+	 * compare only the bytes within the window of the current token
+	 *
+	 * @param key
+	 * @return return -1 if key is lessThan (before) this, 0 if equal, and 1 if key is after
+	 */
+  protected int compareToCurrentToken(Cell key) {
+    int startIndex = rowLength - currentRowNode.getTokenLength();
+    int endIndexExclusive = startIndex + currentRowNode.getTokenLength();
+    for (int i = startIndex; i < endIndexExclusive; ++i) {
+      if (i >= key.getRowLength()) {// key was shorter, so it's first
+        return -1;
+      }
+      byte keyByte = CellTool.getRowByte(key, i);
+      byte thisByte = rowBuffer[i];
+      if (keyByte == thisByte) {
+        continue;
+      }
+      return UnsignedBytes.compare(keyByte, thisByte);
+    }
+    return 0;
+  }
+
+  protected void followLastFansUntilExhausted(){
+    while(currentRowNode.hasFan()){
+      followLastFan();
+    }
+  }
+
+
+	/****************** complete seek when token mismatch ******************/
+
+  /**
+   * @param comparison <0: input key is before the searcher's position<br/>
+   *                   >0: input key is after the searcher's position
+   */
+  protected CellScannerPosition fixRowTokenMissReverse(int comparison) {
+    if (comparison < 0) {//searcher position is after the input key, so back up
+      boolean foundPreviousRow = previousRow(true);
+      if(foundPreviousRow){
+        populateLastNonRowFields();
+        return CellScannerPosition.BEFORE;
+      }else{
+        return CellScannerPosition.BEFORE_FIRST;
+      }
+
+    }else{//searcher position is before the input key
+      if(currentRowNode.hasOccurrences()){
+        populateFirstNonRowFields();
+        return CellScannerPosition.BEFORE;
+      }
+      boolean foundNextRow = nextRow();
+      if(foundNextRow){
+        return CellScannerPosition.AFTER;
+      }else{
+        return CellScannerPosition.AFTER_LAST;
+      }
+    }
+  }
+
+  /**
+   * @param comparison <0: input key is before the searcher's position<br/>
+   *                   >0: input key is after the searcher's position
+   */
+  protected CellScannerPosition fixRowTokenMissForward(int comparison) {
+    if (comparison < 0) {//searcher position is after the input key
+      if(currentRowNode.hasOccurrences()){
+        populateFirstNonRowFields();
+        return CellScannerPosition.AFTER;
+      }
+      boolean foundNextRow = nextRow();
+      if(foundNextRow){
+        return CellScannerPosition.AFTER;
+      }else{
+        return CellScannerPosition.AFTER_LAST;
+      }
+
+    }else{//searcher position is before the input key, so go forward
+      discardCurrentRowNode(true);
+      boolean foundNextRow = nextRow();
+      if(foundNextRow){
+        return CellScannerPosition.AFTER;
+      }else{
+        return CellScannerPosition.AFTER_LAST;
+      }
+    }
+  }
+
+
+  /****************** complete seek when fan mismatch ******************/
+
+  protected CellScannerPosition fixRowFanMissReverse(int fanInsertionPoint){
+    if(fanInsertionPoint == 0){//we need to back up a row
+      boolean foundPreviousRow = previousRow(true);//true -> position on last cell in row
+      if(foundPreviousRow){
+        populateLastNonRowFields();
+        return CellScannerPosition.BEFORE;
+      }
+      return CellScannerPosition.BEFORE_FIRST;
+    }
+
+    //follow the previous fan, but then descend recursively forward
+    followFan(fanInsertionPoint - 1);
+    followLastFansUntilExhausted();
+    populateLastNonRowFields();
+    return CellScannerPosition.BEFORE;
+  }
+
+  protected CellScannerPosition fixRowFanMissForward(int fanInsertionPoint){
+    if(fanInsertionPoint >= currentRowNode.getFanOut()){
+      discardCurrentRowNode(true);
+      if (!nextRow()) {
+        return CellScannerPosition.AFTER_LAST;
+      } else {
+        return CellScannerPosition.AFTER;
+      }
+    }
+
+    followFan(fanInsertionPoint);
+    if(hasOccurrences()){
+      populateFirstNonRowFields();
+      return CellScannerPosition.AFTER;
+    }
+
+    if(nextRowInternal()){
+      populateFirstNonRowFields();
+      return CellScannerPosition.AFTER;
+
+    }else{
+      return CellScannerPosition.AFTER_LAST;
+    }
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeCell.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeCell.java
new file mode 100644
index 0000000..17f5a03
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/PrefixTreeCell.java
@@ -0,0 +1,197 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.decode;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValueTool;
+import org.apache.hbase.Cell;
+import org.apache.hbase.cell.CellComparator;
+
+/**
+ * As the PrefixTreeArrayScanner moves through the tree bytes, it changes the values in the fields
+ * of this class so that Cell logic can be applied, but without allocating new memory for every Cell
+ * iterated through.
+ */
+public class PrefixTreeCell implements Cell, Comparable<Cell> {
+
+  /********************** static **********************/
+
+  public static final KeyValue.Type[] TYPES = new KeyValue.Type[256];
+  static {
+    for (KeyValue.Type type : KeyValue.Type.values()) {
+      TYPES[type.getCode() & 0xff] = type;
+    }
+  }
+
+  //Same as KeyValue constructor.  Only used to avoid NPE's when full cell hasn't been initialized.
+  public static final KeyValue.Type DEFAULT_TYPE = KeyValue.Type.Put;
+
+  /******************** fields ************************/
+
+  protected byte[] block;
+  //we could also avoid setting the memstoreTS in the scanner/searcher, but this is simpler
+  protected boolean includeMemstoreTS;
+
+  protected byte[] rowBuffer;
+  protected int rowLength;
+
+  protected byte[] familyBuffer;
+  protected int familyOffset;
+  protected int familyLength;
+
+  protected byte[] qualifierBuffer;// aligned to the end of the array
+  protected int qualifierOffset;
+  protected int qualifierLength;
+
+  protected Long timestamp;
+  protected Long mvccVersion;
+
+  protected KeyValue.Type type;
+
+  protected int absoluteValueOffset;
+  protected int valueLength;
+
+
+  /********************** Cell methods ******************/
+
+  /**
+   * For debugging.  Currently creates new KeyValue to utilize its toString() method.
+   */
+  @Override
+  public String toString() {
+    return getKeyValueString();
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (!(obj instanceof Cell)) {
+      return false;
+    }
+    //Temporary hack to maintain backwards compatibility with KeyValue.equals
+    return CellComparator.equalsIgnoreMvccVersion(this, (Cell)obj);
+
+    //TODO return CellComparator.equals(this, (Cell)obj);
+  }
+
+  @Override
+  public int hashCode(){
+    //Temporary hack to maintain backwards compatibility with KeyValue.hashCode
+    return KeyValueTool.copyToNewKeyValue(this).hashCode();
+
+    //TODO return CellComparator.hashCode(this);
+  }
+
+  @Override
+  public int compareTo(Cell other) {
+    return CellComparator.compareStatic(this, other);
+  }
+
+  @Override
+  public long getTimestamp() {
+    return timestamp;
+  }
+
+  @Override
+  public long getMvccVersion() {
+    if (!includeMemstoreTS) {
+      return 0L;
+    }
+    return mvccVersion;
+  }
+
+  @Override
+  public int getValueLength() {
+    return valueLength;
+  }
+
+  @Override
+  public byte[] getRowArray() {
+    return rowBuffer;
+  }
+
+  @Override
+  public int getRowOffset() {
+    return 0;
+  }
+
+  @Override
+  public short getRowLength() {
+    return (short) rowLength;
+  }
+
+  @Override
+  public byte[] getFamilyArray() {
+    return familyBuffer;
+  }
+
+  @Override
+  public int getFamilyOffset() {
+    return familyOffset;
+  }
+
+  @Override
+  public byte getFamilyLength() {
+    return (byte) familyLength;
+  }
+
+  @Override
+  public byte[] getQualifierArray() {
+    return qualifierBuffer;
+  }
+
+  @Override
+  public int getQualifierOffset() {
+    return qualifierOffset;
+  }
+
+  @Override
+  public int getQualifierLength() {
+    return qualifierLength;
+  }
+
+  @Override
+  public byte[] getValueArray() {
+    return block;
+  }
+
+  @Override
+  public int getValueOffset() {
+    return absoluteValueOffset;
+  }
+
+  @Override
+  public byte getTypeByte() {
+    return type.getCode();
+  }
+
+
+  /************************* helper methods *************************/
+
+  /**
+   * Need this separate method so we can call it from subclasses' toString() methods
+   */
+  protected String getKeyValueString(){
+    KeyValue kv = KeyValueTool.copyToNewKeyValue(this);
+    if (kv == null) {
+      return "null";
+    }
+    return kv.toString();
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/column/ColumnNodeReader.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/column/ColumnNodeReader.java
new file mode 100644
index 0000000..a758354
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/column/ColumnNodeReader.java
@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.decode.column;
+
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.util.vint.UFIntTool;
+import org.apache.hbase.util.vint.UVIntTool;
+
+public class ColumnNodeReader {
+
+  /**************** fields ************************/
+
+  protected PrefixTreeBlockMeta blockMeta;
+  protected byte[] block;
+
+  protected byte[] columnBuffer;
+  protected boolean familyVsQualifier;
+
+  protected int offsetIntoBlock;
+
+  protected int tokenOffsetIntoBlock;
+  protected int tokenLength;
+  protected int parentStartPosition;
+
+
+  /************** construct *************************/
+
+  public ColumnNodeReader(byte[] columnBuffer, boolean familyVsQualifier) {
+    this.columnBuffer = columnBuffer;
+    this.familyVsQualifier = familyVsQualifier;
+  }
+
+  public void initOnBlock(PrefixTreeBlockMeta blockMeta, byte[] block) {
+    this.blockMeta = blockMeta;
+    this.block = block;
+  }
+
+
+  /************* methods *****************************/
+
+  public void positionAt(int offsetIntoBlock) {
+    this.offsetIntoBlock = offsetIntoBlock;
+    tokenLength = UVIntTool.getInt(block, offsetIntoBlock);
+    tokenOffsetIntoBlock = offsetIntoBlock + UVIntTool.numBytes(tokenLength);
+    int parentStartPositionIndex = tokenOffsetIntoBlock + tokenLength;
+    int offsetWidth;
+    if (familyVsQualifier) {
+      offsetWidth = blockMeta.getFamilyOffsetWidth();
+    } else {
+      offsetWidth = blockMeta.getQualifierOffsetWidth();
+    }
+    parentStartPosition = (int) UFIntTool.fromBytes(block, parentStartPositionIndex, offsetWidth);
+  }
+
+  public void prependTokenToBuffer(int bufferStartIndex) {
+    System.arraycopy(block, tokenOffsetIntoBlock, columnBuffer, bufferStartIndex, tokenLength);
+  }
+
+  public boolean isRoot() {
+    if (familyVsQualifier) {
+      return offsetIntoBlock == blockMeta.getAbsoluteFamilyOffset();
+    } else {
+      return offsetIntoBlock == blockMeta.getAbsoluteQualifierOffset();
+    }
+  }
+
+
+  /************** standard methods *********************/
+
+  @Override
+  public String toString() {
+    return super.toString() + "[" + offsetIntoBlock + "]";
+  }
+
+
+  /****************** get/set ****************************/
+
+  public int getTokenLength() {
+    return tokenLength;
+  }
+
+  public int getParentStartPosition() {
+    return parentStartPosition;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/column/ColumnReader.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/column/ColumnReader.java
new file mode 100644
index 0000000..aa19f7f
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/column/ColumnReader.java
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.decode.column;
+
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+
+public class ColumnReader {
+
+  /****************** fields *************************/
+
+  protected PrefixTreeBlockMeta blockMeta;
+  protected byte[] block;
+
+  protected byte[] columnBuffer;
+  protected int columnOffset;
+  protected int columnLength;
+  protected boolean familyVsQualifier;
+
+  protected ColumnNodeReader columnNodeReader;
+
+
+  /******************** construct *******************/
+
+  public ColumnReader(byte[] columnBuffer, boolean familyVsQualifier) {
+    this.columnBuffer = columnBuffer;
+    this.familyVsQualifier = familyVsQualifier;
+    this.columnNodeReader = new ColumnNodeReader(columnBuffer, familyVsQualifier);
+  }
+
+  public void initOnBlock(PrefixTreeBlockMeta blockMeta, byte[] block) {
+    this.blockMeta = blockMeta;
+    this.block = block;
+    clearColumnBuffer();
+    columnNodeReader.initOnBlock(blockMeta, block);
+  }
+
+
+  /********************* methods *******************/
+
+  public ColumnReader populateBuffer(int offsetIntoColumnData) {
+    clearColumnBuffer();
+    int nextRelativeOffset = offsetIntoColumnData;
+    while (true) {
+      int absoluteOffset;
+      if (familyVsQualifier) {
+        absoluteOffset = blockMeta.getAbsoluteFamilyOffset() + nextRelativeOffset;
+      } else {
+        absoluteOffset = blockMeta.getAbsoluteQualifierOffset() + nextRelativeOffset;
+      }
+      columnNodeReader.positionAt(absoluteOffset);
+      columnOffset -= columnNodeReader.getTokenLength();
+      columnLength += columnNodeReader.getTokenLength();
+      columnNodeReader.prependTokenToBuffer(columnOffset);
+      if (columnNodeReader.isRoot()) {
+        return this;
+      }
+      nextRelativeOffset = columnNodeReader.getParentStartPosition();
+    }
+  }
+
+  public byte[] copyBufferToNewArray() {// for testing
+    byte[] out = new byte[columnLength];
+    System.arraycopy(columnBuffer, columnOffset, out, 0, out.length);
+    return out;
+  }
+
+  public int getColumnLength() {
+    return columnLength;
+  }
+
+  public void clearColumnBuffer() {
+    columnOffset = columnBuffer.length;
+    columnLength = 0;
+  }
+
+
+  /****************************** get/set *************************************/
+
+  public int getColumnOffset() {
+    return columnOffset;
+  }
+
+}
+
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/row/RowNodeReader.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/row/RowNodeReader.java
new file mode 100644
index 0000000..03dfcd5
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/row/RowNodeReader.java
@@ -0,0 +1,259 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.decode.row;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.util.vint.UFIntTool;
+import org.apache.hbase.util.vint.UVIntTool;
+
+public class RowNodeReader {
+
+  /************* fields ***********************************/
+
+  protected PrefixTreeBlockMeta blockMeta;
+  protected byte[] block;
+  protected int offset;
+  protected int fanIndex;
+
+  protected int numCells;
+
+  protected int tokenOffset;
+  protected int tokenWidth;
+  protected int fanOffset;
+  protected int fanOut;
+
+  protected int familyOffsetsOffset;
+  protected int qualifierOffsetsOffset;
+  protected int timestampIndexesOffset;
+  protected int mvccVersionIndexesOffset;
+  protected int operationTypesOffset;
+  protected int valueOffsetsOffset;
+  protected int valueLengthsOffset;
+  protected int nextNodeOffsetsOffset;
+
+
+  /******************* construct **************************/
+
+  public void initOnBlock(PrefixTreeBlockMeta blockMeta, byte[] block, int offset) {
+    this.blockMeta = blockMeta;
+    this.block = block;
+
+    this.offset = offset;
+    resetFanIndex();
+
+    this.tokenWidth = UVIntTool.getInt(block, offset);
+    this.tokenOffset = offset + UVIntTool.numBytes(tokenWidth);
+
+    this.fanOut = UVIntTool.getInt(block, tokenOffset + tokenWidth);
+    this.fanOffset = tokenOffset + tokenWidth + UVIntTool.numBytes(fanOut);
+
+    this.numCells = UVIntTool.getInt(block, fanOffset + fanOut);
+
+    this.familyOffsetsOffset = fanOffset + fanOut + UVIntTool.numBytes(numCells);
+    this.qualifierOffsetsOffset = familyOffsetsOffset + numCells * blockMeta.getFamilyOffsetWidth();
+    this.timestampIndexesOffset = qualifierOffsetsOffset + numCells
+        * blockMeta.getQualifierOffsetWidth();
+    this.mvccVersionIndexesOffset = timestampIndexesOffset + numCells
+        * blockMeta.getTimestampIndexWidth();
+    this.operationTypesOffset = mvccVersionIndexesOffset + numCells
+        * blockMeta.getMvccVersionIndexWidth();
+    this.valueOffsetsOffset = operationTypesOffset + numCells * blockMeta.getKeyValueTypeWidth();
+    this.valueLengthsOffset = valueOffsetsOffset + numCells * blockMeta.getValueOffsetWidth();
+    this.nextNodeOffsetsOffset = valueLengthsOffset + numCells * blockMeta.getValueLengthWidth();
+  }
+
+
+  /******************** methods ****************************/
+
+  public boolean isLeaf() {
+    return fanOut == 0;
+  }
+
+  public boolean isNub() {
+    return fanOut > 0 && numCells > 0;
+  }
+
+  public boolean isBranch() {
+    return fanOut > 0 && numCells == 0;
+  }
+
+  public boolean hasOccurrences() {
+    return numCells > 0;
+  }
+
+  public int getTokenLength() {
+    return tokenWidth;
+  }
+
+  public byte getFanByte(int i) {
+    return block[fanOffset + i];
+  }
+  
+  /**
+   * for debugging
+   */
+  protected String getFanByteReadable(int i){
+    return Bytes.toStringBinary(block, fanOffset + i, 1);
+  }
+
+  public int getFamilyOffset(int index, PrefixTreeBlockMeta blockMeta) {
+    int fIntWidth = blockMeta.getFamilyOffsetWidth();
+    int startIndex = familyOffsetsOffset + fIntWidth * index;
+    return (int) UFIntTool.fromBytes(block, startIndex, fIntWidth);
+  }
+
+  public int getColumnOffset(int index, PrefixTreeBlockMeta blockMeta) {
+    int fIntWidth = blockMeta.getQualifierOffsetWidth();
+    int startIndex = qualifierOffsetsOffset + fIntWidth * index;
+    return (int) UFIntTool.fromBytes(block, startIndex, fIntWidth);
+  }
+
+  public int getTimestampIndex(int index, PrefixTreeBlockMeta blockMeta) {
+    int fIntWidth = blockMeta.getTimestampIndexWidth();
+    int startIndex = timestampIndexesOffset + fIntWidth * index;
+    return (int) UFIntTool.fromBytes(block, startIndex, fIntWidth);
+  }
+
+  public int getMvccVersionIndex(int index, PrefixTreeBlockMeta blockMeta) {
+    int fIntWidth = blockMeta.getMvccVersionIndexWidth();
+    int startIndex = mvccVersionIndexesOffset + fIntWidth * index;
+    return (int) UFIntTool.fromBytes(block, startIndex, fIntWidth);
+  }
+
+  public int getType(int index, PrefixTreeBlockMeta blockMeta) {
+    if (blockMeta.isAllSameType()) {
+      return blockMeta.getAllTypes();
+    }
+    return block[operationTypesOffset + index];
+  }
+
+  public int getValueOffset(int index, PrefixTreeBlockMeta blockMeta) {
+    int fIntWidth = blockMeta.getValueOffsetWidth();
+    int startIndex = valueOffsetsOffset + fIntWidth * index;
+    int offset = (int) UFIntTool.fromBytes(block, startIndex, fIntWidth);
+    return offset;
+  }
+
+  public int getValueLength(int index, PrefixTreeBlockMeta blockMeta) {
+    int fIntWidth = blockMeta.getValueLengthWidth();
+    int startIndex = valueLengthsOffset + fIntWidth * index;
+    int length = (int) UFIntTool.fromBytes(block, startIndex, fIntWidth);
+    return length;
+  }
+
+  public int getNextNodeOffset(int index, PrefixTreeBlockMeta blockMeta) {
+    int fIntWidth = blockMeta.getNextNodeOffsetWidth();
+    int startIndex = nextNodeOffsetsOffset + fIntWidth * index;
+    return (int) UFIntTool.fromBytes(block, startIndex, fIntWidth);
+  }
+
+  public String getBranchNubLeafIndicator() {
+    if (isNub()) {
+      return "N";
+    }
+    return isBranch() ? "B" : "L";
+  }
+
+  public boolean hasChildren() {
+    return fanOut > 0;
+  }
+
+  public int getLastFanIndex() {
+    return fanOut - 1;
+  }
+
+  public int getLastCellIndex() {
+    return numCells - 1;
+  }
+
+  public int getNumCells() {
+    return numCells;
+  }
+
+  public int getFanOut() {
+    return fanOut;
+  }
+
+  public byte[] getToken() {
+    // TODO pass in reusable ByteRange
+    return new ByteRange(block, tokenOffset, tokenWidth).deepCopyToNewArray();
+  }
+
+  public int getOffset() {
+    return offset;
+  }
+
+  public int whichFanNode(byte searchForByte) {
+    if( ! hasFan()){
+      throw new IllegalStateException("This row node has no fan, so can't search it");
+    }
+    int fanIndexInBlock = Bytes.unsignedBinarySearch(block, fanOffset, fanOffset + fanOut,
+      searchForByte);
+    if (fanIndexInBlock >= 0) {// found it, but need to adjust for position of fan in overall block
+      return fanIndexInBlock - fanOffset;
+    }
+    return fanIndexInBlock + fanOffset + 1;// didn't find it, so compensate in reverse
+  }
+  
+  public void resetFanIndex() {
+    fanIndex = -1;// just the way the logic currently works
+  }
+
+  public int getFanIndex() {
+    return fanIndex;
+  }
+
+  public void setFanIndex(int fanIndex) {
+    this.fanIndex = fanIndex;
+  }
+
+  public boolean hasFan(){
+    return fanOut > 0;
+  }
+
+  public boolean hasPreviousFanNodes() {
+    return fanOut > 0 && fanIndex > 0;
+  }
+
+  public boolean hasMoreFanNodes() {
+    return fanIndex < getLastFanIndex();
+  }
+
+  public boolean isOnLastFanNode() {
+    return !hasMoreFanNodes();
+  }
+
+
+  /*************** standard methods **************************/
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    sb.append("fan:" + Bytes.toStringBinary(block, fanOffset, fanOut));
+    sb.append(",token:" + Bytes.toStringBinary(block, tokenOffset, tokenWidth));
+    sb.append(",numCells:" + numCells);
+    sb.append("fanIndex:"+fanIndex);
+    if(fanIndex>=0){
+      sb.append("("+getFanByteReadable(fanIndex)+")");
+    }
+    return sb.toString();
+  }
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/timestamp/MvccVersionDecoder.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/timestamp/MvccVersionDecoder.java
new file mode 100644
index 0000000..ab1dc09
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/timestamp/MvccVersionDecoder.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.decode.timestamp;
+
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.util.vint.UFIntTool;
+
+/**
+ * Given a block and its blockMeta, this will decode the MvccVersion for the i-th Cell in the block.
+ */
+public class MvccVersionDecoder {
+
+  protected PrefixTreeBlockMeta blockMeta;
+  protected byte[] block;
+
+
+  /************** construct ***********************/
+
+  public MvccVersionDecoder() {
+  }
+
+  public void initOnBlock(PrefixTreeBlockMeta blockMeta, byte[] block) {
+    this.block = block;
+    this.blockMeta = blockMeta;
+  }
+
+
+  /************** methods *************************/
+
+  public long getMvccVersion(int index) {
+    if (blockMeta.getMvccVersionIndexWidth() == 0) {//all mvccVersions in the block were identical
+      return blockMeta.getMinMvccVersion();
+    }
+    int startIndex = blockMeta.getAbsoluteMvccVersionOffset()
+        + blockMeta.getMvccVersionDeltaWidth() * index;
+    long delta = UFIntTool.fromBytes(block, startIndex, blockMeta.getMvccVersionDeltaWidth());
+    return blockMeta.getMinMvccVersion() + delta;
+  }
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/timestamp/TimestampDecoder.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/timestamp/TimestampDecoder.java
new file mode 100644
index 0000000..351c5be
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/decode/timestamp/TimestampDecoder.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.decode.timestamp;
+
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.util.vint.UFIntTool;
+
+/**
+ * Given a block and its blockMeta, this will decode the timestamp for the i-th Cell in the block.
+ */
+public class TimestampDecoder {
+
+  protected PrefixTreeBlockMeta blockMeta;
+  protected byte[] block;
+
+
+  /************** construct ***********************/
+
+  public TimestampDecoder() {
+  }
+
+  public void initOnBlock(PrefixTreeBlockMeta blockMeta, byte[] block) {
+    this.block = block;
+    this.blockMeta = blockMeta;
+  }
+
+
+  /************** methods *************************/
+
+  public long getLong(int index) {
+    if (blockMeta.getTimestampIndexWidth() == 0) {//all timestamps in the block were identical
+      return blockMeta.getMinTimestamp();
+    }
+    int startIndex = blockMeta.getAbsoluteTimestampOffset() + blockMeta.getTimestampDeltaWidth()
+        * index;
+    long delta = UFIntTool.fromBytes(block, startIndex, blockMeta.getTimestampDeltaWidth());
+    return blockMeta.getMinTimestamp() + delta;
+  }
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/EncoderFactory.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/EncoderFactory.java
new file mode 100644
index 0000000..23e164d
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/EncoderFactory.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode;
+
+import java.io.OutputStream;
+
+
+public class EncoderFactory {
+
+  protected static EncoderPool POOL = new ThreadLocalEncoderPool();
+
+
+  public static PrefixTreeEncoder checkOut(OutputStream outputStream, boolean includeMvccVersion) {
+    return POOL.checkOut(outputStream, includeMvccVersion);
+  }
+
+  public static void checkIn(PrefixTreeEncoder encoder) {
+    POOL.checkIn(encoder);
+  }
+
+
+  /**************************** helper ******************************/
+
+  protected static PrefixTreeEncoder prepareEncoder(PrefixTreeEncoder encoder,
+      OutputStream outputStream, boolean includeMvccVersion) {
+    PrefixTreeEncoder ret = encoder;
+    if (encoder == null) {
+      ret = new PrefixTreeEncoder(outputStream, includeMvccVersion);
+    }
+    ret.reset(outputStream, includeMvccVersion);
+    return ret;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/EncoderPool.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/EncoderPool.java
new file mode 100644
index 0000000..ed37258
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/EncoderPool.java
@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode;
+
+import java.io.OutputStream;
+
+
+public interface EncoderPool {
+
+  PrefixTreeEncoder checkOut(OutputStream outputStream, boolean includeMvccVersion);
+  void checkIn(PrefixTreeEncoder encoder);
+
+}
\ No newline at end of file
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/PrefixTreeEncoder.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/PrefixTreeEncoder.java
new file mode 100644
index 0000000..89688eb
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/PrefixTreeEncoder.java
@@ -0,0 +1,494 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hbase.KeyValueTool;
+import org.apache.hadoop.hbase.util.ArrayUtils;
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.io.WritableUtils;
+import org.apache.hbase.Cell;
+import org.apache.hbase.cell.CellOutputStream;
+import org.apache.hbase.cell.CellTool;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.encode.column.ColumnSectionWriter;
+import org.apache.hbase.codec.prefixtree.encode.other.CellTypeEncoder;
+import org.apache.hbase.codec.prefixtree.encode.other.LongEncoder;
+import org.apache.hbase.codec.prefixtree.encode.row.RowSectionWriter;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.Tokenizer;
+import org.apache.hbase.util.byterange.ByteRangeSet;
+import org.apache.hbase.util.byterange.impl.ByteRangeHashSet;
+import org.apache.hbase.util.byterange.impl.ByteRangeTreeSet;
+import org.apache.hbase.util.io.OutputStreamUtils;
+import org.apache.hbase.util.vint.UFIntTool;
+
+/**
+ * This is the primary class for converting a CellOutputStream into an encoded byte[]. As Cells are
+ * added they are completely copied into the various encoding structures. This is important because
+ * usually the cells being fed in during compactions will be transient.<br/>
+ * <br/>
+ * Usage:<br/>
+ * 1) constructor<br/>
+ * 4) append cells in sorted order: write(Cell cell)<br/>
+ * 5) flush()<br/>
+ */
+public class PrefixTreeEncoder implements CellOutputStream {
+
+  /**************** static ************************/
+
+  protected static final Log LOG = LogFactory.getLog(PrefixTreeEncoder.class);
+
+  //future-proof where HBase supports multiple families in a data block.
+  public static final boolean MULITPLE_FAMILIES_POSSIBLE = true;
+
+  public static final boolean USE_HASH_COLUMN_SORTER = true;
+  public static final int EXPECTED_CELLS_PLUS_EXTRA = 2000;
+
+  public static final int FAMILY_BYTES_INIT_SIZE = 16 * 1024;
+  public static final int QUALIFIER_BYTES_INIT_SIZE = 16 * 1024;
+  public static final int VALUE_BUFFER_INIT_SIZE = 64 * 1024;
+
+
+  /**************** fields *************************/
+
+  protected long numResets = 0L;
+
+  protected OutputStream outputStream;
+
+  /*
+   * Cannot change during a single block's encoding. If false, then substitute incoming Cell's
+   * mvccVersion with zero and write out the block as usual.
+   */
+  protected boolean includeMvccVersion;
+
+  /*
+   * reusable ByteRanges used for communicating with the sorters/compilers
+   */
+  protected ByteRange rowRange;
+  protected ByteRange familyRange;
+  protected ByteRange qualifierRange;
+
+  /*
+   * incoming Cell fields are copied into these arrays
+   */
+  protected long[] timestamps;
+  protected long[] mvccVersions;
+  protected byte[] typeBytes;
+  protected int[] valueOffsets;
+  protected byte[] values;
+
+  protected PrefixTreeBlockMeta blockMeta;
+
+  /*
+   * Sub-encoders for the simple long/byte fields of a Cell.  Add to these as each cell arrives and
+   * compile before flushing.
+   */
+  protected LongEncoder timestampEncoder;
+  protected LongEncoder mvccVersionEncoder;
+  protected CellTypeEncoder cellTypeEncoder;
+
+  /*
+   * Structures used for collecting families and qualifiers, de-duplicating them, and sorting them
+   * so they can be passed to the tokenizers. Unlike row keys where we can detect duplicates by
+   * comparing only to the previous row key, families and qualifiers can arrive in unsorted order in
+   * blocks spanning multiple rows. We must collect them all into a set to de-duplicate them.
+   */
+  protected ByteRangeSet familyDeduplicator;
+  protected ByteRangeSet qualifierDeduplicator;
+
+  /*
+   * Feed sorted byte[]s into these tokenizers which will convert the byte[]s to an in-memory
+   * trie structure with nodes connected by memory pointers (not serializable yet).
+   */
+  protected Tokenizer rowTokenizer;
+  protected Tokenizer familyTokenizer;
+  protected Tokenizer qualifierTokenizer;
+
+  /*
+   * Writers take an in-memory trie, sort the nodes, calculate offsets and lengths, and write
+   * all information to an output stream of bytes that can be stored on disk.
+   */
+  protected RowSectionWriter rowWriter;
+  protected ColumnSectionWriter familyWriter;
+  protected ColumnSectionWriter qualifierWriter;
+
+  /*
+   * Integers used for counting cells and bytes.  We keep track of the size of the Cells as if they
+   * were full KeyValues because some parts of HBase like to know the "unencoded size".
+   */
+  protected int totalCells = 0;
+  protected int totalUnencodedBytes = 0;//numBytes if the cells were KeyValues
+  protected int totalValueBytes = 0;
+  protected int maxValueLength = 0;
+  protected int totalBytes = 0;//
+
+
+  /***************** construct ***********************/
+
+  public PrefixTreeEncoder(OutputStream outputStream, boolean includeMvccVersion) {
+    // used during cell accumulation
+    this.blockMeta = new PrefixTreeBlockMeta();
+    this.rowRange = new ByteRange();
+    this.familyRange = new ByteRange();
+    this.qualifierRange = new ByteRange();
+    this.timestamps = new long[EXPECTED_CELLS_PLUS_EXTRA];
+    this.mvccVersions = new long[EXPECTED_CELLS_PLUS_EXTRA];
+    this.typeBytes = new byte[EXPECTED_CELLS_PLUS_EXTRA];
+    this.valueOffsets = new int[EXPECTED_CELLS_PLUS_EXTRA];
+    this.values = new byte[VALUE_BUFFER_INIT_SIZE];
+
+    // used during compilation
+    this.familyDeduplicator = USE_HASH_COLUMN_SORTER ? new ByteRangeHashSet() : new ByteRangeTreeSet();
+    this.qualifierDeduplicator = USE_HASH_COLUMN_SORTER ? new ByteRangeHashSet() : new ByteRangeTreeSet();
+    this.timestampEncoder = new LongEncoder(blockMeta);
+    this.mvccVersionEncoder = new LongEncoder(blockMeta);
+    this.cellTypeEncoder = new CellTypeEncoder();
+    this.rowTokenizer = new Tokenizer();
+    this.familyTokenizer = new Tokenizer();
+    this.qualifierTokenizer = new Tokenizer();
+    this.rowWriter = new RowSectionWriter();
+    this.familyWriter = new ColumnSectionWriter();
+    this.qualifierWriter = new ColumnSectionWriter();
+
+    reset(outputStream, includeMvccVersion);
+  }
+
+  public void reset(OutputStream outputStream, boolean includeMvccVersion) {
+    ++numResets;
+    this.includeMvccVersion = includeMvccVersion;
+    this.outputStream = outputStream;
+    valueOffsets[0] = 0;
+
+    familyDeduplicator.reset();
+    qualifierDeduplicator.reset();
+    rowTokenizer.reset();
+    timestampEncoder.reset();
+    mvccVersionEncoder.reset();
+    cellTypeEncoder.reset();
+    familyTokenizer.reset();
+    qualifierTokenizer.reset();
+    rowWriter.reset();
+    familyWriter.reset();
+    qualifierWriter.reset();
+
+    totalCells = 0;
+    totalUnencodedBytes = 0;
+    totalValueBytes = 0;
+    maxValueLength = 0;
+    totalBytes = 0;
+  }
+
+  /**
+   * Check that the arrays used to hold cell fragments are large enough for the cell that is being
+   * added. Since the PrefixTreeEncoder is cached between uses, these arrays may grow during the
+   * first few block encodings but should stabilize quickly.
+   */
+  protected void ensurePerCellCapacities() {
+    int currentCapacity = valueOffsets.length;
+    int neededCapacity = totalCells + 2;// some things write one index ahead. +2 to be safe
+    if (neededCapacity < currentCapacity) {
+      return;
+    }
+
+    int padding = neededCapacity;
+    timestamps = ArrayUtils.growIfNecessary(timestamps, neededCapacity, padding);
+    mvccVersions = ArrayUtils.growIfNecessary(mvccVersions, neededCapacity, padding);
+    typeBytes = ArrayUtils.growIfNecessary(typeBytes, neededCapacity, padding);
+    valueOffsets = ArrayUtils.growIfNecessary(valueOffsets, neededCapacity, padding);
+  }
+
+  /******************** CellOutputStream methods *************************/
+
+  /**
+   * Note: Unused until support is added to the scanner/heap
+   *
+   * The following 3 methods are optimized versions of write(Cell cell). The result should be
+   * identical, however the implementation may be able to execute them much more efficiently because
+   * it does not need to compare the unchanged fields with the previous cell's.
+   * <p/>
+   * Consider the benefits during compaction when paired with a CellScanner that is also aware of
+   * row boundaries. The CellScanner can easily use these methods instead of blindly passing Cells
+   * to the write(Cell cell) method.
+   * <p/>
+   * The savings of skipping duplicate row detection are significant with long row keys. A
+   * DataBlockEncoder may store a row key once in combination with a count of how many cells are in
+   * the row. With a 100 byte row key, we can replace 100 byte comparisons with a single increment
+   * of the counter, and that is for every cell in the row.
+   */
+
+  /**
+   * Add a Cell to the output stream but repeat the previous row. 
+   */
+  //@Override
+  public void writeWithRepeatRow(Cell cell) {
+    ensurePerCellCapacities();//can we optimize away some of this?
+
+    //save a relatively expensive row comparison, incrementing the row's counter instead
+    rowTokenizer.incrementNumOccurrencesOfLatestValue();
+    addFamilyPart(cell);
+    addQualifierPart(cell);
+    addAfterRowFamilyQualifier(cell);
+  }
+
+
+  @Override
+  public void write(Cell cell) {
+    ensurePerCellCapacities();
+
+    rowTokenizer.addSorted(CellTool.fillRowRange(cell, rowRange));
+    addFamilyPart(cell);
+    addQualifierPart(cell);
+    addAfterRowFamilyQualifier(cell);
+  }
+
+
+  /***************** internal add methods ************************/
+
+  protected void addAfterRowFamilyQualifier(Cell cell){
+    // timestamps
+    timestamps[totalCells] = cell.getTimestamp();
+    timestampEncoder.add(cell.getTimestamp());
+
+    // memstore timestamps
+    if (includeMvccVersion) {
+      mvccVersions[totalCells] = cell.getMvccVersion();
+      mvccVersionEncoder.add(cell.getMvccVersion());
+      totalUnencodedBytes += WritableUtils.getVIntSize(cell.getMvccVersion());
+    }else{
+      //must overwrite in case there was a previous version in this array slot
+      mvccVersions[totalCells] = 0L;
+      if(totalCells == 0){//only need to do this for the first cell added
+        mvccVersionEncoder.add(0L);
+      }
+      //totalUncompressedBytes += 0;//mvccVersion takes zero bytes when disabled
+    }
+
+    // types
+    typeBytes[totalCells] = cell.getTypeByte();
+    cellTypeEncoder.add(cell.getTypeByte());
+
+    // values
+    totalValueBytes += cell.getValueLength();
+    // double the array each time we run out of space
+    values = ArrayUtils.growIfNecessary(values, totalValueBytes, 2 * totalValueBytes);
+    CellTool.copyValueTo(cell, values, valueOffsets[totalCells]);
+    if (cell.getValueLength() > maxValueLength) {
+      maxValueLength = cell.getValueLength();
+    }
+    valueOffsets[totalCells + 1] = totalValueBytes;
+
+    // general
+    totalUnencodedBytes += KeyValueTool.length(cell);
+    ++totalCells;
+  }
+
+  protected void addFamilyPart(Cell cell) {
+    if (MULITPLE_FAMILIES_POSSIBLE || totalCells == 0) {
+      CellTool.fillFamilyRange(cell, familyRange);
+      familyDeduplicator.add(familyRange);
+    }
+  }
+
+  protected void addQualifierPart(Cell cell) {
+    CellTool.fillQualifierRange(cell, qualifierRange);
+    qualifierDeduplicator.add(qualifierRange);
+  }
+
+
+  /****************** compiling/flushing ********************/
+
+  /**
+   * Expensive method.  The second half of the encoding work happens here.
+   *
+   * Take all the separate accumulated data structures and turn them into a single stream of bytes
+   * which is written to the outputStream.
+   */
+  @Override
+  public void flush() throws IOException {
+    compile();
+
+    // do the actual flushing to the output stream.  Order matters.
+    blockMeta.writeVariableBytesToOutputStream(outputStream);
+    rowWriter.writeBytes(outputStream);
+    familyWriter.writeBytes(outputStream);
+    qualifierWriter.writeBytes(outputStream);
+    timestampEncoder.writeBytes(outputStream);
+    mvccVersionEncoder.writeBytes(outputStream);
+    //CellType bytes are in the row nodes.  there is no additional type section
+    OutputStreamUtils.write(outputStream, values, 0, totalValueBytes);
+  }
+
+  /**
+   * Now that all the cells have been added, do the work to reduce them to a series of byte[]
+   * fragments that are ready to be written to the output stream.
+   */
+  protected void compile(){
+    blockMeta.setNumKeyValueBytes(totalUnencodedBytes);
+    int lastValueOffset = valueOffsets[totalCells];
+    blockMeta.setValueOffsetWidth(UFIntTool.numBytes(lastValueOffset));
+    blockMeta.setValueLengthWidth(UFIntTool.numBytes(maxValueLength));
+    blockMeta.setNumValueBytes(totalValueBytes);
+    totalBytes += totalValueBytes;
+
+    //these compile methods will add to totalBytes
+    compileTypes();
+    compileMvccVersions();
+    compileTimestamps();
+    compileQualifiers();
+    compileFamilies();
+    compileRows();
+
+    int numMetaBytes = blockMeta.calculateNumMetaBytes();
+    blockMeta.setNumMetaBytes(numMetaBytes);
+    totalBytes += numMetaBytes;
+  }
+
+  /**
+   * The following "compile" methods do any intermediate work necessary to transform the cell
+   * fragments collected during the writing phase into structures that are ready to write to the
+   * outputStream.
+   * <p/>
+   * The family and qualifier treatment is almost identical, as is timestamp and mvccVersion.
+   */
+
+  protected void compileTypes() {
+    blockMeta.setAllSameType(cellTypeEncoder.areAllSameType());
+    if(cellTypeEncoder.areAllSameType()){
+      blockMeta.setAllTypes(cellTypeEncoder.getOnlyType());
+    }
+  }
+
+  protected void compileMvccVersions() {
+    mvccVersionEncoder.compile();
+    blockMeta.setMvccVersionFields(mvccVersionEncoder);
+    int numMvccVersionBytes = mvccVersionEncoder.getOutputArrayLength();
+    totalBytes += numMvccVersionBytes;
+  }
+
+  protected void compileTimestamps() {
+    timestampEncoder.compile();
+    blockMeta.setTimestampFields(timestampEncoder);
+    int numTimestampBytes = timestampEncoder.getOutputArrayLength();
+    totalBytes += numTimestampBytes;
+  }
+
+  protected void compileQualifiers() {
+    blockMeta.setNumUniqueQualifiers(qualifierDeduplicator.size());
+    qualifierDeduplicator.compile();
+    qualifierTokenizer.addAll(qualifierDeduplicator.getSortedRanges());
+    qualifierWriter.reconstruct(blockMeta, qualifierTokenizer, false);
+    qualifierWriter.compile();
+    int numQualifierBytes = qualifierWriter.getNumBytes();
+    blockMeta.setNumQualifierBytes(numQualifierBytes);
+    totalBytes += numQualifierBytes;
+  }
+
+  protected void compileFamilies() {
+    blockMeta.setNumUniqueFamilies(familyDeduplicator.size());
+    familyDeduplicator.compile();
+    familyTokenizer.addAll(familyDeduplicator.getSortedRanges());
+    familyWriter.reconstruct(blockMeta, familyTokenizer, true);
+    familyWriter.compile();
+    int numFamilyBytes = familyWriter.getNumBytes();
+    blockMeta.setNumFamilyBytes(numFamilyBytes);
+    totalBytes += numFamilyBytes;
+  }
+
+  protected void compileRows() {
+    rowWriter.reconstruct(this);
+    rowWriter.compile();
+    int numRowBytes = rowWriter.getNumBytes();
+    blockMeta.setNumRowBytes(numRowBytes);
+    blockMeta.setRowTreeDepth(rowTokenizer.getTreeDepth());
+    totalBytes += numRowBytes;
+  }
+
+  /********************* convenience getters ********************************/
+
+  public long getValueOffset(int index) {
+    return valueOffsets[index];
+  }
+
+  public int getValueLength(int index) {
+    return (int) (valueOffsets[index + 1] - valueOffsets[index]);
+  }
+
+  /************************* get/set *************************************/
+
+  public PrefixTreeBlockMeta getBlockMeta() {
+    return blockMeta;
+  }
+
+  public Tokenizer getRowTokenizer() {
+    return rowTokenizer;
+  }
+
+  public LongEncoder getTimestampEncoder() {
+    return timestampEncoder;
+  }
+
+  public int getTotalBytes() {
+    return totalBytes;
+  }
+
+  public long[] getTimestamps() {
+    return timestamps;
+  }
+
+  public long[] getMvccVersions() {
+    return mvccVersions;
+  }
+
+  public byte[] getTypeBytes() {
+    return typeBytes;
+  }
+
+  public LongEncoder getMvccVersionEncoder() {
+    return mvccVersionEncoder;
+  }
+
+  public ByteRangeSet getFamilySorter() {
+    return familyDeduplicator;
+  }
+
+  public ByteRangeSet getQualifierSorter() {
+    return qualifierDeduplicator;
+  }
+
+  public ColumnSectionWriter getFamilyWriter() {
+    return familyWriter;
+  }
+
+  public ColumnSectionWriter getQualifierWriter() {
+    return qualifierWriter;
+  }
+
+  public RowSectionWriter getRowWriter() {
+    return rowWriter;
+  }
+
+  public ByteRange getValueByteRange() {
+    return new ByteRange(values, 0, totalValueBytes);
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/ThreadLocalEncoderPool.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/ThreadLocalEncoderPool.java
new file mode 100644
index 0000000..57e6335
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/ThreadLocalEncoderPool.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode;
+
+import java.io.OutputStream;
+
+
+/**
+ * Assumes compactions are handled by a single thread.
+ */
+public class ThreadLocalEncoderPool implements EncoderPool{
+
+  protected static ThreadLocal<PrefixTreeEncoder> BUILDER_HOLDER = new ThreadLocal<PrefixTreeEncoder>();
+
+  @Override
+  public PrefixTreeEncoder checkOut(OutputStream os, boolean includeMvccVersion) {
+    PrefixTreeEncoder builder = BUILDER_HOLDER.get();
+    builder = EncoderFactory.prepareEncoder(builder, os, includeMvccVersion);
+    BUILDER_HOLDER.set(builder);
+    return builder;
+  }
+
+  @Override
+  public void checkIn(PrefixTreeEncoder encoder) {
+    // attached to thread on checkOut, so shouldn't need to do anything here
+
+    // do we need to worry about detaching encoders from compaction threads or are the same threads
+    // used over and over
+  }
+
+}
\ No newline at end of file
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/column/ColumnNodeWriter.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/column/ColumnNodeWriter.java
new file mode 100644
index 0000000..ee32d64
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/column/ColumnNodeWriter.java
@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode.column;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.Strings;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.TokenizerNode;
+import org.apache.hbase.util.io.OutputStreamUtils;
+import org.apache.hbase.util.vint.UFIntTool;
+import org.apache.hbase.util.vint.UVIntTool;
+
+/**
+ * Column nodes can be either family nodes or qualifier nodes, as both sections encode similarly.
+ * The family and qualifier sections of the data block are made of 1 or more of these nodes.
+ * <p/>
+ * Each node is composed of 3 sections:<br/>
+ * <li>tokenLength: UVInt (normally 1 byte) indicating the number of token bytes
+ * <li>token[]: the actual token bytes
+ * <li>parentStartPosition: the offset of the next node from the start of the family or qualifier
+ * section
+ */
+public class ColumnNodeWriter{
+
+  /************* fields ****************************/
+
+  protected TokenizerNode builderNode;
+  protected PrefixTreeBlockMeta blockMeta;
+
+  protected boolean familyVsQualifier;
+
+  protected int tokenLength;
+  protected byte[] token;
+  protected int parentStartPosition;
+
+
+  /*************** construct **************************/
+
+  public ColumnNodeWriter(PrefixTreeBlockMeta blockMeta, TokenizerNode builderNode,
+      boolean familyVsQualifier) {
+    this.blockMeta = blockMeta;
+    this.builderNode = builderNode;
+    this.familyVsQualifier = familyVsQualifier;
+    calculateOffsetsAndLengths();
+  }
+
+
+  /************* methods *******************************/
+
+  public boolean isRoot() {
+    return parentStartPosition == 0;
+  }
+
+  protected void calculateOffsetsAndLengths() {
+    tokenLength = builderNode.getTokenLength();
+    token = new byte[tokenLength];
+  }
+
+  /**
+   * This method is called before blockMeta.qualifierOffsetWidth is known, so we pass in a
+   * placeholder.
+   * @param offsetWidthPlaceholder the placeholder
+   * @return
+   */
+  public int getWidthUsingPlaceholderForOffsetWidth(int offsetWidthPlaceholder) {
+    int width = 0;
+    width += UVIntTool.numBytes(tokenLength);
+    width += token.length;
+    width += offsetWidthPlaceholder;
+    return width;
+  }
+
+  public void writeBytes(OutputStream os) throws IOException {
+    int parentOffsetWidth;
+    if (familyVsQualifier) {
+      parentOffsetWidth = blockMeta.getFamilyOffsetWidth();
+    } else {
+      parentOffsetWidth = blockMeta.getQualifierOffsetWidth();
+    }
+    UVIntTool.writeBytes(tokenLength, os);
+    OutputStreamUtils.write(os, token);
+    UFIntTool.writeBytes(parentOffsetWidth, parentStartPosition, os);
+  }
+
+  public void setTokenBytes(ByteRange source) {
+    source.deepCopySubRangeTo(0, tokenLength, token, 0);
+  }
+
+
+  /****************** standard methods ************************/
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    sb.append(Strings.padFront(builderNode.getOutputArrayOffset() + "", ' ', 3) + ",");
+    sb.append("[");
+    sb.append(Bytes.toString(token));
+    sb.append("]->");
+    sb.append(parentStartPosition);
+    return sb.toString();
+  }
+
+
+  /************************** get/set ***********************/
+
+  public void setParentStartPosition(int parentStartPosition) {
+    this.parentStartPosition = parentStartPosition;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/column/ColumnSectionWriter.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/column/ColumnSectionWriter.java
new file mode 100644
index 0000000..e13fb22
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/column/ColumnSectionWriter.java
@@ -0,0 +1,207 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode.column;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.hbase.util.CollectionUtils;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.Tokenizer;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.TokenizerNode;
+import org.apache.hbase.util.vint.UFIntTool;
+
+import com.google.common.collect.Lists;
+
+/**
+ * ColumnWriter takes the tokenized family or qualifier data and flattens it into a stream of bytes
+ * that each compose one of the handful of sections in the data block.
+ * <p/>
+ * The family and qualifier tries, or "column tries", are structured differently than the row trie.
+ * The trie cannot be reassembled without external data about the offsets of the leaf nodes, and
+ * these external pointers are stored in the nubs and leaves of the row trie. For each cell in a
+ * row, the row trie contains a list of offsets into the column sections (along with pointers to
+ * timestamps and other per-cell fields). These offsets point to the last column node/token that
+ * comprises the column name. To assemble the column name, the trie is traversed in reverse (right
+ * to left), with the rightmost tokens pointing to the start of their "parent" node which is the
+ * node to the left.
+ * <p/>
+ * This choice was made to reduce the size of the column trie by storing the minimum amount of
+ * pointer data. As a result, to find a specific qualifier within a row, you must do a binary search
+ * of the column nodes, reassembling each one as you search. Future versions of the PrefixTree might
+ * encode the columns in both a forward and reverse trie, which would convert binary searches into
+ * more efficient trie searches which would be beneficial for wide rows.
+ */
+public class ColumnSectionWriter {
+
+  public static final int EXPECTED_NUBS_PLUS_LEAVES = 100;
+
+  /****************** fields ****************************/
+
+  protected PrefixTreeBlockMeta blockMeta;
+
+  protected boolean familyVsQualifier;
+  protected Tokenizer tokenizer;
+  protected int numBytes = 0;
+  protected int numAppended = 0;// for tests
+  protected ArrayList<TokenizerNode> nonLeaves;
+  protected ArrayList<TokenizerNode> leaves;
+  protected int numNonLeaves = 0;
+  protected int numLeaves = 0;
+  protected ArrayList<TokenizerNode> allNodes;
+  protected ArrayList<ColumnNodeWriter> columnNodeWriters;
+  protected List<Integer> outputArrayOffsets;
+
+
+	/*********************** construct *********************/
+
+  public ColumnSectionWriter() {
+    this.nonLeaves = Lists.newArrayList();
+    this.leaves = Lists.newArrayList();
+    this.outputArrayOffsets = Lists.newArrayList();
+  }
+
+  public ColumnSectionWriter(PrefixTreeBlockMeta blockMeta, Tokenizer builder, boolean familyVsQualifier) {
+    this();// init collections
+    reconstruct(blockMeta, builder, familyVsQualifier);
+  }
+
+  public void reconstruct(PrefixTreeBlockMeta blockMeta, Tokenizer builder, boolean familyVsQualifier) {
+    this.blockMeta = blockMeta;
+    this.tokenizer = builder;
+    this.familyVsQualifier = familyVsQualifier;
+  }
+
+  public void reset() {
+    numBytes = 0;
+    numAppended = 0;
+    nonLeaves.clear();
+    leaves.clear();
+    outputArrayOffsets.clear();
+    numNonLeaves = 0;
+    numLeaves = 0;
+  }
+
+
+	/****************** methods *******************************/
+
+  public ColumnSectionWriter compile() {
+    if (familyVsQualifier) {
+      // do nothing. max family length fixed at Byte.MAX_VALUE
+    } else {
+      blockMeta.setMaxQualifierLength(tokenizer.getMaxElementLength());
+    }
+
+    tokenizer.setNodeFirstInsertionIndexes();
+
+    tokenizer.appendNodes(nonLeaves, true, false);
+    numNonLeaves = nonLeaves.size();
+    Tokenizer.setNodeSortedIndexes(nonLeaves, 0);
+
+    tokenizer.appendNodes(leaves, false, true);
+    numLeaves = leaves.size();
+    Tokenizer.setNodeSortedIndexes(nonLeaves, nonLeaves.size());
+
+    allNodes = Lists.newArrayListWithCapacity(nonLeaves.size() + leaves.size());
+    allNodes.addAll(nonLeaves);
+    allNodes.addAll(leaves);
+
+    columnNodeWriters = Lists.newArrayListWithCapacity(CollectionUtils.nullSafeSize(allNodes));
+    for (int i = 0; i < allNodes.size(); ++i) {
+      TokenizerNode node = allNodes.get(i);
+      columnNodeWriters.add(new ColumnNodeWriter(blockMeta, node, familyVsQualifier));
+    }
+
+    // leaf widths are known at this point, so add them up
+    int totalBytesWithoutOffsets = 0;
+    for (int i = allNodes.size() - 1; i >= 0; --i) {
+      ColumnNodeWriter columnNodeWriter = columnNodeWriters.get(i);
+      // leaves store all but their first token byte
+      totalBytesWithoutOffsets += columnNodeWriter.getWidthUsingPlaceholderForOffsetWidth(0);
+    }
+
+    // figure out how wide our offset FInts are
+    int parentOffsetWidth = 0;
+    while (true) {
+      ++parentOffsetWidth;
+      int numBytesFinder = totalBytesWithoutOffsets + parentOffsetWidth * allNodes.size();
+      if (numBytesFinder < UFIntTool.maxValueForNumBytes(parentOffsetWidth)) {
+        numBytes = numBytesFinder;
+        break;
+      }// it fits
+    }
+    if (familyVsQualifier) {
+      blockMeta.setFamilyOffsetWidth(parentOffsetWidth);
+    } else {
+      blockMeta.setQualifierOffsetWidth(parentOffsetWidth);
+    }
+
+    int forwardIndex = 0;
+    for (int i = 0; i < allNodes.size(); ++i) {
+      TokenizerNode node = allNodes.get(i);
+      ColumnNodeWriter columnNodeWriter = columnNodeWriters.get(i);
+      int fullNodeWidth = columnNodeWriter
+          .getWidthUsingPlaceholderForOffsetWidth(parentOffsetWidth);
+      node.setOutputArrayOffset(forwardIndex);
+      columnNodeWriter.setTokenBytes(node.getToken());
+      if (node.isRoot()) {
+        columnNodeWriter.setParentStartPosition(0);
+      } else {
+        columnNodeWriter.setParentStartPosition(node.getParent().getOutputArrayOffset());
+      }
+      forwardIndex += fullNodeWidth;
+    }
+
+    tokenizer.appendOutputArrayOffsets(outputArrayOffsets);
+
+    return this;
+  }
+
+  public void writeBytes(OutputStream os) throws IOException {
+    for (ColumnNodeWriter columnNodeWriter : columnNodeWriters) {
+      columnNodeWriter.writeBytes(os);
+    }
+  }
+
+
+  /************* get/set **************************/
+
+  public ArrayList<ColumnNodeWriter> getColumnNodeWriters() {
+    return columnNodeWriters;
+  }
+
+  public int getNumBytes() {
+    return numBytes;
+  }
+
+  public int getOutputArrayOffset(int sortedIndex) {
+    return outputArrayOffsets.get(sortedIndex);
+  }
+
+  public ArrayList<TokenizerNode> getNonLeaves() {
+    return nonLeaves;
+  }
+
+  public ArrayList<TokenizerNode> getLeaves() {
+    return leaves;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/other/CellTypeEncoder.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/other/CellTypeEncoder.java
new file mode 100644
index 0000000..e2badee
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/other/CellTypeEncoder.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode.other;
+
+/**
+ * Detect if every KV has the same KeyValue.Type, in which case we don't need to store it for each
+ * KV.  If(allSameType) during conversion to byte[], then we can store the "onlyType" in blockMeta,
+ * therefore not repeating it for each cell and saving 1 byte per cell.
+ */
+public class CellTypeEncoder {
+
+  /************* fields *********************/
+
+  protected boolean pendingFirstType = true;
+  protected boolean allSameType = true;
+  protected byte onlyType;
+
+
+  /************* construct *********************/
+
+  public void reset() {
+    pendingFirstType = true;
+    allSameType = true;
+  }
+
+
+  /************* methods *************************/
+
+  public void add(byte type) {
+    if (pendingFirstType) {
+      onlyType = type;
+      pendingFirstType = false;
+    } else if (onlyType != type) {
+      allSameType = false;
+    }
+  }
+
+
+  /**************** get/set **************************/
+
+  public boolean areAllSameType() {
+    return allSameType;
+  }
+
+  public byte getOnlyType() {
+    return onlyType;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/other/LongEncoder.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/other/LongEncoder.java
new file mode 100644
index 0000000..06c1550
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/other/LongEncoder.java
@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode.other;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Arrays;
+import java.util.HashSet;
+
+import org.apache.hadoop.hbase.util.ArrayUtils;
+import org.apache.hadoop.hbase.util.CollectionUtils;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.util.vint.UFIntTool;
+
+import com.google.common.base.Joiner;
+
+/**
+ * Used to de-duplicate, sort, minimize/diff, and serialize timestamps and mvccVersions from a
+ * collection of Cells.
+ *
+ * 1. add longs to a HashSet for fast de-duplication
+ * 2. keep track of the min and max
+ * 3. copy all values to a new long[]
+ * 4. Collections.sort the long[]
+ * 5. calculate maxDelta = max - min
+ * 6. determine FInt width based on maxDelta
+ * 7. PrefixTreeEncoder binary searches to find index of each value
+ */
+public class LongEncoder {
+
+  /****************** fields ****************************/
+
+  protected PrefixTreeBlockMeta blockMeta;
+
+  protected HashSet<Long> uniqueValues;
+  protected long[] sortedUniqueValues;
+  protected long min, max, maxDelta;
+
+  protected int bytesPerDelta;
+  protected int bytesPerIndex;
+  protected int totalCompressedBytes;
+
+
+  /****************** construct ****************************/
+
+  public LongEncoder(PrefixTreeBlockMeta blockMeta) {
+    this.blockMeta = blockMeta;
+    this.uniqueValues = new HashSet<Long>();
+  }
+
+  public void reset() {
+    uniqueValues.clear();
+    sortedUniqueValues = null;
+    min = Long.MAX_VALUE;
+    max = Long.MIN_VALUE;
+    maxDelta = Long.MIN_VALUE;
+    bytesPerIndex = 0;
+    bytesPerDelta = 0;
+    totalCompressedBytes = 0;
+  }
+
+
+	/************* methods ***************************/
+
+  public void add(long timestamp) {
+    uniqueValues.add(timestamp);
+  }
+
+  public LongEncoder compile() {
+    int numUnique = uniqueValues.size();
+    if (numUnique == 1) {
+      min = CollectionUtils.getFirst(uniqueValues);
+      sortedUniqueValues = new long[] { min };
+      return this;
+    }
+
+    sortedUniqueValues = new long[numUnique];
+    int lastIndex = -1;
+    for (long value : uniqueValues) {
+      sortedUniqueValues[++lastIndex] = value;
+    }
+    Arrays.sort(sortedUniqueValues);
+    min = ArrayUtils.getFirst(sortedUniqueValues);
+    max = ArrayUtils.getLast(sortedUniqueValues);
+    maxDelta = max - min;
+    if (maxDelta > 0) {
+      bytesPerDelta = UFIntTool.numBytes(maxDelta);
+    } else {
+      bytesPerDelta = 0;
+    }
+
+    int maxIndex = numUnique - 1;
+    bytesPerIndex = UFIntTool.numBytes(maxIndex);
+
+    totalCompressedBytes = numUnique * bytesPerDelta;
+
+    return this;
+  }
+
+  public long getDelta(int index) {
+    if (sortedUniqueValues.length == 0) {
+      return 0;
+    }
+    return sortedUniqueValues[index] - min;
+  }
+
+  public int getIndex(long value) {
+    // should always find an exact match
+    return Arrays.binarySearch(sortedUniqueValues, value);
+  }
+
+  public void writeBytes(OutputStream os) throws IOException {
+    for (int i = 0; i < sortedUniqueValues.length; ++i) {
+      long delta = sortedUniqueValues[i] - min;
+      UFIntTool.writeBytes(bytesPerDelta, delta, os);
+    }
+  }
+
+  //convenience method for tests
+  public byte[] getByteArray() throws IOException{
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    writeBytes(baos);
+    return baos.toByteArray();
+  }
+
+  public int getOutputArrayLength() {
+    return sortedUniqueValues.length * bytesPerDelta;
+  }
+
+  public int getNumUniqueValues() {
+    return sortedUniqueValues.length;
+  }
+
+
+  /******************* Object methods **********************/
+
+  @Override
+  public String toString() {
+    if (ArrayUtils.isEmpty(sortedUniqueValues)) {
+      return "[]";
+    }
+    return "[" + Joiner.on(",").join(ArrayUtils.toList(sortedUniqueValues)) + "]";
+  }
+
+
+	/******************** get/set **************************/
+
+  public long getMin() {
+    return min;
+  }
+
+  public int getBytesPerDelta() {
+    return bytesPerDelta;
+  }
+
+  public int getBytesPerIndex() {
+    return bytesPerIndex;
+  }
+
+  public int getTotalCompressedBytes() {
+    return totalCompressedBytes;
+  }
+
+  public long[] getSortedUniqueTimestamps() {
+    return sortedUniqueValues;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/row/RowNodeWriter.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/row/RowNodeWriter.java
new file mode 100644
index 0000000..04bbee6
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/row/RowNodeWriter.java
@@ -0,0 +1,279 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode.row;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hbase.util.CollectionUtils;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.encode.PrefixTreeEncoder;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.TokenizerNode;
+import org.apache.hbase.util.io.OutputStreamUtils;
+import org.apache.hbase.util.vint.UFIntTool;
+import org.apache.hbase.util.vint.UVIntTool;
+
+public class RowNodeWriter{
+  protected static final Log LOG = LogFactory.getLog(RowNodeWriter.class);
+
+  /********************* fields ******************************/
+
+  protected PrefixTreeEncoder prefixTreeEncoder;
+  protected PrefixTreeBlockMeta blockMeta;
+  protected TokenizerNode tokenizerNode;
+
+  protected int tokenWidth;
+  protected int fanOut;
+  protected int numCells;
+
+  protected int width;
+
+
+  /*********************** construct *************************/
+
+  public RowNodeWriter(PrefixTreeEncoder keyValueBuilder, TokenizerNode tokenizerNode) {
+    reconstruct(keyValueBuilder, tokenizerNode);
+  }
+
+  public void reconstruct(PrefixTreeEncoder prefixTreeEncoder, TokenizerNode tokenizerNode) {
+    this.prefixTreeEncoder = prefixTreeEncoder;
+    reset(tokenizerNode);
+  }
+
+  public void reset(TokenizerNode node) {
+    this.blockMeta = prefixTreeEncoder.getBlockMeta();// changes between blocks
+    this.tokenizerNode = node;
+    this.tokenWidth = 0;
+    this.fanOut = 0;
+    this.numCells = 0;
+    this.width = 0;
+    calculateOffsetsAndLengths();
+  }
+
+
+  /********************* methods ****************************/
+
+  protected void calculateOffsetsAndLengths(){
+    tokenWidth = tokenizerNode.getTokenLength();
+    if(!tokenizerNode.isRoot()){
+      --tokenWidth;//root has no parent
+    }
+    fanOut = CollectionUtils.nullSafeSize(tokenizerNode.getChildren());
+    numCells = tokenizerNode.getNumOccurrences();
+  }
+
+  public int calculateWidth(){
+    calculateWidthOverrideOffsetWidth(blockMeta.getNextNodeOffsetWidth());
+    return width;
+  }
+
+  public int calculateWidthOverrideOffsetWidth(int offsetWidth){
+    width = 0;
+    width += UVIntTool.numBytes(tokenWidth);
+    width += tokenWidth;
+
+    width += UVIntTool.numBytes(fanOut);
+    width += fanOut;
+
+    width += UVIntTool.numBytes(numCells);
+
+    if(tokenizerNode.hasOccurrences()){
+      int fixedBytesPerCell = blockMeta.getFamilyOffsetWidth()
+        + blockMeta.getQualifierOffsetWidth()
+        + blockMeta.getTimestampIndexWidth()
+        + blockMeta.getMvccVersionIndexWidth()
+        + blockMeta.getKeyValueTypeWidth()
+        + blockMeta.getValueOffsetWidth()
+        + blockMeta.getValueLengthWidth();
+      width += numCells * fixedBytesPerCell;
+    }
+
+    if( ! tokenizerNode.isLeaf()){
+      width += fanOut * offsetWidth;
+    }
+
+    return width;
+  }
+
+
+  /*********************** writing the compiled structure to the OutputStream ***************/
+
+  public void write(OutputStream os) throws IOException{
+    //info about this row trie node
+    writeRowToken(os);
+    writeFan(os);
+    writeNumCells(os);
+
+    //UFInt indexes and offsets for each cell in the row (if nub or leaf)
+    writeFamilyNodeOffsets(os);
+    writeQualifierNodeOffsets(os);
+    writeTimestampIndexes(os);
+    writeMvccVersionIndexes(os);
+    writeCellTypes(os);
+    writeValueOffsets(os);
+    writeValueLengths(os);
+
+    //offsets to the children of this row trie node (if branch or nub)
+    writeNextRowTrieNodeOffsets(os);
+  }
+
+
+  /**
+   * Row node token, fan, and numCells. Written once at the beginning of each row node. These 3
+   * fields can reproduce all the row keys that compose the block.
+   */
+
+  /**
+   * UVInt: tokenWidth
+   * bytes: token
+   */
+  protected void writeRowToken(OutputStream os) throws IOException {
+    UVIntTool.writeBytes(tokenWidth, os);
+    int tokenStartIndex = tokenizerNode.isRoot() ? 0 : 1;
+    OutputStreamUtils.write(os, tokenizerNode.getToken(), tokenStartIndex);
+  }
+
+  /**
+   * UVInt: numFanBytes/fanOut
+   * bytes: each fan byte
+   */
+  public void writeFan(OutputStream os) throws IOException {
+    UVIntTool.writeBytes(fanOut, os);
+    if (fanOut <= 0) {
+      return;
+    }
+    ArrayList<TokenizerNode> children = tokenizerNode.getChildren();
+    for (int i = 0; i < children.size(); ++i) {
+      TokenizerNode child = children.get(i);
+      OutputStreamUtils.write(os, child.getToken().get(0));// first byte of each child's token
+    }
+  }
+
+  /**
+   * UVInt: numCells, the number of cells in this row which will be 0 for branch nodes
+   */
+  protected void writeNumCells(OutputStream os) throws IOException {
+    UVIntTool.writeBytes(numCells, os);
+  }
+
+
+  /**
+   * The following methods write data for each cell in the row, mostly consisting of indexes or
+   * offsets into the timestamp/column data structures that are written in the middle of the block.
+   * We use {@link UFIntTool} to encode these indexes/offsets to allow random access during a binary
+   * search of a particular column/timestamp combination.
+   * <p/>
+   * Branch nodes will not have any data in these sections.
+   */
+
+  protected void writeFamilyNodeOffsets(OutputStream os) throws IOException {
+    if (blockMeta.getFamilyOffsetWidth() <= 0) {
+      return;
+    }
+    for (int i = 0; i < numCells; ++i) {
+      int cellInsertionIndex = PrefixTreeEncoder.MULITPLE_FAMILIES_POSSIBLE ? tokenizerNode
+          .getFirstInsertionIndex() + i : 0;
+      int sortedIndex = prefixTreeEncoder.getFamilySorter().getSortedIndexForInsertionId(
+        cellInsertionIndex);
+      int indexedFamilyOffset = prefixTreeEncoder.getFamilyWriter().getOutputArrayOffset(
+        sortedIndex);
+      UFIntTool.writeBytes(blockMeta.getFamilyOffsetWidth(), indexedFamilyOffset, os);
+    }
+  }
+
+  protected void writeQualifierNodeOffsets(OutputStream os) throws IOException {
+    if (blockMeta.getQualifierOffsetWidth() <= 0) {
+      return;
+    }
+    for (int i = 0; i < numCells; ++i) {
+      int cellInsertionIndex = tokenizerNode.getFirstInsertionIndex() + i;
+      int sortedIndex = prefixTreeEncoder.getQualifierSorter().getSortedIndexForInsertionId(
+        cellInsertionIndex);
+      int indexedQualifierOffset = prefixTreeEncoder.getQualifierWriter().getOutputArrayOffset(
+        sortedIndex);
+      UFIntTool.writeBytes(blockMeta.getQualifierOffsetWidth(), indexedQualifierOffset, os);
+    }
+  }
+
+  protected void writeTimestampIndexes(OutputStream os) throws IOException {
+    if (blockMeta.getTimestampIndexWidth() <= 0) {
+      return;
+    }
+    for (int i = 0; i < numCells; ++i) {
+      int cellInsertionIndex = tokenizerNode.getFirstInsertionIndex() + i;
+      long timestamp = prefixTreeEncoder.getTimestamps()[cellInsertionIndex];
+      int timestampIndex = prefixTreeEncoder.getTimestampEncoder().getIndex(timestamp);
+      UFIntTool.writeBytes(blockMeta.getTimestampIndexWidth(), timestampIndex, os);
+    }
+  }
+
+  protected void writeMvccVersionIndexes(OutputStream os) throws IOException {
+    if (blockMeta.getMvccVersionIndexWidth() <= 0) {
+      return;
+    }
+    for (int i = 0; i < numCells; ++i) {
+      int cellInsertionIndex = tokenizerNode.getFirstInsertionIndex() + i;
+      long mvccVersion = prefixTreeEncoder.getMvccVersions()[cellInsertionIndex];
+      int mvccVersionIndex = prefixTreeEncoder.getMvccVersionEncoder().getIndex(mvccVersion);
+      UFIntTool.writeBytes(blockMeta.getMvccVersionIndexWidth(), mvccVersionIndex, os);
+    }
+  }
+
+  protected void writeCellTypes(OutputStream os) throws IOException {
+    if (blockMeta.isAllSameType()) {
+      return;
+    }
+    for (int i = 0; i < numCells; ++i) {
+      int cellInsertionIndex = tokenizerNode.getFirstInsertionIndex() + i;
+      OutputStreamUtils.write(os, prefixTreeEncoder.getTypeBytes()[cellInsertionIndex]);
+    }
+  }
+
+  protected void writeValueOffsets(OutputStream os) throws IOException {
+    for (int i = 0; i < numCells; ++i) {
+      int cellInsertionIndex = tokenizerNode.getFirstInsertionIndex() + i;
+      long valueStartIndex = prefixTreeEncoder.getValueOffset(cellInsertionIndex);
+      UFIntTool.writeBytes(blockMeta.getValueOffsetWidth(), valueStartIndex, os);
+    }
+  }
+
+  protected void writeValueLengths(OutputStream os) throws IOException {
+    for (int i = 0; i < numCells; ++i) {
+      int cellInsertionIndex = tokenizerNode.getFirstInsertionIndex() + i;
+      int valueLength = prefixTreeEncoder.getValueLength(cellInsertionIndex);
+      UFIntTool.writeBytes(blockMeta.getValueLengthWidth(), valueLength, os);
+    }
+  }
+
+
+  /**
+   * If a branch or a nub, the last thing we append are the UFInt offsets to the child row nodes.
+   */
+  protected void writeNextRowTrieNodeOffsets(OutputStream os) throws IOException {
+    ArrayList<TokenizerNode> children = tokenizerNode.getChildren();
+    for (int i = 0; i < children.size(); ++i) {
+      TokenizerNode child = children.get(i);
+      int distanceToChild = tokenizerNode.getNegativeIndex() - child.getNegativeIndex();
+      UFIntTool.writeBytes(blockMeta.getNextNodeOffsetWidth(), distanceToChild, os);
+    }
+  }
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/row/RowSectionWriter.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/row/RowSectionWriter.java
new file mode 100644
index 0000000..c7545f7
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/row/RowSectionWriter.java
@@ -0,0 +1,229 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode.row;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.encode.PrefixTreeEncoder;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.Tokenizer;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.TokenizerNode;
+import org.apache.hbase.util.vint.UFIntTool;
+
+import com.google.common.collect.Lists;
+
+/**
+ * Most of the complexity of the PrefixTree is contained in the "row section". It contains the row
+ * key trie structure used to search and recreate all the row keys. Each nub and leaf in this trie
+ * also contains references to offsets in the other sections of the data block that enable the
+ * decoder to match a row key with its qualifier, timestamp, type, value, etc.
+ * <p>
+ * The row section is a concatenated collection of {@link RowNodeWriter}s. See that class for the
+ * internals of each row node.
+ */
+public class RowSectionWriter {
+
+  /***************** fields **************************/
+
+  protected PrefixTreeEncoder prefixTreeEncoder;
+
+  protected PrefixTreeBlockMeta blockMeta;
+
+  protected int numBytes;
+  protected int numAppended = 0;// for tests
+
+  protected ArrayList<TokenizerNode> nonLeaves;
+  protected ArrayList<TokenizerNode> leaves;
+
+  protected int numNonLeaves = 0;
+  protected int numLeaves = 0;
+
+  protected ArrayList<RowNodeWriter> leafWriters;
+  protected ArrayList<RowNodeWriter> nonLeafWriters;
+
+  protected int numLeafWriters;
+  protected int numNonLeafWriters;
+
+
+  /********************* construct **********************/
+
+  public RowSectionWriter() {
+    this.nonLeaves = Lists.newArrayList();
+    this.leaves = Lists.newArrayList();
+    this.leafWriters = Lists.newArrayList();
+    this.nonLeafWriters = Lists.newArrayList();
+  }
+
+  public RowSectionWriter(PrefixTreeEncoder prefixTreeEncoder) {
+    reconstruct(prefixTreeEncoder);
+  }
+
+  public void reconstruct(PrefixTreeEncoder prefixTreeEncoder) {
+    this.prefixTreeEncoder = prefixTreeEncoder;
+    this.blockMeta = prefixTreeEncoder.getBlockMeta();
+    reset();
+  }
+
+  public void reset() {
+    numBytes = 0;
+    numAppended = 0;
+    nonLeaves.clear();
+    leaves.clear();
+    numNonLeaves = 0;
+    numLeaves = 0;
+    numLeafWriters = 0;
+    numNonLeafWriters = 0;
+  }
+
+
+  /****************** methods *******************************/
+
+  public RowSectionWriter compile() {
+    blockMeta.setMaxRowLength(prefixTreeEncoder.getRowTokenizer().getMaxElementLength());
+    prefixTreeEncoder.getRowTokenizer().setNodeFirstInsertionIndexes();
+
+    prefixTreeEncoder.getRowTokenizer().appendNodes(nonLeaves, true, false);
+    numNonLeaves = nonLeaves.size();
+    Tokenizer.setNodeSortedIndexes(nonLeaves, 0);
+    prefixTreeEncoder.getRowTokenizer().appendNodes(leaves, false, true);
+    numLeaves = leaves.size();
+    Tokenizer.setNodeSortedIndexes(leaves, nonLeaves.size());
+
+    // track the starting position of each node in final output
+    int negativeIndex = 0;
+
+    // create leaf writer nodes
+    // leaf widths are known at this point, so add them up
+    int totalLeafBytes = 0;
+    for (int i = leaves.size() - 1; i >= 0; --i) {
+      TokenizerNode leaf = leaves.get(i);
+      RowNodeWriter leafWriter = initializeWriter(leafWriters, numLeafWriters, leaf);
+      ++numLeafWriters;
+      // leaves store all but their first token byte
+      int leafNodeWidth = leafWriter.calculateWidthOverrideOffsetWidth(0);
+      totalLeafBytes += leafNodeWidth;
+      negativeIndex += leafNodeWidth;
+      leaf.setNegativeIndex(negativeIndex);
+    }
+
+    int totalNonLeafBytesWithoutOffsets = 0;
+    int totalChildPointers = 0;
+    for (int i = nonLeaves.size() - 1; i >= 0; --i) {
+      TokenizerNode nonLeaf = nonLeaves.get(i);
+      RowNodeWriter nonLeafWriter = initializeWriter(nonLeafWriters, numNonLeafWriters, nonLeaf);
+      ++numNonLeafWriters;
+      totalNonLeafBytesWithoutOffsets += nonLeafWriter.calculateWidthOverrideOffsetWidth(0);
+      totalChildPointers += nonLeaf.getNumChildren();
+    }
+
+    // figure out how wide our offset FInts are
+    int offsetWidth = 0;
+    while (true) {
+      ++offsetWidth;
+      int offsetBytes = totalChildPointers * offsetWidth;
+      int totalRowBytes = totalNonLeafBytesWithoutOffsets + offsetBytes + totalLeafBytes;
+      if (totalRowBytes < UFIntTool.maxValueForNumBytes(offsetWidth)) {
+        // it fits
+        numBytes = totalRowBytes;
+        break;
+      }
+    }
+    blockMeta.setNextNodeOffsetWidth(offsetWidth);
+
+    // populate negativeIndexes
+    for (int i = nonLeaves.size() - 1; i >= 0; --i) {
+      TokenizerNode nonLeaf = nonLeaves.get(i);
+      int writerIndex = numNonLeaves - i - 1;
+      RowNodeWriter nonLeafWriter = nonLeafWriters.get(writerIndex);
+      int nodeWidth = nonLeafWriter.calculateWidth();
+      negativeIndex += nodeWidth;
+      nonLeaf.setNegativeIndex(negativeIndex);
+    }
+
+    return this;
+  }
+
+  protected RowNodeWriter initializeWriter(List<RowNodeWriter> list, int index,
+      TokenizerNode builderNode) {
+    RowNodeWriter rowNodeWriter = null;
+    //check if there is an existing node we can recycle
+    if (index >= list.size()) {
+      //there are not enough existing nodes, so add a new one which will be retrieved below
+      list.add(new RowNodeWriter(prefixTreeEncoder, builderNode));
+    }
+    rowNodeWriter = list.get(index);
+    rowNodeWriter.reset(builderNode);
+    return rowNodeWriter;
+  }
+
+
+  public void writeBytes(OutputStream os) throws IOException {
+    for (int i = numNonLeafWriters - 1; i >= 0; --i) {
+      RowNodeWriter nonLeafWriter = nonLeafWriters.get(i);
+      nonLeafWriter.write(os);
+    }
+    // duplicates above... written more for clarity right now
+    for (int i = numLeafWriters - 1; i >= 0; --i) {
+      RowNodeWriter leafWriter = leafWriters.get(i);
+      leafWriter.write(os);
+    }
+  }
+
+
+  /***************** static ******************************/
+
+  protected static ArrayList<TokenizerNode> filterByLeafAndReverse(
+      ArrayList<TokenizerNode> ins, boolean leaves) {
+    ArrayList<TokenizerNode> outs = Lists.newArrayList();
+    for (int i = ins.size() - 1; i >= 0; --i) {
+      TokenizerNode n = ins.get(i);
+      if (n.isLeaf() && leaves || (!n.isLeaf() && !leaves)) {
+        outs.add(ins.get(i));
+      }
+    }
+    return outs;
+  }
+
+
+  /************* get/set **************************/
+
+  public int getNumBytes() {
+    return numBytes;
+  }
+
+  public ArrayList<TokenizerNode> getNonLeaves() {
+    return nonLeaves;
+  }
+
+  public ArrayList<TokenizerNode> getLeaves() {
+    return leaves;
+  }
+
+  public ArrayList<RowNodeWriter> getNonLeafWriters() {
+    return nonLeafWriters;
+  }
+
+  public ArrayList<RowNodeWriter> getLeafWriters() {
+    return leafWriters;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenDepthComparator.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenDepthComparator.java
new file mode 100644
index 0000000..d803605
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenDepthComparator.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode.tokenize;
+
+import java.util.Comparator;
+
+/**
+ * Determines order of nodes in the output array.  Maybe possible to optimize further.
+ */
+public class TokenDepthComparator implements Comparator<TokenizerNode> {
+
+  @Override
+  public int compare(TokenizerNode a, TokenizerNode b) {
+    // just throw npe if a or b is null
+
+    // put leaves at the end
+    if (!a.isLeaf() && b.isLeaf()) {
+      return -1;
+    }
+    if (a.isLeaf() && !b.isLeaf()) {
+      return 1;
+    }
+
+    if (a.isLeaf() && b.isLeaf()) {// keep leaves in sorted order (for debugability)
+      return a.getId() < b.getId() ? -1 : 1;
+    }
+
+    // compare depth
+    if (a.getTokenOffset() < b.getTokenOffset()) {
+      return -1;
+    }
+    if (a.getTokenOffset() > b.getTokenOffset()) {
+      return 1;
+    }
+
+    // if same depth, return lower id first. ids are unique
+    return a.getId() < b.getId() ? -1 : 1;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/Tokenizer.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/Tokenizer.java
new file mode 100644
index 0000000..d165bcd
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/Tokenizer.java
@@ -0,0 +1,245 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode.tokenize;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.hbase.util.ArrayUtils;
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.CollectionUtils;
+
+import com.google.common.collect.Lists;
+
+/**
+ * Data structure used in the first stage of PrefixTree encoding:
+ * <li>accepts a sorted stream of ByteRanges
+ * <li>splits them into a set of tokens, each held by a {@link TokenizerNode}
+ * <li>connects the TokenizerNodes via standard java references
+ * <li>keeps a pool of TokenizerNodes and a reusable byte[] for holding all token content
+ * <p><br>
+ * Mainly used for turning Cell rowKeys into a trie, but also used for family and qualifier encoding.
+ */
+public class Tokenizer{
+
+  /***************** fields **************************/
+
+  protected int numArraysAdded = 0;
+  protected long lastNodeId = -1;
+  protected ArrayList<TokenizerNode> nodes;
+  protected int numNodes;
+  protected TokenizerNode root;
+  protected byte[] tokens;
+  protected int tokensLength;
+
+  protected int maxElementLength = 0;
+  // number of levels in the tree assuming root level is 0
+  protected int treeDepth = 0;
+
+
+  /******************* construct *******************/
+
+  public Tokenizer() {
+    this.nodes = Lists.newArrayList();
+    this.tokens = new byte[0];
+  }
+
+  public void reset() {
+    numArraysAdded = 0;
+    lastNodeId = -1;
+    numNodes = 0;
+    tokensLength = 0;
+    root = null;
+    maxElementLength = 0;
+    treeDepth = 0;
+  }
+
+
+  /***************** building *************************/
+
+  public void addAll(ArrayList<ByteRange> sortedByteRanges) {
+    for (int i = 0; i < sortedByteRanges.size(); ++i) {
+      ByteRange byteRange = sortedByteRanges.get(i);
+      addSorted(byteRange);
+    }
+  }
+
+  public void addSorted(final ByteRange bytes) {
+    ++numArraysAdded;
+    if (bytes.getLength() > maxElementLength) {
+      maxElementLength = bytes.getLength();
+    }
+    if (root == null) {
+      // nodeDepth of firstNode (non-root) is 1
+      root = addNode(null, 1, 0, bytes, 0);
+    } else {
+      root.addSorted(bytes);
+    }
+  }
+
+  public void incrementNumOccurrencesOfLatestValue(){
+    CollectionUtils.getLast(nodes).incrementNumOccurrences(1);
+  }
+
+  protected long nextNodeId() {
+    return ++lastNodeId;
+  }
+
+  protected TokenizerNode addNode(TokenizerNode parent, int nodeDepth, int tokenStartOffset,
+      final ByteRange token, int inputTokenOffset) {
+    int inputTokenLength = token.getLength() - inputTokenOffset;
+    int tokenOffset = appendTokenAndRepointByteRange(token, inputTokenOffset);
+    TokenizerNode node = null;
+    if (nodes.size() <= numNodes) {
+      node = new TokenizerNode(this, parent, nodeDepth, tokenStartOffset, tokenOffset,
+          inputTokenLength);
+      nodes.add(node);
+    } else {
+      node = nodes.get(numNodes);
+      node.reset();
+      node.reconstruct(this, parent, nodeDepth, tokenStartOffset, tokenOffset, inputTokenLength);
+    }
+    ++numNodes;
+    return node;
+  }
+
+  protected int appendTokenAndRepointByteRange(final ByteRange token, int inputTokenOffset) {
+    int newOffset = tokensLength;
+    int inputTokenLength = token.getLength() - inputTokenOffset;
+    int newMinimum = tokensLength + inputTokenLength;
+    tokens = ArrayUtils.growIfNecessary(tokens, newMinimum, 2 * newMinimum);
+    token.deepCopySubRangeTo(inputTokenOffset, inputTokenLength, tokens, tokensLength);
+    tokensLength += inputTokenLength;
+    return newOffset;
+  }
+
+  protected void submitMaxNodeDepthCandidate(int nodeDepth) {
+    if (nodeDepth > treeDepth) {
+      treeDepth = nodeDepth;
+    }
+  }
+
+
+  /********************* read ********************/
+
+  public int getNumAdded(){
+    return numArraysAdded;
+  }
+
+  // for debugging
+  public ArrayList<TokenizerNode> getNodes(boolean includeNonLeaves, boolean includeLeaves) {
+    ArrayList<TokenizerNode> nodes = Lists.newArrayList();
+    root.appendNodesToExternalList(nodes, includeNonLeaves, includeLeaves);
+    return nodes;
+  }
+
+  public void appendNodes(List<TokenizerNode> appendTo, boolean includeNonLeaves,
+      boolean includeLeaves) {
+    root.appendNodesToExternalList(appendTo, includeNonLeaves, includeLeaves);
+  }
+
+  public List<byte[]> getArrays() {
+    List<TokenizerNode> nodes = new ArrayList<TokenizerNode>();
+    root.appendNodesToExternalList(nodes, true, true);
+    List<byte[]> byteArrays = Lists.newArrayListWithCapacity(CollectionUtils.nullSafeSize(nodes));
+    for (int i = 0; i < nodes.size(); ++i) {
+      TokenizerNode node = nodes.get(i);
+      for (int j = 0; j < node.getNumOccurrences(); ++j) {
+        byte[] byteArray = node.getNewByteArray();
+        byteArrays.add(byteArray);
+      }
+    }
+    return byteArrays;
+  }
+
+  //currently unused, but working and possibly useful in the future
+  public void getNode(TokenizerRowSearchResult resultHolder, byte[] key, int keyOffset,
+      int keyLength) {
+    root.getNode(resultHolder, key, keyOffset, keyLength);
+  }
+
+
+	/********************** write ***************************/
+
+  public Tokenizer setNodeFirstInsertionIndexes() {
+    root.setInsertionIndexes(0);
+    return this;
+  }
+
+  public static void setNodeSortedIndexes(List<TokenizerNode> nodes, int startIndex) {
+    int sortedIndex = startIndex;
+    for (int i = 0; i < nodes.size(); ++i) {
+      TokenizerNode node = nodes.get(i);
+      node.setNodeSortedIndex(sortedIndex);
+      ++sortedIndex;
+    }
+  }
+
+  public Tokenizer appendOutputArrayOffsets(List<Integer> offsets) {
+    root.appendOutputArrayOffsets(offsets);
+    return this;
+  }
+
+
+  /********************* print/debug ********************/
+
+  protected static final Boolean INCLUDE_FULL_TREE_IN_TO_STRING = false;
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    sb.append(getStructuralString());
+    if (INCLUDE_FULL_TREE_IN_TO_STRING) {
+      for (byte[] bytes : getArrays()) {
+        if (sb.length() > 0) {
+          sb.append("\n");
+        }
+        sb.append(Bytes.toString(bytes));
+      }
+    }
+    return sb.toString();
+  }
+
+  public String getStructuralString() {
+    List<TokenizerNode> nodes = getNodes(true, true);
+    StringBuilder sb = new StringBuilder();
+    for (TokenizerNode node : nodes) {
+      String line = node.getPaddedTokenAndOccurrenceString();
+      sb.append(line + "\n");
+    }
+    return sb.toString();
+  }
+
+
+  /****************** get/set ************************/
+
+  public TokenizerNode getRoot() {
+    return root;
+  }
+
+  public int getMaxElementLength() {
+    return maxElementLength;
+  }
+
+  public int getTreeDepth() {
+    return treeDepth;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenizerNode.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenizerNode.java
new file mode 100644
index 0000000..ab9369f
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenizerNode.java
@@ -0,0 +1,636 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode.tokenize;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.CollectionUtils;
+import org.apache.hadoop.hbase.util.Strings;
+
+import com.google.common.collect.Lists;
+
+/**
+ * Individual node in a Trie structure.  Each node is one of 3 types:
+ * <li>Branch: an internal trie node that may have a token and must have multiple children, but does not represent an
+ * actual input byte[], hence its numOccurrences is 0
+ * <li>Leaf: a node with no children and where numOccurrences is 1+.  It's token represents the last bytes
+ * in the input byte[]s.
+ * <li>Nub: a combination of a branch and leaf.  Its token represents the last bytes of input byte[]s and has 1+ numOccurrences,
+ * but it also has child nodes which represent input byte[]s that add bytes to this nodes input byte[].
+ * <br/><br/>
+ * Example inputs (numInputs=7):
+ * 0: AAA
+ * 1: AAA
+ * 2: AAB
+ * 3: AAB
+ * 4: AAB
+ * 5: AABQQ
+ * 6: AABQQ
+ * <br/><br/>
+ * Resulting TokenizerNodes:
+ * AA <- branch, numOccurrences=0, tokenStartOffset=0, token.length=2
+ * A  <- leaf, numOccurrences=2, tokenStartOffset=2, token.length=1
+ * B  <- nub, numOccurrences=3, tokenStartOffset=2, token.length=1
+ * QQ <- leaf, numOccurrences=2, tokenStartOffset=3, token.length=2
+ * <br/><br/>
+ * numInputs == 7 == sum(numOccurrences) == 0 + 2 + 3 + 2
+ */
+public class TokenizerNode{
+
+  /*
+   * Ref to data structure wrapper
+   */
+  protected Tokenizer builder;
+
+  /****************************************************************** 
+   * Tree content/structure used during tokenization 
+   * ****************************************************************/
+
+  /*
+   * ref to parent trie node
+   */
+  protected TokenizerNode parent;
+
+  /*
+   * node depth in trie, irrespective of each node's token length
+   */
+  protected int nodeDepth;
+
+  /*
+   * start index of this token in original byte[]
+   */
+  protected int tokenStartOffset;
+
+  /*
+   * bytes for this trie node.  can be length 0 in root node
+   */
+  protected ByteRange token;
+
+  /*
+   * A count of occurrences in the input byte[]s, not the trie structure. 0 for branch nodes, 1+ for
+   * nubs and leaves. If the same byte[] is added to the trie multiple times, this is the only thing
+   * that changes in the tokenizer. As a result, duplicate byte[]s are very inexpensive to encode.
+   */
+  protected int numOccurrences;
+
+  /*
+   * The maximum fan-out of a byte[] trie is 256, so there are a maximum of 256
+   * child nodes.
+   */
+  protected ArrayList<TokenizerNode> children;
+
+
+  /*********************************************************************
+   * Fields used later in the encoding process for sorting the nodes into the order they'll be
+   * written to the output byte[].  With these fields, the TokenizerNode and therefore Tokenizer
+   * are not generic data structures but instead are specific to HBase PrefixTree encoding. 
+   ***********************************************************************/
+
+  /*
+   * unique id assigned to each TokenizerNode
+   */
+  protected long id;
+
+  /*
+   * set >=0 for nubs and leaves
+   */
+  protected int firstInsertionIndex = -1;
+
+  /*
+   *
+   */
+  protected int nodeSortedIndex = -1;
+
+  /*
+   *
+   */
+  protected int negativeIndex = 0;
+
+  /*
+   * The index in the output array at which to start writing this node's token bytes.  Influenced
+   * by the lengths of all tokens sorted before this one.
+   */
+  protected int outputArrayOffset = -1;
+
+
+  /*********************** construct *****************************/
+
+  public TokenizerNode(Tokenizer builder, TokenizerNode parent, int nodeDepth,
+      int tokenStartOffset, int tokenOffset, int tokenLength) {
+    this.token = new ByteRange();
+    reconstruct(builder, parent, nodeDepth, tokenStartOffset, tokenOffset, tokenLength);
+    this.children = Lists.newArrayList();
+  }
+
+  /*
+   * Sub-constructor for initializing all fields without allocating a new object.  Used by the
+   * regular constructor.
+   */
+  public void reconstruct(Tokenizer builder, TokenizerNode parent, int nodeDepth,
+      int tokenStartOffset, int tokenOffset, int tokenLength) {
+    this.builder = builder;
+    this.id = builder.nextNodeId();
+    this.parent = parent;
+    this.nodeDepth = nodeDepth;
+    builder.submitMaxNodeDepthCandidate(nodeDepth);
+    this.tokenStartOffset = tokenStartOffset;
+    this.token.set(builder.tokens, tokenOffset, tokenLength);
+    this.numOccurrences = 1;
+  }
+
+  /*
+   * Clear the state of this node so that it looks like it was just allocated.
+   */
+  public void reset() {
+    builder = null;
+    parent = null;
+    nodeDepth = 0;
+    tokenStartOffset = 0;
+    token.clear();
+    numOccurrences = 0;
+    children.clear();// branches & nubs
+
+    // ids/offsets. used during writing to byte[]
+    id = 0;
+    firstInsertionIndex = -1;// set >=0 for nubs and leaves
+    nodeSortedIndex = -1;
+    negativeIndex = 0;
+    outputArrayOffset = -1;
+  }
+
+
+  /************************* building *********************************/
+
+  /*
+   * <li>Only public method used during the tokenization process
+   * <li>Requires that the input ByteRange sort after the previous, and therefore after all previous
+   * inputs
+   * <li>Only looks at bytes of the input array that align with this node's token
+   */
+  public void addSorted(final ByteRange bytes) {// recursively build the tree
+
+    /*
+     * Recurse deeper into the existing trie structure
+     */
+    if (matchesToken(bytes) && CollectionUtils.notEmpty(children)) {
+      TokenizerNode lastChild = CollectionUtils.getLast(children);
+      if (lastChild.partiallyMatchesToken(bytes)) {
+        lastChild.addSorted(bytes);
+        return;
+      }
+    }
+
+    /*
+     * Recursion ended.  We must either
+     * <li>1: increment numOccurrences if this input was equal to the previous
+     * <li>2: convert this node from a leaf to a nub, and add a new child leaf
+     * <li>3: split this node into a branch and leaf, and then add a second leaf
+     */
+
+    // add it as a child of this node
+    int numIdenticalTokenBytes = numIdenticalBytes(bytes);// should be <= token.length
+    int tailOffset = tokenStartOffset + numIdenticalTokenBytes;
+    int tailLength = bytes.getLength() - tailOffset;
+
+    if (numIdenticalTokenBytes == token.getLength()) {
+      if (tailLength == 0) {// identical to this node (case 1)
+        incrementNumOccurrences(1);
+      } else {// identical to this node, but with a few extra tailing bytes. (leaf -> nub) (case 2)
+        int childNodeDepth = nodeDepth + 1;
+        int childTokenStartOffset = tokenStartOffset + numIdenticalTokenBytes;
+        TokenizerNode newChildNode = builder.addNode(this, childNodeDepth, childTokenStartOffset,
+          bytes, tailOffset);
+        addChild(newChildNode);
+      }
+    } else {//numIdenticalBytes > 0, split into branch/leaf and then add second leaf (case 3)
+      split(numIdenticalTokenBytes, bytes);
+    }
+  }
+
+
+  protected void addChild(TokenizerNode node) {
+    node.setParent(this);
+    children.add(node);
+  }
+
+
+  /**
+   * Called when we need to convert a leaf node into a branch with 2 leaves. Comments inside the
+   * method assume we have token BAA starting at tokenStartOffset=0 and are adding BOO. The output
+   * will be 3 nodes:<br/>
+   * <li>1: B <- branch
+   * <li>2: AA <- leaf
+   * <li>3: OO <- leaf
+   *
+   * @param numTokenBytesToRetain => 1 (the B)
+   * @param bytes => BOO
+   */
+  protected void split(int numTokenBytesToRetain, final ByteRange bytes) {
+    int childNodeDepth = nodeDepth;
+    int childTokenStartOffset = tokenStartOffset + numTokenBytesToRetain;
+
+    //create leaf AA
+    TokenizerNode firstChild = builder.addNode(this, childNodeDepth, childTokenStartOffset,
+      token, numTokenBytesToRetain);
+    firstChild.setNumOccurrences(numOccurrences);// do before clearing this node's numOccurrences
+    token.setLength(numTokenBytesToRetain);//shorten current token from BAA to B
+    numOccurrences = 0;//current node is now a branch
+
+    moveChildrenToDifferentParent(firstChild);//point the new leaf (AA) to the new branch (B)
+    addChild(firstChild);//add the new leaf (AA) to the branch's (B's) children
+
+    //create leaf OO
+    TokenizerNode secondChild = builder.addNode(this, childNodeDepth, childTokenStartOffset,
+      bytes, tokenStartOffset + numTokenBytesToRetain);
+    addChild(secondChild);//add the new leaf (00) to the branch's (B's) children
+
+    // we inserted branch node B node as a new level above/before the two children, so increment the
+    // depths of the children below
+    firstChild.incrementNodeDepthRecursive();
+    secondChild.incrementNodeDepthRecursive();
+  }
+
+
+  protected void incrementNodeDepthRecursive() {
+    ++nodeDepth;
+    builder.submitMaxNodeDepthCandidate(nodeDepth);
+    for (int i = 0; i < children.size(); ++i) {
+      children.get(i).incrementNodeDepthRecursive();
+    }
+  }
+
+
+  protected void moveChildrenToDifferentParent(TokenizerNode newParent) {
+    for (int i = 0; i < children.size(); ++i) {
+      TokenizerNode child = children.get(i);
+      child.setParent(newParent);
+      newParent.children.add(child);
+    }
+    children.clear();
+  }
+
+
+	/************************ byte[] utils *************************/
+
+  protected boolean partiallyMatchesToken(ByteRange bytes) {
+    return numIdenticalBytes(bytes) > 0;
+  }
+
+  protected boolean matchesToken(ByteRange bytes) {
+    return numIdenticalBytes(bytes) == getTokenLength();
+  }
+
+  protected int numIdenticalBytes(ByteRange bytes) {
+    return token.numEqualPrefixBytes(bytes, tokenStartOffset);
+  }
+
+
+	/***************** moving nodes around ************************/
+
+  public void appendNodesToExternalList(List<TokenizerNode> appendTo, boolean includeNonLeaves,
+      boolean includeLeaves) {
+    if (includeNonLeaves && !isLeaf() || includeLeaves && isLeaf()) {
+      appendTo.add(this);
+    }
+    for (int i = 0; i < children.size(); ++i) {
+      TokenizerNode child = children.get(i);
+      child.appendNodesToExternalList(appendTo, includeNonLeaves, includeLeaves);
+    }
+  }
+
+  public int setInsertionIndexes(int nextIndex) {
+    int newNextIndex = nextIndex;
+    if (hasOccurrences()) {
+      setFirstInsertionIndex(nextIndex);
+      newNextIndex += numOccurrences;
+    }
+    for (int i = 0; i < children.size(); ++i) {
+      TokenizerNode child = children.get(i);
+      newNextIndex = child.setInsertionIndexes(newNextIndex);
+    }
+    return newNextIndex;
+  }
+
+  public void appendOutputArrayOffsets(List<Integer> offsets) {
+    if (hasOccurrences()) {
+      offsets.add(outputArrayOffset);
+    }
+    for (int i = 0; i < children.size(); ++i) {
+      TokenizerNode child = children.get(i);
+      child.appendOutputArrayOffsets(offsets);
+    }
+  }
+
+
+  /***************** searching *********************************/
+
+  public void getNode(TokenizerRowSearchResult resultHolder, byte[] key, int keyOffset,
+      int keyLength) {
+    int thisNodeDepthPlusLength = tokenStartOffset + token.getLength();
+
+    // quick check if the key is shorter than this node (may not work for binary search)
+    if (CollectionUtils.isEmpty(children)) {
+      if (thisNodeDepthPlusLength < keyLength) {// ran out of bytes
+        resultHolder.set(TokenizerRowSearchPosition.NO_MATCH, null);
+        return;
+      }
+    }
+
+    // all token bytes must match
+    for (int i = 0; i < token.getLength(); ++i) {
+      if (key[tokenStartOffset + keyOffset + i] != token.get(i)) {
+        // TODO return whether it's before or after so we can binary search
+        resultHolder.set(TokenizerRowSearchPosition.NO_MATCH, null);
+        return;
+      }
+    }
+
+    if (thisNodeDepthPlusLength == keyLength && numOccurrences > 0) {
+      resultHolder.set(TokenizerRowSearchPosition.MATCH, this);// MATCH
+      return;
+    }
+
+    if (CollectionUtils.notEmpty(children)) {
+      // TODO binary search the children
+      for (int i = 0; i < children.size(); ++i) {
+        TokenizerNode child = children.get(i);
+        child.getNode(resultHolder, key, keyOffset, keyLength);
+        if (resultHolder.isMatch()) {
+          return;
+        } else if (resultHolder.getDifference() == TokenizerRowSearchPosition.BEFORE) {
+          // passed it, so it doesn't exist
+          resultHolder.set(TokenizerRowSearchPosition.NO_MATCH, null);
+          return;
+        }
+        // key is still AFTER the current node, so continue searching
+      }
+    }
+
+    // checked all children (or there were no children), and didn't find it
+    resultHolder.set(TokenizerRowSearchPosition.NO_MATCH, null);
+    return;
+  }
+
+
+  /****************** writing back to byte[]'s *************************/
+
+  public byte[] getNewByteArray() {
+    byte[] arrayToFill = new byte[tokenStartOffset + token.getLength()];
+    fillInBytes(arrayToFill);
+    return arrayToFill;
+  }
+
+  public void fillInBytes(byte[] arrayToFill) {
+    for (int i = 0; i < token.getLength(); ++i) {
+      arrayToFill[tokenStartOffset + i] = token.get(i);
+    }
+    if (parent != null) {
+      parent.fillInBytes(arrayToFill);
+    }
+  }
+
+
+  /************************** printing ***********************/
+
+  @Override
+  public String toString() {
+    String s = "";
+    if (parent == null) {
+      s += "R:";
+    } else {
+      s += (getBnlIndicator(false)) + Bytes.toString(parent.getNewByteArray());
+    }
+    s += "[" + Bytes.toString(token.deepCopyToNewArray()) + "]";
+    if (numOccurrences > 0) {
+      s += "x" + numOccurrences;
+    }
+    return s;
+  }
+
+  public String getPaddedTokenAndOccurrenceString() {
+    StringBuilder sb = new StringBuilder();
+    sb.append(getBnlIndicator(true));
+    sb.append(Strings.padFront(numOccurrences + "", ' ', 3));
+    sb.append(Strings.padFront(nodeDepth + "", ' ', 3));
+    if (outputArrayOffset >= 0) {
+      sb.append(Strings.padFront(outputArrayOffset + "", ' ', 3));
+    }
+    sb.append("  ");
+    for (int i = 0; i < tokenStartOffset; ++i) {
+      sb.append(" ");
+    }
+    sb.append(Bytes.toString(token.deepCopyToNewArray()).replaceAll(" ", "_"));
+    return sb.toString();
+  }
+
+  public String getBnlIndicator(boolean indent) {
+    if (indent) {
+      if (isNub()) {
+        return " N ";
+      }
+      return isBranch() ? "B  " : "  L";
+    }
+    if (isNub()) {
+      return "N";
+    }
+    return isBranch() ? "B" : "L";
+  }
+
+
+	/********************** count different node types ********************/
+
+  public int getNumBranchNodesIncludingThisNode() {
+    if (isLeaf()) {
+      return 0;
+    }
+    int totalFromThisPlusChildren = isBranch() ? 1 : 0;
+    for (int i = 0; i < children.size(); ++i) {
+      TokenizerNode child = children.get(i);
+      totalFromThisPlusChildren += child.getNumBranchNodesIncludingThisNode();
+    }
+    return totalFromThisPlusChildren;
+  }
+
+  public int getNumNubNodesIncludingThisNode() {
+    if (isLeaf()) {
+      return 0;
+    }
+    int totalFromThisPlusChildren = isNub() ? 1 : 0;
+    for (int i = 0; i < children.size(); ++i) {
+      TokenizerNode child = children.get(i);
+      totalFromThisPlusChildren += child.getNumNubNodesIncludingThisNode();
+    }
+    return totalFromThisPlusChildren;
+  }
+
+  public int getNumLeafNodesIncludingThisNode() {
+    if (isLeaf()) {
+      return 1;
+    }
+    int totalFromChildren = 0;
+    for (int i = 0; i < children.size(); ++i) {
+      TokenizerNode child = children.get(i);
+      totalFromChildren += child.getNumLeafNodesIncludingThisNode();
+    }
+    return totalFromChildren;
+  }
+
+
+  /*********************** simple read methods *******************************/
+
+  public int getNodeDepth() {
+    return nodeDepth;
+  }
+
+  public int getTokenLength() {
+    return token.getLength();
+  }
+
+  public boolean hasOccurrences() {
+    return numOccurrences > 0;
+  }
+
+  public boolean isRoot() {
+    return this.parent == null;
+  }
+
+  public int getNumChildren() {
+    return CollectionUtils.nullSafeSize(children);
+  }
+
+  public TokenizerNode getLastChild() {
+    if (CollectionUtils.isEmpty(children)) {
+      return null;
+    }
+    return CollectionUtils.getLast(children);
+  }
+
+  public boolean isLeaf() {
+    return CollectionUtils.isEmpty(children) && hasOccurrences();
+  }
+
+  public boolean isBranch() {
+    return CollectionUtils.notEmpty(children) && !hasOccurrences();
+  }
+
+  public boolean isNub() {
+    return CollectionUtils.notEmpty(children) && hasOccurrences();
+  }
+
+
+  /********************** simple write methods *************************/
+
+  /**
+   * Each occurrence > 1 indicates a repeat of the previous entry.  This can be called directly by
+   * an external class without going through the process of detecting a repeat if it is a known
+   * repeat by some external mechanism.  PtEncoder uses this when adding cells to a row if it knows
+   * the new cells are part of the current row.
+   * @param d increment by this amount
+   */
+  public void incrementNumOccurrences(int d) {
+    numOccurrences += d;
+  }
+
+
+  /************************* autogenerated get/set ******************/
+
+  public int getTokenOffset() {
+    return tokenStartOffset;
+  }
+
+  public TokenizerNode getParent() {
+    return parent;
+  }
+
+  public ByteRange getToken() {
+    return token;
+  }
+
+  public int getNumOccurrences() {
+    return numOccurrences;
+  }
+
+  public void setParent(TokenizerNode parent) {
+    this.parent = parent;
+  }
+
+  public void setNumOccurrences(int numOccurrences) {
+    this.numOccurrences = numOccurrences;
+  }
+
+  public ArrayList<TokenizerNode> getChildren() {
+    return children;
+  }
+
+  public long getId() {
+    return id;
+  }
+
+  public int getFirstInsertionIndex() {
+    return firstInsertionIndex;
+  }
+
+  public void setFirstInsertionIndex(int firstInsertionIndex) {
+    this.firstInsertionIndex = firstInsertionIndex;
+  }
+
+  public int getNodeSortedIndex() {
+    return nodeSortedIndex;
+  }
+
+  public void setNodeSortedIndex(int nodeSortedIndex) {
+    this.nodeSortedIndex = nodeSortedIndex;
+  }
+
+  public int getNegativeIndex() {
+    return negativeIndex;
+  }
+
+  public void setNegativeIndex(int negativeIndex) {
+    this.negativeIndex = negativeIndex;
+  }
+
+  public int getOutputArrayOffset() {
+    return outputArrayOffset;
+  }
+
+  public void setOutputArrayOffset(int outputArrayOffset) {
+    this.outputArrayOffset = outputArrayOffset;
+  }
+
+  public void setId(long id) {
+    this.id = id;
+  }
+
+  public void setBuilder(Tokenizer builder) {
+    this.builder = builder;
+  }
+
+  public void setTokenOffset(int tokenOffset) {
+    this.tokenStartOffset = tokenOffset;
+  }
+
+  public void setToken(ByteRange token) {
+    this.token = token;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenizerRowSearchPosition.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenizerRowSearchPosition.java
new file mode 100644
index 0000000..a6c8a13
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenizerRowSearchPosition.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode.tokenize;
+
+public enum TokenizerRowSearchPosition {
+
+	/*
+	 * where is the key relative to our current position in the tree
+	 *
+	 * for example, the current tree node is "BEFORE" the key we are seeking
+	 */
+
+	AFTER,//the key is after this tree node, so keep searching
+	BEFORE,//in a binary search, this tells us to back up
+	MATCH,//the current node is a full match
+	NO_MATCH,//might as well return a value more informative than null
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenizerRowSearchResult.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenizerRowSearchResult.java
new file mode 100644
index 0000000..1396da1
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/encode/tokenize/TokenizerRowSearchResult.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.encode.tokenize;
+
+
+/**
+ * for recursively searching a PtBuilder
+ */
+public class TokenizerRowSearchResult{
+
+  /************ fields ************************/
+
+  protected TokenizerRowSearchPosition difference;
+  protected TokenizerNode matchingNode;
+
+
+  /*************** construct *****************/
+
+  public TokenizerRowSearchResult() {
+  }
+
+  public TokenizerRowSearchResult(TokenizerRowSearchPosition difference) {
+    this.difference = difference;
+  }
+
+  public TokenizerRowSearchResult(TokenizerNode matchingNode) {
+    this.difference = TokenizerRowSearchPosition.MATCH;
+    this.matchingNode = matchingNode;
+  }
+
+
+  /*************** methods **********************/
+
+  public boolean isMatch() {
+    return TokenizerRowSearchPosition.MATCH == difference;
+  }
+
+
+  /************* get/set ***************************/
+
+  public TokenizerRowSearchPosition getDifference() {
+    return difference;
+  }
+
+  public TokenizerNode getMatchingNode() {
+    return matchingNode;
+  }
+
+  public void set(TokenizerRowSearchPosition difference, TokenizerNode matchingNode) {
+    this.difference = difference;
+    this.matchingNode = matchingNode;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/scanner/CellScanner.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/scanner/CellScanner.java
new file mode 100644
index 0000000..6febe68
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/scanner/CellScanner.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.scanner;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.classification.InterfaceStability;
+import org.apache.hbase.Cell;
+
+/**
+ * Alternate name may be CellInputStream
+ * <p/>
+ * An interface for iterating through a sequence of cells. Similar to Java's Iterator, but without
+ * the hasNext() or remove() methods. The hasNext() method is problematic because it may require
+ * actually loading the next object, which in turn requires storing the previous object somewhere.
+ * The core data block decoder should be as fast as possible, so we push the complexity and
+ * performance expense of concurrently tracking multiple cells to layers above the CellScanner.
+ * <p/>
+ * The getCurrentCell() method will return a reference to a Cell implementation. This reference may
+ * or may not point to a reusable cell implementation, so users of the CellScanner should not, for
+ * example, accumulate a List of Cells. All of the references may point to the same object, which
+ * would be the latest state of the underlying Cell. In short, the Cell is mutable.
+ * <p/>
+ * At a minimum, an implementation will need to be able to advance from one cell to the next in a
+ * LinkedList fashion. The nextQualifier(), nextFamily(), and nextRow() methods can all be
+ * implemented by calling nextCell(), however, if the DataBlockEncoding supports random access into
+ * the block then it may provide smarter versions of these methods.
+ * <p/>
+ * Typical usage:
+ * 
+ * <pre>
+ * while (scanner.nextCell()) {
+ *   Cell cell = scanner.getCurrentCell();
+ *   // do something
+ * }
+ * </pre>
+ */
+@InterfaceAudience.Private
+@InterfaceStability.Unstable
+public interface CellScanner{
+
+  /**
+   * Reset any state in the scanner so it appears it was freshly opened.
+   */
+  void resetToBeforeFirstEntry();
+
+  /**
+   * @return the current Cell which may be mutable
+   */
+  Cell getCurrent();
+
+  /**
+   * Advance the scanner 1 cell.
+   * @return true if the next cell is found and getCurrentCell() will return a valid Cell
+   */
+  boolean next();
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/scanner/CellSearcher.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/scanner/CellSearcher.java
new file mode 100644
index 0000000..eeaf12a
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/scanner/CellSearcher.java
@@ -0,0 +1,109 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.scanner;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.classification.InterfaceStability;
+import org.apache.hbase.Cell;
+import org.apache.hbase.cell.CellScannerPosition;
+
+/**
+ * Methods for seeking to a random {@link Cell} inside a sorted collection of cells. Indicates that
+ * the implementation is able to navigate between cells without iterating forward through every
+ * cell.
+ */
+@InterfaceAudience.Private
+@InterfaceStability.Unstable
+public interface CellSearcher extends ReversibleCellScanner {
+
+  /**
+   * Do everything within this scanner's power to find the key. Look forward and backwards.
+   * <p/>
+   * Abort as soon as we know it can't be found, possibly leaving the Searcher in an invalid state.
+   * <p/>
+   * @param key position the CellScanner exactly on this key
+   * @return true if the cell existed and getCurrentCell() holds a valid cell
+   */
+  boolean positionAt(Cell key);
+
+  /**
+   * Same as positionAt(..), but go to the extra effort of finding the previous key if there's no
+   * exact match.
+   * <p/>
+   * @param key position the CellScanner on this key or the closest cell before
+   * @return AT if exact match<br/>
+   *         BEFORE if on last cell before key<br/>
+   *         BEFORE_FIRST if key was before the first cell in this scanner's scope
+   */
+  CellScannerPosition positionAtOrBefore(Cell key);
+
+  /**
+   * Same as positionAt(..), but go to the extra effort of finding the next key if there's no exact
+   * match.
+   * <p/>
+   * @param key position the CellScanner on this key or the closest cell after
+   * @return AT if exact match<br/>
+   *         AFTER if on first cell after key<br/>
+   *         AFTER_LAST if key was after the last cell in this scanner's scope
+   */
+  CellScannerPosition positionAtOrAfter(Cell key);
+
+  /**
+   * Note: Added for backwards compatibility with {@link #KeyValueScanner.reseek()}
+   * <p/>
+   * Look for the key, but only look after the current position. Probably not needed for an
+   * efficient tree implementation, but is important for implementations without random access such
+   * as unencoded KeyValue blocks.
+   * <p/>
+   * @param key position the CellScanner exactly on this key
+   * @return true if getCurrent() holds a valid cell
+   */
+  boolean seekForwardTo(Cell key);
+
+  /**
+   * Same as seekForwardTo(..), but go to the extra effort of finding the next key if there's no
+   * exact match.
+   * <p/>
+   * @param key
+   * @return AT if exact match<br/>
+   *         AFTER if on first cell after key<br/>
+   *         AFTER_LAST if key was after the last cell in this scanner's scope
+   */
+  CellScannerPosition seekForwardToOrBefore(Cell key);
+
+  /**
+   * Same as seekForwardTo(..), but go to the extra effort of finding the next key if there's no
+   * exact match.
+   * <p/>
+   * @param key
+   * @return AT if exact match<br/>
+   *         AFTER if on first cell after key<br/>
+   *         AFTER_LAST if key was after the last cell in this scanner's scope
+   */
+  CellScannerPosition seekForwardToOrAfter(Cell key);
+
+  /**
+   * Note: This may not be appropriate to have in the interface.  Need to investigate.
+   * <p/>
+   * Position the scanner in an invalid state after the last cell: CellScannerPosition.AFTER_LAST.
+   * This is used by tests and for handling certain edge cases.
+   */
+  void positionAfterLastCell();
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/scanner/ReversibleCellScanner.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/scanner/ReversibleCellScanner.java
new file mode 100644
index 0000000..7297f9d
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/codec/prefixtree/scanner/ReversibleCellScanner.java
@@ -0,0 +1,54 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.scanner;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.classification.InterfaceStability;
+
+/**
+ * An extension of CellScanner indicating the scanner supports iterating backwards through cells.
+ * <p>
+ * Note: This was not added to suggest that HBase should support client facing reverse Scanners, but
+ * because some {@link CellSearcher} implementations, namely PrefixTree, need a method of backing up
+ * if the positionAt(..) method goes past the requested cell.
+ */
+@InterfaceAudience.Private
+@InterfaceStability.Unstable
+public interface ReversibleCellScanner extends CellScanner {
+
+  /**
+   * Try to position the scanner one Cell before the current position.
+   * @return true if the operation was successful, meaning getCurrentCell() will return a valid
+   *         Cell.<br/>
+   *         false if there were no previous cells, meaning getCurrentCell() will return null.
+   *         Scanner position will be {@link CellScannerPosition.BEFORE_FIRST}
+   */
+  boolean previous();
+
+  /**
+   * Try to position the scanner in the row before the current row.
+   * @param endOfRow true for the last cell in the previous row; false for the first cell
+   * @return true if the operation was successful, meaning getCurrentCell() will return a valid
+   *         Cell.<br/>
+   *         false if there were no previous cells, meaning getCurrentCell() will return null.
+   *         Scanner position will be {@link CellScannerPosition.BEFORE_FIRST}
+   */
+  boolean previousRow(boolean endOfRow);
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/util/ByteUtils.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/ByteUtils.java
new file mode 100644
index 0000000..027620d
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/ByteUtils.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.IterableUtils;
+
+public class ByteUtils {
+
+  public static boolean equals(List<byte[]> a, List<byte[]> b) {
+    if (a == null && b == null) {
+      return true;
+    }
+    if (a == null && b != null) {
+      return false;
+    }
+    if (a != null && b == null) {
+      return false;
+    }
+    if (a.size() != b.size()) {
+      return false;
+    }
+    for (int i = 0; i < a.size(); ++i) {
+      if (!Bytes.equals(a.get(i), b.get(i))) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  public static boolean isSorted(Collection<byte[]> arrays) {
+    byte[] previous = new byte[0];
+    for (byte[] array : IterableUtils.nullSafe(arrays)) {
+      if (Bytes.compareTo(previous, array) > 0) {
+        return false;
+      }
+      previous = array;
+    }
+    return true;
+  }
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/util/byterange/ByteRangeSet.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/byterange/ByteRangeSet.java
new file mode 100644
index 0000000..307dcfe
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/byterange/ByteRangeSet.java
@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.byterange;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.hadoop.hbase.util.ArrayUtils;
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.Bytes;
+
+import com.google.common.collect.Lists;
+
+/**
+ * Performance oriented class for de-duping and storing arbitrary byte[]'s arriving in non-sorted
+ * order.  Appends individual byte[]'s to a single big byte[] to avoid overhead and garbage.
+ * <p>
+ * Current implementations are {@link ByteRangeHashSet} and {@link ByteRangeTreeSet}, but other
+ * options might be a trie-oriented ByteRangeTrieSet, etc
+ */
+public abstract class ByteRangeSet {
+
+  /******************** fields **********************/
+
+  protected byte[] byteAppender;
+  protected int numBytes;
+
+  protected Map<ByteRange, Integer> uniqueIndexByUniqueRange;
+
+  protected ArrayList<ByteRange> uniqueRanges;
+  protected int numUniqueRanges = 0;
+
+  protected int[] uniqueRangeIndexByInsertionId;
+  protected int numInputs;
+
+  protected List<Integer> sortedIndexByUniqueIndex;
+  protected int[] sortedIndexByInsertionId;
+  protected ArrayList<ByteRange> sortedRanges;
+
+
+  /****************** construct **********************/
+
+  protected ByteRangeSet() {
+    this.byteAppender = new byte[0];
+    this.uniqueRanges = Lists.newArrayList();
+    this.uniqueRangeIndexByInsertionId = new int[0];
+    this.sortedIndexByUniqueIndex = Lists.newArrayList();
+    this.sortedIndexByInsertionId = new int[0];
+    this.sortedRanges = Lists.newArrayList();
+  }
+
+  public void reset() {
+    numBytes = 0;
+    uniqueIndexByUniqueRange.clear();
+    numUniqueRanges = 0;
+    numInputs = 0;
+    sortedIndexByUniqueIndex.clear();
+    sortedRanges.clear();
+  }
+
+
+  /*************** abstract *************************/
+
+  public abstract void addToSortedRanges();
+
+
+  /**************** methods *************************/
+
+  /**
+   * Check if the incoming byte range exists.  If not, add it to the backing byteAppender[] and
+   * insert it into the tracking Map uniqueIndexByUniqueRange.
+   */
+  public void add(ByteRange bytes) {
+    Integer index = uniqueIndexByUniqueRange.get(bytes);
+    if (index == null) {
+      index = store(bytes);
+    }
+    int minLength = numInputs + 1;
+    uniqueRangeIndexByInsertionId = ArrayUtils.growIfNecessary(uniqueRangeIndexByInsertionId,
+        minLength, 2 * minLength);
+    uniqueRangeIndexByInsertionId[numInputs] = index;
+    ++numInputs;
+  }
+
+  protected int store(ByteRange bytes) {
+    int indexOfNewElement = numUniqueRanges;
+    if (uniqueRanges.size() <= numUniqueRanges) {
+      uniqueRanges.add(new ByteRange());
+    }
+    ByteRange storedRange = uniqueRanges.get(numUniqueRanges);
+    int neededBytes = numBytes + bytes.getLength();
+    byteAppender = ArrayUtils.growIfNecessary(byteAppender, neededBytes, 2 * neededBytes);
+    bytes.deepCopyTo(byteAppender, numBytes);
+    storedRange.set(byteAppender, numBytes, bytes.getLength());// this isn't valid yet
+    numBytes += bytes.getLength();
+    uniqueIndexByUniqueRange.put(storedRange, indexOfNewElement);
+    int newestUniqueIndex = numUniqueRanges;
+    ++numUniqueRanges;
+    return newestUniqueIndex;
+  }
+
+  public ByteRangeSet compile() {
+    addToSortedRanges();
+    for (int i = 0; i < sortedRanges.size(); ++i) {
+      sortedIndexByUniqueIndex.add(null);// need to grow the size
+    }
+    // TODO move this to an invert(int[]) util method
+    for (int i = 0; i < sortedIndexByUniqueIndex.size(); ++i) {
+      int uniqueIndex = uniqueIndexByUniqueRange.get(sortedRanges.get(i));
+      sortedIndexByUniqueIndex.set(uniqueIndex, i);
+    }
+    sortedIndexByInsertionId = ArrayUtils.growIfNecessary(sortedIndexByInsertionId, numInputs,
+        numInputs);
+    for (int i = 0; i < numInputs; ++i) {
+      int uniqueRangeIndex = uniqueRangeIndexByInsertionId[i];
+      int sortedIndex = sortedIndexByUniqueIndex.get(uniqueRangeIndex);
+      sortedIndexByInsertionId[i] = sortedIndex;
+    }
+    return this;
+  }
+
+  public ByteRange getForInputIndex(int insertionId) {
+    return uniqueRanges.get(uniqueRangeIndexByInsertionId[insertionId]);
+  }
+
+  public int getSortedIndexForInsertionId(int insertionId) {
+    return sortedIndexByInsertionId[insertionId];
+  }
+
+  public int size() {
+    return uniqueIndexByUniqueRange.size();
+  }
+
+  public long getTotalSize() {
+    return numBytes;
+  }
+
+
+  /***************** standard methods ************************/
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    int i = 0;
+    for (ByteRange r : sortedRanges) {
+      if (i > 0) {
+        sb.append("\n");
+      }
+      sb.append(i + " " + Bytes.toStringBinary(r.deepCopyToNewArray()));
+      ++i;
+    }
+    sb.append("\ntotalSize:" + getTotalSize());
+    sb.append("\navgSize:" + getAvgSize());
+    return sb.toString();
+  }
+
+
+  /**************** get/set *****************************/
+
+  public ArrayList<ByteRange> getSortedRanges() {
+    return sortedRanges;
+  }
+
+  public long getAvgSize() {
+    return numBytes / numUniqueRanges;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/util/byterange/impl/ByteRangeHashSet.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/byterange/impl/ByteRangeHashSet.java
new file mode 100644
index 0000000..f9d52aa
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/byterange/impl/ByteRangeHashSet.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.byterange.impl;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.CollectionUtils;
+import org.apache.hadoop.hbase.util.IterableUtils;
+import org.apache.hbase.util.byterange.ByteRangeSet;
+
+/**
+ * This is probably the best implementation at the moment, though a HashMap produces garbage when
+ * adding a new element to it.  We can probably create a tighter implementation without pointers
+ * or garbage.
+ */
+public class ByteRangeHashSet extends ByteRangeSet {
+
+  /************************ constructors *****************************/
+
+  public ByteRangeHashSet() {
+    this.uniqueIndexByUniqueRange = new HashMap<ByteRange, Integer>();
+  }
+
+  public ByteRangeHashSet(List<ByteRange> rawByteArrays) {
+    for (ByteRange in : IterableUtils.nullSafe(rawByteArrays)) {
+      add(in);
+    }
+  }
+
+  @Override
+  public void addToSortedRanges() {
+    sortedRanges.addAll(CollectionUtils.nullSafe(uniqueIndexByUniqueRange.keySet()));
+    Collections.sort(sortedRanges);
+  }
+
+}
\ No newline at end of file
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/util/byterange/impl/ByteRangeTreeSet.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/byterange/impl/ByteRangeTreeSet.java
new file mode 100644
index 0000000..5c8e0c4
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/byterange/impl/ByteRangeTreeSet.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.byterange.impl;
+
+import java.util.List;
+import java.util.TreeMap;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.CollectionUtils;
+import org.apache.hadoop.hbase.util.IterableUtils;
+import org.apache.hbase.util.byterange.ByteRangeSet;
+
+/**
+ * Not currently used in production, but here as a benchmark comparison against ByteRangeHashSet.
+ */
+public class ByteRangeTreeSet extends ByteRangeSet {
+
+  /************************ constructors *****************************/
+
+  public ByteRangeTreeSet() {
+    this.uniqueIndexByUniqueRange = new TreeMap<ByteRange,Integer>();
+  }
+
+  public ByteRangeTreeSet(List<ByteRange> rawByteArrays) {
+    this();//needed to initialize the TreeSet
+    for(ByteRange in : IterableUtils.nullSafe(rawByteArrays)){
+      add(in);
+    }
+  }
+
+  @Override
+  public void addToSortedRanges() {
+    sortedRanges.addAll(CollectionUtils.nullSafe(uniqueIndexByUniqueRange.keySet()));
+  }
+
+}
\ No newline at end of file
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/util/io/OutputStreamUtils.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/io/OutputStreamUtils.java
new file mode 100644
index 0000000..9278a98
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/io/OutputStreamUtils.java
@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.io;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+
+/**
+ * Convenience methods for writing to an OutputStream.  They're currently unchecking IOExceptions
+ * because prefix-tree only writes to ByteArrayOutputStreams which should not throw IOExceptions,
+ * but maybe there is a better way to rethrow them.  RuntimeIOException?
+ */
+public class OutputStreamUtils {
+
+  public static void write(OutputStream os, byte b) throws IOException {
+    // try {
+    os.write(b);
+    // } catch (IOException e) {
+    // throw new RuntimeException(e);
+    // }
+  }
+
+  public static void write(OutputStream os, byte[] bytes) throws IOException {
+    write(os, bytes, 0, bytes.length);
+  }
+
+  public static void write(OutputStream os, byte[] bytes, int offset, int length)
+      throws IOException {
+    // try {
+    os.write(bytes, offset, length);
+    // } catch (IOException e) {
+    // throw new RuntimeException(e);
+    // }
+  }
+
+  public static void write(OutputStream os, ByteRange byteRange) throws IOException {
+    write(os, byteRange.getBytes(), byteRange.getOffset(), byteRange.getLength());
+  }
+
+  public static void write(OutputStream os, ByteRange byteRange, int byteRangeInnerOffset)
+      throws IOException {
+    write(os, byteRange.getBytes(), byteRange.getOffset() + byteRangeInnerOffset,
+      byteRange.getLength() - byteRangeInnerOffset);
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/util/vint/UFIntTool.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/vint/UFIntTool.java
new file mode 100644
index 0000000..40a845a
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/vint/UFIntTool.java
@@ -0,0 +1,116 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.vint;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import org.apache.hbase.util.io.OutputStreamUtils;
+
+/**
+ * UFInt is an abbreviation for Unsigned Fixed-width Integer.
+ *
+ * This class converts between positive ints and 1-4 bytes that represent the int.  All input ints
+ * must be positive.  Max values stored in N bytes are:
+ *
+ * N=1: 2^8  =>           256
+ * N=2: 2^16 =>        65,536
+ * N=3: 2^24 =>    16,777,216
+ * N=4: 2^31 => 2,147,483,648 (Integer.MAX_VALUE)
+ *
+ * Currently does not support 2^32, but could be supported by modifying the interface to accept
+ * long inputs and outputs.
+ *
+ * This was created to get most of the memory savings of a variable length integer when encoding
+ * an array of input integers, but to fix the number of bytes for each integer to the number needed
+ * to store the maximum integer in the array.  This enables a binary search to be performed on the
+ * array of encoded integers.
+ *
+ * PrefixTree nodes often store offsets into a block that can fit into 1 or 2 bytes.  Note that if
+ * the maximum value of an array of numbers needs 2 bytes, then it's likely that a majority of the
+ * numbers will also require 2 bytes.
+ *
+ * warnings:
+ *  * no input validation for max performance
+ *  * no negatives
+ */
+public class UFIntTool {
+
+  public static long maxValueForNumBytes(int numBytes) {
+    return (1L << (numBytes * 8)) - 1;
+  }
+
+  public static int numBytes(final long value) {
+    if (value == 0) {
+      return 1;
+    }// 0 doesn't work with the formula below
+    return (64 + 7 - Long.numberOfLeadingZeros(value)) / 8;
+  }
+
+  public static byte[] getBytes(int outputWidth, final long value) {
+    byte[] bytes = new byte[outputWidth];
+    writeBytes(outputWidth, value, bytes, 0);
+    return bytes;
+  }
+
+  public static void writeBytes(int outputWidth, final long value, byte[] bytes, int offset) {
+    bytes[offset + outputWidth - 1] = (byte) value;
+    for (int i = outputWidth - 2; i >= 0; --i) {
+      bytes[offset + i] = (byte) (value >>> (outputWidth - i - 1) * 8);
+    }
+  }
+
+  static final long[] MASKS = new long[]{
+    (long)255,
+	  (long)255 << 8,
+	  (long)255 << 16,
+	  (long)255 << 24,
+	  (long)255 << 32,
+	  (long)255 << 40,
+	  (long)255 << 48,
+	  (long)255 << 56
+  };
+
+  public static void writeBytes(int outputWidth, final long value, OutputStream os) throws IOException {
+    for (int i = outputWidth - 1; i >= 0; --i) {
+      OutputStreamUtils.write(os, (byte) ((value & MASKS[i]) >>> (8 * i)));
+    }
+  }
+
+  public static long fromBytes(final byte[] bytes) {
+    long value = 0;
+    value |= bytes[0] & 0xff;// these seem to do ok without casting the byte to int
+    for (int i = 1; i < bytes.length; ++i) {
+      value <<= 8;
+      value |= bytes[i] & 0xff;
+    }
+    return value;
+  }
+
+  public static long fromBytes(final byte[] bytes, final int offset, final int width) {
+    long value = 0;
+    value |= bytes[0 + offset] & 0xff;// these seem to do ok without casting the byte to int
+    for (int i = 1; i < width; ++i) {
+      value <<= 8;
+      value |= bytes[i + offset] & 0xff;
+    }
+    return value;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/util/vint/UVIntTool.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/vint/UVIntTool.java
new file mode 100644
index 0000000..04a323a
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/vint/UVIntTool.java
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.vint;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import org.apache.hbase.util.io.OutputStreamUtils;
+
+/**
+ * Simple Variable Length Integer encoding.  Left bit of 0 means we are on the last bit.
+ *
+ * Need more doc.
+ */
+public class UVIntTool {
+
+  public static final byte
+    BYTE_7_RIGHT_BITS_SET = 127,
+    BYTE_LEFT_BIT_SET = -128;
+
+  public static final long
+    INT_3_RIGHT_BITS_SET = 127,
+    INT_8TH_BIT_SET = 128;
+
+  public static final byte[]
+    MAX_VALUE_BYTES = new byte[] { -1, -1, -1, -1, 7 };
+
+  /********************* int -> bytes **************************/
+
+  public static int numBytes(int in) {
+    if (in == 0) {
+      // doesn't work with the formula below
+      return 1;
+    }
+    return (38 - Integer.numberOfLeadingZeros(in)) / 7;// 38 comes from 32+(7-1)
+  }
+
+  public static byte[] getBytes(int value) {
+    int numBytes = numBytes(value);
+    byte[] bytes = new byte[numBytes];
+    int remainder = value;
+    for (int i = 0; i < numBytes - 1; ++i) {
+      // set the left bit
+      bytes[i] = (byte) ((remainder & INT_3_RIGHT_BITS_SET) | INT_8TH_BIT_SET);
+      remainder >>= 7;
+    }
+    // do not set the left bit
+    bytes[numBytes - 1] = (byte) (remainder & INT_3_RIGHT_BITS_SET);
+    return bytes;
+  }
+
+  public static int writeBytes(int value, OutputStream os) throws IOException {
+    int numBytes = numBytes(value);
+    int remainder = value;
+    for (int i = 0; i < numBytes - 1; ++i) {
+      // set the left bit
+      OutputStreamUtils.write(os, (byte) ((remainder & INT_3_RIGHT_BITS_SET) | INT_8TH_BIT_SET));
+      remainder >>= 7;
+    }
+    // do not set the left bit
+    OutputStreamUtils.write(os, (byte) (remainder & INT_3_RIGHT_BITS_SET));
+    return numBytes;
+  }
+
+  /******************** bytes -> int **************************/
+
+  public static int getInt(byte[] bytes) {
+    return getInt(bytes, 0);
+  }
+
+  public static int getInt(byte[] bytes, int offset) {
+    int value = 0;
+    for (int i = 0;; ++i) {
+      byte b = bytes[offset + i];
+      int shifted = BYTE_7_RIGHT_BITS_SET & b;// kill leftmost bit
+      shifted <<= 7 * i;
+      value |= shifted;
+      if (b >= 0) {
+        break;
+      }
+    }
+    return value;
+  }
+
+  public static int getInt(InputStream is) throws IOException {
+    int value = 0;
+    int i = 0;
+    int b;
+    do{
+      b = is.read();
+      int shifted = BYTE_7_RIGHT_BITS_SET & b;// kill leftmost bit
+      shifted <<= 7 * i;
+      value |= shifted;
+      ++i;
+    }while(b > Byte.MAX_VALUE);
+    return value;
+  }
+}
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hbase/util/vint/UVLongTool.java b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/vint/UVLongTool.java
new file mode 100644
index 0000000..b35b4a8
--- /dev/null
+++ b/hbase-prefix-tree/src/main/java/org/apache/hbase/util/vint/UVLongTool.java
@@ -0,0 +1,108 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.vint;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import org.apache.hbase.util.io.OutputStreamUtils;
+
+public class UVLongTool{
+
+  public static final byte
+    BYTE_7_RIGHT_BITS_SET = 127,
+    BYTE_LEFT_BIT_SET = -128;
+
+  public static final long
+    LONG_7_RIGHT_BITS_SET = 127,
+    LONG_8TH_BIT_SET = 128;
+
+  public static final byte[]
+    MAX_VALUE_BYTES = new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, 127 };
+
+
+  /********************* int -> bytes **************************/
+
+  public static int numBytes(long in) {// do a check for illegal arguments if not protected
+    if (in == 0) {
+      return 1;
+    }// doesn't work with the formula below
+    return (70 - Long.numberOfLeadingZeros(in)) / 7;// 70 comes from 64+(7-1)
+  }
+
+  public static byte[] getBytes(long value) {
+    int numBytes = numBytes(value);
+    byte[] bytes = new byte[numBytes];
+    long remainder = value;
+    for (int i = 0; i < numBytes - 1; ++i) {
+      bytes[i] = (byte) ((remainder & LONG_7_RIGHT_BITS_SET) | LONG_8TH_BIT_SET);// set the left bit
+      remainder >>= 7;
+    }
+    bytes[numBytes - 1] = (byte) (remainder & LONG_7_RIGHT_BITS_SET);// do not set the left bit
+    return bytes;
+  }
+
+  public static int writeBytes(long value, OutputStream os) throws IOException {
+    int numBytes = numBytes(value);
+    long remainder = value;
+    for (int i = 0; i < numBytes - 1; ++i) {
+      // set the left bit
+      OutputStreamUtils.write(os, (byte) ((remainder & LONG_7_RIGHT_BITS_SET) | LONG_8TH_BIT_SET));
+      remainder >>= 7;
+    }
+    // do not set the left bit
+    OutputStreamUtils.write(os, (byte) (remainder & LONG_7_RIGHT_BITS_SET));
+    return numBytes;
+  }
+
+  /******************** bytes -> int **************************/
+
+  public static long getLong(byte[] bytes) {
+    return getLong(bytes, 0);
+  }
+
+  public static long getLong(byte[] bytes, int offset) {
+    long value = 0;
+    for (int i = 0;; ++i) {
+      byte b = bytes[offset + i];
+      long shifted = BYTE_7_RIGHT_BITS_SET & b;// kill leftmost bit
+      shifted <<= 7 * i;
+      value |= shifted;
+      if (b >= 0) {
+        break;
+      }// first bit was 0, so that's the last byte in the VarLong
+    }
+    return value;
+  }
+
+  public static long getLong(InputStream is) throws IOException {
+    long value = 0;
+    int i = 0;
+    int b;
+    do {
+      b = is.read();
+      long shifted = BYTE_7_RIGHT_BITS_SET & b;// kill leftmost bit
+      shifted <<= 7 * i;
+      value |= shifted;
+      ++i;
+    } while (b > Byte.MAX_VALUE);
+    return value;
+  }
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/keyvalue/KeyValueToolTests.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/keyvalue/KeyValueToolTests.java
new file mode 100644
index 0000000..219fc10
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/keyvalue/KeyValueToolTests.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.keyvalue;
+
+import java.nio.ByteBuffer;
+import java.util.Collection;
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValueTestUtil;
+import org.apache.hbase.codec.prefixtree.row.TestRows;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class KeyValueToolTests {
+
+  @Parameters
+  public static Collection<Object[]> parameters() {
+    return new TestRows.InMemory().getAllAsObjectArray();
+  }
+
+  private TestRows rows;
+
+  public KeyValueToolTests(TestRows testRows) {
+    this.rows = testRows;
+  }
+
+  @Test
+  public void testRoundTripToBytes() {
+    List<KeyValue> kvs = rows.getInputs();
+    ByteBuffer bb = KeyValueTestUtil.toByteBufferAndRewind(kvs, false);
+    List<KeyValue> roundTrippedKvs = KeyValueTestUtil.rewindThenToList(bb, false);
+    Assert.assertArrayEquals(kvs.toArray(), roundTrippedKvs.toArray());
+  }
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/PrefixTreeTestConstants.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/PrefixTreeTestConstants.java
new file mode 100644
index 0000000..675934f
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/PrefixTreeTestConstants.java
@@ -0,0 +1,28 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree;
+
+import org.apache.hadoop.hbase.util.Bytes;
+
+public class PrefixTreeTestConstants {
+
+  public static final byte[]
+  	TEST_CF = Bytes.toBytes("cfDefault");
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/blockmeta/PrefixTreeBlockMetaTests.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/blockmeta/PrefixTreeBlockMetaTests.java
new file mode 100644
index 0000000..480a0de
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/blockmeta/PrefixTreeBlockMetaTests.java
@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.blockmeta;
+
+import java.io.ByteArrayOutputStream;
+import java.nio.ByteBuffer;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class PrefixTreeBlockMetaTests {
+
+  static int BLOCK_START = 123;
+
+  static PrefixTreeBlockMeta createSample() {
+    PrefixTreeBlockMeta m = new PrefixTreeBlockMeta();
+    m.setNumMetaBytes(0);
+    m.setNumKeyValueBytes(3195);
+
+    m.setNumRowBytes(0);
+    m.setNumFamilyBytes(3);
+    m.setNumQualifierBytes(12345);
+    m.setNumTimestampBytes(23456);
+    m.setNumMvccVersionBytes(5);
+    m.setNumValueBytes(34567);
+
+    m.setNextNodeOffsetWidth(3);
+    m.setFamilyOffsetWidth(1);
+    m.setQualifierOffsetWidth(2);
+    m.setTimestampIndexWidth(1);
+    m.setMvccVersionIndexWidth(2);
+    m.setValueOffsetWidth(8);
+    m.setValueLengthWidth(3);
+
+    m.setRowTreeDepth(11);
+    m.setMaxRowLength(200);
+    m.setMaxQualifierLength(50);
+
+    m.setMinTimestamp(1318966363481L);
+    m.setTimestampDeltaWidth(3);
+    m.setMinMvccVersion(100L);
+    m.setMvccVersionDeltaWidth(4);
+
+    m.setAllSameType(false);
+    m.setAllTypes(KeyValue.Type.Delete.getCode());
+
+    m.setNumUniqueRows(88);
+    m.setNumUniqueFamilies(1);
+    m.setNumUniqueQualifiers(56);
+    return m;
+  }
+
+	@Test public void testStreamSerialization(){
+		PrefixTreeBlockMeta original = createSample();
+		ByteArrayOutputStream os = new ByteArrayOutputStream(10000);
+		original.writeVariableBytesToOutputStream(os);
+		ByteBuffer buffer = ByteBuffer.wrap(os.toByteArray());
+		PrefixTreeBlockMeta roundTripped = new PrefixTreeBlockMeta(buffer);
+		Assert.assertTrue(original.equals(roundTripped));
+	}
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/TestSortedByteArrays.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/TestSortedByteArrays.java
new file mode 100644
index 0000000..e4a0946
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/TestSortedByteArrays.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.builder;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.apache.hbase.codec.prefixtree.builder.data.TestSortedByteArrays1;
+import org.apache.hbase.codec.prefixtree.builder.data.TestSortedByteArrays2;
+
+import com.google.common.collect.Lists;
+
+public interface TestSortedByteArrays {
+
+  List<byte[]> getInputs();
+  List<byte[]> getOutputs();
+
+  public static class InMemory {
+    public Collection<Object[]> getAllAsObjectArray() {
+      List<Object[]> all = Lists.newArrayList();
+      all.add(new Object[] { new TestSortedByteArrays1() });
+      all.add(new Object[] { new TestSortedByteArrays2() });
+      return all;
+    }
+  }
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/TestTreeDepth.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/TestTreeDepth.java
new file mode 100644
index 0000000..7b64cf5
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/TestTreeDepth.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.builder;
+
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.Tokenizer;
+import org.junit.Test;
+import org.mortbay.log.Log;
+
+import com.google.common.collect.Lists;
+
+public class TestTreeDepth {
+
+  @Test
+  public void testSingleNode() {
+    List<String> inputs = Lists.newArrayList("a");
+    testInternal(inputs, 1);
+  }
+
+  @Test
+  public void testSimpleBranch() {
+    List<String> inputs = Lists.newArrayList("a", "aa", "ab");
+    testInternal(inputs, 2);
+  }
+
+  @Test
+  public void testEmptyRoot() {
+    List<String> inputs = Lists.newArrayList("a", "b");
+    testInternal(inputs, 2);
+  }
+
+  @Test
+  public void testRootAsNub() {
+    List<String> inputs = Lists.newArrayList("a", "aa");
+    testInternal(inputs, 2);
+  }
+
+  @Test
+  public void testRootAsNubPlusNub() {
+    List<String> inputs = Lists.newArrayList("a", "aa", "aaa");
+    testInternal(inputs, 3);
+  }
+
+  @Test
+  public void testEmptyRootPlusNub() {
+    List<String> inputs = Lists.newArrayList("a", "aa", "b");
+    testInternal(inputs, 3);
+  }
+
+  @Test
+  public void testSplitDistantAncestor() {
+    List<String> inputs = Lists.newArrayList("a", "ac", "acd", "b");
+    testInternal(inputs, 4);
+  }
+
+  protected void testInternal(List<String> inputs, int expectedTreeDepth) {
+    Log.warn("init logger");
+    Tokenizer builder = new Tokenizer();
+    for (String s : inputs) {
+//      System.out.println(s);
+      ByteRange b = new ByteRange(Bytes.toBytes(s));
+      builder.addSorted(b);
+//      System.out.println(builder);
+    }
+    Assert.assertEquals(1, builder.getRoot().getNodeDepth());
+    Assert.assertEquals(expectedTreeDepth, builder.getTreeDepth());
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/TokenizerTests.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/TokenizerTests.java
new file mode 100644
index 0000000..79d4b13
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/TokenizerTests.java
@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.builder;
+
+import java.util.Collection;
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.Tokenizer;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.TokenizerNode;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.TokenizerRowSearchResult;
+import org.apache.hbase.util.ByteUtils;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class TokenizerTests {
+
+  @Parameters
+  public static Collection<Object[]> parameters() {
+    return new TestSortedByteArrays.InMemory().getAllAsObjectArray();
+  }
+
+  private List<byte[]> inputs;
+  private Tokenizer builder;
+  private List<byte[]> roundTripped;
+
+  public TokenizerTests(TestSortedByteArrays sortedByteArrays) {
+    this.inputs = sortedByteArrays.getInputs();
+    this.builder = new Tokenizer();
+    for (byte[] array : inputs) {
+      builder.addSorted(new ByteRange(array));
+    }
+    this.roundTripped = builder.getArrays();
+  }
+
+  @Test
+  public void testReaderRoundTrip() {
+    Assert.assertEquals(inputs.size(), roundTripped.size());
+    Assert.assertTrue(ByteUtils.isSorted(roundTripped));
+    Assert.assertTrue(ByteUtils.equals(inputs, roundTripped));
+  }
+
+  @Test
+  public void testSearching() {
+    for (byte[] input : inputs) {
+      TokenizerRowSearchResult resultHolder = new TokenizerRowSearchResult();
+      builder.getNode(resultHolder, input, 0, input.length);
+      TokenizerNode n = resultHolder.getMatchingNode();
+      byte[] output = n.getNewByteArray();
+      Assert.assertTrue(Bytes.equals(input, output));
+    }
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/data/TestSortedByteArrays1.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/data/TestSortedByteArrays1.java
new file mode 100644
index 0000000..ebe3bea
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/data/TestSortedByteArrays1.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.builder.data;
+
+import java.util.List;
+
+import org.apache.hbase.codec.prefixtree.builder.TestSortedByteArrays;
+import org.apache.hbase.util.bytes.StringByteUtils;
+
+import com.google.common.collect.Lists;
+
+public class TestSortedByteArrays1 implements TestSortedByteArrays {
+
+  static List<byte[]> d = Lists.newArrayList();
+  static {
+    List<String> s = Lists.newArrayList();
+    s.add("abc");// nub
+    s.add("abcde");// leaf
+    s.add("bbc");// causes root to split and have empty token
+    s.add("bbc");// makes numOccurrences=2 on the bbc node
+    s.add("cd");// just to get another node after the numOccurrences=2
+    d = StringByteUtils.getUtf8ByteArrays(s);
+  }
+
+  @Override
+  public List<byte[]> getInputs() {
+    return d;
+  }
+
+  @Override
+  public List<byte[]> getOutputs() {
+    return d;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/data/TestSortedByteArrays2.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/data/TestSortedByteArrays2.java
new file mode 100644
index 0000000..75fff2a
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/builder/data/TestSortedByteArrays2.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.builder.data;
+
+import java.util.List;
+
+import org.apache.hbase.codec.prefixtree.builder.TestSortedByteArrays;
+import org.apache.hbase.util.bytes.StringByteUtils;
+
+import com.google.common.collect.Lists;
+
+public class TestSortedByteArrays2 implements TestSortedByteArrays {
+
+  static List<byte[]> d = Lists.newArrayList();
+  static {
+    /*
+     * tricky little combination because the acegi token will partially match abdfi, but when you
+     * descend into abdfi, it will not fully match
+     */
+    List<String> s = Lists.newArrayList();
+    s.add("abdfh");
+    s.add("abdfi");
+    s.add("acegi");
+    d = StringByteUtils.getUtf8ByteArrays(s);
+  }
+
+  @Override
+  public List<byte[]> getInputs() {
+    return d;
+  }
+
+  @Override
+  public List<byte[]> getOutputs() {
+    return d;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/ColumnBuilderTests.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/ColumnBuilderTests.java
new file mode 100644
index 0000000..a969643
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/ColumnBuilderTests.java
@@ -0,0 +1,122 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.column;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.ByteRangeTool;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.decode.column.ColumnReader;
+import org.apache.hbase.codec.prefixtree.encode.column.ColumnSectionWriter;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.Tokenizer;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.TokenizerNode;
+import org.apache.hbase.util.ByteUtils;
+import org.apache.hbase.util.byterange.impl.ByteRangeTreeSet;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import com.google.common.collect.Lists;
+
+@RunWith(Parameterized.class)
+public class ColumnBuilderTests {
+
+  @Parameters
+  public static Collection<Object[]> parameters() {
+    return new TestColumns.InMemory().getAllAsObjectArray();
+  }
+
+  /*********** fields **********************************/
+
+  protected TestColumns columns;
+  protected ByteRangeTreeSet columnSorter;
+  protected List<ByteRange> sortedUniqueColumns;
+  protected PrefixTreeBlockMeta blockMeta;
+  protected Tokenizer builder;
+  protected ColumnSectionWriter writer;
+  protected byte[] bytes;
+  protected byte[] buffer;
+  protected ColumnReader reader;
+
+  /*************** construct ****************************/
+
+  public ColumnBuilderTests(TestColumns columns) {
+    this.columns = columns;
+    List<ByteRange> inputs = columns.getInputs();
+    this.columnSorter = new ByteRangeTreeSet(inputs);
+    this.sortedUniqueColumns = columnSorter.compile().getSortedRanges();
+    List<byte[]> copies = ByteRangeTool.copyToNewArrays(sortedUniqueColumns);
+    Assert.assertTrue(ByteUtils.isSorted(copies));
+    this.blockMeta = new PrefixTreeBlockMeta();
+    this.blockMeta.setNumMetaBytes(0);
+    this.blockMeta.setNumRowBytes(0);
+    this.builder = new Tokenizer();
+  }
+
+  /************* methods ********************************/
+
+  @Test
+  public void testReaderRoundTrip() throws IOException {
+    for (int i = 0; i < sortedUniqueColumns.size(); ++i) {
+      ByteRange column = sortedUniqueColumns.get(i);
+      builder.addSorted(column);
+    }
+    List<byte[]> builderOutputArrays = builder.getArrays();
+    for (int i = 0; i < builderOutputArrays.size(); ++i) {
+      byte[] inputArray = sortedUniqueColumns.get(i).deepCopyToNewArray();
+      byte[] outputArray = builderOutputArrays.get(i);
+      boolean same = Bytes.equals(inputArray, outputArray);
+      Assert.assertTrue(same);
+    }
+    Assert.assertEquals(sortedUniqueColumns.size(), builderOutputArrays.size());
+
+    writer = new ColumnSectionWriter(blockMeta, builder, false);
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    writer.compile().writeBytes(baos);
+    bytes = baos.toByteArray();
+    buffer = new byte[blockMeta.getMaxQualifierLength()];
+    reader = new ColumnReader(buffer, false);
+    reader.initOnBlock(blockMeta, bytes);
+
+    List<TokenizerNode> builderNodes = Lists.newArrayList();
+    builder.appendNodes(builderNodes, true, true);
+    int i = 0;
+    for (TokenizerNode builderNode : builderNodes) {
+      if (!builderNode.hasOccurrences()) {
+        continue;
+      }
+      Assert.assertEquals(1, builderNode.getNumOccurrences());// we de-duped before adding to
+                                                              // builder
+      int position = builderNode.getOutputArrayOffset();
+      byte[] output = reader.populateBuffer(position).copyBufferToNewArray();
+      boolean same = Bytes.equals(sortedUniqueColumns.get(i).deepCopyToNewArray(), output);
+      Assert.assertTrue(same);
+      ++i;
+    }
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/TestColumns.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/TestColumns.java
new file mode 100644
index 0000000..558d8c6
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/TestColumns.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.column;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hbase.codec.prefixtree.column.data.TestColumnsRandom;
+import org.apache.hbase.codec.prefixtree.column.data.TestColumnsSimple;
+
+import com.google.common.collect.Lists;
+
+public interface TestColumns {
+
+  List<ByteRange> getInputs();
+  List<ByteRange> getOutputs();
+
+  public static class InMemory {
+    public Collection<Object[]> getAllAsObjectArray() {
+      List<Object[]> all = Lists.newArrayList();
+      all.add(new Object[] { new TestColumnsSimple() });
+      for (int powerOf2 = 0; powerOf2 < 16; ++powerOf2) {
+        all.add(new Object[] { new TestColumnsRandom(1 << powerOf2) });
+      }
+      return all;
+    }
+  }
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/data/TestColumnsRandom.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/data/TestColumnsRandom.java
new file mode 100644
index 0000000..3fefaa5
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/data/TestColumnsRandom.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.column.data;
+
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.test.RedundantKVGenerator;
+import org.apache.hbase.codec.prefixtree.column.TestColumns;
+import org.apache.hbase.util.byterange.ByteRangeSet;
+import org.apache.hbase.util.byterange.impl.ByteRangeTreeSet;
+
+import com.google.common.collect.Lists;
+
+public class TestColumnsRandom implements TestColumns {
+
+  private List<ByteRange> inputs = Lists.newArrayList();
+  private List<ByteRange> outputs = Lists.newArrayList();
+
+  public TestColumnsRandom(int numColumns) {
+    RedundantKVGenerator generator = new RedundantKVGenerator();
+    ByteRangeSet sortedColumns = new ByteRangeTreeSet();
+    List<KeyValue> d = generator.generateTestKeyValues(numColumns);
+    for (KeyValue col : d) {
+      ByteRange colRange = new ByteRange(col.getQualifier());
+      inputs.add(colRange);
+      sortedColumns.add(colRange);
+    }
+    for (ByteRange col : sortedColumns.compile().getSortedRanges()) {
+      outputs.add(col);
+    }
+  }
+
+  @Override
+  public List<ByteRange> getInputs() {
+    return inputs;
+  }
+
+  @Override
+  public List<ByteRange> getOutputs() {
+    return outputs;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/data/TestColumnsSimple.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/data/TestColumnsSimple.java
new file mode 100644
index 0000000..cea7e56
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/column/data/TestColumnsSimple.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.column.data;
+
+import java.util.List;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.ByteRangeTool;
+import org.apache.hbase.codec.prefixtree.column.TestColumns;
+import org.apache.hbase.util.bytes.StringByteUtils;
+
+import com.google.common.collect.Lists;
+
+public class TestColumnsSimple implements TestColumns {
+
+  @Override
+  public List<ByteRange> getInputs() {
+    List<String> d = Lists.newArrayList();
+    d.add("abc");
+    d.add("abcde");
+    d.add("abc");
+    d.add("bbc");
+    d.add("abc");
+    return ByteRangeTool.fromArrays(StringByteUtils.getUtf8ByteArrays(d));
+  }
+
+  @Override
+  public List<ByteRange> getOutputs() {
+    List<String> d = Lists.newArrayList();
+    d.add("abc");
+    d.add("abcde");
+    d.add("bbc");
+    return ByteRangeTool.fromArrays(StringByteUtils.getUtf8ByteArrays(d));
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/BaseTestRows.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/BaseTestRows.java
new file mode 100644
index 0000000..a4cbc65
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/BaseTestRows.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row;
+
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hbase.cell.CellComparator;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.scanner.CellSearcher;
+
+import com.google.common.collect.Lists;
+
+public abstract class BaseTestRows implements TestRows {
+
+  @Override
+  public List<Integer> getRowStartIndexes() {
+    List<Integer> rowStartIndexes = Lists.newArrayList();
+    rowStartIndexes.add(0);
+    List<KeyValue> inputs = getInputs();
+    for (int i = 1; i < inputs.size(); ++i) {
+      KeyValue lastKv = inputs.get(i - 1);
+      KeyValue kv = inputs.get(i);
+      if (!CellComparator.equalsRow(lastKv, kv)) {
+        rowStartIndexes.add(i);
+      }
+    }
+    return rowStartIndexes;
+  }
+
+  @Override
+  public void individualBlockMetaAssertions(PrefixTreeBlockMeta blockMeta) {
+  }
+
+  @Override
+  public void individualSearcherAssertions(CellSearcher searcher) {
+  }
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/RowBuilderTests.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/RowBuilderTests.java
new file mode 100644
index 0000000..f213971
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/RowBuilderTests.java
@@ -0,0 +1,196 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Collection;
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValueTool;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.Cell;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.decode.PrefixTreeArraySearcher;
+import org.apache.hbase.codec.prefixtree.encode.PrefixTreeEncoder;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import com.google.common.collect.Lists;
+
+@RunWith(Parameterized.class)
+public class RowBuilderTests {
+
+	protected static int BLOCK_START = 7;
+
+	@Parameters
+	public static Collection<Object[]> parameters(){
+	  List<Object[]> parameters = Lists.newArrayList();
+	  for(TestRows testRows : TestRows.InMemory.getAll()){
+      parameters.add(new Object[]{testRows});
+	  }
+		return parameters;
+	}
+
+	protected TestRows rows;
+	protected List<KeyValue> inputKvs;
+	protected boolean includeMemstoreTS = true;
+	protected ByteArrayOutputStream os;
+	protected PrefixTreeEncoder encoder;
+	protected int totalBytes;
+	protected PrefixTreeBlockMeta blockMetaWriter;
+	protected byte[] outputBytes;
+	protected ByteBuffer buffer;
+	protected ByteArrayInputStream is;
+	protected PrefixTreeBlockMeta blockMetaReader;
+	protected byte[] inputBytes;
+	protected PrefixTreeArraySearcher searcher;
+
+	public RowBuilderTests(TestRows testRows){
+		this.rows = testRows;
+	}
+
+	@Before 
+	public void compile() throws IOException{
+    os = new ByteArrayOutputStream(1<<20);
+    encoder = new PrefixTreeEncoder(os, includeMemstoreTS);
+
+    int counter = 0;
+    inputKvs = rows.getInputs();
+    for(KeyValue kv : inputKvs){
+      encoder.write(kv);
+//      System.out.println(counter+" "+kv);
+//      System.out.println(encoder.getRowTokenizer());
+      ++counter;
+    }
+    encoder.flush();
+    totalBytes = encoder.getTotalBytes();
+    blockMetaWriter = encoder.getBlockMeta();
+    outputBytes = os.toByteArray();
+
+    //start reading, but save the assertions for @Test methods
+    buffer = ByteBuffer.wrap(outputBytes);
+    blockMetaReader = new PrefixTreeBlockMeta(buffer);
+
+    searcher = new PrefixTreeArraySearcher(blockMetaReader, blockMetaReader.getRowTreeDepth(),
+        blockMetaReader.getMaxRowLength(), blockMetaReader.getMaxQualifierLength());
+    searcher.initOnBlock(blockMetaReader, outputBytes, includeMemstoreTS);
+	}
+
+  @Test
+  public void testEncoderOutput() throws IOException {
+    Assert.assertEquals(totalBytes, outputBytes.length);
+    Assert.assertEquals(blockMetaWriter, blockMetaReader);
+  }
+
+  @Test
+  public void testForwardScanner() {
+    int counter = -1;
+    while (searcher.next()) {
+      ++counter;
+      KeyValue inputKv = rows.getInputs().get(counter);
+      KeyValue outputKv = KeyValueTool.copyToNewKeyValue(searcher.getCurrent());
+//      System.out.println(StringUtils.padFront(counter + "", ' ', 5) + " out:" + outputKv);
+      assertKeyAndValueEqual(inputKv, outputKv);
+    }
+    // assert same number of cells
+    Assert.assertEquals(rows.getInputs().size(), counter + 1);
+  }
+
+
+  /**
+   * probably not needed since testReverseScannerWithJitter() below is more thorough
+   */
+  @Test
+  public void testReverseScanner() {
+    searcher.positionAfterLastCell();
+    int counter = -1;
+    while (searcher.previous()) {
+      ++counter;
+//      System.out.println(counter+" "+searcher);
+      int oppositeIndex = rows.getInputs().size() - counter - 1;
+      KeyValue inputKv = rows.getInputs().get(oppositeIndex);
+      KeyValue outputKv = KeyValueTool.copyToNewKeyValue(searcher.getCurrent());
+      assertKeyAndValueEqual(inputKv, outputKv);
+    }
+    Assert.assertEquals(rows.getInputs().size(), counter + 1);
+  }
+
+
+  /**
+   * Exercise the nubCellsRemain variable by calling next+previous.  NubCellsRemain is basically
+   * a special fan index.
+   */
+  @Test
+  public void testReverseScannerWithJitter() {
+    searcher.positionAfterLastCell();
+    int counter = -1;
+    while (true) {
+      boolean foundCell = searcher.previous();
+      if(!foundCell){
+        break;
+      }
+      ++counter;
+//      System.out.println(counter+" "+searcher);
+
+      //a next+previous should cancel out
+      if(!searcher.isAfterLast()){
+        searcher.next();
+//        System.out.println(counter+" "+searcher);
+        searcher.previous();
+      }
+
+//      System.out.println(counter+" "+searcher);
+      int oppositeIndex = rows.getInputs().size() - counter - 1;
+      KeyValue inputKv = rows.getInputs().get(oppositeIndex);
+      KeyValue outputKv = KeyValueTool.copyToNewKeyValue(searcher.getCurrent());
+      assertKeyAndValueEqual(inputKv, outputKv);
+    }
+    Assert.assertEquals(rows.getInputs().size(), counter + 1);
+  }
+
+  @Test
+  public void testIndividualBlockMetaAssertions() {
+    rows.individualBlockMetaAssertions(blockMetaReader);
+  }
+
+
+	/**************** helper **************************/
+
+  protected void assertKeyAndValueEqual(Cell expected, Cell actual) {
+    // assert keys are equal (doesn't compare values)
+    Assert.assertEquals(expected, actual);
+    if(includeMemstoreTS){
+      Assert.assertEquals(expected.getMvccVersion(), actual.getMvccVersion());
+    }
+    // assert values equal
+    Assert.assertTrue(Bytes.equals(expected.getValueArray(), expected.getValueOffset(),
+      expected.getValueLength(), actual.getValueArray(), actual.getValueOffset(),
+      actual.getValueLength()));
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/TestPtSearcher.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/TestPtSearcher.java
new file mode 100644
index 0000000..1171855
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/TestPtSearcher.java
@@ -0,0 +1,200 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Collection;
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValueTool;
+import org.apache.hadoop.hbase.util.CollectionUtils;
+import org.apache.hbase.Cell;
+import org.apache.hbase.cell.CellComparator;
+import org.apache.hbase.cell.CellScannerPosition;
+import org.apache.hbase.codec.prefixtree.decode.DecoderFactory;
+import org.apache.hbase.codec.prefixtree.encode.PrefixTreeEncoder;
+import org.apache.hbase.codec.prefixtree.scanner.CellSearcher;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class TestPtSearcher {
+
+	protected static int BLOCK_START = 7;
+
+	@Parameters
+	public static Collection<Object[]> parameters(){
+		return new TestRows.InMemory().getAllAsObjectArray();
+	}
+
+	protected TestRows rows;
+	protected ByteBuffer block;
+
+	public TestPtSearcher(TestRows testRows) throws IOException{
+		this.rows = testRows;
+		ByteArrayOutputStream os = new ByteArrayOutputStream(1<<20);
+		PrefixTreeEncoder kvBuilder = new PrefixTreeEncoder(os, true);
+		for(KeyValue kv : rows.getInputs()){
+			kvBuilder.write(kv);
+		}
+		kvBuilder.flush();
+		byte[] outputBytes = os.toByteArray();
+		this.block = ByteBuffer.wrap(outputBytes);
+	}
+
+	
+  @Test
+  public void testScanForwards() throws IOException {
+    CellSearcher searcher = null;
+    try {
+      searcher = DecoderFactory.checkOut(block, true);
+
+      int i = -1;
+      while (searcher.next()) {
+        ++i;
+        KeyValue inputCell = rows.getInputs().get(i);
+        Cell outputCell = searcher.getCurrent();
+
+        // check all 3 permutations of equals()
+        Assert.assertEquals(inputCell, outputCell);
+        Assert.assertEquals(outputCell, inputCell);
+        Assert.assertTrue(CellComparator.equals(inputCell, outputCell));
+      }
+      Assert.assertEquals(rows.getInputs().size(), i + 1);
+    } finally {
+      DecoderFactory.checkIn(searcher);
+    }
+  }
+
+
+  @Test
+  public void testScanBackwards() throws IOException {
+    CellSearcher searcher = null;
+    try {
+      searcher = DecoderFactory.checkOut(block, true);
+      searcher.positionAfterLastCell();
+      int i = -1;
+      while (searcher.previous()) {
+        ++i;
+        int oppositeIndex = rows.getInputs().size() - i - 1;
+        KeyValue inputKv = rows.getInputs().get(oppositeIndex);
+        KeyValue outputKv = KeyValueTool.copyToNewKeyValue(searcher.getCurrent());
+        Assert.assertEquals(inputKv, outputKv);
+      }
+      Assert.assertEquals(rows.getInputs().size(), i + 1);
+    } finally {
+      DecoderFactory.checkIn(searcher);
+    }
+  }
+
+
+  @Test
+  public void testRandomSeekHits() throws IOException {
+    CellSearcher searcher = null;
+    try {
+      searcher = DecoderFactory.checkOut(block, true);
+      for (KeyValue kv : rows.getInputs()) {
+        boolean hit = searcher.positionAt(kv);
+        Assert.assertTrue(hit);
+        Cell foundKv = searcher.getCurrent();
+        Assert.assertTrue(CellComparator.equals(kv, foundKv));
+      }
+    } finally {
+      DecoderFactory.checkIn(searcher);
+    }
+  }
+
+  /**
+   * very hard to test nubs with this thing since the a nextRowKey function will usually skip them
+   */
+  @Test
+  public void testRandomSeekMisses() throws IOException {
+    CellSearcher searcher = null;
+    List<Integer> rowStartIndexes = rows.getRowStartIndexes();
+    try {
+      searcher = DecoderFactory.checkOut(block, true);
+      for (int i=0; i < rows.getInputs().size(); ++i) {
+        KeyValue kv = rows.getInputs().get(i);
+//        System.out.println(i);
+//        System.out.println(kv);
+
+        //nextRow
+        KeyValue inputNextRow = KeyValueTool.createFirstKeyInNextRow(kv);
+//        System.out.println(inputNextRow);
+//        //expect a hit if we are not on the last row
+//        CellScannerPosition expectedPosition = i < CollectionUtils.getLast(rowStartIndexes)
+//            ? CellScannerPosition.AFTER : CellScannerPosition.AFTER_LAST;
+//        CellScannerPosition position = searcher.positionAtOrAfter(inputNextRow);
+//        System.out.println(searcher.getCurrent());
+//        Assert.assertEquals(expectedPosition, position);
+
+        CellScannerPosition position = searcher.positionAtOrBefore(inputNextRow);
+//        System.out.println(searcher.getCurrent());
+        boolean isFirstInRow = rowStartIndexes.contains(i);
+        if(isFirstInRow){
+          int rowIndex = rowStartIndexes.indexOf(i);
+          if(rowIndex < rowStartIndexes.size() - 1){
+            int lastKvInRowI = rowStartIndexes.get(rowIndex + 1) - 1;
+            Assert.assertEquals(CellScannerPosition.BEFORE, position);
+            /*
+             * can't get this to work between nubs like rowB\x00 <-> rowBB
+             */
+//            Assert.assertEquals(rows.getInputs().get(lastKvInRowI), searcher.getCurrentCell());
+          }
+        }
+
+        //previous KV
+        KeyValue inputPreviousKv = KeyValueTool.previousKey(kv);
+        boolean hit = searcher.positionAt(inputPreviousKv);
+        Assert.assertFalse(hit);
+        position = searcher.positionAtOrAfter(inputPreviousKv);
+        if(CollectionUtils.isLastIndex(rows.getInputs(), i)){
+          Assert.assertTrue(CellScannerPosition.AFTER_LAST == position);
+        }else{
+          Assert.assertTrue(CellScannerPosition.AFTER == position);
+          /*
+           * arghh - why i+1 instead of i?
+           */
+          Assert.assertEquals(rows.getInputs().get(i+1), searcher.getCurrent());
+        }
+      }
+    } finally {
+      DecoderFactory.checkIn(searcher);
+    }
+  }
+
+
+  @Test
+  public void testRandomSeekIndividualAssertions() throws IOException {
+    CellSearcher searcher = null;
+    try {
+      searcher = DecoderFactory.checkOut(block, true);
+      rows.individualSearcherAssertions(searcher);
+    } finally {
+      DecoderFactory.checkIn(searcher);
+    }
+  }
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/TestRows.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/TestRows.java
new file mode 100644
index 0000000..4869490
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/TestRows.java
@@ -0,0 +1,91 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.row.data.TestRandomKeyValues;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsComplexQualifiers;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsDeeper;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsDifferentTimestamps;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsEmpty;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsExerciseFInts;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsMultiFamilies;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsNub;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsNumberStrings;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsQualifierByteOrdering;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsSearcherRowMiss;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsSimple;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsSingleQualifier;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsTrivial;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsUrls;
+import org.apache.hbase.codec.prefixtree.row.data.TestRowsUrlsExample;
+import org.apache.hbase.codec.prefixtree.scanner.CellSearcher;
+
+import com.google.common.collect.Lists;
+
+public interface TestRows {
+
+  List<KeyValue> getInputs();
+  List<Integer> getRowStartIndexes();
+
+  void individualBlockMetaAssertions(PrefixTreeBlockMeta blockMeta);
+
+  void individualSearcherAssertions(CellSearcher searcher);
+
+  public static class InMemory {
+
+    public static Collection<TestRows> getAll() {
+      List<TestRows> all = Lists.newArrayList();
+      //simple
+      all.add(new TestRowsEmpty());
+      all.add(new TestRowsTrivial());
+      all.add(new TestRowsSimple());
+      all.add(new TestRowsDeeper());
+
+      //more specific
+      all.add(new TestRowsSingleQualifier());
+      all.add(new TestRowsMultiFamilies());
+      all.add(new TestRowsNub());
+      all.add(new TestRowsSearcherRowMiss());
+      all.add(new TestRowsQualifierByteOrdering());
+      all.add(new TestRowsComplexQualifiers());
+      all.add(new TestRowsDifferentTimestamps());
+
+      //larger data volumes (hard to debug)
+      all.add(new TestRowsNumberStrings());
+      all.add(new TestRowsUrls());
+      all.add(new TestRowsUrlsExample());
+      all.add(new TestRowsExerciseFInts());
+      all.add(new TestRandomKeyValues());
+      return all;
+    }
+
+    public static Collection<Object[]> getAllAsObjectArray() {
+      List<Object[]> all = Lists.newArrayList();
+      for (TestRows testRows : getAll()) {
+        all.add(new Object[] { testRows });
+      }
+      return all;
+    }
+  }
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRandomKeyValues.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRandomKeyValues.java
new file mode 100644
index 0000000..537dceb
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRandomKeyValues.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.test.RedundantKVGenerator;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+
+import com.google.common.collect.Lists;
+
+public class TestRandomKeyValues extends BaseTestRows {
+
+  static List<KeyValue> d = Lists.newArrayList();
+  static RedundantKVGenerator generator = new RedundantKVGenerator();
+  static {
+    d = generator.generateTestKeyValues(1 << 10);
+  }
+
+  @Override
+  public List<KeyValue> getInputs() {
+    return d;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsComplexQualifiers.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsComplexQualifiers.java
new file mode 100644
index 0000000..79ba466
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsComplexQualifiers.java
@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.PrefixTreeTestConstants;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+
+import com.google.common.collect.Lists;
+
+public class TestRowsComplexQualifiers extends BaseTestRows{
+
+	static byte[] 
+        Arow = Bytes.toBytes("Arow"),
+        cf = PrefixTreeTestConstants.TEST_CF,
+        v0 = Bytes.toBytes("v0");
+
+	static List<byte[]> qualifiers = Lists.newArrayList();
+	static{
+		List<String> qualifierStrings = Lists.newArrayList();
+		qualifierStrings.add("cq");
+		qualifierStrings.add("cq0");
+		qualifierStrings.add("cq1");
+		qualifierStrings.add("cq2");
+		qualifierStrings.add("dq0");//second root level fan
+		qualifierStrings.add("dq1");//nub
+		qualifierStrings.add("dq111");//leaf on nub
+		qualifierStrings.add("dq11111a");//leaf on leaf
+		for(String s : qualifierStrings){
+			qualifiers.add(Bytes.toBytes(s));
+		}
+	}
+
+	static long
+		ts = 55L;
+
+	static List<KeyValue> d = Lists.newArrayList();
+	static{
+		for(byte[] qualifier : qualifiers){
+			d.add(new KeyValue(Arow, cf, qualifier, ts, v0));
+		}
+	}
+
+	@Override
+	public List<KeyValue> getInputs() {
+		return d;
+	}
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsDeeper.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsDeeper.java
new file mode 100644
index 0000000..27b906b
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsDeeper.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.cell.CellScannerPosition;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+import org.apache.hbase.codec.prefixtree.scanner.CellSearcher;
+
+import com.google.common.collect.Lists;
+
+public class TestRowsDeeper extends BaseTestRows{
+
+	static byte[] 
+        cdc = Bytes.toBytes("cdc"),
+        cf6 = Bytes.toBytes("cf6"),
+        cfc = Bytes.toBytes("cfc"),
+        f = Bytes.toBytes("f"),
+        q = Bytes.toBytes("q"),
+        v = Bytes.toBytes("v");
+
+	static long
+		ts = 55L;
+
+	static List<KeyValue> d = Lists.newArrayList();
+	static{
+		d.add(new KeyValue(cdc, f, q, ts, v));
+    d.add(new KeyValue(cf6, f, q, ts, v));
+    d.add(new KeyValue(cfc, f, q, ts, v));
+	}
+
+	@Override
+	public List<KeyValue> getInputs() {
+		return d;
+	}
+
+	@Override
+	public void individualBlockMetaAssertions(PrefixTreeBlockMeta blockMeta) {
+	  //0: token:c; fan:d,f
+	  //1: token:f; fan:6,c
+	  //2: leaves
+		Assert.assertEquals(3, blockMeta.getRowTreeDepth());
+	}
+
+  @Override
+  public void individualSearcherAssertions(CellSearcher searcher) {
+    /**
+     * The searcher should get a token mismatch on the "r" branch.  Assert that it skips not only
+     * rA, but rB as well.
+     */
+    KeyValue cfcRow = KeyValue.createFirstOnRow(Bytes.toBytes("cfc"));
+    CellScannerPosition position = searcher.positionAtOrAfter(cfcRow);
+    Assert.assertEquals(CellScannerPosition.AFTER, position);
+    Assert.assertEquals(d.get(2), searcher.getCurrent());
+    searcher.previous();
+    Assert.assertEquals(d.get(1), searcher.getCurrent());
+  }
+}
+
+
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsDifferentTimestamps.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsDifferentTimestamps.java
new file mode 100644
index 0000000..83e2952
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsDifferentTimestamps.java
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+
+import com.google.common.collect.Lists;
+
+/*
+ * test different timestamps
+ */
+public class TestRowsDifferentTimestamps extends BaseTestRows{
+
+	static byte[]
+        Arow = Bytes.toBytes("Arow"),
+        Brow = Bytes.toBytes("Brow"),
+        cf = Bytes.toBytes("fammy"),
+        cq0 = Bytes.toBytes("cq0"),
+        cq1 = Bytes.toBytes("cq1"),
+        v0 = Bytes.toBytes("v0");
+
+	static List<KeyValue> d = Lists.newArrayList();
+	static{
+	  KeyValue kv0 = new KeyValue(Arow, cf, cq0, 0L, v0);
+	  kv0.setMemstoreTS(123456789L);
+	  d.add(kv0);
+
+	  KeyValue kv1 = new KeyValue(Arow, cf, cq1, 1L, v0);
+    kv1.setMemstoreTS(3L);
+    d.add(kv1);
+
+	  KeyValue kv2 = new KeyValue(Brow, cf, cq0, 12345678L, v0);
+    kv2.setMemstoreTS(65537L);
+    d.add(kv2);
+
+		//watch out... Long.MAX_VALUE comes back as 1332221664203, even with other encoders
+//		d.add(new KeyValue(Brow, cf, cq1, Long.MAX_VALUE, v0));
+	  KeyValue kv3 = new KeyValue(Brow, cf, cq1, Long.MAX_VALUE-1, v0);
+    kv3.setMemstoreTS(1L);
+    d.add(kv3);
+
+	  KeyValue kv4 = new KeyValue(Brow, cf, cq1, 999999999, v0);
+    //don't set memstoreTS
+	  d.add(kv4);
+
+	  KeyValue kv5 = new KeyValue(Brow, cf, cq1, 12345, v0);
+    kv5.setMemstoreTS(0L);
+    d.add(kv5);
+	}
+
+	@Override
+	public List<KeyValue> getInputs() {
+		return d;
+	}
+
+	@Override
+	public void individualBlockMetaAssertions(PrefixTreeBlockMeta blockMeta) {
+	  Assert.assertTrue(blockMeta.getNumMvccVersionBytes() > 0);
+	  Assert.assertEquals(12, blockMeta.getNumValueBytes());
+
+		Assert.assertFalse(blockMeta.isAllSameTimestamp());
+		Assert.assertNotNull(blockMeta.getMinTimestamp());
+		Assert.assertTrue(blockMeta.getTimestampIndexWidth() > 0);
+		Assert.assertTrue(blockMeta.getTimestampDeltaWidth() > 0);
+
+    Assert.assertFalse(blockMeta.isAllSameMvccVersion());
+    Assert.assertNotNull(blockMeta.getMinMvccVersion());
+    Assert.assertTrue(blockMeta.getMvccVersionIndexWidth() > 0);
+    Assert.assertTrue(blockMeta.getMvccVersionDeltaWidth() > 0);
+	}
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsEmpty.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsEmpty.java
new file mode 100644
index 0000000..3eac3c4
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsEmpty.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValue.Type;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+
+import com.google.common.collect.Lists;
+
+public class TestRowsEmpty extends BaseTestRows{
+  
+  private static byte[] b = new byte[0];
+
+  static List<KeyValue> d = Lists.newArrayList();
+  static {
+    d.add(new KeyValue(b, b, b, 0L, Type.Put, b));
+  }
+
+  @Override
+  public List<KeyValue> getInputs() {
+    return d;
+  }
+  
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsExerciseFInts.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsExerciseFInts.java
new file mode 100644
index 0000000..e0ef508
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsExerciseFInts.java
@@ -0,0 +1,121 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.PrefixTreeTestConstants;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+import org.apache.hbase.util.byterange.impl.ByteRangeTreeSet;
+
+import com.google.common.collect.Lists;
+
+/*
+ * test different timestamps
+ *
+ * http://pastebin.com/7ks8kzJ2
+ * http://pastebin.com/MPn03nsK
+ */
+public class TestRowsExerciseFInts extends BaseTestRows{
+
+	static List<ByteRange> rows;
+	static{
+		List<String> rowStrings = new ArrayList<String>();
+        rowStrings.add("com.edsBlog/directoryAa/pageAaa");
+        rowStrings.add("com.edsBlog/directoryAa/pageBbb");
+        rowStrings.add("com.edsBlog/directoryAa/pageCcc");
+        rowStrings.add("com.edsBlog/directoryAa/pageDdd");
+        rowStrings.add("com.edsBlog/directoryBb/pageEee");
+        rowStrings.add("com.edsBlog/directoryBb/pageFff");
+        rowStrings.add("com.edsBlog/directoryBb/pageGgg");
+        rowStrings.add("com.edsBlog/directoryBb/pageHhh");
+        rowStrings.add("com.isabellasBlog/directoryAa/pageAaa");
+        rowStrings.add("com.isabellasBlog/directoryAa/pageBbb");
+        rowStrings.add("com.isabellasBlog/directoryAa/pageCcc");
+        rowStrings.add("com.isabellasBlog/directoryAa/pageDdd");
+        rowStrings.add("com.isabellasBlog/directoryBb/pageEee");
+        rowStrings.add("com.isabellasBlog/directoryBb/pageFff");
+        rowStrings.add("com.isabellasBlog/directoryBb/pageGgg");
+        rowStrings.add("com.isabellasBlog/directoryBb/pageHhh");
+        ByteRangeTreeSet ba = new ByteRangeTreeSet();
+        for(String row : rowStrings){
+        	ba.add(new ByteRange(Bytes.toBytes(row)));
+        }
+        rows = ba.compile().getSortedRanges();
+	}
+
+	static List<String> cols = Lists.newArrayList();
+	static{
+		cols.add("Chrome");
+		cols.add("Chromeb");
+		cols.add("Firefox");
+		cols.add("InternetExplorer");
+		cols.add("Opera");
+		cols.add("Safari");
+		cols.add("Z1stBrowserWithHuuuuuuuuuuuugeQualifier");
+		cols.add("Z2ndBrowserWithEvenBiggerQualifierMoreMoreMoreMoreMore");
+		cols.add("Z3rdBrowserWithEvenBiggerQualifierMoreMoreMoreMoreMore");
+		cols.add("Z4thBrowserWithEvenBiggerQualifierMoreMoreMoreMoreMore");
+		cols.add("Z5thBrowserWithEvenBiggerQualifierMoreMoreMoreMoreMore");
+		cols.add("Z6thBrowserWithEvenBiggerQualifierMoreMoreMoreMoreMore");
+		cols.add("Z7thBrowserWithEvenBiggerQualifierMoreMoreMoreMoreMore");
+		cols.add("Z8thBrowserWithEvenBiggerQualifierMoreMoreMoreMoreMore");
+		cols.add("Z9thBrowserWithEvenBiggerQualifierMoreMoreMoreMoreMore");
+	}
+
+  static long ts = 1234567890;
+
+  static int MAX_VALUE = 50;
+
+  static List<KeyValue> kvs = Lists.newArrayList();
+  static {
+    for (ByteRange row : rows) {
+      for (String col : cols) {
+        KeyValue kv = new KeyValue(row.deepCopyToNewArray(), PrefixTreeTestConstants.TEST_CF,
+            Bytes.toBytes(col), ts, KeyValue.Type.Put, Bytes.toBytes("VALUE"));
+        kvs.add(kv);
+      }
+    }
+  }
+
+//  public static void main(String... args) {
+//    for (KeyValue kv : kvs) {
+//      System.out.println(kv);
+//    }
+//  }
+
+  @Override
+  public List<KeyValue> getInputs() {
+    return kvs;
+  }
+
+  @Override
+  public void individualBlockMetaAssertions(PrefixTreeBlockMeta blockMeta) {
+    Assert.assertTrue(blockMeta.getNextNodeOffsetWidth() > 1);
+    Assert.assertTrue(blockMeta.getQualifierOffsetWidth() > 1);
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsMultiFamilies.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsMultiFamilies.java
new file mode 100644
index 0000000..b01ae85
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsMultiFamilies.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+
+import com.google.common.collect.Lists;
+
+public class TestRowsMultiFamilies extends BaseTestRows{
+
+  static byte[] 
+        rowA = Bytes.toBytes("rowA"),
+        rowB = Bytes.toBytes("rowB"),
+        famA = Bytes.toBytes("famA"),
+        famB = Bytes.toBytes("famB"),
+        famBB = Bytes.toBytes("famBB"),
+        q0 = Bytes.toBytes("q0"),
+        q1 = Bytes.toBytes("q1"),//start with a different character
+        vvv = Bytes.toBytes("vvv");
+
+  static long ts = 55L;
+
+  static List<KeyValue> d = Lists.newArrayList();
+  static {
+    d.add(new KeyValue(rowA, famA, q0, ts, vvv));
+    d.add(new KeyValue(rowA, famB, q1, ts, vvv));
+    d.add(new KeyValue(rowA, famBB, q0, ts, vvv));
+    d.add(new KeyValue(rowB, famA, q0, ts, vvv));
+    d.add(new KeyValue(rowB, famA, q1, ts, vvv));
+    d.add(new KeyValue(rowB, famB, q0, ts, vvv));
+    d.add(new KeyValue(rowB, famBB, q0, ts, vvv));
+    d.add(new KeyValue(rowB, famBB, q1, ts, vvv));
+  }
+
+  @Override
+  public List<KeyValue> getInputs() {
+    return d;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsNub.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsNub.java
new file mode 100644
index 0000000..c54a4a8
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsNub.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.PrefixTreeTestConstants;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+
+import com.google.common.collect.Lists;
+
+public class TestRowsNub extends BaseTestRows{
+
+	static byte[]
+        rowA = Bytes.toBytes("rowA"),
+        rowB = Bytes.toBytes("rowB"),//nub
+        rowBB = Bytes.toBytes("rowBB"),
+        cf = PrefixTreeTestConstants.TEST_CF,
+        cq0 = Bytes.toBytes("cq0"),
+        cq1 = Bytes.toBytes("cq1"),
+        v0 = Bytes.toBytes("v0");
+
+	static long
+		ts = 55L;
+
+	static List<KeyValue> d = Lists.newArrayList();
+	static{
+		d.add(new KeyValue(rowA, cf, cq0, ts, v0));
+		d.add(new KeyValue(rowA, cf, cq1, ts, v0));
+		d.add(new KeyValue(rowB, cf, cq0, ts, v0));
+		d.add(new KeyValue(rowB, cf, cq1, ts, v0));
+		d.add(new KeyValue(rowBB, cf, cq0, ts, v0));
+		d.add(new KeyValue(rowBB, cf, cq1, ts, v0));
+	}
+
+	@Override
+	public List<KeyValue> getInputs() {
+		return d;
+	}
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsNumberStrings.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsNumberStrings.java
new file mode 100644
index 0000000..c8fe822
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsNumberStrings.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.Collections;
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValue.Type;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.cell.CellComparator;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+
+import com.google.common.collect.Lists;
+
+public class TestRowsNumberStrings extends BaseTestRows{
+  
+  static List<KeyValue> d = Lists.newArrayList();
+  static {
+
+  /**
+   * Test a string-encoded list of numbers.  0, 1, 10, 11 will sort as 0, 1, 10, 11 if strings
+   * 
+   * This helped catch a bug with reverse scanning where it was jumping from the last leaf cell to
+   * the previous nub.  It should do 11->10, but it was incorrectly doing 11->1
+   */
+    List<Integer> problematicSeries = Lists.newArrayList(0, 1, 10, 11);//sort this at the end
+    for(Integer i : problematicSeries){
+//    for(int i=0; i < 13; ++i){
+      byte[] row = Bytes.toBytes(""+i);
+      byte[] family = Bytes.toBytes("F");
+      byte[] column = Bytes.toBytes("C");
+      byte[] value = Bytes.toBytes("V");
+      
+      d.add(new KeyValue(row, family, column, 0L, Type.Put, value));
+    }
+    Collections.sort(d, new CellComparator());
+  }
+
+  @Override
+  public List<KeyValue> getInputs() {
+    return d;
+  }
+  
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsQualifierByteOrdering.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsQualifierByteOrdering.java
new file mode 100644
index 0000000..abe0679
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsQualifierByteOrdering.java
@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+
+import com.google.common.collect.Lists;
+
+public class TestRowsQualifierByteOrdering extends BaseTestRows{
+
+	static byte[]
+        Arow = Bytes.toBytes("Arow"),
+        Brow = Bytes.toBytes("Brow"),
+        Brow2 = Bytes.toBytes("Brow2"),
+        fam = Bytes.toBytes("HappyFam"),
+        cq0 = Bytes.toBytes("cq0"),
+        cq1 = Bytes.toBytes("cq1tail"),//make sure tail does not come back as liat
+        cq2 = Bytes.toBytes("cq2"),
+        v0 = Bytes.toBytes("v0");
+
+  static long ts = 55L;
+
+  static List<KeyValue> d = Lists.newArrayList();
+  static {
+    d.add(new KeyValue(Arow, fam, cq0, ts, v0));
+    d.add(new KeyValue(Arow, fam, cq1, ts, v0));
+    d.add(new KeyValue(Brow, fam, cq0, ts, v0));
+    d.add(new KeyValue(Brow, fam, cq2, ts, v0));
+    d.add(new KeyValue(Brow2, fam, cq1, ts, v0));
+    d.add(new KeyValue(Brow2, fam, cq2, ts, v0));
+  }
+
+  @Override
+  public List<KeyValue> getInputs() {
+    return d;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsSearcherRowMiss.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsSearcherRowMiss.java
new file mode 100644
index 0000000..42b4fa2
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsSearcherRowMiss.java
@@ -0,0 +1,124 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.Cell;
+import org.apache.hbase.cell.CellComparator;
+import org.apache.hbase.cell.CellScannerPosition;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+import org.apache.hbase.codec.prefixtree.scanner.CellSearcher;
+
+import com.google.common.collect.Lists;
+
+public class TestRowsSearcherRowMiss extends BaseTestRows{
+
+  static byte[]
+      //don't let the rows share any common prefix bytes
+      A = Bytes.toBytes("A"),
+      AA = Bytes.toBytes("AA"),
+      AAA = Bytes.toBytes("AAA"),
+      B = Bytes.toBytes("B"),
+      cf = Bytes.toBytes("fam"),
+      cq = Bytes.toBytes("cq0"),
+      v = Bytes.toBytes("v0");
+
+  static long
+    ts = 55L;
+
+  static List<KeyValue> d = Lists.newArrayList();
+  static{
+    d.add(new KeyValue(A, cf, cq, ts, v));
+    d.add(new KeyValue(AA, cf, cq, ts, v));
+    d.add(new KeyValue(AAA, cf, cq, ts, v));
+    d.add(new KeyValue(B, cf, cq, ts, v));
+  }
+
+	@Override
+	public List<KeyValue> getInputs() {
+		return d;
+	}
+
+	@Override
+	public void individualSearcherAssertions(CellSearcher searcher) {
+	  assertRowOffsetsCorrect();
+
+    searcher.resetToBeforeFirstEntry();
+
+    //test first cell
+    searcher.next();
+    Cell first = searcher.getCurrent();
+    Assert.assertTrue(CellComparator.equals(d.get(0), first));
+
+    //test first cell in second row
+    Assert.assertTrue(searcher.positionAt(d.get(1)));
+    Assert.assertTrue(CellComparator.equals(d.get(1), searcher.getCurrent()));
+
+    testBetween1and2(searcher);
+    testBetween2and3(searcher);
+  }
+
+	/************ private methods, call from above *******************/
+
+	private void assertRowOffsetsCorrect(){
+	  Assert.assertEquals(4, getRowStartIndexes().size());
+	}
+
+	private void testBetween1and2(CellSearcher searcher){
+    CellScannerPosition p;//reuse
+    Cell betweenAAndAAA = new KeyValue(AA, cf, cq, ts-2, v);
+
+    //test exact
+    Assert.assertFalse(searcher.positionAt(betweenAAndAAA));
+
+    //test atOrBefore
+    p = searcher.positionAtOrBefore(betweenAAndAAA);
+    Assert.assertEquals(CellScannerPosition.BEFORE, p);
+    Assert.assertTrue(CellComparator.equals(searcher.getCurrent(), d.get(1)));
+
+    //test atOrAfter
+    p = searcher.positionAtOrAfter(betweenAAndAAA);
+    Assert.assertEquals(CellScannerPosition.AFTER, p);
+    Assert.assertTrue(CellComparator.equals(searcher.getCurrent(), d.get(2)));
+	}
+
+  private void testBetween2and3(CellSearcher searcher){
+    CellScannerPosition p;//reuse
+    Cell betweenAAAndB = new KeyValue(AAA, cf, cq, ts-2, v);
+
+    //test exact
+    Assert.assertFalse(searcher.positionAt(betweenAAAndB));
+
+    //test atOrBefore
+    p = searcher.positionAtOrBefore(betweenAAAndB);
+    Assert.assertEquals(CellScannerPosition.BEFORE, p);
+    Assert.assertTrue(CellComparator.equals(searcher.getCurrent(), d.get(2)));
+
+    //test atOrAfter
+    p = searcher.positionAtOrAfter(betweenAAAndB);
+    Assert.assertEquals(CellScannerPosition.AFTER, p);
+    Assert.assertTrue(CellComparator.equals(searcher.getCurrent(), d.get(3)));
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsSimple.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsSimple.java
new file mode 100644
index 0000000..c735fc7
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsSimple.java
@@ -0,0 +1,114 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.CollectionUtils;
+import org.apache.hbase.Cell;
+import org.apache.hbase.cell.CellComparator;
+import org.apache.hbase.cell.CellScannerPosition;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+import org.apache.hbase.codec.prefixtree.scanner.CellSearcher;
+
+import com.google.common.collect.Lists;
+
+public class TestRowsSimple extends BaseTestRows {
+
+  static byte[]
+  // don't let the rows share any common prefix bytes
+      rowA = Bytes.toBytes("Arow"),
+      rowB = Bytes.toBytes("Brow"), cf = Bytes.toBytes("fam"),
+      cq0 = Bytes.toBytes("cq0"),
+      cq1 = Bytes.toBytes("cq1tail"),// make sure tail does not come back as liat
+      cq2 = Bytes.toBytes("dcq2"),// start with a different character
+      v0 = Bytes.toBytes("v0");
+
+  static long ts = 55L;
+
+  static List<KeyValue> d = Lists.newArrayList();
+  static {
+    d.add(new KeyValue(rowA, cf, cq0, ts, v0));
+    d.add(new KeyValue(rowA, cf, cq1, ts, v0));
+    d.add(new KeyValue(rowA, cf, cq2, ts, v0));
+    d.add(new KeyValue(rowB, cf, cq0, ts, v0));
+    d.add(new KeyValue(rowB, cf, cq1, ts, v0));
+    d.add(new KeyValue(rowB, cf, cq2, ts, v0));
+  }
+
+  @Override
+  public List<KeyValue> getInputs() {
+    return d;
+  }
+
+  @Override
+  public void individualSearcherAssertions(CellSearcher searcher) {
+    CellScannerPosition p;// reuse
+    searcher.resetToBeforeFirstEntry();
+
+    // test first cell
+    searcher.next();
+    Cell first = searcher.getCurrent();
+    Assert.assertTrue(CellComparator.equals(d.get(0), first));
+
+    // test first cell in second row
+    Assert.assertTrue(searcher.positionAt(d.get(3)));
+    Assert.assertTrue(CellComparator.equals(d.get(3), searcher.getCurrent()));
+
+    Cell between4And5 = new KeyValue(rowB, cf, cq1, ts - 2, v0);
+
+    // test exact
+    Assert.assertFalse(searcher.positionAt(between4And5));
+
+    // test atOrBefore
+    p = searcher.positionAtOrBefore(between4And5);
+    Assert.assertEquals(CellScannerPosition.BEFORE, p);
+    Assert.assertTrue(CellComparator.equals(searcher.getCurrent(), d.get(4)));
+
+    // test atOrAfter
+    p = searcher.positionAtOrAfter(between4And5);
+    Assert.assertEquals(CellScannerPosition.AFTER, p);
+    Assert.assertTrue(CellComparator.equals(searcher.getCurrent(), d.get(5)));
+
+    // test when key falls before first key in block
+    Cell beforeFirst = new KeyValue(Bytes.toBytes("A"), cf, cq0, ts, v0);
+    Assert.assertFalse(searcher.positionAt(beforeFirst));
+    p = searcher.positionAtOrBefore(beforeFirst);
+    Assert.assertEquals(CellScannerPosition.BEFORE_FIRST, p);
+    p = searcher.positionAtOrAfter(beforeFirst);
+    Assert.assertEquals(CellScannerPosition.AFTER, p);
+    Assert.assertTrue(CellComparator.equals(searcher.getCurrent(), d.get(0)));
+    Assert.assertEquals(d.get(0), searcher.getCurrent());
+
+    // test when key falls after last key in block
+    Cell afterLast = new KeyValue(Bytes.toBytes("z"), cf, cq0, ts, v0);// must be lower case z
+    Assert.assertFalse(searcher.positionAt(afterLast));
+    p = searcher.positionAtOrAfter(afterLast);
+    Assert.assertEquals(CellScannerPosition.AFTER_LAST, p);
+    p = searcher.positionAtOrBefore(afterLast);
+//    System.out.println(searcher.getCurrent());
+    Assert.assertEquals(CellScannerPosition.BEFORE, p);
+    Assert.assertTrue(CellComparator.equals(searcher.getCurrent(), CollectionUtils.getLast(d)));
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsSingleQualifier.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsSingleQualifier.java
new file mode 100644
index 0000000..e58654d
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsSingleQualifier.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.PrefixTreeTestConstants;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+
+import com.google.common.collect.Lists;
+
+public class TestRowsSingleQualifier extends BaseTestRows{
+
+	static byte[] 
+        rowA = Bytes.toBytes("rowA"),
+        rowB = Bytes.toBytes("rowB"),
+        cf = PrefixTreeTestConstants.TEST_CF,
+        cq0 = Bytes.toBytes("cq0"),
+        v0 = Bytes.toBytes("v0");
+
+  static long ts = 55L;
+
+  static List<KeyValue> d = Lists.newArrayList();
+  static {
+    d.add(new KeyValue(rowA, cf, cq0, ts, v0));
+    d.add(new KeyValue(rowB, cf, cq0, ts, v0));
+  }
+
+  @Override
+  public List<KeyValue> getInputs() {
+    return d;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsTrivial.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsTrivial.java
new file mode 100644
index 0000000..8abc98b
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsTrivial.java
@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.cell.CellScannerPosition;
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+import org.apache.hbase.codec.prefixtree.scanner.CellSearcher;
+
+import com.google.common.collect.Lists;
+
+public class TestRowsTrivial extends BaseTestRows{
+
+	static byte[] 
+        rA = Bytes.toBytes("rA"),
+        rB = Bytes.toBytes("rB"),//turn "r" into a branch for the Searcher tests
+        cf = Bytes.toBytes("fam"),
+        cq0 = Bytes.toBytes("q0"),
+        v0 = Bytes.toBytes("v0");
+
+  static long ts = 55L;
+
+  static List<KeyValue> d = Lists.newArrayList();
+  static {
+    d.add(new KeyValue(rA, cf, cq0, ts, v0));
+    d.add(new KeyValue(rB, cf, cq0, ts, v0));
+  }
+
+  @Override
+  public List<KeyValue> getInputs() {
+    return d;
+  }
+
+  @Override
+  public void individualBlockMetaAssertions(PrefixTreeBlockMeta blockMeta) {
+    // node[0] -> root[r]
+    // node[1] -> leaf[A], etc
+    Assert.assertEquals(2, blockMeta.getRowTreeDepth());
+  }
+
+  @Override
+  public void individualSearcherAssertions(CellSearcher searcher) {
+    /**
+     * The searcher should get a token mismatch on the "r" branch. Assert that it skips not only rA,
+     * but rB as well.
+     */
+    KeyValue afterLast = KeyValue.createFirstOnRow(Bytes.toBytes("zzz"));
+    CellScannerPosition position = searcher.positionAtOrAfter(afterLast);
+    Assert.assertEquals(CellScannerPosition.AFTER_LAST, position);
+    Assert.assertNull(searcher.getCurrent());
+  }
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsUrls.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsUrls.java
new file mode 100644
index 0000000..771c2cc
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsUrls.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.PrefixTreeTestConstants;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+import org.apache.hbase.util.byterange.impl.ByteRangeTreeSet;
+
+import com.google.common.collect.Lists;
+
+/*
+ * test different timestamps
+ * 
+ * http://pastebin.com/7ks8kzJ2
+ * http://pastebin.com/MPn03nsK
+ */
+public class TestRowsUrls extends BaseTestRows{
+
+	static List<ByteRange> rows;
+	static{
+    List<String> rowStrings = new ArrayList<String>();
+    rowStrings.add("com.edsBlog/directoryAa/pageAaa");
+    rowStrings.add("com.edsBlog/directoryAa/pageBbb");
+    rowStrings.add("com.edsBlog/directoryAa/pageCcc");
+    rowStrings.add("com.edsBlog/directoryAa/pageDdd");
+    rowStrings.add("com.edsBlog/directoryBb/pageEee");
+    rowStrings.add("com.edsBlog/directoryBb/pageFff");
+    rowStrings.add("com.edsBlog/directoryBb/pageGgg");
+    rowStrings.add("com.edsBlog/directoryBb/pageHhh");
+    rowStrings.add("com.isabellasBlog/directoryAa/pageAaa");
+    rowStrings.add("com.isabellasBlog/directoryAa/pageBbb");
+    rowStrings.add("com.isabellasBlog/directoryAa/pageCcc");
+    rowStrings.add("com.isabellasBlog/directoryAa/pageDdd");
+    rowStrings.add("com.isabellasBlog/directoryBb/pageEee");
+    rowStrings.add("com.isabellasBlog/directoryBb/pageFff");
+    rowStrings.add("com.isabellasBlog/directoryBb/pageGgg");
+    rowStrings.add("com.isabellasBlog/directoryBb/pageHhh");
+    ByteRangeTreeSet ba = new ByteRangeTreeSet();
+    for (String row : rowStrings) {
+      ba.add(new ByteRange(Bytes.toBytes(row)));
+    }
+    rows = ba.compile().getSortedRanges();
+  }
+
+  static List<String> cols = Lists.newArrayList();
+  static {
+    cols.add("Chrome");
+    cols.add("Chromeb");
+    cols.add("Firefox");
+    cols.add("InternetExplorer");
+    cols.add("Opera");
+    cols.add("Safari");
+  }
+
+  static long ts = 1234567890;
+
+  static int MAX_VALUE = 50;
+
+  static List<KeyValue> kvs = Lists.newArrayList();
+  static {
+    for (ByteRange row : rows) {
+      for (String col : cols) {
+        KeyValue kv = new KeyValue(row.deepCopyToNewArray(), PrefixTreeTestConstants.TEST_CF,
+            Bytes.toBytes(col), ts, KeyValue.Type.Put, Bytes.toBytes("VALUE"));
+        kvs.add(kv);
+        // System.out.println("TestRows5:"+kv);
+      }
+    }
+  }
+
+//  public static void main(String... args) {
+//    for (KeyValue kv : kvs) {
+//      System.out.println(kv);
+//    }
+//  }
+
+  @Override
+  public List<KeyValue> getInputs() {
+    return kvs;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsUrlsExample.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsUrlsExample.java
new file mode 100644
index 0000000..8abca16
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/row/data/TestRowsUrlsExample.java
@@ -0,0 +1,124 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.row.data;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValueTestUtil;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.codec.prefixtree.encode.PrefixTreeEncoder;
+import org.apache.hbase.codec.prefixtree.encode.column.ColumnNodeWriter;
+import org.apache.hbase.codec.prefixtree.encode.row.RowNodeWriter;
+import org.apache.hbase.codec.prefixtree.encode.tokenize.TokenizerNode;
+import org.apache.hbase.codec.prefixtree.row.BaseTestRows;
+
+import com.google.common.collect.Lists;
+
+/*
+ * test different timestamps
+ * 
+ * http://pastebin.com/7ks8kzJ2
+ * http://pastebin.com/MPn03nsK
+ */
+public class TestRowsUrlsExample extends BaseTestRows{
+
+  static String TENANT_ID = Integer.toString(95322);
+  static String APP_ID = Integer.toString(12);
+  static List<String> URLS = Lists.newArrayList(
+      "com.dablog/2011/10/04/boating", 
+      "com.dablog/2011/10/09/lasers", 
+      "com.jamiesrecipes", //this nub helped find a bug
+      "com.jamiesrecipes/eggs");
+  static String FAMILY = "hits";
+  static List<String> BROWSERS = Lists.newArrayList(
+      "Chrome", "IE8", "IE9beta");//, "Opera", "Safari");
+	static long TIMESTAMP = 1234567890;
+
+	static int MAX_VALUE = 50;
+
+	static List<KeyValue> kvs = Lists.newArrayList();
+	static{
+		for(String rowKey : URLS){
+			for(String qualifier : BROWSERS){
+			  KeyValue kv = new KeyValue(
+						Bytes.toBytes(rowKey), 
+						Bytes.toBytes(FAMILY), 
+						Bytes.toBytes(qualifier), 
+						TIMESTAMP, 
+						KeyValue.Type.Put, 
+						Bytes.toBytes("VvvV"));
+				kvs.add(kv);
+			}
+		}
+	}
+
+	/**
+	 * Used for generating docs.
+	 */
+	public static void main(String... args) throws IOException{
+    System.out.println("-- inputs --");
+    System.out.println(KeyValueTestUtil.toStringWithPadding(kvs, true));
+		ByteArrayOutputStream os = new ByteArrayOutputStream(1<<20);
+    PrefixTreeEncoder kvBuilder = new PrefixTreeEncoder(os, false);
+
+    for(KeyValue kv : kvs){
+      kvBuilder.write(kv);
+    }
+    kvBuilder.flush();
+
+    System.out.println("-- qualifier SortedPtBuilderNodes --");
+    for(TokenizerNode builder : kvBuilder.getQualifierWriter().getNonLeaves()){
+      System.out.println(builder);
+    }
+    for(TokenizerNode builder : kvBuilder.getQualifierWriter().getLeaves()){
+      System.out.println(builder);
+    }
+    System.out.println("-- qualifier PtColumnNodeWriters --");
+    for(ColumnNodeWriter writer : kvBuilder.getQualifierWriter().getColumnNodeWriters()){
+      System.out.println(writer);
+    }
+
+    System.out.println("-- rowKey SortedPtBuilderNodes --");
+    for(TokenizerNode builder : kvBuilder.getRowWriter().getNonLeaves()){
+      System.out.println(builder);
+    }
+    for(TokenizerNode builder : kvBuilder.getRowWriter().getLeaves()){
+      System.out.println(builder);
+    }
+    System.out.println("-- row PtRowNodeWriterLights --");
+    for(RowNodeWriter writer : kvBuilder.getRowWriter().getNonLeafWriters()){
+      System.out.println(writer);
+    }
+    for(RowNodeWriter writer : kvBuilder.getRowWriter().getLeafWriters()){
+      System.out.println(writer);
+    }
+
+    System.out.println("-- concatenated values --");
+    System.out.println(Bytes.toStringBinary(kvBuilder.getValueByteRange().deepCopyToNewArray()));
+	}
+
+	@Override
+	public List<KeyValue> getInputs() {
+		return kvs;
+	}
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/TestTimestamps.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/TestTimestamps.java
new file mode 100644
index 0000000..bdd3212
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/TestTimestamps.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.timestamp;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.apache.hbase.codec.prefixtree.timestamp.data.TestTimestamps1;
+import org.apache.hbase.codec.prefixtree.timestamp.data.TestTimestamps2;
+import org.apache.hbase.codec.prefixtree.timestamp.data.TestTimestamps3;
+
+import com.google.common.collect.Lists;
+
+public interface TestTimestamps {
+
+  List<Long> getInputs();
+  long getMinimum();
+  List<Long> getOutputs();
+
+  public static class InMemory {
+    public Collection<Object[]> getAllAsObjectArray() {
+      List<Object[]> all = Lists.newArrayList();
+      all.add(new Object[] { new TestTimestamps1() });
+      all.add(new Object[] { new TestTimestamps2() });
+      all.add(new Object[] { new TestTimestamps3() });
+      return all;
+    }
+  }
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/TimestampCompressorTests.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/TimestampCompressorTests.java
new file mode 100644
index 0000000..edd88bc
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/TimestampCompressorTests.java
@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.timestamp;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Collection;
+
+import junit.framework.Assert;
+
+import org.apache.hbase.codec.prefixtree.PrefixTreeBlockMeta;
+import org.apache.hbase.codec.prefixtree.decode.timestamp.TimestampDecoder;
+import org.apache.hbase.codec.prefixtree.encode.other.LongEncoder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class TimestampCompressorTests {
+
+  @Parameters
+  public static Collection<Object[]> parameters() {
+    return new TestTimestamps.InMemory().getAllAsObjectArray();
+  }
+
+  private TestTimestamps timestamps;
+  private PrefixTreeBlockMeta blockMeta;
+  private LongEncoder encoder;
+  private byte[] bytes;
+  private TimestampDecoder decoder;
+
+  public TimestampCompressorTests(TestTimestamps testTimestamps) throws IOException {
+    this.timestamps = testTimestamps;
+    this.blockMeta = new PrefixTreeBlockMeta();
+    this.blockMeta.setNumMetaBytes(0);
+    this.blockMeta.setNumRowBytes(0);
+    this.blockMeta.setNumQualifierBytes(0);
+    this.encoder = new LongEncoder(blockMeta);
+    for (Long ts : testTimestamps.getInputs()) {
+      encoder.add(ts);
+    }
+    encoder.compile();
+    blockMeta.setTimestampFields(encoder);
+    bytes = encoder.getByteArray();
+    decoder = new TimestampDecoder();
+    decoder.initOnBlock(blockMeta, bytes);
+  }
+
+  @Test
+  public void testCompressorMinimum() {
+    Assert.assertEquals(timestamps.getMinimum(), encoder.getMin());
+  }
+
+  @Test
+  public void testCompressorRoundTrip() {
+    long[] outputs = encoder.getSortedUniqueTimestamps();
+    for (int i = 0; i < timestamps.getOutputs().size(); ++i) {
+      long input = timestamps.getOutputs().get(i);
+      long output = outputs[i];
+      Assert.assertEquals(input, output);
+    }
+  }
+
+  @Test
+  public void testReaderMinimum() {
+    Assert.assertEquals(timestamps.getMinimum(), decoder.getLong(0));
+  }
+
+  @Test
+  public void testReaderRoundTrip() {
+    for (int i = 0; i < timestamps.getOutputs().size(); ++i) {
+      long input = timestamps.getOutputs().get(i);
+      long output = decoder.getLong(i);
+      Assert.assertEquals(input, output);
+    }
+  }
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/data/TestTimestamps1.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/data/TestTimestamps1.java
new file mode 100644
index 0000000..caa79cd
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/data/TestTimestamps1.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.timestamp.data;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hbase.codec.prefixtree.timestamp.TestTimestamps;
+
+public class TestTimestamps1 implements TestTimestamps {
+
+  @Override
+  public List<Long> getInputs() {
+    List<Long> d = new ArrayList<Long>();
+    d.add(5L);
+    d.add(3L);
+    d.add(0L);
+    d.add(1L);
+    d.add(3L);
+    return d;
+  }
+
+  @Override
+  public long getMinimum() {
+    return 0L;
+  }
+
+  @Override
+  public List<Long> getOutputs() {
+    List<Long> d = new ArrayList<Long>();
+    d.add(0L);
+    d.add(1L);
+    d.add(3L);
+    d.add(5L);
+    return d;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/data/TestTimestamps2.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/data/TestTimestamps2.java
new file mode 100644
index 0000000..d7a3f90
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/data/TestTimestamps2.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.timestamp.data;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hbase.codec.prefixtree.timestamp.TestTimestamps;
+
+public class TestTimestamps2 implements TestTimestamps {
+
+  private int shift = 8;
+
+  @Override
+  public List<Long> getInputs() {
+    List<Long> d = new ArrayList<Long>();
+    d.add(5L << shift);
+    d.add(3L << shift);
+    d.add(7L << shift);
+    d.add(1L << shift);
+    d.add(3L << shift);
+    return d;
+  }
+
+  @Override
+  public long getMinimum() {
+    return 1L << shift;
+  }
+
+  @Override
+  public List<Long> getOutputs() {
+    List<Long> d = new ArrayList<Long>();
+    d.add(1L << shift);
+    d.add(3L << shift);
+    d.add(5L << shift);
+    d.add(7L << shift);
+    return d;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/data/TestTimestamps3.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/data/TestTimestamps3.java
new file mode 100644
index 0000000..1dd2839
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/codec/prefixtree/timestamp/data/TestTimestamps3.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.codec.prefixtree.timestamp.data;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hbase.codec.prefixtree.timestamp.TestTimestamps;
+
+public class TestTimestamps3 implements TestTimestamps {
+
+  private static long t = 1234567890L;
+
+  @Override
+  public List<Long> getInputs() {
+    List<Long> d = new ArrayList<Long>();
+    d.add(t);
+    d.add(t);
+    d.add(t);
+    d.add(t);
+    d.add(t);
+    return d;
+  }
+
+  @Override
+  public long getMinimum() {
+    return t;
+  }
+
+  @Override
+  public List<Long> getOutputs() {
+    List<Long> d = new ArrayList<Long>();
+    return d;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/util/bytes/StringByteUtils.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/bytes/StringByteUtils.java
new file mode 100644
index 0000000..84e7ba3
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/bytes/StringByteUtils.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.bytes;
+
+import java.util.List;
+
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.CollectionUtils;
+import org.apache.hadoop.hbase.util.IterableUtils;
+
+import com.google.common.collect.Lists;
+
+public class StringByteUtils {
+
+  public static List<byte[]> getUtf8ByteArrays(List<String> strings) {
+    List<byte[]> byteArrays = Lists.newArrayListWithCapacity(CollectionUtils.nullSafeSize(strings));
+    for (String s : IterableUtils.nullSafe(strings)) {
+      byteArrays.add(Bytes.toBytes(s));
+    }
+    return byteArrays;
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/util/bytes/TestByteRange.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/bytes/TestByteRange.java
new file mode 100644
index 0000000..41bbb6a
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/bytes/TestByteRange.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.bytes;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.junit.Test;
+
+public class TestByteRange {
+
+  @Test
+  public void testConstructor() {
+    ByteRange b = new ByteRange(new byte[] { 0, 1, 2 });
+    Assert.assertEquals(3, b.getLength());
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/util/comparator/ByteArrayComparator.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/comparator/ByteArrayComparator.java
new file mode 100644
index 0000000..8cf7bd9
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/comparator/ByteArrayComparator.java
@@ -0,0 +1,32 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.comparator;
+
+import java.util.Comparator;
+
+import org.apache.hadoop.hbase.util.Bytes;
+
+public class ByteArrayComparator implements Comparator<byte[]> {
+
+  @Override
+  public int compare(byte[] a, byte[] b) {
+    return Bytes.compareTo(a, b);
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/util/number/NumberFormatter.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/number/NumberFormatter.java
new file mode 100644
index 0000000..05f9c02
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/number/NumberFormatter.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.number;
+
+import java.text.DecimalFormat;
+
+public class NumberFormatter {
+
+  public static String addCommas(final Number pValue) {
+    if (pValue == null) {
+      return null;
+    }
+    String format = "###,###,###,###,###,###,###,###.#####################";
+    return new DecimalFormat(format).format(pValue);// biggest is 19 digits
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/util/number/RandomNumberUtils.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/number/RandomNumberUtils.java
new file mode 100644
index 0000000..57fd8f5
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/number/RandomNumberUtils.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.number;
+
+import java.util.Random;
+
+public class RandomNumberUtils {
+
+  public static long nextPositiveLong(Random random) {
+    while (true) {
+      long value = random.nextLong();
+      if (value > 0) {
+        return value;
+      }
+    }
+  }
+
+}
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/util/vint/TestFIntTool.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/vint/TestFIntTool.java
new file mode 100644
index 0000000..579af34
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/vint/TestFIntTool.java
@@ -0,0 +1,122 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.vint;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+/********************** tests *************************/
+
+public class TestFIntTool {
+  @Test
+  public void testLeadingZeros() {
+    Assert.assertEquals(64, Long.numberOfLeadingZeros(0));
+    Assert.assertEquals(63, Long.numberOfLeadingZeros(1));
+    Assert.assertEquals(0, Long.numberOfLeadingZeros(Long.MIN_VALUE));
+    Assert.assertEquals(0, Long.numberOfLeadingZeros(-1));
+    Assert.assertEquals(1, Long.numberOfLeadingZeros(Long.MAX_VALUE));
+    Assert.assertEquals(1, Long.numberOfLeadingZeros(Long.MAX_VALUE - 1));
+  }
+
+  @Test
+  public void testMaxValueForNumBytes() {
+    Assert.assertEquals(255, UFIntTool.maxValueForNumBytes(1));
+    Assert.assertEquals(65535, UFIntTool.maxValueForNumBytes(2));
+    Assert.assertEquals(0xffffff, UFIntTool.maxValueForNumBytes(3));
+    Assert.assertEquals(0xffffffffffffffL, UFIntTool.maxValueForNumBytes(7));
+  }
+
+  @Test
+  public void testNumBytes() {
+    Assert.assertEquals(1, UFIntTool.numBytes(0));
+    Assert.assertEquals(1, UFIntTool.numBytes(1));
+    Assert.assertEquals(1, UFIntTool.numBytes(255));
+    Assert.assertEquals(2, UFIntTool.numBytes(256));
+    Assert.assertEquals(2, UFIntTool.numBytes(65535));
+    Assert.assertEquals(3, UFIntTool.numBytes(65536));
+    Assert.assertEquals(4, UFIntTool.numBytes(0xffffffffL));
+    Assert.assertEquals(5, UFIntTool.numBytes(0x100000000L));
+    Assert.assertEquals(4, UFIntTool.numBytes(Integer.MAX_VALUE));
+    Assert.assertEquals(8, UFIntTool.numBytes(Long.MAX_VALUE));
+    Assert.assertEquals(8, UFIntTool.numBytes(Long.MAX_VALUE - 1));
+  }
+
+  @Test
+  public void testGetBytes() {
+    Assert.assertArrayEquals(new byte[] { 0 }, UFIntTool.getBytes(1, 0));
+    Assert.assertArrayEquals(new byte[] { 1 }, UFIntTool.getBytes(1, 1));
+    Assert.assertArrayEquals(new byte[] { -1 }, UFIntTool.getBytes(1, 255));
+    Assert.assertArrayEquals(new byte[] { 1, 0 }, UFIntTool.getBytes(2, 256));
+    Assert.assertArrayEquals(new byte[] { 1, 3 }, UFIntTool.getBytes(2, 256 + 3));
+    Assert.assertArrayEquals(new byte[] { 1, -128 }, UFIntTool.getBytes(2, 256 + 128));
+    Assert.assertArrayEquals(new byte[] { 1, -1 }, UFIntTool.getBytes(2, 256 + 255));
+    Assert.assertArrayEquals(new byte[] { 127, -1, -1, -1 },
+      UFIntTool.getBytes(4, Integer.MAX_VALUE));
+    Assert.assertArrayEquals(new byte[] { 127, -1, -1, -1, -1, -1, -1, -1 },
+      UFIntTool.getBytes(8, Long.MAX_VALUE));
+  }
+
+  @Test
+  public void testFromBytes() {
+    Assert.assertEquals(0, UFIntTool.fromBytes(new byte[] { 0 }));
+    Assert.assertEquals(1, UFIntTool.fromBytes(new byte[] { 1 }));
+    Assert.assertEquals(255, UFIntTool.fromBytes(new byte[] { -1 }));
+    Assert.assertEquals(256, UFIntTool.fromBytes(new byte[] { 1, 0 }));
+    Assert.assertEquals(256 + 3, UFIntTool.fromBytes(new byte[] { 1, 3 }));
+    Assert.assertEquals(256 + 128, UFIntTool.fromBytes(new byte[] { 1, -128 }));
+    Assert.assertEquals(256 + 255, UFIntTool.fromBytes(new byte[] { 1, -1 }));
+    Assert.assertEquals(Integer.MAX_VALUE, UFIntTool.fromBytes(new byte[] { 127, -1, -1, -1 }));
+    Assert.assertEquals(Long.MAX_VALUE,
+      UFIntTool.fromBytes(new byte[] { 127, -1, -1, -1, -1, -1, -1, -1 }));
+  }
+
+  @Test
+  public void testRoundTrips() {
+    long[] values = new long[] { 0, 1, 2, 255, 256, 31123, 65535, 65536, 65537, 0xfffffeL,
+        0xffffffL, 0x1000000L, 0x1000001L, Integer.MAX_VALUE - 1, Integer.MAX_VALUE,
+        (long) Integer.MAX_VALUE + 1, Long.MAX_VALUE - 1, Long.MAX_VALUE };
+    for (int i = 0; i < values.length; ++i) {
+      Assert.assertEquals(values[i], UFIntTool.fromBytes(UFIntTool.getBytes(8, values[i])));
+    }
+  }
+
+  @Test
+  public void testWriteBytes() throws IOException {// copied from testGetBytes
+    Assert.assertArrayEquals(new byte[] { 0 }, bytesViaOutputStream(1, 0));
+    Assert.assertArrayEquals(new byte[] { 1 }, bytesViaOutputStream(1, 1));
+    Assert.assertArrayEquals(new byte[] { -1 }, bytesViaOutputStream(1, 255));
+    Assert.assertArrayEquals(new byte[] { 1, 0 }, bytesViaOutputStream(2, 256));
+    Assert.assertArrayEquals(new byte[] { 1, 3 }, bytesViaOutputStream(2, 256 + 3));
+    Assert.assertArrayEquals(new byte[] { 1, -128 }, bytesViaOutputStream(2, 256 + 128));
+    Assert.assertArrayEquals(new byte[] { 1, -1 }, bytesViaOutputStream(2, 256 + 255));
+    Assert.assertArrayEquals(new byte[] { 127, -1, -1, -1 },
+      bytesViaOutputStream(4, Integer.MAX_VALUE));
+    Assert.assertArrayEquals(new byte[] { 127, -1, -1, -1, -1, -1, -1, -1 },
+      bytesViaOutputStream(8, Long.MAX_VALUE));
+  }
+
+  private byte[] bytesViaOutputStream(int outputWidth, long value) throws IOException {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    UFIntTool.writeBytes(outputWidth, value, os);
+    return os.toByteArray();
+  }
+}
\ No newline at end of file
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/util/vint/TestVIntTool.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/vint/TestVIntTool.java
new file mode 100644
index 0000000..341ad2a
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/vint/TestVIntTool.java
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.vint;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Random;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+/************************** Tests ********************************/
+
+public class TestVIntTool {
+
+  @Test
+  public void testNumBytes() {
+    Assert.assertEquals(1, UVIntTool.numBytes(0));
+    Assert.assertEquals(1, UVIntTool.numBytes(1));
+    Assert.assertEquals(1, UVIntTool.numBytes(100));
+    Assert.assertEquals(1, UVIntTool.numBytes(126));
+    Assert.assertEquals(1, UVIntTool.numBytes(127));
+    Assert.assertEquals(2, UVIntTool.numBytes(128));
+    Assert.assertEquals(2, UVIntTool.numBytes(129));
+    Assert.assertEquals(5, UVIntTool.numBytes(Integer.MAX_VALUE));
+  }
+
+  @Test
+  public void testWriteBytes() throws IOException {
+    Assert.assertArrayEquals(new byte[] { 0 }, bytesViaOutputStream(0));
+    Assert.assertArrayEquals(new byte[] { 1 }, bytesViaOutputStream(1));
+    Assert.assertArrayEquals(new byte[] { 63 }, bytesViaOutputStream(63));
+    Assert.assertArrayEquals(new byte[] { 127 }, bytesViaOutputStream(127));
+    Assert.assertArrayEquals(new byte[] { -128, 1 }, bytesViaOutputStream(128));
+    Assert.assertArrayEquals(new byte[] { -128 + 27, 1 }, bytesViaOutputStream(155));
+    Assert.assertArrayEquals(UVIntTool.MAX_VALUE_BYTES, bytesViaOutputStream(Integer.MAX_VALUE));
+  }
+
+  private byte[] bytesViaOutputStream(int value) throws IOException {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    UVIntTool.writeBytes(value, os);
+    return os.toByteArray();
+  }
+
+  @Test
+  public void testToBytes() {
+    Assert.assertArrayEquals(new byte[] { 0 }, UVIntTool.getBytes(0));
+    Assert.assertArrayEquals(new byte[] { 1 }, UVIntTool.getBytes(1));
+    Assert.assertArrayEquals(new byte[] { 63 }, UVIntTool.getBytes(63));
+    Assert.assertArrayEquals(new byte[] { 127 }, UVIntTool.getBytes(127));
+    Assert.assertArrayEquals(new byte[] { -128, 1 }, UVIntTool.getBytes(128));
+    Assert.assertArrayEquals(new byte[] { -128 + 27, 1 }, UVIntTool.getBytes(155));
+    Assert.assertArrayEquals(UVIntTool.MAX_VALUE_BYTES, UVIntTool.getBytes(Integer.MAX_VALUE));
+  }
+
+  @Test
+  public void testFromBytes() {
+    Assert.assertEquals(Integer.MAX_VALUE, UVIntTool.getInt(UVIntTool.MAX_VALUE_BYTES));
+  }
+
+  @Test
+  public void testRoundTrips() {
+    Random random = new Random();
+    for (int i = 0; i < 10000; ++i) {
+      int value = random.nextInt(Integer.MAX_VALUE);
+      byte[] bytes = UVIntTool.getBytes(value);
+      int roundTripped = UVIntTool.getInt(bytes);
+      Assert.assertEquals(value, roundTripped);
+    }
+  }
+
+  @Test
+  public void testInputStreams() throws IOException {
+    ByteArrayInputStream is;
+    is = new ByteArrayInputStream(new byte[] { 0 });
+    Assert.assertEquals(0, UVIntTool.getInt(is));
+    is = new ByteArrayInputStream(new byte[] { 5 });
+    Assert.assertEquals(5, UVIntTool.getInt(is));
+    is = new ByteArrayInputStream(new byte[] { -128 + 27, 1 });
+    Assert.assertEquals(155, UVIntTool.getInt(is));
+  }
+
+}
\ No newline at end of file
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hbase/util/vint/TestVLongTool.java b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/vint/TestVLongTool.java
new file mode 100644
index 0000000..c754885
--- /dev/null
+++ b/hbase-prefix-tree/src/test/java/org/apache/hbase/util/vint/TestVLongTool.java
@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hbase.util.vint;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+
+import org.apache.hbase.util.number.RandomNumberUtils;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TestVLongTool {
+
+  @Test
+  public void testNumBytes() {
+    Assert.assertEquals(1, UVLongTool.numBytes(0));
+    Assert.assertEquals(1, UVLongTool.numBytes(1));
+    Assert.assertEquals(1, UVLongTool.numBytes(100));
+    Assert.assertEquals(1, UVLongTool.numBytes(126));
+    Assert.assertEquals(1, UVLongTool.numBytes(127));
+    Assert.assertEquals(2, UVLongTool.numBytes(128));
+    Assert.assertEquals(2, UVLongTool.numBytes(129));
+    Assert.assertEquals(9, UVLongTool.numBytes(Long.MAX_VALUE));
+  }
+
+  @Test
+  public void testToBytes() {
+    Assert.assertArrayEquals(new byte[] { 0 }, UVLongTool.getBytes(0));
+    Assert.assertArrayEquals(new byte[] { 1 }, UVLongTool.getBytes(1));
+    Assert.assertArrayEquals(new byte[] { 63 }, UVLongTool.getBytes(63));
+    Assert.assertArrayEquals(new byte[] { 127 }, UVLongTool.getBytes(127));
+    Assert.assertArrayEquals(new byte[] { -128, 1 }, UVLongTool.getBytes(128));
+    Assert.assertArrayEquals(new byte[] { -128 + 27, 1 }, UVLongTool.getBytes(155));
+    Assert.assertArrayEquals(UVLongTool.MAX_VALUE_BYTES, UVLongTool.getBytes(Long.MAX_VALUE));
+  }
+
+  @Test
+  public void testFromBytes() {
+    Assert.assertEquals(Long.MAX_VALUE, UVLongTool.getLong(UVLongTool.MAX_VALUE_BYTES));
+  }
+
+  @Test
+  public void testFromBytesOffset() {
+    Assert.assertEquals(Long.MAX_VALUE, UVLongTool.getLong(UVLongTool.MAX_VALUE_BYTES, 0));
+
+    long ms = 1318966363481L;
+//    System.out.println(ms);
+    byte[] bytes = UVLongTool.getBytes(ms);
+//    System.out.println(Arrays.toString(bytes));
+    long roundTripped = UVLongTool.getLong(bytes, 0);
+    Assert.assertEquals(ms, roundTripped);
+
+    int calculatedNumBytes = UVLongTool.numBytes(ms);
+    int actualNumBytes = bytes.length;
+    Assert.assertEquals(actualNumBytes, calculatedNumBytes);
+
+    byte[] shiftedBytes = new byte[1000];
+    int shift = 33;
+    System.arraycopy(bytes, 0, shiftedBytes, shift, bytes.length);
+    long shiftedRoundTrip = UVLongTool.getLong(shiftedBytes, shift);
+    Assert.assertEquals(ms, shiftedRoundTrip);
+  }
+
+  @Test
+  public void testRoundTrips() {
+    Random random = new Random();
+    for (int i = 0; i < 10000; ++i) {
+      long value = RandomNumberUtils.nextPositiveLong(random);
+      byte[] bytes = UVLongTool.getBytes(value);
+      long roundTripped = UVLongTool.getLong(bytes);
+      Assert.assertEquals(value, roundTripped);
+      int calculatedNumBytes = UVLongTool.numBytes(value);
+      int actualNumBytes = bytes.length;
+      Assert.assertEquals(actualNumBytes, calculatedNumBytes);
+    }
+  }
+
+  @Test
+  public void testInputStreams() throws IOException {
+    ByteArrayInputStream is;
+    is = new ByteArrayInputStream(new byte[] { 0 });
+    Assert.assertEquals(0, UVLongTool.getLong(is));
+    is = new ByteArrayInputStream(new byte[] { 5 });
+    Assert.assertEquals(5, UVLongTool.getLong(is));
+    is = new ByteArrayInputStream(new byte[] { -128 + 27, 1 });
+    Assert.assertEquals(155, UVLongTool.getLong(is));
+  }
+}
\ No newline at end of file
diff --git a/hbase-server/pom.xml b/hbase-server/pom.xml
index 53c643b..07d086b 100644
--- a/hbase-server/pom.xml
+++ b/hbase-server/pom.xml
@@ -280,6 +280,12 @@
     </dependency>
     <dependency>
       <groupId>org.apache.hbase</groupId>
+      <artifactId>hbase-prefix-tree</artifactId>
+      <!-- unfortunately, runtime scope causes eclipse to put it in the compile time classpath -->
+      <scope>runtime</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.hbase</groupId>
       <artifactId>hbase-common</artifactId>
       <type>test-jar</type>
     </dependency>
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
index 29f2cc8..62fe176 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
@@ -32,6 +32,7 @@ import org.apache.hadoop.hbase.io.hfile.CacheConfig;
 import org.apache.hadoop.hbase.io.hfile.HFileScanner;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
 import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hbase.Cell;
 
 /**
  * A facade for a {@link org.apache.hadoop.hbase.io.hfile.HFile.Reader} that serves up
@@ -139,6 +140,17 @@ public class HalfStoreFileReader extends StoreFile.Reader {
         return true;
       }
 
+
+      @Override
+      public Cell getCurrentCell(){
+        return getKeyValue();
+      }
+
+      @Override
+      public boolean nextCell() throws IOException{
+        return next();
+      }
+
       public boolean seekBefore(byte[] key) throws IOException {
         return seekBefore(key, 0, key.length);
       }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java
index 7e71f94..814bb8d 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java
@@ -24,12 +24,15 @@ import java.nio.ByteBuffer;
 import org.apache.hadoop.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.SamePrefixComparator;
+import org.apache.hadoop.hbase.KeyValueTool;
 import org.apache.hadoop.hbase.io.compress.Compression.Algorithm;
 import org.apache.hadoop.hbase.io.hfile.BlockType;
 import org.apache.hadoop.hbase.util.ByteBufferUtils;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.io.RawComparator;
 import org.apache.hadoop.io.WritableUtils;
+import org.apache.hbase.Cell;
+import org.apache.hbase.cell.CellComparator;
 
 /**
  * Base class for all data block encoders that use a buffer.
@@ -45,7 +48,19 @@ abstract class BufferedDataBlockEncoder implements DataBlockEncoder {
     return decodeKeyValues(source, 0, 0, includesMemstoreTS);
   }
 
-  protected static class SeekerState {
+  protected static class SeekerState implements Cell, Comparable<Cell>{
+    protected ByteBuffer currentBuffer;
+    
+    //new
+    protected short rowLength;
+    protected int familyOffset;
+    protected byte familyLength;
+    protected int qualifierOffset;
+    protected int qualifierLength;
+    protected long timestamp;
+    protected byte typeByte;
+    //end new
+    
     protected int valueOffset = -1;
     protected int keyLength;
     protected int valueLength;
@@ -78,6 +93,21 @@ abstract class BufferedDataBlockEncoder implements DataBlockEncoder {
       }
     }
 
+    /*
+     * calling this everywhere value.offset is updated in hopes that's everywhere necessary
+     */
+    protected void extractOffsetsAndLengthsFromKey(){
+      rowLength = Bytes.toShort(keyBuffer);
+      familyOffset = Bytes.SIZEOF_SHORT + getRowLength() + Bytes.SIZEOF_BYTE;
+      familyLength = keyBuffer[getFamilyOffset()-Bytes.SIZEOF_BYTE];
+      qualifierOffset = familyOffset + familyLength;
+      qualifierLength = keyLength - (int) KeyValue.getKeyDataStructureSize(rowLength, familyLength, 
+        0);
+      int tsOffset = keyLength - KeyValue.TIMESTAMP_TYPE_SIZE;
+      timestamp = Bytes.toLong(keyBuffer, tsOffset);
+      typeByte = keyBuffer[keyLength - 1];
+    }
+
     /**
      * Copy the state from the next one into this instance (the previous state
      * placeholder). Used to save the previous state when we are advancing the
@@ -98,6 +128,16 @@ abstract class BufferedDataBlockEncoder implements DataBlockEncoder {
                 - nextState.lastCommonPrefix);
       }
 
+      //new
+      rowLength = nextState.rowLength;
+      familyOffset = nextState.familyOffset;
+      familyLength = nextState.familyLength;
+      qualifierOffset = nextState.qualifierOffset;
+      qualifierLength = nextState.qualifierLength;
+      timestamp = nextState.timestamp;
+      typeByte = nextState.typeByte;
+      //end new
+
       valueOffset = nextState.valueOffset;
       keyLength = nextState.keyLength;
       valueLength = nextState.valueLength;
@@ -106,6 +146,123 @@ abstract class BufferedDataBlockEncoder implements DataBlockEncoder {
       memstoreTS = nextState.memstoreTS;
     }
 
+    /************ Cell methods ******************************/
+    /*
+     * These are first-draft copies of the internals of KeyValue and can be more performant if we
+     * cache the length/offset values rather than parsing them out of the backing array each method
+     * call.  We cannot cache them in KeyValue because it would bloat memory, but we can here.
+     */
+
+    @Override
+    public byte[] getRowArray() {
+      return keyBuffer;
+    }
+
+    @Override
+    public int getRowOffset() {
+      return Bytes.SIZEOF_SHORT;
+    }
+
+    @Override
+    public short getRowLength() {
+      return rowLength;
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return keyBuffer;
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return familyOffset;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return familyLength;
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return keyBuffer;
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return qualifierOffset;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return qualifierLength;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return timestamp;
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return typeByte;
+    }
+
+    @Override
+    public long getMvccVersion() {
+      return memstoreTS;
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return currentBuffer.array();
+    }
+
+    @Override
+    public int getValueOffset() {
+      return currentBuffer.arrayOffset() + valueOffset;
+    }
+
+    @Override
+    public int getValueLength() {
+      return valueLength;
+    }
+
+    /************** copied from PrefixTreeCell ************************/
+
+    @Override
+    public String toString() {
+      KeyValue kv = KeyValueTool.copyToNewKeyValue(this);
+      if (kv == null) {
+        return "null";
+      }
+      return kv.toString();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (!(obj instanceof Cell)) {
+        return false;
+      }
+      //Temporary hack to maintain backwards compatibility with KeyValue.equals
+      return CellComparator.equalsIgnoreMvccVersion(this, (Cell)obj);
+
+      //TODO return CellComparator.equals(this, (Cell)obj);
+    }
+
+    @Override
+    public int hashCode(){
+      //Temporary hack to maintain backwards compatibility with KeyValue.hashCode
+      return KeyValueTool.copyToNewKeyValue(this).hashCode();
+
+      //TODO return CellComparator.hashCode(this);
+    }
+
+    @Override
+    public int compareTo(Cell other) {
+      return CellComparator.compareStatic(this, other);
+    }
+
   }
 
   protected abstract static class
@@ -131,6 +288,8 @@ abstract class BufferedDataBlockEncoder implements DataBlockEncoder {
     @Override
     public void setCurrentBuffer(ByteBuffer buffer) {
       currentBuffer = buffer;
+      current.currentBuffer = buffer;
+      previous.currentBuffer = buffer;
       decodeFirst();
       previous.invalidate();
     }
@@ -187,6 +346,18 @@ abstract class BufferedDataBlockEncoder implements DataBlockEncoder {
       return true;
     }
 
+
+    @Override
+    public Cell getCurrentCell(){
+//      return getKeyValue();
+      return current;
+    }
+
+    @Override
+    public boolean nextCell(){
+      return next();
+    }
+
     @Override
     public int seekToKeyInBlock(byte[] key, int offset, int length,
         boolean seekBefore) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/CopyKeyDataBlockEncoder.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/CopyKeyDataBlockEncoder.java
index 023d731..9abcd74 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/CopyKeyDataBlockEncoder.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/CopyKeyDataBlockEncoder.java
@@ -77,6 +77,7 @@ public class CopyKeyDataBlockEncoder extends BufferedDataBlockEncoder {
         current.ensureSpaceForKey();
         currentBuffer.get(current.keyBuffer, 0, current.keyLength);
         current.valueOffset = currentBuffer.position();
+        current.extractOffsetsAndLengthsFromKey();//TODO move somewhere better
         ByteBufferUtils.skip(currentBuffer, current.valueLength);
         if (includesMemstoreTS) {
           current.memstoreTS = ByteBufferUtils.readVLong(currentBuffer);
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java
index 039187d..384288c 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java
@@ -513,6 +513,7 @@ public class DiffKeyDeltaEncoder extends BufferedDataBlockEncoder {
         }
 
         current.valueOffset = currentBuffer.position();
+        current.extractOffsetsAndLengthsFromKey();//TODO move somewhere better
         ByteBufferUtils.skip(currentBuffer, current.valueLength);
 
         if (includesMemstoreTS) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java
index 7c7c4b7..577e18e 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java
@@ -518,6 +518,7 @@ public class FastDiffDeltaEncoder extends BufferedDataBlockEncoder {
           current.valueOffset = currentBuffer.position();
           ByteBufferUtils.skip(currentBuffer, current.valueLength);
         }
+        current.extractOffsetsAndLengthsFromKey();//TODO move somewhere better
 
         if (includesMemstoreTS) {
           current.memstoreTS = ByteBufferUtils.readVLong(currentBuffer);
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java
index 925801a..554b956 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java
@@ -16,14 +16,10 @@
  */
 package org.apache.hadoop.hbase.io.encoding;
 
-import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
-import java.io.FilterOutputStream;
 import java.io.IOException;
-import java.lang.reflect.Field;
 import java.nio.ByteBuffer;
-import java.util.Arrays;
 
 import org.apache.hadoop.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.KeyValue;
@@ -182,6 +178,7 @@ public class PrefixKeyDeltaEncoder extends BufferedDataBlockEncoder {
         currentBuffer.get(current.keyBuffer, current.lastCommonPrefix,
             current.keyLength - current.lastCommonPrefix);
         current.valueOffset = currentBuffer.position();
+        current.extractOffsetsAndLengthsFromKey();//TODO move somewhere better
         ByteBufferUtils.skip(currentBuffer, current.valueLength);
         if (includesMemstoreTS) {
           current.memstoreTS = ByteBufferUtils.readVLong(currentBuffer);
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV1.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV1.java
index 125dcdc..5d7c99d 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV1.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV1.java
@@ -37,6 +37,7 @@ import org.apache.hadoop.hbase.io.hfile.HFile.Writer;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.io.IOUtils;
 import org.apache.hadoop.io.RawComparator;
+import org.apache.hbase.Cell;
 
 import com.google.common.base.Preconditions;
 
@@ -557,6 +558,16 @@ public class HFileReaderV1 extends AbstractHFileReader {
     }
 
     @Override
+    public Cell getCurrentCell(){
+      return getKeyValue();
+    }
+
+    @Override
+    public boolean nextCell() throws IOException{
+      return next();
+    }
+
+    @Override
     protected int blockSeek(byte[] key, int offset, int length,
         boolean seekBefore) {
       int klen, vlen;
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV2.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV2.java
index b9a79f9..f08a3d3 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV2.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV2.java
@@ -38,6 +38,7 @@ import org.apache.hadoop.hbase.io.hfile.HFile.FileInfo;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.IdLock;
 import org.apache.hadoop.io.WritableUtils;
+import org.apache.hbase.Cell;
 
 /**
  * {@link HFile} reader for version 2.
@@ -687,6 +688,16 @@ public class HFileReaderV2 extends AbstractHFileReader {
       return true;
     }
 
+    @Override
+    public Cell getCurrentCell(){
+      return getKeyValue();
+    }
+
+    @Override
+    public boolean nextCell() throws IOException{
+      return next();
+    }
+
     /**
      * Positions this scanner at the start of the file.
      *
@@ -1001,6 +1012,16 @@ public class HFileReaderV2 extends AbstractHFileReader {
     }
 
     @Override
+    public Cell getCurrentCell(){
+      return seeker.getCurrentCell();
+    }
+
+    @Override
+    public boolean nextCell() throws IOException{
+      return next();
+    }
+
+    @Override
     public ByteBuffer getKey() {
       assertValidSeek();
       return seeker.getKeyDeepCopy();
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileScanner.java
index ffca0c2..acfb5f0 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileScanner.java
@@ -23,6 +23,7 @@ import java.nio.ByteBuffer;
 
 import org.apache.hadoop.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hbase.Cell;
 
 /**
  * A scanner allows you to position yourself within a HFile and
@@ -122,6 +123,12 @@ public interface HFileScanner {
    * @return Instance of {@link KeyValue}.
    */
   public KeyValue getKeyValue();
+  
+  
+  public Cell getCurrentCell();
+  public boolean nextCell() throws IOException;
+  
+  
   /**
    * Convenience method to get a copy of the key as a string - interpreting the
    * bytes as UTF8. You must call {@link #seekTo(byte[])} before this method.
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueHeap.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueHeap.java
index ed501dc..ba55af2 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueHeap.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueHeap.java
@@ -27,6 +27,8 @@ import java.util.PriorityQueue;
 import org.apache.hadoop.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.KVComparator;
+import org.apache.hbase.Cell;
+import org.apache.hbase.cell.CellComparator;
 
 /**
  * Implements a heap merge across any number of KeyValueScanners.
@@ -82,6 +84,7 @@ public class KeyValueHeap extends NonLazyKeyValueScanner
     }
   }
 
+  @Override
   public KeyValue peek() {
     if (this.current == null) {
       return null;
@@ -89,6 +92,7 @@ public class KeyValueHeap extends NonLazyKeyValueScanner
     return this.current.peek();
   }
 
+  @Override
   public KeyValue next()  throws IOException {
     if(this.current == null) {
       return null;
@@ -109,6 +113,34 @@ public class KeyValueHeap extends NonLazyKeyValueScanner
     return kvReturn;
   }
 
+  @Override
+  public Cell getCurrentCell() throws IOException{
+    if (this.current == null) {
+      return null;
+    }
+    return current.getCurrentCell();
+  }
+
+  @Override
+  public Cell nextCell() throws IOException{
+    if(this.current == null) {
+      return null;
+    }
+    Cell cell = current.nextCell();
+    if (cell == null) {
+      this.current.close();
+      this.current = pollRealKV();
+    } else {
+      KeyValueScanner topScanner = this.heap.peek();
+      if (topScanner == null ||
+          CellComparator.compareStatic(cell, topScanner.getCurrentCell()) >= 0) {
+        this.heap.add(this.current);
+        this.current = pollRealKV();
+      }
+    }
+    return cell;
+  }
+
   /**
    * Gets the next row of keys from the top-most scanner.
    * <p>
@@ -120,6 +152,7 @@ public class KeyValueHeap extends NonLazyKeyValueScanner
    * @param limit
    * @return true if there are more keys, false if all scanners are done
    */
+  @Override
   public boolean next(List<KeyValue> result, int limit) throws IOException {
     return next(result, limit, null);
   }
@@ -136,6 +169,7 @@ public class KeyValueHeap extends NonLazyKeyValueScanner
    * @param metric the metric name
    * @return true if there are more keys, false if all scanners are done
    */
+  @Override
   public boolean next(List<KeyValue> result, int limit, String metric) throws IOException {
     if (this.current == null) {
       return false;
@@ -169,6 +203,7 @@ public class KeyValueHeap extends NonLazyKeyValueScanner
    * @param result
    * @return true if there are more keys, false if all scanners are done
    */
+  @Override
   public boolean next(List<KeyValue> result) throws IOException {
     return next(result, -1);
   }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueScanner.java
index bc8d487..eb44a6b 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueScanner.java
@@ -24,6 +24,7 @@ import java.util.SortedSet;
 import org.apache.hadoop.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hbase.Cell;
 
 /**
  * Scanner that returns the next KeyValue.
@@ -41,6 +42,10 @@ public interface KeyValueScanner {
    * @return the next KeyValue
    */
   public KeyValue next() throws IOException;
+  
+  public Cell getCurrentCell() throws IOException;
+  
+  public Cell nextCell() throws IOException;
 
   /**
    * Seek the scanner at or after the specified KeyValue.
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MemStore.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MemStore.java
index 64eb206..69c955e 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MemStore.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MemStore.java
@@ -19,6 +19,7 @@
 
 package org.apache.hadoop.hbase.regionserver;
 
+import java.io.IOException;
 import java.lang.management.ManagementFactory;
 import java.lang.management.RuntimeMXBean;
 import java.rmi.UnexpectedException;
@@ -43,6 +44,7 @@ import org.apache.hadoop.hbase.io.HeapSize;
 import org.apache.hadoop.hbase.regionserver.MemStoreLAB.Allocation;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.ClassSize;
+import org.apache.hbase.Cell;
 
 /**
  * The MemStore holds in-memory modifications to the Store.  Modifications
@@ -842,6 +844,17 @@ public class MemStore implements HeapSize {
       return ret;
     }
 
+
+    @Override
+    public Cell getCurrentCell(){
+      return peek();
+    }
+
+    @Override
+    public Cell nextCell() throws IOException{
+      return next();
+    }
+
     /*
      * Returns the lower of the two key values, or null if they are both null.
      * This uses comparator.compare() to compare the KeyValue using the memstore
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
index dd716d3..1477faf 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
@@ -33,6 +33,7 @@ import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.Scan;
 import org.apache.hadoop.hbase.io.hfile.HFileScanner;
 import org.apache.hadoop.hbase.regionserver.StoreFile.Reader;
+import org.apache.hbase.Cell;
 
 /**
  * KeyValueScanner adaptor over the Reader.  It also provides hooks into
@@ -137,7 +138,21 @@ public class StoreFileScanner implements KeyValueScanner {
     }
     return retKey;
   }
+  
+  @Override
+  public Cell getCurrentCell(){
+    return hfs.getCurrentCell();
+  }
 
+  @Override
+  public Cell nextCell() throws IOException {
+    if(hfs.next()){
+      return hfs.getCurrentCell();
+    }
+    return null;
+  }
+
+  @Override
   public boolean seek(KeyValue key) throws IOException {
     seekCount.incrementAndGet();
 
@@ -160,6 +175,7 @@ public class StoreFileScanner implements KeyValueScanner {
     }
   }
 
+  @Override
   public boolean reseek(KeyValue key) throws IOException {
     seekCount.incrementAndGet();
 
@@ -210,6 +226,7 @@ public class StoreFileScanner implements KeyValueScanner {
     return true;
   }
 
+  @Override
   public void close() {
     // Nothing to close on HFileScanner?
     cur = null;
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java
index 24b74b7..76f2547 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java
@@ -35,6 +35,7 @@ import org.apache.hadoop.hbase.filter.Filter;
 import org.apache.hadoop.hbase.regionserver.HStore.ScanInfo;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;
+import org.apache.hbase.Cell;
 
 /**
  * Scanner scans both the memstore and the HStore. Coalesce KeyValue stream
@@ -175,7 +176,7 @@ public class StoreScanner extends NonLazyKeyValueScanner
   }
 
   /** Constructor for testing. */
-  StoreScanner(final Scan scan, HStore.ScanInfo scanInfo,
+  public StoreScanner(final Scan scan, HStore.ScanInfo scanInfo,
       ScanType scanType, final NavigableSet<byte[]> columns,
       final List<KeyValueScanner> scanners) throws IOException {
     this(scan, scanInfo, scanType, columns, scanners,
@@ -261,6 +262,16 @@ public class StoreScanner extends NonLazyKeyValueScanner
     // throw runtime exception perhaps?
     throw new RuntimeException("Never call StoreScanner.next()");
   }
+  
+  @Override
+  public Cell getCurrentCell(){
+    return peek();
+  }
+
+  @Override
+  public Cell nextCell() throws IOException{
+    throw new RuntimeException("Never call StoreScanner.nextCell()");
+  }
 
   @Override
   public synchronized void close() {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/util/CollectionBackedScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/util/CollectionBackedScanner.java
index 7b8164b..b2e5d0c 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/util/CollectionBackedScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/util/CollectionBackedScanner.java
@@ -18,6 +18,7 @@
  */
 package org.apache.hadoop.hbase.util;
 
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
@@ -27,6 +28,7 @@ import java.util.SortedSet;
 import org.apache.hadoop.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.regionserver.NonLazyKeyValueScanner;
+import org.apache.hbase.Cell;
 
 /**
  * Utility scanner that wraps a sortable collection and serves
@@ -99,6 +101,16 @@ public class CollectionBackedScanner extends NonLazyKeyValueScanner {
   }
 
   @Override
+  public Cell getCurrentCell(){
+    return peek();
+  }
+
+  @Override
+  public Cell nextCell() throws IOException{
+    return next();
+  }
+
+  @Override
   public boolean seek(KeyValue seekKv) {
     // restart iterator
     iter = data.iterator();
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/PerformanceEvaluation.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/PerformanceEvaluation.java
index faf7b9b..5588259 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/PerformanceEvaluation.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/PerformanceEvaluation.java
@@ -112,9 +112,10 @@ import org.hbase.async.Scanner;
 public class PerformanceEvaluation extends Configured implements Tool {
   protected static final Log LOG = LogFactory.getLog(PerformanceEvaluation.class.getName());
 
-  private static final int ROW_LENGTH = 1000;
+  private static final int DEFAULT_ROW_PREFIX_LENGTH = 16;
+  private static final int VALUE_LENGTH = 1000;
   private static final int ONE_GB = 1024 * 1024 * 1000;
-  private static final int ROWS_PER_GB = ONE_GB / ROW_LENGTH;
+  private static final int ROWS_PER_GB = ONE_GB / VALUE_LENGTH;
 
   public static final byte[] COMPRESSION = Bytes.toBytes("NONE");
   public static final byte[] TABLE_NAME = Bytes.toBytes("TestTable");
@@ -127,6 +128,7 @@ public class PerformanceEvaluation extends Configured implements Tool {
 
   private boolean miniCluster = false;
   private boolean nomapred = false;
+  private int rowPrefixLength = DEFAULT_ROW_PREFIX_LENGTH;
   private int N = 1;
   private int R = ROWS_PER_GB;
   private byte[] tableName = TABLE_NAME;
@@ -537,10 +539,11 @@ public class PerformanceEvaluation extends Configured implements Tool {
     if (this.presplitRegions == 0)
       return new byte [0][];
 
-    byte[][] splits = new byte[this.presplitRegions][];
+    int numSplitPoints = presplitRegions - 1;
+    byte[][] splits = new byte[numSplitPoints][];
     int jump = this.R  / this.presplitRegions;
-    for (int i=0; i <this.presplitRegions; i++) {
-      int rowkey = jump * i;
+    for (int i=0; i < numSplitPoints; i++) {
+      int rowkey = jump * (1 + i);
       splits[i] = format(rowkey);
     }
     return splits;
@@ -931,9 +934,9 @@ public class PerformanceEvaluation extends Configured implements Tool {
       if (row.size() != 1) {
         throw new IOException((row.isEmpty() ? "No" : "Multiple (" + row.size() + ')')
                               + " KeyValue found in row");
-      } else if (row.get(0).value().length != ROW_LENGTH) {
+      } else if (row.get(0).value().length != VALUE_LENGTH) {
         throw new IOException("Invalid value length (found: " + row.get(0).value().length
-                              + ", expected: " + ROW_LENGTH + ") in row \""
+                              + ", expected: " + VALUE_LENGTH + ") in row \""
                               + new String(row.get(0).key()) + '"');
       }
     }
@@ -1420,7 +1423,7 @@ public class PerformanceEvaluation extends Configured implements Tool {
    * number (Does absolute in case number is negative).
    */
   public static byte [] format(final int number) {
-    byte [] b = new byte[10];
+    byte [] b = new byte[DEFAULT_ROW_PREFIX_LENGTH + 10];
     int d = Math.abs(number);
     for (int i = b.length - 1; i >= 0; i--) {
       b[i] = (byte)((d % 10) + '0');
@@ -1436,10 +1439,10 @@ public class PerformanceEvaluation extends Configured implements Tool {
    * @return Generated random value to insert into a table cell.
    */
   public static byte[] generateValue(final Random r) {
-    byte [] b = new byte [ROW_LENGTH];
+    byte [] b = new byte [VALUE_LENGTH];
     int i = 0;
 
-    for(i = 0; i < (ROW_LENGTH-8); i += 8) {
+    for(i = 0; i < (VALUE_LENGTH-8); i += 8) {
       b[i] = (byte) (65 + r.nextInt(26));
       b[i+1] = b[i];
       b[i+2] = b[i];
@@ -1451,7 +1454,7 @@ public class PerformanceEvaluation extends Configured implements Tool {
     }
 
     byte a = (byte) (65 + r.nextInt(26));
-    for(; i < ROW_LENGTH; i++) {
+    for(; i < VALUE_LENGTH; i++) {
       b[i] = a;
     }
     return b;
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestEncodedSeekers.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestEncodedSeekers.java
index 7d81a60..7c22049 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestEncodedSeekers.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestEncodedSeekers.java
@@ -105,15 +105,15 @@ public class TestEncodedSeekers {
 
     //write the data, but leave some in the memstore
     doPuts(region);
-    
+
     //verify correctness when memstore contains data
     doGets(region);
-    
+
     //verify correctness again after compacting
     region.compactStores();
     doGets(region);
 
-    
+
     Map<DataBlockEncoding, Integer> encodingCounts = cache.getEncodingCountsForTest();
 
     // Ensure that compactions don't pollute the cache with unencoded blocks
@@ -124,8 +124,8 @@ public class TestEncodedSeekers {
     assertEquals(encoding, encodingInCache);
     assertTrue(encodingCounts.get(encodingInCache) > 0);
   }
-  
-  
+
+
   private void doPuts(HRegion region) throws IOException{
     LoadTestKVGenerator dataGenerator = new LoadTestKVGenerator(MIN_VALUE_SIZE, MAX_VALUE_SIZE);
      for (int i = 0; i < NUM_ROWS; ++i) {
@@ -147,8 +147,8 @@ public class TestEncodedSeekers {
       }
     }
   }
-  
-  
+
+
   private void doGets(HRegion region) throws IOException{
     for (int i = 0; i < NUM_ROWS; ++i) {
       final byte[] rowKey = MultiThreadedWriter.longToByteArrayKey(i);
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/EncoderBenchmarkParams.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/EncoderBenchmarkParams.java
new file mode 100644
index 0000000..d2068c9
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/EncoderBenchmarkParams.java
@@ -0,0 +1,63 @@
+package org.apache.hadoop.hbase.io.encoding.benchmark;
+
+import org.apache.hadoop.hbase.io.encoding.DataBlockEncoding;
+
+public class EncoderBenchmarkParams {
+
+  protected String rootDir;
+  protected String tableName;
+  protected String blockSizeSuffix;
+  protected String hFileName;
+  protected DataBlockEncoding encoding;
+  protected Integer numSeeks;
+  protected Integer numSeekThreads;
+  protected Boolean pread;
+
+
+  public EncoderBenchmarkParams(String rootDir, String table, String blockSizeSuffix,
+      String hFileName, DataBlockEncoding encoding, Integer numSeeks,
+      Integer numSeekThreads, Boolean pread) {
+    this.rootDir = rootDir;
+    this.tableName = table;
+    this.blockSizeSuffix = blockSizeSuffix;
+    this.hFileName = hFileName;
+    this.encoding = encoding;
+    this.numSeeks = numSeeks;
+    this.numSeekThreads = numSeekThreads;
+    this.pread = pread;
+  }
+
+
+  public String getRootDir() {
+    return rootDir;
+  }
+
+  public String getTable() {
+    return tableName;
+  }
+
+  public String getBlockSizeSuffix() {
+    return blockSizeSuffix;
+  }
+
+  public String gethFileName() {
+    return hFileName;
+  }
+
+  public DataBlockEncoding getEncoding() {
+    return encoding;
+  }
+
+  public Integer getNumSeeks() {
+    return numSeeks;
+  }
+
+  public Integer getNumSeekThreads() {
+    return numSeekThreads;
+  }
+
+  public Boolean getPread() {
+    return pread;
+  }
+
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/EncodingBenchmarkMain.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/EncodingBenchmarkMain.java
new file mode 100644
index 0000000..ef8cd35
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/EncodingBenchmarkMain.java
@@ -0,0 +1,106 @@
+package org.apache.hadoop.hbase.io.encoding.benchmark;
+
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hbase.io.encoding.DataBlockEncoding;
+import org.apache.hadoop.hbase.util.CollectionUtils;
+
+import com.google.common.collect.Lists;
+
+/**
+ * - set rootDir variable below to something on your dev machine
+ * - note (or set and compact) the block size of an HFile in your cluster
+ * - copy HFiles from your cluster to (example): [rootDir]/MonthlyListingSummary/256KB/a
+ * - rename the file "a"
+ * - add jvm options like: -Xms4g -Xmx4g -XX:+UseConcMarkSweepGC  -XX:NewSize=512M -XX:+PrintGCDetails
+ * - comment in/out the options below and run
+ * - avoid debug mode for performance
+ * - copy paste csv output with headers into spreadsheet
+ * - (in LibreOffice), go to Data -> Text To Columns
+ */
+public class EncodingBenchmarkMain {
+  private static final Log LOG = LogFactory.getLog(EncodingBenchmarkMain.class);
+
+  public static void main(final String[] args) throws Exception {
+    String rootDir = "/home/mcorgan/prefixTreeTest";
+
+    List<String> tables = Lists.newArrayList();
+    // tables.add("Count5s");
+    // tables.add("Event");
+    tables.add("MonthlyListingSummary");
+    // tables.add("RandomValue");
+    // tables.add("Trace");
+
+    // filename must be only hex characters
+    String hFileName = "a";// StringTool.repeat('0', 32);
+
+    List<String> blockSizeSuffixes = Lists.newArrayList();
+    // blockSizes.add("1KB");
+    // blockSizes.add("4KB");
+//    blockSizes.add("16KB");
+    blockSizeSuffixes.add("64KB");
+//    blockSizes.add("256KB");
+    // blockSizes.add("1MB");
+
+    List<DataBlockEncoding> encodings = Lists.newArrayList();
+//    encodings.add(null);//is this valid anymore?
+    encodings.add(DataBlockEncoding.NONE);
+    encodings.add(DataBlockEncoding.PREFIX);
+//    encodings.add(DataBlockEncoding.DIFF);
+//    encodings.add(DataBlockEncoding.FAST_DIFF);
+    encodings.add(DataBlockEncoding.PREFIX_TREE);
+
+    List<Integer> readerThreadCounts = Lists.newArrayList();
+    readerThreadCounts.add(1);
+    // readerThreadCounts.add(2);
+    // readerThreadCounts.add(4);
+    // readerThreadCounts.add(8);
+    // readerThreadCounts.add(16);
+    // readerThreadCounts.add(32);
+
+    boolean doWarmupRun = true;
+
+    int numberOfSeeks = 100000;
+
+    // boolean[] preads = new boolean[]{false, true};
+    // boolean[] preads = new boolean[]{true};
+    boolean[] preads = new boolean[] { false };
+    // if(numReaderThreads <= 1){ preads = new boolean[]{false, true}; }
+
+    List<EncodingBenchmarkResult> results = Lists.newArrayList();
+
+    for (String table : tables) {
+      for (DataBlockEncoding encoding : encodings) {
+        for (String blockSizeSuffix : blockSizeSuffixes) {
+          for (Integer numReaderThreads : readerThreadCounts) {
+            for (Boolean pread : preads) {
+              SingleEncoderBenchmark benchmark = null;
+              try {
+                EncoderBenchmarkParams params = new EncoderBenchmarkParams(rootDir, table,
+                    blockSizeSuffix, hFileName, encoding, numberOfSeeks, numReaderThreads, pread);
+                if (doWarmupRun) {// usually 10% slower than second run
+                  new SingleEncoderBenchmark(params).call();
+                }
+                results.add(new SingleEncoderBenchmark(params).call());
+              } catch (Exception e) {
+                e.printStackTrace();
+              } finally {
+                if(benchmark!=null && benchmark.testingUtility!=null){
+                  benchmark.testingUtility.shutdownMiniCluster();
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+
+    System.out.println(CollectionUtils.getFirst(results).getHeader());
+    for (EncodingBenchmarkResult result : results) {
+      System.out.println(result.toString());
+    }
+    System.exit(0);
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/EncodingBenchmarkResult.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/EncodingBenchmarkResult.java
new file mode 100644
index 0000000..c96b5ec
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/EncodingBenchmarkResult.java
@@ -0,0 +1,202 @@
+package org.apache.hadoop.hbase.io.encoding.benchmark;
+
+import org.apache.hadoop.hbase.io.encoding.DataBlockEncoding;
+import org.apache.hadoop.util.StringUtils;
+
+class EncodingBenchmarkResult {
+
+  protected EncoderBenchmarkParams params;
+  long numHardwareThreads;
+  DataBlockEncoding encodingInMemory;
+  boolean inMemory;
+  long numCells = 0;
+  long numKeyBytes = 0, numValueBytes = 0, numKeyValueBytes = 0;
+  long numBlocks, numNonLeafRowNodes = 0, numLeafRowNodes = 0,
+      numNonLeafQualifierNodes = 0, numLeafQualifierNodes = 0,
+      numRawBytes = 0, numEncodedBytes = 0;
+  long nsForEncoding, nsAllocateBytes, nsAddTotal, 
+      nsCompileTimestamps, nsCompileQualifiers, nsCompileRows;
+  long nsAddRow=0, nsAddFamily=0, nsAddQualifier=0, nsAddTimestamp=0, nsAddMemstoreTimestamp=0, nsAddType=0, nsAddValue=0;
+  long nsWriteRows=0, nsWriteFamilies=0, nsWriteQualifiers=0, nsWriteTimestamps=0, nsWriteMemstoreTimestamps=0, nsWriteValues=0;
+  long nsForScanning, numIterationGarbageBytes;
+  long nsForSeeking, numSeeks = 0, numSeekGarbageBytes;
+  boolean includePerformance, includeSettings, includeDataStats,
+      includePtDetails;
+
+  long ASSUME_CYCLES_PER_NS = 2;
+
+  public EncodingBenchmarkResult(EncoderBenchmarkParams params, boolean includePerformance,
+      boolean includeSettings, boolean includeDataStats,
+      boolean includePtDetails) {
+    this.params = params;
+    this.includePerformance = includePerformance;
+    this.includeSettings = includeSettings;
+    this.includeDataStats = includeDataStats;
+    this.includePtDetails = includePtDetails;
+  }
+
+  public String getHeader() {
+    String header = "table,encoding,rawBlockSize";
+    if (includePerformance) {
+      header += ",encodingMB/s,scanningMB/s,seeks/s,cycles/seek";
+    }
+    if (includeSettings) {
+      header += ",numHardwareThreads,numReaderThreads,pread";
+    }
+    if (includeDataStats) {
+      header += ",numBlocks,numNonLeafRowNodes,numLeafRowNodes,numNonLeafQualifierNodes,numLeafQualifierNodes"
+      		+ ",avgRawBlockBytes,avgEncodedBlockBytes,avgCellsPerBlock"
+          + ",numCells,avgRawKeyBytes,avgEncodedKeyBytes,keyCompressionRatio"
+          + ",avgValueBytes,compressionRatio";
+    }
+    if (includePtDetails) {
+      header += ",totalMs,allocateBytesMs,addTotalMs,addRowMs,addFamilyMs,addQualifierMs,addTimestampMs,addMemstoreTimestampMs"
+    	  +",addTypeMs,addValueMs";
+      header += ",compileTimestampMs,compileColumnMs,compileRowMs";
+      header += ",writeRowsMs,writeFamiliesMs,writeQualifiersMs,writeTimestampsMs,writeMemstoreTimestampsMs,writeValuesMs";
+    }
+    return header;
+  }
+
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    sb.append(params.getTable());
+    sb.append("," + (encodingInMemory==null?"NULL":encodingInMemory.name()));
+    sb.append("," + params.getBlockSizeSuffix());
+    if (includePerformance) {
+      sb.append("," + StringUtils.limitDecimalTo2(getEncodingMBPerSec()));
+      sb.append("," + StringUtils.limitDecimalTo2(getScanningMBPerSec()));
+      sb.append("," + getSeeksPerSec());
+      sb.append("," + getCyclesPerSeek());
+    }
+    if (includeSettings) {
+      sb.append("," + numHardwareThreads);
+      sb.append("," + params.getNumSeekThreads());
+      sb.append("," + params.getPread());
+    }
+    if (includeDataStats) {
+      sb.append("," + (numBlocks == 0 ? "?" : numBlocks));
+      sb.append("," + numNonLeafRowNodes);
+      sb.append("," + numLeafRowNodes);
+      sb.append("," + numNonLeafQualifierNodes);
+      sb.append("," + numLeafQualifierNodes);
+      sb.append(","
+          + (getAvgRawBlockBytes() == 0 ? "?" : getAvgRawBlockBytes()));
+      sb.append(","
+          + (getAvgEncodedBlockBytes() == 0 ? "?" : getAvgEncodedBlockBytes()));
+      sb.append(","
+          + (getAvgCellsPerBlock() == 0 ? "?" : getAvgCellsPerBlock()));
+      sb.append("," + numCells);
+      sb.append("," + getAvgRawKeyBytes());
+      sb.append("," + getAvgEncodedKeyBytes());
+      sb.append("," + StringUtils.limitDecimalTo2(getKeyCompressionRatio()));
+      sb.append("," + getAvgValueBytes());
+      // includes values which we can't compress
+      sb.append("," + StringUtils.limitDecimalTo2(getCompressionRatio()));
+    }
+    if (includePtDetails) {
+      sb.append("," + nsToMs(nsForEncoding));
+      sb.append("," + nsToMs(nsAllocateBytes));
+      sb.append("," + nsToMs(nsAddTotal));
+      sb.append("," + nsToMs(nsAddRow));
+      sb.append("," + nsToMs(nsAddFamily));
+      sb.append("," + nsToMs(nsAddQualifier));
+      sb.append("," + nsToMs(nsAddTimestamp));
+      sb.append("," + nsToMs(nsAddMemstoreTimestamp));
+      sb.append("," + nsToMs(nsAddType));
+      sb.append("," + nsToMs(nsAddValue));
+      sb.append("," + nsToMs(nsCompileTimestamps));
+      sb.append("," + nsToMs(nsCompileQualifiers));
+      sb.append("," + nsToMs(nsCompileRows));
+      sb.append("," + nsToMs(nsWriteRows));
+      sb.append("," + nsToMs(nsWriteFamilies));
+      sb.append("," + nsToMs(nsWriteQualifiers));
+      sb.append("," + nsToMs(nsWriteTimestamps));
+      sb.append("," + nsToMs(nsWriteMemstoreTimestamps));
+      sb.append("," + nsToMs(nsWriteValues));
+    }
+    return sb.toString();
+  }
+
+  long getAvgRawKeyBytes() {
+    return numKeyBytes / numCells;
+  }
+
+  long getAvgEncodedKeyBytes() {
+    if (numEncodedBytes == 0) {
+      return getAvgRawKeyBytes();
+    }
+    long numEncodedKeyBytes = numEncodedBytes - numValueBytes;
+    return numEncodedKeyBytes / numCells;
+  }
+
+  long getAvgValueBytes() {
+    return numValueBytes / numCells;
+  }
+
+  double getEncodingMBPerSec() {
+    double mb = (double) numKeyValueBytes
+        / (double) SingleEncoderBenchmark.BYTES_IN_MEGABYTES;
+    double sec = (double) nsForEncoding
+        / (double) SingleEncoderBenchmark.NANOSEC_IN_SEC;
+    return mb / sec;
+  }
+
+  double getScanningMBPerSec() {
+    double mb = (double) numKeyValueBytes
+        / (double) SingleEncoderBenchmark.BYTES_IN_MEGABYTES;
+    double sec = (double) nsForScanning
+        / (double) SingleEncoderBenchmark.NANOSEC_IN_SEC;
+    return mb / sec;
+  }
+
+  long getSeeksPerSec() {
+    return (long) (numSeeks * SingleEncoderBenchmark.NANOSEC_IN_SEC)
+        / nsForSeeking;
+  }
+
+  long getCyclesPerSeek() {
+    return ASSUME_CYCLES_PER_NS * nsForSeeking / numSeeks;
+  }
+
+  double getCompressionRatio() {
+    if (numRawBytes == 0 || numEncodedBytes == 0) {
+      return 1.0;
+    }
+    return (double) numRawBytes / (double) numEncodedBytes;
+  }
+
+  double getKeyCompressionRatio() {
+    if (numRawBytes == 0 || numEncodedBytes == 0) {
+      return 1.0;
+    }
+    return (double) getAvgRawKeyBytes() / (double) getAvgEncodedKeyBytes();
+  }
+
+  long getAvgRawBlockBytes() {
+    if (numRawBytes == 0 || numBlocks == 0) {
+      return 0;
+    }
+    return numRawBytes / numBlocks;
+  }
+
+  long getAvgEncodedBlockBytes() {
+    if (numEncodedBytes == 0 || numBlocks == 0) {
+      return 0;
+    }
+    return numEncodedBytes / numBlocks;
+  }
+
+  long getAvgCellsPerBlock() {
+    if (numCells == 0 || numBlocks == 0) {
+      return 0;
+    }
+    return numCells / numBlocks;
+  }
+
+  
+	public static Long nsToMs(Long ns) {
+		double ms = (double) ns / (double) 1000000;
+		return (long) ms;
+	}
+}
\ No newline at end of file
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/SeeksCallable.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/SeeksCallable.java
new file mode 100644
index 0000000..6a7e985
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/SeeksCallable.java
@@ -0,0 +1,73 @@
+package org.apache.hadoop.hbase.io.encoding.benchmark;
+
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.logging.Logger;
+
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFileScanner;
+
+/**
+ * NOTICE: multi-threaded behavior not working since addition of
+ * PrefetchedHeader ThreadLocal variable in HFileBlock. Haven't figured out a
+ * work-around.
+ * 
+ * Class for testing how many seeks we can get on a machine. Does performance
+ * degrade before numThreads=numCores or after?
+ */
+class SeeksCallable implements Callable<Long> {
+  protected static Logger logger = Logger.getLogger(SeeksCallable.class.getSimpleName());
+
+  protected StoreFile storeFile;
+  protected boolean pread;
+  protected List<KeyValue> seekTargets;
+  protected CountDownLatch countDownLatch;
+
+  public SeeksCallable(StoreFile storeFile, boolean pread, List<KeyValue> seekTargets,
+      CountDownLatch countDownLatch) {
+    this.storeFile = storeFile;
+    this.pread = pread;
+    this.seekTargets = seekTargets;
+    this.countDownLatch = countDownLatch;
+  }
+
+  @Override
+  public Long call() throws Exception {
+    StoreFile.Reader threadReader = storeFile.createReader();
+    StoreFileScanner threadScanner = threadReader.getStoreFileScanner(true, pread);
+    KeyValue seekTarget = null;
+    KeyValue foundKv = null;
+    int numCorrect = 0;
+    Long timeNs = null;
+    long startSeeksTime = System.nanoTime();
+    try {
+      for (int i = 0; i < seekTargets.size(); ++i) {
+        seekTarget = seekTargets.get(i);
+        try {
+          threadScanner.seek(seekTarget);
+          foundKv = threadScanner.peek();
+          if (!seekTarget.equals(foundKv)) { throw new RuntimeException("orig!=ret"); }
+          ++numCorrect;
+        } catch (RuntimeException re) {
+          System.out.println(Thread.currentThread().getId() + " "
+              + SingleEncoderBenchmark.getKeyValueMismatchMessage(i, seekTarget, foundKv));
+        }
+      }
+    } catch (Exception e) {
+      logger.warning("numCorrect:" + numCorrect + ", errored key=" + seekTarget);
+      e.printStackTrace();
+      throw new RuntimeException(e);
+    } finally {
+      countDownLatch.countDown();
+    }
+    if (numCorrect < seekTargets.size()) {
+      System.out.println(" numCorrect " + numCorrect + "/" + seekTargets.size());
+    }
+    timeNs = System.nanoTime() - startSeeksTime;
+    threadScanner.close();
+    return timeNs;
+  }
+
+}
\ No newline at end of file
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/SingleEncoderBenchmark.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/SingleEncoderBenchmark.java
new file mode 100644
index 0000000..07439d0
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/benchmark/SingleEncoderBenchmark.java
@@ -0,0 +1,353 @@
+package org.apache.hadoop.hbase.io.encoding.benchmark;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+
+import junit.framework.Assert;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.io.encoding.DataBlockEncoding;
+import org.apache.hadoop.hbase.io.hfile.BlockCache;
+import org.apache.hadoop.hbase.io.hfile.CacheConfig;
+import org.apache.hadoop.hbase.io.hfile.HFileDataBlockEncoder;
+import org.apache.hadoop.hbase.io.hfile.HFileDataBlockEncoderImpl;
+import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFile.BloomType;
+import org.apache.hadoop.hbase.regionserver.StoreFileScanner;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.CollectionUtils;
+import org.apache.hadoop.hbase.util.Pair;
+
+import com.google.common.collect.Lists;
+
+public class SingleEncoderBenchmark implements Callable<EncodingBenchmarkResult>{
+  private static final Log LOG = LogFactory.getLog(SingleEncoderBenchmark.class);
+
+  protected static final Long NANOSEC_IN_SEC = 1000 * 1000 * 1000L;
+  protected static final Long BYTES_IN_MEGABYTES = 1024 * 1024L;
+
+  protected static boolean RANDOM_RANDOM = true;
+  protected static long RANDOM_SEED = 1L;//if RANDOM_RANDOM==false
+
+
+  /****************** fields **********************************/
+
+  protected EncoderBenchmarkParams params;
+  protected EncodingBenchmarkResult result;
+
+  protected HBaseTestingUtility testingUtility = new HBaseTestingUtility();
+  protected Configuration configuration = testingUtility.getConfiguration();
+  protected CacheConfig cacheConfig = new CacheConfig(configuration);
+
+  protected StoreFile storeFile;
+  protected ArrayList<KeyValue> allKeyValues = Lists.newArrayList();
+  protected ArrayList<KeyValue> seeks = Lists.newArrayList();
+  protected Integer maxSeekIndex = null;// set to null for full coverage
+
+
+  /******************** construct *****************************/
+
+  public SingleEncoderBenchmark(EncoderBenchmarkParams params) {
+    this.params = params;
+    configuration.setFloat(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY, 0.5f);
+	}
+
+
+  /********************* Callable ********************************/
+
+  @Override
+  public EncodingBenchmarkResult call() throws IOException {
+    assertBlockCacheIsEmpty();
+
+    String hfilePath = params.getRootDir() + "/" + params.getTable() + "/" + params.getBlockSizeSuffix()
+        + "/" + params.gethFileName();
+    Path path = new Path(hfilePath);
+    allKeyValues.clear();
+
+    loadAllKeyValues(path);
+    prepareListOfTestSeeks();
+    // DataBlockEncodingStaticVars.reset();
+
+    Pair<DataBlockEncoding, DataBlockEncoding> encoderPair = new Pair<DataBlockEncoding, DataBlockEncoding>(
+        DataBlockEncoding.NONE, params.getEncoding());
+    result = new EncodingBenchmarkResult(params, true, false, true, true);
+    result.numHardwareThreads = Runtime.getRuntime().availableProcessors();
+    result.encodingInMemory = encoderPair.getSecond();
+    HFileDataBlockEncoder encoder = new HFileDataBlockEncoderImpl(encoderPair.getFirst(),
+        encoderPair.getSecond());
+    runTest(path, encoder, params.getNumSeekThreads(), params.getPread(), seeks, false);
+    System.out.println(result.getHeader());
+    System.out.println(result);
+    return result;
+  }
+
+
+	/****************** methods ***************************************/
+
+	protected void loadAllKeyValues(Path path) throws IOException {
+		// read all of the key values
+    HFileDataBlockEncoder hFileEncoder = new HFileDataBlockEncoderImpl(DataBlockEncoding.NONE,
+        DataBlockEncoding.NONE);
+    StoreFile storeFile = new StoreFile(testingUtility.getTestFileSystem(), path,
+        testingUtility.getConfiguration(), cacheConfig, BloomType.NONE, hFileEncoder);
+
+		StoreFile.Reader reader = storeFile.createReader();
+		StoreFileScanner scanner = reader.getStoreFileScanner(true, false);
+		KeyValue previous = null;
+		KeyValue current = null;
+
+		System.out.println("--start building random seek list--");
+		scanner.seek(KeyValue.LOWESTKEY);
+//		long lastTimestamp = 0L;
+//		int uniqueTimestamps = 0;
+		int numToPrint = 0;//set this to a positive number of you want to print the next n rows
+		while (true) {
+			previous = current;
+			current = scanner.next();
+			if (current == null) {
+				break;
+			}
+//			33366, \x00\x00\x07\xDC\x00\x00\x00\x02RealPage\x001002353\x00
+//			33366, \x00\x00\x07\xDC\x00\x00\x00\x02Real
+//			34838, \x00\x00\x07\xDC\x00\x00\x00\x02RealtySoft\x0020113711\x00
+      byte[] debugRow = Bytes.toBytesBinary("\\x00\\x00\\x07\\xDC\\x00\\x00\\x00\\x02RealEstateShows\\x0092898\\x00");
+      if(Bytes.equals(debugRow, current.getRow())){
+        numToPrint = 200;
+      }
+			if(numToPrint > 0){
+//        LOG.warn(Bytes.toStringBinary(current.getRow()));
+//			  LOG.warn(current);
+        --numToPrint;
+      }
+//			long timestamp = current.getTimestamp();
+//			if(timestamp != lastTimestamp){
+//				++uniqueTimestamps;
+//				System.out.println("new timestamp "+timestamp+", unique:"+uniqueTimestamps);
+//				lastTimestamp = timestamp;
+//			}
+			// if(FLATTEN_TIMESTAMPS){
+			// KeyValueTool.overwriteTimestamp(current, FLAT_TIMESTAMP);
+			// }
+			if (previous != null) {
+				int comp = KeyValue.COMPARATOR.compare(previous, current);
+				Assert.assertTrue(comp < 0);
+			}
+			allKeyValues.add(current);
+			if (maxSeekIndex != null && allKeyValues.size() >= maxSeekIndex) {
+				break;
+			}
+		}
+		System.out.println("loaded " + allKeyValues.size() + " KeyValues");
+		System.out.println("first:"+CollectionUtils.getFirst(allKeyValues));
+		System.out.println(" last:"+CollectionUtils.getLast(allKeyValues));
+		System.out.println("--finished building random seek list--");
+
+		storeFile.closeReader(true);
+		assertBlockCacheIsEmpty();
+	}
+
+	protected void prepareListOfTestSeeks() throws IOException {
+		seeks.clear();
+		Random random;
+		if(RANDOM_RANDOM){
+			random = new Random(); 
+		}else{
+			random = new Random(RANDOM_SEED);
+		}
+		if (maxSeekIndex == null) {
+			maxSeekIndex = allKeyValues.size();
+		}
+		List<Integer> seekIndexes = Lists.newArrayList();
+		for (int i = 0; i < params.getNumSeeks(); ++i) {
+			int r = random.nextInt(maxSeekIndex);
+			seekIndexes.add(r);
+		}
+		for (Integer seekIndex : seekIndexes) {
+			KeyValue keyValue = allKeyValues.get(seekIndex);
+			seeks.add(keyValue);
+		}
+	}
+
+	protected void runTest(Path path, HFileDataBlockEncoder hFileEncoder,
+			Integer numReaderThreads, boolean pread, List<KeyValue> seeks, boolean clearCacheBeforeSeeks)
+			throws IOException{
+
+		// read all of the key values
+    StoreFile storeFile = new StoreFile(testingUtility.getTestFileSystem(), path,
+        testingUtility.getConfiguration(), cacheConfig, BloomType.NONE, hFileEncoder);
+
+		encodeWhileReadingFromDiskToBlockCache(storeFile);
+		runSequentialScan(storeFile);
+		if(clearCacheBeforeSeeks){
+			clearBlockCache(false);
+		}
+		runRandomSeeks(storeFile);
+	}
+
+	protected void encodeWhileReadingFromDiskToBlockCache(StoreFile storeFile) throws IOException {
+    assertBlockCacheIsEmpty();
+
+    StoreFile.Reader reader = storeFile.createReader();
+    StoreFileScanner scanner = reader.getStoreFileScanner(true, params.getPread());
+
+		System.gc();
+		System.out.println("--starting encoding --");
+		long startEncodingNs = System.nanoTime();
+		KeyValue current;
+		scanner.seek(KeyValue.LOWESTKEY);
+		//this call to scanner.next is creating garbage
+		while (null != (current = scanner.next())) {
+			++result.numCells;
+			result.numKeyBytes += current.getKeyLength();
+			result.numValueBytes += current.getValueLength();
+			// does this include memstoreTS?
+			result.numKeyValueBytes += current.getLength();
+		}
+		result.nsForEncoding = System.nanoTime() - startEncodingNs;
+		System.gc();
+
+//		result.numBlocks = DataBlockEncodingStaticVars.NUM_BLOCKS_ENCODED;
+//		result.numNonLeafRowNodes = DataBlockEncodingStaticVars.NUM_NON_LEAF_ROW_NODES;
+//    result.numLeafRowNodes = DataBlockEncodingStaticVars.NUM_LEAF_ROW_NODES;
+//    result.numNonLeafQualifierNodes = DataBlockEncodingStaticVars.NUM_NON_LEAF_QUALIFIER_NODES;
+//    result.numLeafQualifierNodes = DataBlockEncodingStaticVars.NUM_LEAF_QUALIFIER_NODES;
+//		result.numRawBytes = DataBlockEncodingStaticVars.NUM_UNENCODED_BYTES;
+//		result.numEncodedBytes = DataBlockEncodingStaticVars.NUM_ENCODED_BYTES;
+//
+//		result.nsAllocateBytes = DataBlockEncodingStaticVars.PT_WRITER_ALLOCATE_BYTES_NS;
+//
+//		result.nsAddTotal = DataBlockEncodingStaticVars.PT_WRITER_ADD_NS;
+//		result.nsAddRow = DataBlockEncodingStaticVars.PT_WRITER_ADD_ROW_NS;
+//		result.nsAddFamily = DataBlockEncodingStaticVars.PT_WRITER_ADD_FAMILY_NS;
+//		result.nsAddQualifier = DataBlockEncodingStaticVars.PT_WRITER_ADD_QUALIFIER_NS;
+//		result.nsAddTimestamp = DataBlockEncodingStaticVars.PT_WRITER_ADD_TIMESTAMP_NS;
+//		result.nsAddMemstoreTimestamp = DataBlockEncodingStaticVars.PT_WRITER_ADD_MEMSTORE_TIMESTAMP_NS;
+//		result.nsAddType = DataBlockEncodingStaticVars.PT_WRITER_ADD_TYPE_NS;
+//		result.nsAddValue = DataBlockEncodingStaticVars.PT_WRITER_ADD_VALUE_NS;
+//
+//		result.nsCompileTimestamps = DataBlockEncodingStaticVars.PT_COMPILE_TIMESTAMPS_NS;
+//		result.nsCompileQualifiers = DataBlockEncodingStaticVars.PT_COMPILE_QUALIFIERS_NS;
+//		result.nsCompileRows = DataBlockEncodingStaticVars.PT_COMPILE_ROWS_NS;
+//
+//		result.nsWriteRows = DataBlockEncodingStaticVars.PT_WRITER_FLUSH_ROWS_NS;
+//		result.nsWriteFamilies = DataBlockEncodingStaticVars.PT_WRITER_FLUSH_FAMILIES_NS;
+//		result.nsWriteQualifiers = DataBlockEncodingStaticVars.PT_WRITER_FLUSH_QUALIFIERS_NS;
+//		result.nsWriteTimestamps = DataBlockEncodingStaticVars.PT_WRITER_FLUSH_TIMESTAMPS_NS;
+//		result.nsWriteMemstoreTimestamps = DataBlockEncodingStaticVars.PT_WRITER_FLUSH_MEMSTORE_TIMESTAMPS_NS;
+//		result.nsWriteValues = DataBlockEncodingStaticVars.PT_WRITER_FLUSH_VALUES_NS;
+//
+//		DataBlockEncodingStaticVars.reset();
+		System.out.println("--finished block cache load--");
+		scanner.close();
+		assertBlockCacheNotEmpty();
+	}
+
+	protected void runSequentialScan(StoreFile storeFile) throws IOException{
+    StoreFile.Reader reader = storeFile.createReader();
+    StoreFileScanner scanner = reader.getStoreFileScanner(true, params.getPread());
+
+		System.gc();
+		System.out.println("--starting scan--");
+		int numScanCells = 0;
+		long startScanningNs = System.nanoTime();
+		scanner.seek(KeyValue.LOWESTKEY);
+		while (scanner.next() != null) {// cuts a new byte[] with cell contents
+			// while(scanner.nextCell()){//just positions the Cell. 2x faster,
+			// not counting GC
+			// sequential scan
+			++numScanCells;
+		}
+		result.nsForScanning = System.nanoTime() - startScanningNs;
+		System.out.println("--finished scan--");
+		// Assert.assertEquals(result.numCells, numScanCells);
+		assertBlockCacheNotEmpty();
+		scanner.close();
+	}
+
+	protected void runRandomSeeks(StoreFile storeFile) throws IOException{
+    ExecutorService executorService = Executors.newFixedThreadPool(params.getNumSeekThreads());
+		List<List<KeyValue>> perThreadSeeks = Lists.newArrayList();
+		int seeksPerThread = seeks.size() / params.getNumSeekThreads();
+		for (int i = 0; i < params.getNumSeekThreads(); ++i) {
+			int startIndex = i * seeksPerThread;
+			int endIndex = Math.min(startIndex + seeksPerThread, seeks.size());
+			perThreadSeeks.add(seeks.subList(startIndex, endIndex));
+		}
+		List<Future<Long>> futures = Lists.newArrayList();
+		CountDownLatch countDownLatch = new CountDownLatch(params.getNumSeekThreads());
+		System.gc();
+		System.out.println("--starting random reads--");
+		long startSeeksTime = System.nanoTime();
+		try {
+			if(params.getNumSeekThreads() > 1){
+				for (int i = 0; i < params.getNumSeekThreads(); ++i) {
+          futures.add(executorService.submit(new SeeksCallable(storeFile, params.getPread(), perThreadSeeks
+              .get(i), countDownLatch)));
+				}
+				countDownLatch.await();
+				executorService.shutdown();
+				executorService.awaitTermination(1, TimeUnit.SECONDS);
+			}else{
+        new SeeksCallable(storeFile, params.getPread(), perThreadSeeks.get(0), countDownLatch).call();
+			}
+		} catch (Exception e) {
+			throw new RuntimeException(e);
+		}
+		result.nsForSeeking = System.nanoTime() - startSeeksTime;
+		result.numSeeks = seeks.size();
+		System.gc();
+		System.out.println("--finished random reads--");
+		assertBlockCacheNotEmpty();
+
+		storeFile.closeReader(true);
+		assertBlockCacheIsEmpty();
+	}
+
+
+	/********************** helpers ********************************/
+
+	protected static String getKeyValueMismatchMessage(int i,
+			KeyValue expectedKv, KeyValue wrongKv) {
+		String expectedString = expectedKv == null ? "null" : expectedKv.toString();
+		String wrongString = wrongKv == null ? "null" : wrongKv.toString();
+		return String.format(i + ":KeyValue doesn't match:\n"
+				+ "Orig key: %s\n" + "Ret key:  %s", expectedString,
+				wrongString);
+		// String right = Bytes.toStringBinary(expectedKv.getRow()) +"   "
+		// + Bytes.toStringBinary(expectedKv.getQualifier());
+		// String wrong = Bytes.toStringBinary(wrongKv.getRow()) +"   "
+		// + Bytes.toStringBinary(wrongKv.getQualifier());
+		// return right+"\n"+wrong;
+	}
+
+	protected void clearBlockCache(boolean assertNotEmpty) {
+		BlockCache blockCache = cacheConfig.getBlockCache();
+		int numEvicted = blockCache.evictBlocksByHfileName(params.gethFileName());
+		if (assertNotEmpty) {
+			Assert.assertTrue(numEvicted > 0);
+		}
+		assertBlockCacheIsEmpty();
+	}
+
+	protected void assertBlockCacheNotEmpty() {
+		Assert.assertTrue(cacheConfig.getBlockCache().getBlockCount() > 0);
+	}
+
+	protected void assertBlockCacheIsEmpty() {
+		Assert.assertTrue(cacheConfig.getBlockCache().getBlockCount() == 0);
+	}
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmark.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmark.java
new file mode 100644
index 0000000..f416c57
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmark.java
@@ -0,0 +1,353 @@
+package org.apache.hadoop.hbase.io.encoding.compaction;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.Callable;
+
+import junit.framework.Assert;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValueTool;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.io.hfile.CacheConfig;
+import org.apache.hadoop.hbase.io.hfile.HFileDataBlockEncoder;
+import org.apache.hadoop.hbase.io.hfile.HFileDataBlockEncoderImpl;
+import org.apache.hadoop.hbase.regionserver.HStore.ScanInfo;
+import org.apache.hadoop.hbase.regionserver.KeyValueHeap;
+import org.apache.hadoop.hbase.regionserver.KeyValueScanner;
+import org.apache.hadoop.hbase.regionserver.ScanType;
+import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFile.BloomType;
+import org.apache.hadoop.hbase.regionserver.StoreFileScanner;
+import org.apache.hadoop.hbase.regionserver.StoreScanner;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.Strings;
+import org.apache.hadoop.hbase.util.test.RedundantKVGenerator;
+import org.apache.hadoop.util.StringUtils;
+import org.apache.hbase.Cell;
+
+import com.google.common.collect.Lists;
+
+public class CompactionBenchmark implements Callable<CompactionBenchmarkResult>{
+  protected static final Log LOG = LogFactory.getLog(CompactionBenchmark.class.getName());
+  
+  protected static final byte[] FAMILY = Bytes.toBytes("f");
+
+  protected HBaseTestingUtility testingUtility;
+  protected Configuration configuration;
+  protected CacheConfig cacheConfig;
+  
+  protected CompactionBenchmarkParams params;
+  
+  protected CompactionBenchmarkResult result;
+  protected List<KeyValue> allKvs;
+  protected List<Integer> randomCellIndexesGroupedByFile;
+  protected HFileDataBlockEncoder encoder;
+  
+  protected List<StoreFile> storeFiles = Lists.newArrayList();
+  protected List<StoreFile.Writer> storeFileWriters = Lists.newArrayList();
+  protected List<StoreFile.Reader> storeFileReaders = Lists.newArrayList();
+  protected List<KeyValueScanner> storeFileScanners = Lists.newArrayList();
+  
+  
+  public CompactionBenchmark(HBaseTestingUtility testingUtility, CompactionBenchmarkParams params) {
+    this.testingUtility = testingUtility;
+    this.configuration = testingUtility.getConfiguration();
+    this.cacheConfig = new CacheConfig(configuration);
+    this.params = params;
+    this.result = new CompactionBenchmarkResult(params);
+    this.encoder = new HFileDataBlockEncoderImpl(params.getEncoding(), params.getEncoding());
+    this.allKvs = Lists.newArrayListWithCapacity(params.getNumFiles() * params.getNumCellsPerFile());
+    this.randomCellIndexesGroupedByFile = Lists.newArrayListWithCapacity(params.getNumSeeks());
+  }
+
+  @Override
+  public CompactionBenchmarkResult call() throws IOException {
+    LOG.info("Starting benchmark:" + params);
+
+
+    cacheConfig.setCacheDataOnWrite(false);
+    for (int i = 0; i < params.getNumFiles(); ++i) {
+      createFile(i);
+    }
+
+//    Random random = new Random(55555);
+//    for(int i = 0; i < params.getNumSeeks(); ++i){
+//      randomSeekIndexes.add(random.nextInt(allKvs.size()));
+//    }
+
+    openScanners();
+    for (int i = 0; i < params.getNumFiles(); ++i) {
+      doPerFileReads(i);
+    }
+
+
+    /********* store (through heap) ************/
+    System.gc();
+    long scanStoreNs = System.nanoTime();
+    doStoreScan();
+    result.scanStoreNs += (System.nanoTime() - scanStoreNs);
+
+    System.gc();
+    long seekStoreCellsNs = System.nanoTime();
+    doStoreSeeks();
+    result.seekStoreNs += (System.nanoTime() - seekStoreCellsNs);
+
+    closeScanners();
+
+    System.out.println(result);
+
+    return result;
+  }
+
+  protected void createFile(int fileNum) throws IOException{
+    LOG.info("starting createFile:"+fileNum);
+
+    StoreFile.Writer writer = new StoreFile.WriterBuilder(configuration, cacheConfig, 
+        testingUtility.getTestFileSystem(), params.getBlockSize())
+        .withFilePath(createPathNum(fileNum))
+        .withDataBlockEncoder(encoder)
+        .withCompression(params.getCompression())
+        .build();
+    storeFileWriters.add(writer);
+    
+    int commonPrefixLength = 20;
+    byte[] commonPrefix = new byte[commonPrefixLength];
+    Bytes.putInt(commonPrefix, commonPrefixLength - 4, fileNum);
+    RedundantKVGenerator kvGenerator = new RedundantKVGenerator()
+        .setCommonPrefix(commonPrefix)
+        .setNumberOfRowPrefixes(4)
+        .setAveragePrefixLength(16)
+        .setPrefixLengthVariance(4)
+        .setAverageSuffixLength(4)
+        .setSuffixLengthVariance(2)
+        .setNumberOfRows(10000)
+        .setFamily(FAMILY)
+        .setChanceForSameQualifier(0)
+        .setChanceForSimilarQualifier(0)
+        .setAverageQualifierLength(8)
+        .setQualifierLengthVariance(5)
+        .setColumnFamilyLength(1)
+        .setValueLength(1)
+        .setChanceForZeroValue(.1f)
+        .setBaseTimestampDivide(60 * 1000)
+        .setTimestampDiffSize(10*1000)
+        ;
+    List<KeyValue> fileKvs = Lists.newArrayList(kvGenerator.generateTestKeyValues(
+        params.getNumCellsPerFile()));
+//  System.out.println(KeyValueTestUtil.toStringWithPadding(cells, true));
+    LOG.info("generated " + fileKvs.size() + " cells, total bytes="
+      + StringUtils.humanReadableInt(KeyValueTool.totalLengthWithMvccVersion(allKvs, true)));
+    for(int i=0; i < 2; ++i){
+      System.out.println(Strings.padFront(i+"", ' ', 2) + fileKvs.get(i).toString());
+    }
+    
+    System.gc();
+    long writeStartNs = System.nanoTime();
+    for (KeyValue cell : fileKvs) {
+      writer.append(cell);
+      result.numKeyBytes += cell.getKeyLength();
+      result.numValueBytes += cell.getValueLength();
+      result.numKeyValueBytes += cell.getLength();
+    }
+    result.writeNs += (System.nanoTime() - writeStartNs);
+
+    writer.close();
+    result.numBytes = FileUtils.numBytes(createPathStringNum(fileNum));
+    
+    LOG.info("finished createFile:"+fileNum);
+    
+    /*
+     * prep multi-file stuff
+     */
+    allKvs.addAll(fileKvs);
+    
+    //generate random indexes
+    Random random = new Random(55555);
+    int startIndex = fileNum * params.getNumCellsPerFile();
+    for (int i = 0; i < fileKvs.size(); ++i) {
+      int r = startIndex + random.nextInt(fileKvs.size());
+      randomCellIndexesGroupedByFile.add(r);
+    }
+  }
+
+  protected void openScanners() throws IOException {
+    for (int fileNum = 0; fileNum < params.getNumFiles(); ++fileNum) {
+      StoreFile storeFile = new StoreFile(testingUtility.getTestFileSystem(),
+          createPathNum(fileNum), testingUtility.getConfiguration(), cacheConfig, BloomType.NONE,
+          encoder);
+      storeFiles.add(storeFile);
+
+      StoreFile.Reader reader = storeFile.createReader();
+      storeFileReaders.add(reader);
+
+      StoreFileScanner scanner = reader.getStoreFileScanner(true, false);
+      storeFileScanners.add(scanner);
+    }
+  }
+
+  protected void closeScanners() throws IOException {
+    for (int fileNum = 0; fileNum < params.getNumFiles(); ++fileNum) {
+      storeFileReaders.get(fileNum).close(true);
+    }
+  }
+
+  protected void doPerFileReads(int fileNum) throws IOException{
+    LOG.info("starting readFile:" + fileNum);
+    KeyValueScanner scanner = storeFileScanners.get(fileNum);
+    
+    System.gc();
+    long scanUncachedStoreFileStartNs = System.nanoTime();
+    doStoreFileScan(fileNum);// warm up block cache
+    result.scanUncachedFileNs += (System.nanoTime() - scanUncachedStoreFileStartNs);
+    
+    System.gc();
+    long scanCachedStoreFileStartNs = System.nanoTime();
+    doStoreFileScan(fileNum);// warm up block cache
+    result.scanCachedFileNs += (System.nanoTime() - scanCachedStoreFileStartNs);
+
+    
+    /********* seeks ***********/
+
+    System.gc();
+    long seekCachedStoreFileStartNs = System.nanoTime();
+    doStoreFileSeeks(fileNum);
+    result.seekCachedFileNs += (System.nanoTime() - seekCachedStoreFileStartNs);
+
+//    storeFileReaders.get(fileNum).close(true);
+    LOG.info("finished readFile:" + fileNum);
+  }
+
+  protected void doStoreFileScan(int fileNum)
+      throws IOException {
+    boolean assertReadsCorrect = params.getAssertReadsCorrect();
+    KeyValueScanner scanner = storeFileScanners.get(fileNum);
+    scanner.seek(KeyValue.LOWESTKEY);
+    int startIndex = fileNum * params.getNumCellsPerFile();
+    int cellIndex = startIndex -1;
+    Cell cell;
+    int counter = 0;
+    if(params.getCellsVsKeyValues()){
+      cell = scanner.getCurrentCell();
+      do {
+        ++cellIndex;
+        if (assertReadsCorrect) {
+          assertCorrect(cellIndex, cell);
+        }
+        ++counter;
+      }while ((cell = scanner.nextCell()) != null);
+    }else{
+      while ((cell = scanner.next()) != null) {//<---------- playing here next() vs nextCell()
+        ++cellIndex;
+        if (assertReadsCorrect) {
+          assertCorrect(cellIndex, cell);
+        }
+        ++counter;
+      }
+    }
+    Assert.assertEquals(params.getNumCellsPerFile(), counter);
+  }
+
+  protected void doStoreFileSeeks(int fileNum) throws IOException{
+    KeyValueScanner scanner = storeFileScanners.get(fileNum);
+    KeyValue seekTarget = null;
+    Cell foundKv = null;
+    int startIndex = fileNum * params.getNumCellsPerFile();
+    int endIndexExclusive = startIndex + params.getNumCellsPerFile();
+    int stepSize = params.getSeekStepSize();
+    for (int i = startIndex; i < endIndexExclusive; i += stepSize) {
+      int allKvsIndex = randomCellIndexesGroupedByFile.get(i);
+      seekTarget = allKvs.get(allKvsIndex);
+      boolean found = scanner.seek(seekTarget);
+      if(!found){
+        throw new RuntimeException("expected Cell not found:"+seekTarget);
+      }
+      if (params.getAssertReadsCorrect()) {
+        if(params.getCellsVsKeyValues()){
+          foundKv = scanner.getCurrentCell();
+        }else{
+          foundKv = scanner.peek();
+        }
+        assertCorrect(allKvsIndex, foundKv);
+      }
+    }
+  }
+  
+  protected void doStoreScan() throws IOException{
+    Scan scan = new Scan();
+    ScanInfo scanInfo = new ScanInfo(FAMILY, 0, Integer.MAX_VALUE,
+        Long.MAX_VALUE, false, 0, KeyValue.COMPARATOR);
+    StoreScanner scanner = new StoreScanner(scan, scanInfo, ScanType.USER_SCAN, null, storeFileScanners);
+//    scanner.seek(allKvs.get(0));
+    int cellIndex = -1;
+    ArrayList<KeyValue> perRowCollector = Lists.newArrayListWithCapacity(1000);
+    while (scanner.next(perRowCollector)) {
+      if(perRowCollector.isEmpty()){
+        break;
+      }
+      for(int i=0; i < perRowCollector.size(); ++i){
+        ++cellIndex;
+        //disabled because the redundant KV generator still gives a few redundant qualifiers which
+        // throw the counts off
+//        if (assertReadsCorrect) {
+//          assertCorrect(cellIndex, perRowCollector.get(i));
+//        }
+      }
+      perRowCollector.clear();
+    }
+    int numScanned = cellIndex + 1;//count = index+1
+//    Assert.assertEquals(params.getNumCells(), numScanned);
+  }
+  
+  protected void doStoreSeeks() throws IOException{
+    KeyValueScanner scanner = new KeyValueHeap(storeFileScanners, KeyValue.COMPARATOR);
+    KeyValue seekTarget = null;
+    Cell foundKv = null;
+    int startIndex = 0;
+    int endIndexExclusive = params.getNumFiles() + params.getNumCellsPerFile() - 1;
+    int stepSize = params.getSeekStepSize();
+    int counter = 0;
+    for (int i = startIndex; i < endIndexExclusive; i += stepSize) {
+      int allKvsIndex = randomCellIndexesGroupedByFile.get(i);
+      seekTarget = allKvs.get(allKvsIndex);
+      boolean found = scanner.seek(seekTarget);
+      if (params.getAssertReadsCorrect()) {
+        if(params.getCellsVsKeyValues()){
+          foundKv = scanner.getCurrentCell();
+        }else{
+          foundKv = scanner.peek();
+        }
+//        assertCorrect(allKvsIndex, foundKv);
+      }
+      ++counter;
+    }
+    System.out.println("doStoreSeeks did "+counter);
+  }
+  
+  protected void assertCorrect(int cellId, Cell cell){
+    boolean same = cell.equals(allKvs.get(cellId));
+    if (!same) {
+      System.out.println("mismatch on " + cellId);
+      System.out.println(" in:" + allKvs.get(cellId));
+      System.out.println("out:" + cell);
+    }
+    Assert.assertTrue(same);
+  }
+  
+  
+  protected Path createPathNum(int i){
+    return new Path(createPathStringNum(i));
+  }
+
+  protected String createPathStringNum(int i){
+    String legalHFileCharacters = "abcdef";//HFiles names are hex
+    return params.getTmpDir() + "/" + legalHFileCharacters + i;
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmarkMain.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmarkMain.java
new file mode 100644
index 0000000..1619bf6
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmarkMain.java
@@ -0,0 +1,103 @@
+package org.apache.hadoop.hbase.io.encoding.compaction;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.io.compress.Compression;
+import org.apache.hadoop.hbase.io.encoding.DataBlockEncoding;
+
+import com.google.common.collect.Lists;
+
+public class CompactionBenchmarkMain {
+
+	public static void main(final String[] args) throws IOException {
+
+	  HBaseTestingUtility testingUtility = new HBaseTestingUtility();
+
+    String rootDir = "/home/mcorgan/prefixTreeTest";
+    List<String> tables = Lists.newArrayList("Table1");
+    List<Integer> blockSizes = Lists.newArrayList(1 << 16);
+    
+    List<DataBlockEncoding> encodings = Lists.newArrayList();
+//    encodings.add(null);//is this valid anymore?
+    encodings.add(DataBlockEncoding.NONE);
+//    encodings.add(DataBlockEncoding.COPY_KEY);
+    encodings.add(DataBlockEncoding.PREFIX);
+//    encodings.add(DataBlockEncoding.DIFF);
+//    encodings.add(DataBlockEncoding.FAST_DIFF);
+    encodings.add(DataBlockEncoding.PREFIX_TREE);
+    
+    List<Compression.Algorithm> compressions = Lists.newArrayList();
+    compressions.add(Compression.Algorithm.NONE);
+//    compressions.add(Compression.Algorithm.GZ);
+//    compressions.add(Compression.Algorithm.LZ4);
+//    compressions.add(Compression.Algorithm.LZO);
+//    compressions.add(Compression.Algorithm.SNAPPY);
+    
+    int numFiles = 4;
+    int numCells = 1000*1000;
+    int numSeeks = 10*1000;
+    boolean[] assertReadsCorrectParams = new boolean[]{false,true};
+    boolean[] preadParams = new boolean[]{false};
+    boolean[] cellsVsKeyValuesParams = new boolean[]{false, true};
+    
+    int numRuns = 2;//generally do at least 1 warmup run
+    boolean recordWarmupRuns = false;
+
+    /*
+     * build params for each benchmark run
+     */
+    List<CompactionBenchmarkParams> forEachParams = Lists.newArrayList();
+
+    for (String table : tables) {
+      FileUtils.createFileAndParents(new File(rootDir + "/abcdef"+System.currentTimeMillis()));
+      for (DataBlockEncoding encoding : encodings) {
+        for(Compression.Algorithm compression : compressions){
+          for (Integer blockSize : blockSizes) {
+            for(boolean pread : preadParams){
+              for(boolean cellsVsKeyValues : cellsVsKeyValuesParams){
+                for(boolean assertReadsCorrect : assertReadsCorrectParams){
+                  for (int runNumber=1; runNumber <= numRuns; ++runNumber) {
+                    CompactionBenchmarkParams params = new CompactionBenchmarkParams(runNumber,
+                        numRuns, rootDir, table, encoding, compression, blockSize, numCells,
+                        numFiles, numSeeks, 1, pread, cellsVsKeyValues, assertReadsCorrect);
+                    forEachParams.add(params);
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+    
+    /*
+     * run each param and collect the desired results for reporting
+     */
+
+    List<CompactionBenchmarkResult> results = Lists.newArrayList();
+    
+    for(CompactionBenchmarkParams params : forEachParams){
+      CompactionBenchmark benchmark = new CompactionBenchmark(testingUtility, params);
+      CompactionBenchmarkResult result = benchmark.call();
+      if(recordWarmupRuns || params.isLastRun()){
+        results.add(result);
+      }
+  	}
+    
+    
+    /*
+     * output the collected results
+     */
+    
+		System.out.println(CompactionBenchmarkResult.HEADER);
+		for (CompactionBenchmarkResult result : results) {
+			System.out.println(result);
+		}
+
+		System.exit(0);
+	}
+
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmarkParams.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmarkParams.java
new file mode 100644
index 0000000..a0aff55
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmarkParams.java
@@ -0,0 +1,123 @@
+package org.apache.hadoop.hbase.io.encoding.compaction;
+
+import org.apache.hadoop.hbase.io.compress.Compression;
+import org.apache.hadoop.hbase.io.encoding.DataBlockEncoding;
+
+public class CompactionBenchmarkParams {
+  
+  protected int runNumber;
+  protected int numRuns;
+
+  // write params
+  protected String tmpDir;//where to store intermediate test files (deleted at end)
+  protected String inputDir;//single Store directory containing the set of input HFiles
+  protected String tableName;//needed for result reporting
+  protected DataBlockEncoding encoding;
+  protected Compression.Algorithm compression;
+  protected int blockSize;
+  protected int numCells;
+  protected int numFiles;
+
+  // read params
+  protected int numSeeks;
+  protected int numSeekThreads;
+  protected boolean pread;
+  protected boolean cellsVsKeyValues;
+  protected boolean assertReadsCorrect;
+
+  public CompactionBenchmarkParams(Integer runNumber, Integer numRuns, String tmpDir,
+      String inputDir, DataBlockEncoding encoding, Compression.Algorithm compression,
+      Integer blockSize, Integer numCells, Integer numFiles, Integer numSeeks, 
+      Integer numSeekThreads, Boolean pread, Boolean cellsVsKeyValues, Boolean assertReadsCorrect) {
+    this.runNumber = runNumber;
+    this.numRuns = numRuns;
+    this.tmpDir = tmpDir;
+    this.inputDir = inputDir;
+    this.encoding = encoding;
+    this.compression = compression;
+    this.blockSize = blockSize;
+    this.numCells = numCells;
+    this.numFiles = numFiles;
+    this.numSeeks = numSeeks;
+    this.numSeekThreads = numSeekThreads;
+    this.pread = pread;
+    this.cellsVsKeyValues = cellsVsKeyValues;
+    this.assertReadsCorrect = assertReadsCorrect;
+  }
+  
+  public boolean isLastRun(){
+    return runNumber == numRuns;
+  }
+  
+  public int getNumCellsPerFile(){
+    return numCells / numFiles;
+  }
+  
+  public int getSeekStepSize(){
+    return numCells / numSeeks;
+  }
+  
+  /******************** get/set ***************************/
+
+  public String getTableName() {
+    return tableName;
+  }
+
+  public DataBlockEncoding getEncoding() {
+    return encoding;
+  }
+
+  public Integer getBlockSize() {
+    return blockSize;
+  }
+
+  public Integer getNumFiles() {
+    return numFiles;
+  }
+
+  public Integer getNumSeeks() {
+    return numSeeks;
+  }
+
+  public Integer getNumSeekThreads() {
+    return numSeekThreads;
+  }
+
+  public Boolean getPread() {
+    return pread;
+  }
+
+  public Integer getRunNumber() {
+    return runNumber;
+  }
+
+  public Integer getNumRuns() {
+    return numRuns;
+  }
+
+  public String getTmpDir() {
+    return tmpDir;
+  }
+
+  public String getInputDir() {
+    return inputDir;
+  }
+
+  public Compression.Algorithm getCompression() {
+    return compression;
+  }
+
+  public int getNumCells() {
+    return numCells;
+  }
+
+  public boolean getAssertReadsCorrect() {
+    return assertReadsCorrect;
+  }
+
+  public boolean getCellsVsKeyValues() {
+    return cellsVsKeyValues;
+  }
+  
+
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmarkResult.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmarkResult.java
new file mode 100644
index 0000000..7d8cee1
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/CompactionBenchmarkResult.java
@@ -0,0 +1,162 @@
+package org.apache.hadoop.hbase.io.encoding.compaction;
+
+import java.util.List;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.Lists;
+
+/**
+ * Kcps = Kilo Cells per Second
+ */
+class CompactionBenchmarkResult {
+  
+  /**************** static **************************/
+
+  protected static long ASSUME_CYCLES_PER_NS = 2, BYTES_IN_MB = 1 << 20,
+      NANOSEC_IN_SEC = 1000 * 1000 * 1000;
+
+  protected static List<String> headerColumns = Lists.newArrayList();
+  static{
+    headerColumns.add("numRuns");
+    headerColumns.add("runNumber");
+    headerColumns.add("table");
+    headerColumns.add("encoding");
+    headerColumns.add("compression");
+    headerColumns.add("blockSize");
+    headerColumns.add("pread");
+    headerColumns.add("cellsVsKeyValues");
+    headerColumns.add("assertReads");
+    headerColumns.add("numBytes");
+    headerColumns.add("numCells");
+    headerColumns.add("avgKeyBytes");
+    headerColumns.add("avgValueBytes");
+//    headerColumns.add("writeMB/s");
+//    headerColumns.add("readUncachedMB/s");
+//    headerColumns.add("readCachedMB/s");
+    headerColumns.add("writeKcps");
+    
+    headerColumns.add("scanUncachedFileKcps");
+    headerColumns.add("scanCachedFileKcps");
+    headerColumns.add("seekCachedFileKcps");
+    
+    headerColumns.add("scanStoreKcps");
+    headerColumns.add("seekStoreKcps");
+  }
+  protected static String HEADER = Joiner.on(",").join(headerColumns);
+  
+  
+  /************* fields ***********************/
+  
+  protected CompactionBenchmarkParams params;
+  
+  protected long numBytes = 0;
+  protected long numKeyBytes = 0;
+  protected long numValueBytes = 0;
+  protected long numKeyValueBytes = 0;
+  protected long writeNs = 0;
+  
+  protected long scanUncachedFileNs = 0;
+  protected long scanCachedFileNs = 0;
+  protected long seekCachedFileNs = 0;
+  
+  protected long scanStoreNs = 0;
+  protected long seekStoreNs = 0;
+  
+  
+  /************* construct **********************/
+  
+  public CompactionBenchmarkResult(CompactionBenchmarkParams params){
+    this.params = params;
+  }
+  
+  
+  /**************** methods ***********************/
+
+  @Override
+  public String toString() {
+    List<String> tokens = Lists.newArrayList();
+    tokens.add(""+params.getNumRuns());
+    tokens.add(""+params.getRunNumber());
+    tokens.add(""+params.getTableName());
+    tokens.add(""+params.getEncoding().name());
+    tokens.add(""+params.getCompression().name());
+    tokens.add(""+params.getBlockSize());
+    tokens.add(""+params.getPread());
+    tokens.add(""+params.getCellsVsKeyValues());
+    tokens.add(""+params.getAssertReadsCorrect());
+    tokens.add(""+numBytes);
+    tokens.add(""+params.getNumCells());
+    tokens.add(""+getAvgKeyBytes());
+    tokens.add(""+getAvgValueBytes());
+//    tokens.add(""+getWriteMBps().longValue());
+//    tokens.add(""+getReadUncachedMBps().longValue());
+//    tokens.add(""+getReadCachedMBps().longValue());
+    tokens.add(""+getWriteKcps().longValue());
+    
+    tokens.add(""+getScanUncachedKcps().longValue());
+    tokens.add(""+getScanCachedKcps().longValue());
+    tokens.add(""+getSeekCachedKcps().longValue());
+    
+    tokens.add(""+getScanStoreKcps().longValue());
+    tokens.add(""+getSeekStoreKcps().longValue());
+    return Joiner.on(",").join(tokens);
+  }
+
+  public Long getAvgKeyBytes() {
+    return numKeyBytes / params.getNumCells();
+  }
+
+  public Long getAvgValueBytes() {
+    return numValueBytes / params.getNumCells();
+  }
+
+  public Double getWriteKcps() {
+    return calcKiloCellsPerSecond(params.getNumCells(), writeNs);
+  }
+
+  public Double getWriteMBps() {
+    return calcMegabytesPerSecond(numKeyValueBytes, writeNs);
+  }
+
+  ////////////////
+  public Double getScanUncachedKcps() {
+    return calcKiloCellsPerSecond(params.getNumCells(), scanUncachedFileNs);
+  }
+
+  public Double getScanCachedKcps() {
+    return calcKiloCellsPerSecond(params.getNumCells(), scanCachedFileNs);
+  }
+  
+  ///////////////////
+
+  public Double getSeekCachedKcps() {
+    return calcKiloCellsPerSecond(params.getNumSeeks(), seekCachedFileNs);
+  }
+  
+  /////////////////////
+  public Double getScanStoreKcps() {
+    return calcKiloCellsPerSecond(params.getNumCells(), scanStoreNs);
+  }
+  
+  public Double getSeekStoreKcps() {
+    return calcKiloCellsPerSecond(params.getNumSeeks(), seekStoreNs);
+  }
+
+  public Double getReadUncachedMBps() {
+    return calcMegabytesPerSecond(numKeyValueBytes, scanUncachedFileNs);
+  }
+
+  public Double getReadCachedMBps() {
+    return calcMegabytesPerSecond(numKeyValueBytes, scanCachedFileNs);
+  }
+
+  protected Double calcKiloCellsPerSecond(long numCells, long nanoseconds){
+    double seconds = (double) nanoseconds / (double) NANOSEC_IN_SEC;
+    return (double) (numCells / 1000) / seconds;
+  }
+
+  protected Double calcMegabytesPerSecond(long numBytes, long nanoseconds){
+    double seconds = (double) nanoseconds / (double) NANOSEC_IN_SEC;
+    return (double) (numBytes / BYTES_IN_MB) / seconds;
+  }
+}
\ No newline at end of file
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/FileUtils.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/FileUtils.java
new file mode 100644
index 0000000..133f822
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/compaction/FileUtils.java
@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hbase.io.encoding.compaction;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.hbase.util.Strings;
+
+/**
+ * Utility methods for dealing with Java's File API.  Created for use by tests/benchmarks.
+ */
+@InterfaceAudience.Private
+public class FileUtils {
+
+  /**
+   * Wrap an OutputStream around an existing File
+   * @param fileLocation full path to the file
+   * @param create whether to create the file if it doesn't exist yet
+   * @param append flag passed to FileOutputStream constructor
+   * @return new FileOutputStream
+   */
+  public static FileOutputStream makeFileOutputStream(String fileLocation, boolean create,
+      boolean append) {
+    File f = new File(fileLocation);
+    if (create) {
+      createFileAndParents(f);
+    }
+    try {
+      return new FileOutputStream(f, append);
+    } catch (FileNotFoundException fnfe) {
+      throw new IllegalArgumentException("FileNotFoundException for :" + fileLocation, fnfe);
+    }
+  }
+
+  /**
+   * @param aFile Full directory path and filename
+   */
+  public static void createFileAndParents(File aFile) {
+    if (aFile.exists()) {
+      return;
+    }
+    File parent = new File(aFile.getParent());
+    if (parent.exists()) {
+      return;
+    }
+    parent.mkdirs();
+  }
+
+  /**
+   * Delete a file but with safety check for "" and "/".
+   * @param path full path to file
+   */
+  public static void delete(String path) {
+    if (Strings.isEmpty(path) || "/".equals(path)) {
+      throw new IllegalArgumentException("cannot delete empty or root path");
+    }
+    File file = new File(path);
+    file.delete();
+  }
+  
+  
+  public static long numBytes(String path){
+    File file = new File(path);
+    return file.length();
+  }
+
+}
diff --git a/pom.xml b/pom.xml
index 4b4fe9f..0cce299 100644
--- a/pom.xml
+++ b/pom.xml
@@ -42,7 +42,7 @@
   <version>0.95-SNAPSHOT</version>
   <name>HBase</name>
   <description>
-    Apache HBase&#153; is the &amp;lt;a href="http://hadoop.apache.org"&amp;rt;Hadoop&lt;/a&amp;rt; database. Use it when you need
+    Apache HBase is the &amp;lt;a href="http://hadoop.apache.org"&amp;rt;Hadoop&lt;/a&amp;rt; database. Use it when you need
     random, realtime read/write access to your Big Data.
     This project's goal is the hosting of very large tables -- billions of rows X millions of columns -- atop clusters
     of commodity hardware.
@@ -58,6 +58,7 @@
     <module>hbase-common</module>
     <module>hbase-it</module>
     <module>hbase-examples</module>
+    <module>hbase-prefix-tree</module>
   </modules>
   <scm>
     <connection>scm:svn:http://svn.apache.org/repos/asf/hbase/trunk</connection>
@@ -961,6 +962,11 @@
         <scope>test</scope>
       </dependency>
       <dependency>
+        <groupId>org.apache.hbase</groupId>
+        <artifactId>hbase-prefix-tree</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
         <artifactId>hbase-examples</artifactId>
         <groupId>org.apache.hbase</groupId>
         <version>${project.version}</version>
