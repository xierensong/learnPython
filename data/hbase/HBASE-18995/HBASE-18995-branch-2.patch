diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java
index 4f22402..a21bb14 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java
@@ -43,6 +43,7 @@ import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.MasterNotRunningException;
 import org.apache.hadoop.hbase.ServerName;
 import org.apache.hadoop.hbase.TableName;
@@ -331,7 +332,7 @@ public final class ConnectionUtils {
       return result;
     }
     // not the same row
-    if (!CellUtil.matchingRow(keepCellsAfter, result.getRow(), 0, result.getRow().length)) {
+    if (!InternalCellUtil.matchingRow(keepCellsAfter, result.getRow(), 0, result.getRow().length)) {
       return result;
     }
     Cell[] rawCells = result.rawCells();
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java
index 68aa381..c05f6ed 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java
@@ -29,6 +29,7 @@ import java.util.UUID;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.security.access.Permission;
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Mutation.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Mutation.java
index 426cf2a..d8430ca 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Mutation.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Mutation.java
@@ -34,6 +34,7 @@ import org.apache.hadoop.hbase.CellScannable;
 import org.apache.hadoop.hbase.CellScanner;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagUtil;
@@ -225,7 +226,7 @@ public abstract class Mutation extends OperationWithAttributes implements Row, C
                 c.getQualifierLength()));
     stringMap.put("timestamp", c.getTimestamp());
     stringMap.put("vlen", c.getValueLength());
-    List<Tag> tags = CellUtil.getTags(c);
+    List<Tag> tags = InternalCellUtil.getTags(c);
     if (tags != null) {
       List<String> tagsString = new ArrayList<>(tags.size());
       for (Tag t : tags) {
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/BigDecimalColumnInterpreter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/BigDecimalColumnInterpreter.java
index 31162ac..4edb03b 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/BigDecimalColumnInterpreter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/BigDecimalColumnInterpreter.java
@@ -25,6 +25,7 @@ import java.math.RoundingMode;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.yetus.audience.InterfaceStability;
 import org.apache.hadoop.hbase.coprocessor.ColumnInterpreter;
@@ -49,7 +50,7 @@ public class BigDecimalColumnInterpreter extends ColumnInterpreter<BigDecimal, B
     if (kv == null || CellUtil.cloneValue(kv) == null) {
       return null;
     }
-    return CellUtil.getValueAsBigDecimal(kv).setScale(2, RoundingMode.HALF_EVEN);
+    return InternalCellUtil.getValueAsBigDecimal(kv).setScale(2, RoundingMode.HALF_EVEN);
   }
 
   @Override
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/DoubleColumnInterpreter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/DoubleColumnInterpreter.java
index b484664..d5b380b 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/DoubleColumnInterpreter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/DoubleColumnInterpreter.java
@@ -21,8 +21,8 @@ package org.apache.hadoop.hbase.client.coprocessor;
 import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.yetus.audience.InterfaceStability;
 import org.apache.hadoop.hbase.coprocessor.ColumnInterpreter;
@@ -48,7 +48,7 @@ public class DoubleColumnInterpreter extends ColumnInterpreter<Double, Double,
       throws IOException {
     if (c == null || c.getValueLength() != Bytes.SIZEOF_DOUBLE)
       return null;
-    return CellUtil.getValueAsDouble(c);
+    return InternalCellUtil.getValueAsDouble(c);
   }
 
   @Override
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/LongColumnInterpreter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/LongColumnInterpreter.java
index 553ce2c..e7bd1bf 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/LongColumnInterpreter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/LongColumnInterpreter.java
@@ -21,8 +21,8 @@ package org.apache.hadoop.hbase.client.coprocessor;
 import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.yetus.audience.InterfaceStability;
 import org.apache.hadoop.hbase.coprocessor.ColumnInterpreter;
@@ -47,7 +47,7 @@ public class LongColumnInterpreter extends ColumnInterpreter<Long, Long,
       throws IOException {
     if (kv == null || kv.getValueLength() != Bytes.SIZEOF_LONG)
       return null;
-    return CellUtil.getValueAsLong(kv);
+    return InternalCellUtil.getValueAsLong(kv);
   }
 
    @Override
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/CompareFilter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/CompareFilter.java
index 8145f01..626b064 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/CompareFilter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/CompareFilter.java
@@ -25,6 +25,7 @@ import java.util.ArrayList;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.CompareOperator;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil;
 import org.apache.hadoop.hbase.shaded.protobuf.generated.FilterProtos;
@@ -137,7 +138,7 @@ public abstract class CompareFilter extends FilterBase {
     if (compareOp == CompareOp.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareRow(cell, comparator);
+    int compareResult = InternalCellUtil.compareRow(cell, comparator);
     return compare(compareOp, compareResult);
   }
 
@@ -146,7 +147,7 @@ public abstract class CompareFilter extends FilterBase {
     if (op == CompareOperator.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareRow(cell, comparator);
+    int compareResult = InternalCellUtil.compareRow(cell, comparator);
     return compare(op, compareResult);
   }
 
@@ -160,7 +161,7 @@ public abstract class CompareFilter extends FilterBase {
     if (compareOp == CompareOp.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareFamily(cell, comparator);
+    int compareResult = InternalCellUtil.compareFamily(cell, comparator);
     return compare(compareOp, compareResult);
   }
 
@@ -169,7 +170,7 @@ public abstract class CompareFilter extends FilterBase {
     if (op == CompareOperator.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareFamily(cell, comparator);
+    int compareResult = InternalCellUtil.compareFamily(cell, comparator);
     return compare(op, compareResult);
   }
 
@@ -184,7 +185,7 @@ public abstract class CompareFilter extends FilterBase {
     if (compareOp == CompareOp.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareQualifier(cell, comparator);
+    int compareResult = InternalCellUtil.compareQualifier(cell, comparator);
     return compare(compareOp, compareResult);
   }
 
@@ -194,7 +195,7 @@ public abstract class CompareFilter extends FilterBase {
     if (op == CompareOperator.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareQualifier(cell, comparator);
+    int compareResult = InternalCellUtil.compareQualifier(cell, comparator);
     return compare(op, compareResult);
   }
 
@@ -209,7 +210,7 @@ public abstract class CompareFilter extends FilterBase {
     if (compareOp == CompareOp.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareValue(cell, comparator);
+    int compareResult = InternalCellUtil.compareValue(cell, comparator);
     return compare(compareOp, compareResult);
   }
 
@@ -218,7 +219,7 @@ public abstract class CompareFilter extends FilterBase {
     if (op == CompareOperator.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareValue(cell, comparator);
+    int compareResult = InternalCellUtil.compareValue(cell, comparator);
     return compare(op, compareResult);
   }
 
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.java
index 468af8c..9b429bb 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.java
@@ -25,6 +25,7 @@ import java.util.ArrayList;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.CompareOperator;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.filter.CompareFilter.CompareOp;
@@ -267,7 +268,7 @@ public class SingleColumnValueFilter extends FilterBase {
   }
 
   private boolean filterColumnValue(final Cell cell) {
-    int compareResult = CellUtil.compareValue(cell, this.comparator);
+    int compareResult = InternalCellUtil.compareValue(cell, this.comparator);
     return CompareFilter.compare(this.op, compareResult);
   }
 
diff --git a/hbase-client/src/test/java/org/apache/hadoop/hbase/filter/TestComparators.java b/hbase-client/src/test/java/org/apache/hadoop/hbase/filter/TestComparators.java
index f640c5e..aef95ad 100644
--- a/hbase-client/src/test/java/org/apache/hadoop/hbase/filter/TestComparators.java
+++ b/hbase-client/src/test/java/org/apache/hadoop/hbase/filter/TestComparators.java
@@ -25,6 +25,7 @@ import org.apache.hadoop.hbase.ByteBufferKeyValue;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.testclassification.MiscTests;
 import org.apache.hadoop.hbase.testclassification.SmallTests;
@@ -53,44 +54,44 @@ public class TestComparators {
     ByteBuffer buffer = ByteBuffer.wrap(kv.getBuffer());
     Cell bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
     ByteArrayComparable comparable = new BinaryComparator(r1);
-    assertEquals(0, CellUtil.compareRow(bbCell, comparable));
-    assertEquals(0, CellUtil.compareRow(kv, comparable));
+    assertEquals(0, InternalCellUtil.compareRow(bbCell, comparable));
+    assertEquals(0, InternalCellUtil.compareRow(kv, comparable));
     kv = new KeyValue(r0, f, q1, v1);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertTrue(CellUtil.compareRow(bbCell, comparable) > 0);
-    assertTrue(CellUtil.compareRow(kv, comparable) > 0);
+    assertTrue(InternalCellUtil.compareRow(bbCell, comparable) > 0);
+    assertTrue(InternalCellUtil.compareRow(kv, comparable) > 0);
     kv = new KeyValue(r2, f, q1, v1);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertTrue(CellUtil.compareRow(bbCell, comparable) < 0);
-    assertTrue(CellUtil.compareRow(kv, comparable) < 0);
+    assertTrue(InternalCellUtil.compareRow(bbCell, comparable) < 0);
+    assertTrue(InternalCellUtil.compareRow(kv, comparable) < 0);
     // Qualifier compare
     comparable = new BinaryPrefixComparator(Bytes.toBytes("qual"));
-    assertEquals(0, CellUtil.compareQualifier(bbCell, comparable));
-    assertEquals(0, CellUtil.compareQualifier(kv, comparable));
+    assertEquals(0, InternalCellUtil.compareQualifier(bbCell, comparable));
+    assertEquals(0, InternalCellUtil.compareQualifier(kv, comparable));
     kv = new KeyValue(r2, f, q2, v1);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertEquals(0, CellUtil.compareQualifier(bbCell, comparable));
-    assertEquals(0, CellUtil.compareQualifier(kv, comparable));
+    assertEquals(0, InternalCellUtil.compareQualifier(bbCell, comparable));
+    assertEquals(0, InternalCellUtil.compareQualifier(kv, comparable));
     kv = new KeyValue(r2, f, q3, v1);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertTrue(CellUtil.compareQualifier(bbCell, comparable) < 0);
-    assertTrue(CellUtil.compareQualifier(kv, comparable) < 0);
+    assertTrue(InternalCellUtil.compareQualifier(bbCell, comparable) < 0);
+    assertTrue(InternalCellUtil.compareQualifier(kv, comparable) < 0);
     // Value compare
     comparable = new LongComparator(l1);
-    assertEquals(0, CellUtil.compareValue(bbCell, comparable));
-    assertEquals(0, CellUtil.compareValue(kv, comparable));
+    assertEquals(0, InternalCellUtil.compareValue(bbCell, comparable));
+    assertEquals(0, InternalCellUtil.compareValue(kv, comparable));
     kv = new KeyValue(r1, f, q1, v2);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertTrue(CellUtil.compareValue(bbCell, comparable) < 0);
-    assertTrue(CellUtil.compareValue(kv, comparable) < 0);
+    assertTrue(InternalCellUtil.compareValue(bbCell, comparable) < 0);
+    assertTrue(InternalCellUtil.compareValue(kv, comparable) < 0);
     // Family compare
     comparable = new SubstringComparator("cf");
-    assertEquals(0, CellUtil.compareFamily(bbCell, comparable));
-    assertEquals(0, CellUtil.compareFamily(kv, comparable));
+    assertEquals(0, InternalCellUtil.compareFamily(bbCell, comparable));
+    assertEquals(0, InternalCellUtil.compareFamily(kv, comparable));
   }
 }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java
index f9640a3..90d97e0 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java
@@ -1,24 +1,16 @@
 /*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable
+ * law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
+ * for the specific language governing permissions and limitations under the License.
  */
 
 package org.apache.hadoop.hbase;
 
-import static org.apache.hadoop.hbase.HConstants.EMPTY_BYTE_ARRAY;
 import static org.apache.hadoop.hbase.Tag.TAG_LENGTH_SIZE;
 import static org.apache.hadoop.hbase.KeyValue.COLUMN_FAMILY_DELIMITER;
 import static org.apache.hadoop.hbase.KeyValue.getDelimiter;
@@ -38,7 +30,6 @@ import java.util.Map.Entry;
 import java.util.NavigableMap;
 
 import org.apache.hadoop.hbase.KeyValue.Type;
-import org.apache.hadoop.hbase.filter.ByteArrayComparable;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.yetus.audience.InterfaceAudience.Private;
 
@@ -47,16 +38,13 @@ import com.google.common.annotations.VisibleForTesting;
 import org.apache.hadoop.hbase.io.HeapSize;
 import org.apache.hadoop.hbase.io.TagCompressionContext;
 import org.apache.hadoop.hbase.io.util.Dictionary;
-import org.apache.hadoop.hbase.io.util.StreamUtils;
 import org.apache.hadoop.hbase.util.ByteBufferUtils;
 import org.apache.hadoop.hbase.util.ByteRange;
 import org.apache.hadoop.hbase.util.Bytes;
-import org.apache.hadoop.hbase.util.ClassSize;
 
 /**
- * Utility methods helpful slinging {@link Cell} instances.
- * Some methods below are for internal use only and are marked InterfaceAudience.Private at the
- * method level.
+ * Utility methods helpful slinging {@link Cell} instances. Some methods below are for internal use
+ * only and are marked InterfaceAudience.Private at the method level.
  */
 @InterfaceAudience.Public
 public final class CellUtil {
@@ -64,52 +52,73 @@ public final class CellUtil {
   /**
    * Private constructor to keep this class from being instantiated.
    */
-  private CellUtil(){}
+  private CellUtil() {
+  }
 
   /******************* ByteRange *******************************/
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
+   */
+  @Deprecated
   public static ByteRange fillRowRange(Cell cell, ByteRange range) {
     return range.set(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
+   */
+  @Deprecated
   public static ByteRange fillFamilyRange(Cell cell, ByteRange range) {
     return range.set(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
+   */
+  @Deprecated
   public static ByteRange fillQualifierRange(Cell cell, ByteRange range) {
     return range.set(cell.getQualifierArray(), cell.getQualifierOffset(),
       cell.getQualifierLength());
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
+   */
+  @Deprecated
   public static ByteRange fillValueRange(Cell cell, ByteRange range) {
     return range.set(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
+   */
+  @Deprecated
   public static ByteRange fillTagRange(Cell cell, ByteRange range) {
     return range.set(cell.getTagsArray(), cell.getTagsOffset(), cell.getTagsLength());
   }
 
   /***************** get individual arrays for tests ************/
 
-  public static byte[] cloneRow(Cell cell){
+  public static byte[] cloneRow(Cell cell) {
     byte[] output = new byte[cell.getRowLength()];
     copyRowTo(cell, output, 0);
     return output;
   }
 
-  public static byte[] cloneFamily(Cell cell){
+  public static byte[] cloneFamily(Cell cell) {
     byte[] output = new byte[cell.getFamilyLength()];
     copyFamilyTo(cell, output, 0);
     return output;
   }
 
-  public static byte[] cloneQualifier(Cell cell){
+  public static byte[] cloneQualifier(Cell cell) {
     byte[] output = new byte[cell.getQualifierLength()];
     copyQualifierTo(cell, output, 0);
     return output;
   }
 
-  public static byte[] cloneValue(Cell cell){
+  public static byte[] cloneValue(Cell cell) {
     byte[] output = new byte[cell.getValueLength()];
     copyValueTo(cell, output, 0);
     return output;
@@ -117,20 +126,22 @@ public final class CellUtil {
 
   public static byte[] cloneTags(Cell cell) {
     byte[] output = new byte[cell.getTagsLength()];
-    copyTagTo(cell, output, 0);
+    InternalCellUtil.copyTagTo(cell, output, 0);
     return output;
   }
 
   /**
-   * Returns tag value in a new byte array. If server-side, use
-   * {@link Tag#getValueArray()} with appropriate {@link Tag#getValueOffset()} and
-   * {@link Tag#getValueLength()} instead to save on allocations.
+   * Returns tag value in a new byte array. If server-side, use {@link Tag#getValueArray()} with
+   * appropriate {@link Tag#getValueOffset()} and {@link Tag#getValueLength()} instead to save on
+   * allocations.
    * @param cell
    * @return tag value in a new byte array.
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
    */
-  public static byte[] getTagArray(Cell cell){
+  @Deprecated
+  public static byte[] getTagArray(Cell cell) {
     byte[] output = new byte[cell.getTagsLength()];
-    copyTagTo(cell, output, 0);
+    InternalCellUtil.copyTagTo(cell, output, 0);
     return output;
   }
 
@@ -142,7 +153,7 @@ public final class CellUtil {
    * @param qualifier
    * @return family:qualifier
    */
-  public static byte [] makeColumn(byte [] family, byte [] qualifier) {
+  public static byte[] makeColumn(byte[] family, byte[] qualifier) {
     return Bytes.add(family, COLUMN_FAMILY_DELIM_ARRAY, qualifier);
   }
 
@@ -159,20 +170,20 @@ public final class CellUtil {
    * @param c The column.
    * @return The parsed column.
    */
-  public static byte [][] parseColumn(byte [] c) {
+  public static byte[][] parseColumn(byte[] c) {
     final int index = getDelimiter(c, 0, c.length, COLUMN_FAMILY_DELIMITER);
     if (index == -1) {
       // If no delimiter, return array of size 1
-      return new byte [][] { c };
-    } else if(index == c.length - 1) {
+      return new byte[][] { c };
+    } else if (index == c.length - 1) {
       // family with empty qualifier, return array size 2
-      byte [] family = new byte[c.length-1];
+      byte[] family = new byte[c.length - 1];
       System.arraycopy(c, 0, family, 0, family.length);
-      return new byte [][] { family, HConstants.EMPTY_BYTE_ARRAY};
+      return new byte[][] { family, HConstants.EMPTY_BYTE_ARRAY };
     }
     // Family and column, return array size 2
-    final byte [][] result = new byte [2][];
-    result[0] = new byte [index];
+    final byte[][] result = new byte[2][];
+    result[0] = new byte[index];
     System.arraycopy(c, 0, result[0], 0, index);
     final int len = c.length - (index + 1);
     result[1] = new byte[len];
@@ -182,27 +193,40 @@ public final class CellUtil {
 
   /******************** copyTo **********************************/
 
+  /**
+   * Copies the row to the given byte[]
+   * @param cell the cell whose row has to be copied
+   * @param destination the destination byte[] to which the row has to be copied
+   * @param destinationOffset the offset in the destination byte[]
+   * @return the offset of the byte[] after the copy has happened
+   */
   public static int copyRowTo(Cell cell, byte[] destination, int destinationOffset) {
     short rowLen = cell.getRowLength();
     if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyFromBufferToArray(destination,
-          ((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), destinationOffset, rowLen);
+      ByteBufferUtils.copyFromBufferToArray(destination, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), destinationOffset, rowLen);
     } else {
       System.arraycopy(cell.getRowArray(), cell.getRowOffset(), destination, destinationOffset,
-          rowLen);
+        rowLen);
     }
     return destinationOffset + rowLen;
   }
 
+  /**
+   * Copies the row to the given bytebuffer
+   * @param cell cell the cell whose row has to be copied
+   * @param destination the destination bytebuffer to which the row has to be copied
+   * @param destinationOffset the offset in the destination byte[]
+   * @return the offset of the bytebuffer after the copy has happened
+   */
   public static int copyRowTo(Cell cell, ByteBuffer destination, int destinationOffset) {
     short rowLen = cell.getRowLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getRowByteBuffer(),
-          destination, ((ByteBufferCell) cell).getRowPosition(), destinationOffset, rowLen);
+        destination, ((ByteBufferCell) cell).getRowPosition(), destinationOffset, rowLen);
     } else {
       ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset, cell.getRowArray(),
-          cell.getRowOffset(), rowLen);
+        cell.getRowOffset(), rowLen);
     }
     return destinationOffset + rowLen;
   }
@@ -223,77 +247,119 @@ public final class CellUtil {
     }
   }
 
+  /**
+   * Copies the family to the given byte[]
+   * @param cell the cell whose family has to be copied
+   * @param destination the destination byte[] to which the family has to be copied
+   * @param destinationOffset the offset in the destination byte[]
+   * @return the offset of the byte[] after the copy has happened
+   */
   public static int copyFamilyTo(Cell cell, byte[] destination, int destinationOffset) {
     byte fLen = cell.getFamilyLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToArray(destination,
-          ((ByteBufferCell) cell).getFamilyByteBuffer(),
-          ((ByteBufferCell) cell).getFamilyPosition(), destinationOffset, fLen);
+        ((ByteBufferCell) cell).getFamilyByteBuffer(), ((ByteBufferCell) cell).getFamilyPosition(),
+        destinationOffset, fLen);
     } else {
       System.arraycopy(cell.getFamilyArray(), cell.getFamilyOffset(), destination,
-          destinationOffset, fLen);
+        destinationOffset, fLen);
     }
     return destinationOffset + fLen;
   }
 
+  /**
+   * Copies the family to the given bytebuffer
+   * @param cell the cell whose family has to be copied
+   * @param destination the destination bytebuffer to which the family has to be copied
+   * @param destinationOffset the offset in the destination bytebuffer
+   * @return the offset of the bytebuffer after the copy has happened
+   */
   public static int copyFamilyTo(Cell cell, ByteBuffer destination, int destinationOffset) {
     byte fLen = cell.getFamilyLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getFamilyByteBuffer(),
-          destination, ((ByteBufferCell) cell).getFamilyPosition(), destinationOffset, fLen);
+        destination, ((ByteBufferCell) cell).getFamilyPosition(), destinationOffset, fLen);
     } else {
       ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset, cell.getFamilyArray(),
-          cell.getFamilyOffset(), fLen);
+        cell.getFamilyOffset(), fLen);
     }
     return destinationOffset + fLen;
   }
 
+  /**
+   * Copies the qualifier to the given byte[]
+   * @param cell the cell whose qualifier has to be copied
+   * @param destination the destination byte[] to which the qualifier has to be copied
+   * @param destinationOffset the offset in the destination byte[]
+   * @return the offset of the byte[] after the copy has happened
+   */
   public static int copyQualifierTo(Cell cell, byte[] destination, int destinationOffset) {
     int qlen = cell.getQualifierLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToArray(destination,
-          ((ByteBufferCell) cell).getQualifierByteBuffer(),
-          ((ByteBufferCell) cell).getQualifierPosition(), destinationOffset, qlen);
+        ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), destinationOffset, qlen);
     } else {
       System.arraycopy(cell.getQualifierArray(), cell.getQualifierOffset(), destination,
-          destinationOffset, qlen);
+        destinationOffset, qlen);
     }
     return destinationOffset + qlen;
   }
 
+  /**
+   * Copies the qualifier to the given bytebuffer
+   * @param cell the cell whose qualifier has to be copied
+   * @param destination the destination bytebuffer to which the qualifier has to be copied
+   * @param destinationOffset the offset in the destination bytebuffer
+   * @return the offset of the bytebuffer after the copy has happened
+   */
   public static int copyQualifierTo(Cell cell, ByteBuffer destination, int destinationOffset) {
     int qlen = cell.getQualifierLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getQualifierByteBuffer(),
-          destination, ((ByteBufferCell) cell).getQualifierPosition(), destinationOffset, qlen);
+        destination, ((ByteBufferCell) cell).getQualifierPosition(), destinationOffset, qlen);
     } else {
       ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset,
-          cell.getQualifierArray(), cell.getQualifierOffset(), qlen);
+        cell.getQualifierArray(), cell.getQualifierOffset(), qlen);
     }
     return destinationOffset + qlen;
   }
 
+  /**
+   * Copies the value to the given byte[]
+   * @param cell the cell whose value has to be copied
+   * @param destination the destination byte[] to which the value has to be copied
+   * @param destinationOffset the offset in the destination byte[]
+   * @return the offset of the byte[] after the copy has happened
+   */
   public static int copyValueTo(Cell cell, byte[] destination, int destinationOffset) {
     int vlen = cell.getValueLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToArray(destination,
-          ((ByteBufferCell) cell).getValueByteBuffer(),
-          ((ByteBufferCell) cell).getValuePosition(), destinationOffset, vlen);
+        ((ByteBufferCell) cell).getValueByteBuffer(), ((ByteBufferCell) cell).getValuePosition(),
+        destinationOffset, vlen);
     } else {
       System.arraycopy(cell.getValueArray(), cell.getValueOffset(), destination, destinationOffset,
-          vlen);
+        vlen);
     }
     return destinationOffset + vlen;
   }
 
+  /**
+   * Copies the value to the given bytebuffer
+   * @param cell the cell whose value has to be copied
+   * @param destination the destination bytebuffer to which the value has to be copied
+   * @param destinationOffset the offset in the destination bytebuffer
+   * @return the offset of the bytebuffer after the copy has happened
+   */
   public static int copyValueTo(Cell cell, ByteBuffer destination, int destinationOffset) {
     int vlen = cell.getValueLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getValueByteBuffer(),
-          destination, ((ByteBufferCell) cell).getValuePosition(), destinationOffset, vlen);
+        destination, ((ByteBufferCell) cell).getValuePosition(), destinationOffset, vlen);
     } else {
       ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset, cell.getValueArray(),
-          cell.getValueOffset(), vlen);
+        cell.getValueOffset(), vlen);
     }
     return destinationOffset + vlen;
   }
@@ -304,28 +370,39 @@ public final class CellUtil {
    * @param destination
    * @param destinationOffset
    * @return position after tags
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
    */
+  @Deprecated
   public static int copyTagTo(Cell cell, byte[] destination, int destinationOffset) {
     int tlen = cell.getTagsLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToArray(destination,
-          ((ByteBufferCell) cell).getTagsByteBuffer(),
-          ((ByteBufferCell) cell).getTagsPosition(), destinationOffset, tlen);
+        ((ByteBufferCell) cell).getTagsByteBuffer(), ((ByteBufferCell) cell).getTagsPosition(),
+        destinationOffset, tlen);
     } else {
       System.arraycopy(cell.getTagsArray(), cell.getTagsOffset(), destination, destinationOffset,
-          tlen);
+        tlen);
     }
     return destinationOffset + tlen;
   }
 
+  /**
+   * Copies the tags info into the tag portion of the cell
+   * @param cell
+   * @param destination
+   * @param destinationOffset
+   * @return
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
+   */
+  @Deprecated
   public static int copyTagTo(Cell cell, ByteBuffer destination, int destinationOffset) {
     int tlen = cell.getTagsLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getTagsByteBuffer(),
-          destination, ((ByteBufferCell) cell).getTagsPosition(), destinationOffset, tlen);
+        destination, ((ByteBufferCell) cell).getTagsPosition(), destinationOffset, tlen);
     } else {
       ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset, cell.getTagsArray(),
-          cell.getTagsOffset(), tlen);
+        cell.getTagsOffset(), tlen);
     }
     return destinationOffset + tlen;
   }
@@ -333,26 +410,38 @@ public final class CellUtil {
   /********************* misc *************************************/
 
   @Private
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
+   */
+  @Deprecated
   public static byte getRowByte(Cell cell, int index) {
     if (cell instanceof ByteBufferCell) {
-      return ((ByteBufferCell) cell).getRowByteBuffer().get(
-          ((ByteBufferCell) cell).getRowPosition() + index);
+      return ((ByteBufferCell) cell).getRowByteBuffer()
+          .get(((ByteBufferCell) cell).getRowPosition() + index);
     }
     return cell.getRowArray()[cell.getRowOffset() + index];
   }
 
   @Private
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
+   */
+  @Deprecated
   public static byte getQualifierByte(Cell cell, int index) {
     if (cell instanceof ByteBufferCell) {
-      return ((ByteBufferCell) cell).getQualifierByteBuffer().get(
-          ((ByteBufferCell) cell).getQualifierPosition() + index);
+      return ((ByteBufferCell) cell).getQualifierByteBuffer()
+          .get(((ByteBufferCell) cell).getQualifierPosition() + index);
     }
     return cell.getQualifierArray()[cell.getQualifierOffset() + index];
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
+   */
+  @Deprecated
   public static ByteBuffer getValueBufferShallowCopy(Cell cell) {
-    ByteBuffer buffer = ByteBuffer.wrap(cell.getValueArray(), cell.getValueOffset(),
-      cell.getValueLength());
+    ByteBuffer buffer =
+        ByteBuffer.wrap(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
     return buffer;
   }
 
@@ -365,53 +454,44 @@ public final class CellUtil {
   public static ByteBuffer getQualifierBufferShallowCopy(Cell cell) {
     // No usage of this in code.
     ByteBuffer buffer = ByteBuffer.wrap(cell.getQualifierArray(), cell.getQualifierOffset(),
-        cell.getQualifierLength());
+      cell.getQualifierLength());
     return buffer;
   }
 
   /**
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link CellBuilder} instead
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}
+   *             instead
    */
   @Deprecated
-  public static Cell createCell(final byte [] row, final byte [] family, final byte [] qualifier,
-      final long timestamp, final byte type, final byte [] value) {
-    return ExtendedCellBuilderFactory.create(CellBuilderType.DEEP_COPY)
-            .setRow(row)
-            .setFamily(family)
-            .setQualifier(qualifier)
-            .setTimestamp(timestamp)
-            .setType(type)
-            .setValue(value)
-            .build();
+  public static Cell createCell(final byte[] row, final byte[] family, final byte[] qualifier,
+      final long timestamp, final byte type, final byte[] value) {
+    return ExtendedCellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row)
+        .setFamily(family).setQualifier(qualifier).setTimestamp(timestamp).setType(type)
+        .setValue(value).build();
   }
 
   /**
    * Creates a cell with deep copy of all passed bytes.
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link CellBuilder} instead
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}
+   *             instead
    */
   @Deprecated
-  public static Cell createCell(final byte [] rowArray, final int rowOffset, final int rowLength,
-      final byte [] familyArray, final int familyOffset, final int familyLength,
-      final byte [] qualifierArray, final int qualifierOffset, final int qualifierLength) {
+  public static Cell createCell(final byte[] rowArray, final int rowOffset, final int rowLength,
+      final byte[] familyArray, final int familyOffset, final int familyLength,
+      final byte[] qualifierArray, final int qualifierOffset, final int qualifierLength) {
     // See createCell(final byte [] row, final byte [] value) for why we default Maximum type.
     return ExtendedCellBuilderFactory.create(CellBuilderType.DEEP_COPY)
-            .setRow(rowArray, rowOffset, rowLength)
-            .setFamily(familyArray, familyOffset, familyLength)
-            .setQualifier(qualifierArray, qualifierOffset, qualifierLength)
-            .setTimestamp(HConstants.LATEST_TIMESTAMP)
-            .setType(KeyValue.Type.Maximum.getCode())
-            .setValue(HConstants.EMPTY_BYTE_ARRAY, 0, HConstants.EMPTY_BYTE_ARRAY.length)
-            .build();
+        .setRow(rowArray, rowOffset, rowLength).setFamily(familyArray, familyOffset, familyLength)
+        .setQualifier(qualifierArray, qualifierOffset, qualifierLength)
+        .setTimestamp(HConstants.LATEST_TIMESTAMP).setType(KeyValue.Type.Maximum.getCode())
+        .setValue(HConstants.EMPTY_BYTE_ARRAY, 0, HConstants.EMPTY_BYTE_ARRAY.length).build();
   }
 
   /**
-   * Marked as audience Private as of 1.2.0.
-   * Creating a Cell with a memstoreTS/mvcc is an internal implementation detail not for
-   * public use.
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link ExtendedCellBuilder} instead
+   * Marked as audience Private as of 1.2.0. Creating a Cell with a memstoreTS/mvcc is an internal
+   * implementation detail not for public use.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use
+   *             {@link ExtendedCellBuilder} instead
    */
   @InterfaceAudience.Private
   @Deprecated
@@ -421,68 +501,58 @@ public final class CellUtil {
   }
 
   /**
-   * Marked as audience Private as of 1.2.0.
-   * Creating a Cell with tags and a memstoreTS/mvcc is an internal implementation detail not for
-   * public use.
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link ExtendedCellBuilder} instead
+   * Marked as audience Private as of 1.2.0. Creating a Cell with tags and a memstoreTS/mvcc is an
+   * internal implementation detail not for public use.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use
+   *             {@link ExtendedCellBuilder} instead
    */
   @InterfaceAudience.Private
   @Deprecated
   public static Cell createCell(final byte[] row, final byte[] family, final byte[] qualifier,
       final long timestamp, final byte type, final byte[] value, byte[] tags,
       final long memstoreTS) {
-    return ExtendedCellBuilderFactory.create(CellBuilderType.DEEP_COPY)
-            .setRow(row)
-            .setFamily(family)
-            .setQualifier(qualifier)
-            .setTimestamp(timestamp)
-            .setType(type)
-            .setValue(value)
-            .setTags(tags)
-            .setSequenceId(memstoreTS)
-            .build();
+    return ExtendedCellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row)
+        .setFamily(family).setQualifier(qualifier).setTimestamp(timestamp).setType(type)
+        .setValue(value).setTags(tags).setSequenceId(memstoreTS).build();
   }
 
   /**
-   * Marked as audience Private as of 1.2.0.
-   * Creating a Cell with tags is an internal implementation detail not for
-   * public use.
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link ExtendedCellBuilder} instead
+   * Marked as audience Private as of 1.2.0. Creating a Cell with tags is an internal implementation
+   * detail not for public use.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use
+   *             {@link ExtendedCellBuilder} instead
    */
   @InterfaceAudience.Private
   @Deprecated
   public static Cell createCell(final byte[] row, final byte[] family, final byte[] qualifier,
       final long timestamp, Type type, final byte[] value, byte[] tags) {
-    return createCell(row, family, qualifier, timestamp, type.getCode(), value,
-            tags, 0);
+    return createCell(row, family, qualifier, timestamp, type.getCode(), value, tags, 0);
   }
 
   /**
-   * Create a Cell with specific row.  Other fields defaulted.
+   * Create a Cell with specific row. Other fields defaulted.
    * @param row
    * @return Cell with passed row but all other fields are arbitrary
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link CellBuilder} instead
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}
+   *             instead
    */
   @Deprecated
-  public static Cell createCell(final byte [] row) {
+  public static Cell createCell(final byte[] row) {
     return createCell(row, HConstants.EMPTY_BYTE_ARRAY);
   }
 
   /**
-   * Create a Cell with specific row and value.  Other fields are defaulted.
+   * Create a Cell with specific row and value. Other fields are defaulted.
    * @param row
    * @param value
    * @return Cell with passed row and value but all other fields are arbitrary
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link CellBuilder} instead
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}
+   *             instead
    */
   @Deprecated
-  public static Cell createCell(final byte [] row, final byte [] value) {
+  public static Cell createCell(final byte[] row, final byte[] value) {
     // An empty family + empty qualifier + Type.Minimum is used as flag to indicate last on row.
-    // See the CellComparator and KeyValue comparator.  Search for compareWithoutRow.
+    // See the CellComparator and KeyValue comparator. Search for compareWithoutRow.
     // Lets not make a last-on-row key as default but at same time, if you are making a key
     // without specifying type, etc., flag it as weird by setting type to be Maximum.
     return createCell(row, HConstants.EMPTY_BYTE_ARRAY, HConstants.EMPTY_BYTE_ARRAY,
@@ -490,22 +560,24 @@ public final class CellUtil {
   }
 
   /**
-   * Create a Cell with specific row.  Other fields defaulted.
+   * Create a Cell with specific row. Other fields defaulted.
    * @param row
    * @param family
    * @param qualifier
    * @return Cell with passed row but all other fields are arbitrary
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link CellBuilder} instead
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}
+   *             instead
    */
   @Deprecated
-  public static Cell createCell(final byte [] row, final byte [] family, final byte [] qualifier) {
+  public static Cell createCell(final byte[] row, final byte[] family, final byte[] qualifier) {
     // See above in createCell(final byte [] row, final byte [] value) why we set type to Maximum.
-    return createCell(row, family, qualifier,
-        HConstants.LATEST_TIMESTAMP, KeyValue.Type.Maximum.getCode(), HConstants.EMPTY_BYTE_ARRAY);
+    return createCell(row, family, qualifier, HConstants.LATEST_TIMESTAMP,
+      KeyValue.Type.Maximum.getCode(), HConstants.EMPTY_BYTE_ARRAY);
   }
 
+  @Deprecated
   /**
+   * Will be removed in 3.0.
    * @return A new cell which is having the extra tags also added to it.
    */
   public static Cell createCell(Cell cell, List<Tag> tags) {
@@ -513,3155 +585,1536 @@ public final class CellUtil {
   }
 
   /**
+   * Will be removed in 3.0.
    * @return A new cell which is having the extra tags also added to it.
    */
+  @Deprecated
   public static Cell createCell(Cell cell, byte[] tags) {
     if (cell instanceof ByteBufferCell) {
-      return new TagRewriteByteBufferCell((ByteBufferCell) cell, tags);
+      return new InternalCellUtil.TagRewriteByteBufferCell((ByteBufferCell) cell, tags);
     }
-    return new TagRewriteCell(cell, tags);
+    return new InternalCellUtil.TagRewriteCell(cell, tags);
   }
 
+  /**
+   * Will be removed in 3.0.
+   */
+  @Deprecated
   public static Cell createCell(Cell cell, byte[] value, byte[] tags) {
     if (cell instanceof ByteBufferCell) {
-      return new ValueAndTagRewriteByteBufferCell((ByteBufferCell) cell, value, tags);
+      return new InternalCellUtil.ValueAndTagRewriteByteBufferCell((ByteBufferCell) cell, value,
+          tags);
     }
-    return new ValueAndTagRewriteCell(cell, value, tags);
+    return new InternalCellUtil.ValueAndTagRewriteCell(cell, value, tags);
   }
 
   /**
-   * This can be used when a Cell has to change with addition/removal of one or more tags. This is an
-   * efficient way to do so in which only the tags bytes part need to recreated and copied. All other
-   * parts, refer to the original Cell.
+   * @param cellScannerables
+   * @return CellScanner interface over <code>cellIterables</code>
    */
-  @InterfaceAudience.Private
-  private static class TagRewriteCell implements ExtendedCell {
-    protected Cell cell;
-    protected byte[] tags;
-    private static final long HEAP_SIZE_OVERHEAD = ClassSize.OBJECT + 2 * ClassSize.REFERENCE;
-
-    /**
-     * @param cell The original Cell which it rewrites
-     * @param tags the tags bytes. The array suppose to contain the tags bytes alone.
-     */
-    public TagRewriteCell(Cell cell, byte[] tags) {
-      assert cell instanceof ExtendedCell;
-      assert tags != null;
-      this.cell = cell;
-      this.tags = tags;
-      // tag offset will be treated as 0 and length this.tags.length
-      if (this.cell instanceof TagRewriteCell) {
-        // Cleaning the ref so that the byte[] can be GCed
-        ((TagRewriteCell) this.cell).tags = null;
+  public static CellScanner
+      createCellScanner(final List<? extends CellScannable> cellScannerables) {
+    return new CellScanner() {
+      private final Iterator<? extends CellScannable> iterator = cellScannerables.iterator();
+      private CellScanner cellScanner = null;
+
+      @Override
+      public Cell current() {
+        return this.cellScanner != null ? this.cellScanner.current() : null;
       }
-    }
 
-    @Override
-    public byte[] getRowArray() {
-      return cell.getRowArray();
-    }
+      @Override
+      public boolean advance() throws IOException {
+        while (true) {
+          if (this.cellScanner == null) {
+            if (!this.iterator.hasNext()) return false;
+            this.cellScanner = this.iterator.next().cellScanner();
+          }
+          if (this.cellScanner.advance()) return true;
+          this.cellScanner = null;
+        }
+      }
+    };
+  }
 
-    @Override
-    public int getRowOffset() {
-      return cell.getRowOffset();
-    }
+  /**
+   * @param cellIterable
+   * @return CellScanner interface over <code>cellIterable</code>
+   */
+  public static CellScanner createCellScanner(final Iterable<Cell> cellIterable) {
+    if (cellIterable == null) return null;
+    return createCellScanner(cellIterable.iterator());
+  }
 
-    @Override
-    public short getRowLength() {
-      return cell.getRowLength();
-    }
+  /**
+   * @param cells
+   * @return CellScanner interface over <code>cellIterable</code> or null if <code>cells</code> is
+   *         null
+   */
+  public static CellScanner createCellScanner(final Iterator<Cell> cells) {
+    if (cells == null) return null;
+    return new CellScanner() {
+      private final Iterator<Cell> iterator = cells;
+      private Cell current = null;
 
-    @Override
-    public byte[] getFamilyArray() {
-      return cell.getFamilyArray();
-    }
+      @Override
+      public Cell current() {
+        return this.current;
+      }
 
-    @Override
-    public int getFamilyOffset() {
-      return cell.getFamilyOffset();
-    }
+      @Override
+      public boolean advance() {
+        boolean hasNext = this.iterator.hasNext();
+        this.current = hasNext ? this.iterator.next() : null;
+        return hasNext;
+      }
+    };
+  }
 
-    @Override
-    public byte getFamilyLength() {
-      return cell.getFamilyLength();
-    }
+  /**
+   * @param cellArray
+   * @return CellScanner interface over <code>cellArray</code>
+   */
+  public static CellScanner createCellScanner(final Cell[] cellArray) {
+    return new CellScanner() {
+      private final Cell[] cells = cellArray;
+      private int index = -1;
 
-    @Override
-    public byte[] getQualifierArray() {
-      return cell.getQualifierArray();
-    }
+      @Override
+      public Cell current() {
+        if (cells == null) return null;
+        return (index < 0) ? null : this.cells[index];
+      }
 
-    @Override
-    public int getQualifierOffset() {
-      return cell.getQualifierOffset();
-    }
+      @Override
+      public boolean advance() {
+        if (cells == null) return false;
+        return ++index < this.cells.length;
+      }
+    };
+  }
 
-    @Override
-    public int getQualifierLength() {
-      return cell.getQualifierLength();
-    }
+  /**
+   * Flatten the map of cells out under the CellScanner
+   * @param map Map of Cell Lists; for example, the map of families to Cells that is used inside
+   *          Put, etc., keeping Cells organized by family.
+   * @return CellScanner interface over <code>cellIterable</code>
+   */
+  public static CellScanner createCellScanner(final NavigableMap<byte[], List<Cell>> map) {
+    return new CellScanner() {
+      private final Iterator<Entry<byte[], List<Cell>>> entries = map.entrySet().iterator();
+      private Iterator<Cell> currentIterator = null;
+      private Cell currentCell;
 
-    @Override
-    public long getTimestamp() {
-      return cell.getTimestamp();
-    }
+      @Override
+      public Cell current() {
+        return this.currentCell;
+      }
 
-    @Override
-    public byte getTypeByte() {
-      return cell.getTypeByte();
-    }
+      @Override
+      public boolean advance() {
+        while (true) {
+          if (this.currentIterator == null) {
+            if (!this.entries.hasNext()) return false;
+            this.currentIterator = this.entries.next().getValue().iterator();
+          }
+          if (this.currentIterator.hasNext()) {
+            this.currentCell = this.currentIterator.next();
+            return true;
+          }
+          this.currentCell = null;
+          this.currentIterator = null;
+        }
+      }
+    };
+  }
 
-    @Override
-    public long getSequenceId() {
-      return cell.getSequenceId();
-    }
+  /**
+   * @param left
+   * @param right
+   * @return True if the rows in <code>left</code> and <code>right</code> Cells match
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Instead use
+   *             {@link #matchingRows(Cell, Cell)}
+   */
+  @Deprecated
+  public static boolean matchingRow(final Cell left, final Cell right) {
+    return matchingRows(left, right);
+  }
 
-    @Override
-    public byte[] getValueArray() {
-      return cell.getValueArray();
+  public static boolean matchingRow(final Cell left, final byte[] buf) {
+    if (buf == null) {
+      return left.getRowLength() == 0;
     }
+    return InternalCellUtil.matchingRow(left, buf, 0, buf.length);
+  }
 
-    @Override
-    public int getValueOffset() {
-      return cell.getValueOffset();
+  /**
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Instead use
+   *             {@link #matchingRows(Cell, Cell)}
+   * @return
+   */
+  @Deprecated
+  public static boolean matchingRow(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
+        ((ByteBufferCell) left).getRowPosition(), left.getRowLength(), buf, offset, length);
     }
+    return Bytes.equals(left.getRowArray(), left.getRowOffset(), left.getRowLength(), buf, offset,
+      length);
+  }
 
-    @Override
-    public int getValueLength() {
-      return cell.getValueLength();
+  public static boolean matchingFamily(final Cell left, final Cell right) {
+    byte lfamlength = left.getFamilyLength();
+    byte rfamlength = right.getFamilyLength();
+    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
+        ((ByteBufferCell) left).getFamilyPosition(), lfamlength,
+        ((ByteBufferCell) right).getFamilyByteBuffer(),
+        ((ByteBufferCell) right).getFamilyPosition(), rfamlength);
     }
-
-    @Override
-    public byte[] getTagsArray() {
-      return this.tags;
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
+        ((ByteBufferCell) left).getFamilyPosition(), lfamlength, right.getFamilyArray(),
+        right.getFamilyOffset(), rfamlength);
     }
-
-    @Override
-    public int getTagsOffset() {
-      return 0;
+    if (right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) right).getFamilyByteBuffer(),
+        ((ByteBufferCell) right).getFamilyPosition(), rfamlength, left.getFamilyArray(),
+        left.getFamilyOffset(), lfamlength);
     }
+    return Bytes.equals(left.getFamilyArray(), left.getFamilyOffset(), lfamlength,
+      right.getFamilyArray(), right.getFamilyOffset(), rfamlength);
+  }
 
-    @Override
-    public int getTagsLength() {
-      if (null == this.tags) {
-        // Nulled out tags array optimization in constructor
-        return 0;
-      }
-      return this.tags.length;
+  public static boolean matchingFamily(final Cell left, final byte[] buf) {
+    if (buf == null) {
+      return left.getFamilyLength() == 0;
     }
+    return InternalCellUtil.matchingFamily(left, buf, 0, buf.length);
+  }
 
-    @Override
-    public long heapSize() {
-      long sum = HEAP_SIZE_OVERHEAD + CellUtil.estimatedHeapSizeOf(cell);
-      if (this.tags != null) {
-        sum += ClassSize.sizeOf(this.tags);
-      }
-      return sum;
+  /**
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static boolean matchingFamily(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
+        ((ByteBufferCell) left).getFamilyPosition(), left.getFamilyLength(), buf, offset, length);
     }
+    return Bytes.equals(left.getFamilyArray(), left.getFamilyOffset(), left.getFamilyLength(), buf,
+      offset, length);
+  }
 
-    @Override
-    public void setTimestamp(long ts) throws IOException {
-      // The incoming cell is supposed to be SettableTimestamp type.
-      CellUtil.setTimestamp(cell, ts);
+  public static boolean matchingQualifier(final Cell left, final Cell right) {
+    int lqlength = left.getQualifierLength();
+    int rqlength = right.getQualifierLength();
+    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
+        ((ByteBufferCell) left).getQualifierPosition(), lqlength,
+        ((ByteBufferCell) right).getQualifierByteBuffer(),
+        ((ByteBufferCell) right).getQualifierPosition(), rqlength);
     }
-
-    @Override
-    public void setTimestamp(byte[] ts, int tsOffset) throws IOException {
-      // The incoming cell is supposed to be SettableTimestamp type.
-      CellUtil.setTimestamp(cell, ts, tsOffset);
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
+        ((ByteBufferCell) left).getQualifierPosition(), lqlength, right.getQualifierArray(),
+        right.getQualifierOffset(), rqlength);
     }
-
-    @Override
-    public void setSequenceId(long seqId) throws IOException {
-      // The incoming cell is supposed to be SettableSequenceId type.
-      CellUtil.setSequenceId(cell, seqId);
+    if (right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) right).getQualifierByteBuffer(),
+        ((ByteBufferCell) right).getQualifierPosition(), rqlength, left.getQualifierArray(),
+        left.getQualifierOffset(), lqlength);
     }
+    return Bytes.equals(left.getQualifierArray(), left.getQualifierOffset(), lqlength,
+      right.getQualifierArray(), right.getQualifierOffset(), rqlength);
+  }
 
-    @Override
-    public int write(OutputStream out, boolean withTags) throws IOException {
-      int len = ((ExtendedCell) this.cell).write(out, false);
-      if (withTags && this.tags != null) {
-        // Write the tagsLength 2 bytes
-        out.write((byte) (0xff & (this.tags.length >> 8)));
-        out.write((byte) (0xff & this.tags.length));
-        out.write(this.tags);
-        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
-      }
-      return len;
+  /**
+   * Finds if the qualifier part of the cell and the KV serialized byte[] are equal
+   * @param left
+   * @param buf the serialized keyvalue format byte[]
+   * @return true if the qualifier matches, false otherwise
+   */
+  public static boolean matchingQualifier(final Cell left, final byte[] buf) {
+    if (buf == null) {
+      return left.getQualifierLength() == 0;
     }
+    return InternalCellUtil.matchingQualifier(left, buf, 0, buf.length);
+  }
 
-    @Override
-    public int getSerializedSize(boolean withTags) {
-      int len = ((ExtendedCell) this.cell).getSerializedSize(false);
-      if (withTags && this.tags != null) {
-        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
-      }
-      return len;
-    }
-
-    @Override
-    public void write(ByteBuffer buf, int offset) {
-      offset = KeyValueUtil.appendTo(this.cell, buf, offset, false);
-      int tagsLen = this.tags == null ? 0 : this.tags.length;
-      if (tagsLen > 0) {
-        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
-        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, this.tags, 0, tagsLen);
-      }
-    }
-
-    @Override
-    public ExtendedCell deepClone() {
-      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
-      return new TagRewriteCell(clonedBaseCell, this.tags);
-    }
-  }
-
-  @InterfaceAudience.Private
-  private static class TagRewriteByteBufferCell extends ByteBufferCell implements ExtendedCell {
-
-    protected ByteBufferCell cell;
-    protected byte[] tags;
-    private static final long HEAP_SIZE_OVERHEAD = ClassSize.OBJECT + 2 * ClassSize.REFERENCE;
-
-    /**
-     * @param cell The original ByteBufferCell which it rewrites
-     * @param tags the tags bytes. The array suppose to contain the tags bytes alone.
-     */
-    public TagRewriteByteBufferCell(ByteBufferCell cell, byte[] tags) {
-      assert cell instanceof ExtendedCell;
-      assert tags != null;
-      this.cell = cell;
-      this.tags = tags;
-      // tag offset will be treated as 0 and length this.tags.length
-      if (this.cell instanceof TagRewriteByteBufferCell) {
-        // Cleaning the ref so that the byte[] can be GCed
-        ((TagRewriteByteBufferCell) this.cell).tags = null;
-      }
-    }
-
-    @Override
-    public byte[] getRowArray() {
-      return this.cell.getRowArray();
-    }
-
-    @Override
-    public int getRowOffset() {
-      return this.cell.getRowOffset();
-    }
-
-    @Override
-    public short getRowLength() {
-      return this.cell.getRowLength();
-    }
-
-    @Override
-    public byte[] getFamilyArray() {
-      return this.cell.getFamilyArray();
-    }
-
-    @Override
-    public int getFamilyOffset() {
-      return this.cell.getFamilyOffset();
-    }
-
-    @Override
-    public byte getFamilyLength() {
-      return this.cell.getFamilyLength();
-    }
-
-    @Override
-    public byte[] getQualifierArray() {
-      return this.cell.getQualifierArray();
-    }
-
-    @Override
-    public int getQualifierOffset() {
-      return this.cell.getQualifierOffset();
-    }
-
-    @Override
-    public int getQualifierLength() {
-      return this.cell.getQualifierLength();
-    }
-
-    @Override
-    public long getTimestamp() {
-      return this.cell.getTimestamp();
-    }
-
-    @Override
-    public byte getTypeByte() {
-      return this.cell.getTypeByte();
-    }
-
-    @Override
-    public long getSequenceId() {
-      return this.cell.getSequenceId();
-    }
-
-    @Override
-    public byte[] getValueArray() {
-      return this.cell.getValueArray();
-    }
-
-    @Override
-    public int getValueOffset() {
-      return this.cell.getValueOffset();
-    }
-
-    @Override
-    public int getValueLength() {
-      return this.cell.getValueLength();
-    }
-
-    @Override
-    public byte[] getTagsArray() {
-      return this.tags;
-    }
-
-    @Override
-    public int getTagsOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getTagsLength() {
-      if (null == this.tags) {
-        // Nulled out tags array optimization in constructor
-        return 0;
-      }
-      return this.tags.length;
-    }
-
-    @Override
-    public void setSequenceId(long seqId) throws IOException {
-      CellUtil.setSequenceId(this.cell, seqId);
-    }
-
-    @Override
-    public void setTimestamp(long ts) throws IOException {
-      CellUtil.setTimestamp(this.cell, ts);
-    }
-
-    @Override
-    public void setTimestamp(byte[] ts, int tsOffset) throws IOException {
-      CellUtil.setTimestamp(this.cell, ts, tsOffset);
-    }
-
-    @Override
-    public long heapSize() {
-      long sum = HEAP_SIZE_OVERHEAD + CellUtil.estimatedHeapSizeOf(cell);
-      // this.tags is on heap byte[]
-      if (this.tags != null) {
-        sum += ClassSize.sizeOf(this.tags);
-      }
-      return sum;
-    }
-
-    @Override
-    public int write(OutputStream out, boolean withTags) throws IOException {
-      int len = ((ExtendedCell) this.cell).write(out, false);
-      if (withTags && this.tags != null) {
-        // Write the tagsLength 2 bytes
-        out.write((byte) (0xff & (this.tags.length >> 8)));
-        out.write((byte) (0xff & this.tags.length));
-        out.write(this.tags);
-        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
-      }
-      return len;
-    }
-
-    @Override
-    public int getSerializedSize(boolean withTags) {
-      int len = ((ExtendedCell) this.cell).getSerializedSize(false);
-      if (withTags && this.tags != null) {
-        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
-      }
-      return len;
-    }
-
-    @Override
-    public void write(ByteBuffer buf, int offset) {
-      offset = KeyValueUtil.appendTo(this.cell, buf, offset, false);
-      int tagsLen = this.tags == null ? 0 : this.tags.length;
-      if (tagsLen > 0) {
-        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
-        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, this.tags, 0, tagsLen);
-      }
-    }
-
-    @Override
-    public ExtendedCell deepClone() {
-      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
-      if (clonedBaseCell instanceof ByteBufferCell) {
-        return new TagRewriteByteBufferCell((ByteBufferCell) clonedBaseCell, this.tags);
-      }
-      return new TagRewriteCell(clonedBaseCell, this.tags);
-    }
-
-    @Override
-    public ByteBuffer getRowByteBuffer() {
-      return this.cell.getRowByteBuffer();
-    }
-
-    @Override
-    public int getRowPosition() {
-      return this.cell.getRowPosition();
-    }
-
-    @Override
-    public ByteBuffer getFamilyByteBuffer() {
-      return this.cell.getFamilyByteBuffer();
-    }
-
-    @Override
-    public int getFamilyPosition() {
-      return this.cell.getFamilyPosition();
-    }
-
-    @Override
-    public ByteBuffer getQualifierByteBuffer() {
-      return this.cell.getQualifierByteBuffer();
-    }
-
-    @Override
-    public int getQualifierPosition() {
-      return this.cell.getQualifierPosition();
-    }
-
-    @Override
-    public ByteBuffer getValueByteBuffer() {
-      return this.cell.getValueByteBuffer();
-    }
-
-    @Override
-    public int getValuePosition() {
-      return this.cell.getValuePosition();
-    }
-
-    @Override
-    public ByteBuffer getTagsByteBuffer() {
-      return this.tags == null ? HConstants.EMPTY_BYTE_BUFFER : ByteBuffer.wrap(this.tags);
-    }
-
-    @Override
-    public int getTagsPosition() {
-      return 0;
-    }
-  }
-
-  @InterfaceAudience.Private
-  private static class ValueAndTagRewriteCell extends TagRewriteCell {
-
-    protected byte[] value;
-
-    public ValueAndTagRewriteCell(Cell cell, byte[] value, byte[] tags) {
-      super(cell, tags);
-      this.value = value;
-    }
-
-    @Override
-    public byte[] getValueArray() {
-      return this.value;
-    }
-
-    @Override
-    public int getValueOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getValueLength() {
-      return this.value == null ? 0 : this.value.length;
-    }
-
-    @Override
-    public long heapSize() {
-      long sum = ClassSize.REFERENCE + super.heapSize();
-      if (this.value != null) {
-        sum += ClassSize.sizeOf(this.value);
-      }
-      return sum;
-    }
-
-    @Override
-    public int write(OutputStream out, boolean withTags) throws IOException {
-      return write(out, withTags, this.cell, this.value, this.tags);
-    }
-
-    // Made into a static method so as to reuse the logic within ValueAndTagRewriteByteBufferCell
-    static int write(OutputStream out, boolean withTags, Cell cell, byte[] value, byte[] tags)
-        throws IOException {
-      int valLen = value == null ? 0 : value.length;
-      ByteBufferUtils.putInt(out, KeyValueUtil.keyLength(cell));// Key length
-      ByteBufferUtils.putInt(out, valLen);// Value length
-      int len = 2 * Bytes.SIZEOF_INT;
-      len += CellUtil.writeFlatKey(cell, out);// Key
-      if (valLen > 0) out.write(value);// Value
-      len += valLen;
-      if (withTags && tags != null) {
-        // Write the tagsLength 2 bytes
-        out.write((byte) (0xff & (tags.length >> 8)));
-        out.write((byte) (0xff & tags.length));
-        out.write(tags);
-        len += KeyValue.TAGS_LENGTH_SIZE + tags.length;
-      }
-      return len;
-    }
-
-    @Override
-    public int getSerializedSize(boolean withTags) {
-      return super.getSerializedSize(withTags) - this.cell.getValueLength() + this.value.length;
-    }
-
-    @Override
-    public void write(ByteBuffer buf, int offset) {
-      write(buf, offset, this.cell, this.value, this.tags);
-    }
-
-    // Made into a static method so as to reuse the logic within ValueAndTagRewriteByteBufferCell
-    static void write(ByteBuffer buf, int offset, Cell cell, byte[] value, byte[] tags) {
-      offset = ByteBufferUtils.putInt(buf, offset, KeyValueUtil.keyLength(cell));// Key length
-      offset = ByteBufferUtils.putInt(buf, offset, value.length);// Value length
-      offset = KeyValueUtil.appendKeyTo(cell, buf, offset);
-      ByteBufferUtils.copyFromArrayToBuffer(buf, offset, value, 0, value.length);
-      offset += value.length;
-      int tagsLen = tags == null ? 0 : tags.length;
-      if (tagsLen > 0) {
-        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
-        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, tags, 0, tagsLen);
-      }
-    }
-
-    @Override
-    public ExtendedCell deepClone() {
-      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
-      return new ValueAndTagRewriteCell(clonedBaseCell, this.value, this.tags);
-    }
-  }
-
-  @InterfaceAudience.Private
-  private static class ValueAndTagRewriteByteBufferCell extends TagRewriteByteBufferCell {
-
-    protected byte[] value;
-
-    public ValueAndTagRewriteByteBufferCell(ByteBufferCell cell, byte[] value, byte[] tags) {
-      super(cell, tags);
-      this.value = value;
-    }
-
-    @Override
-    public byte[] getValueArray() {
-      return this.value;
-    }
-
-    @Override
-    public int getValueOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getValueLength() {
-      return this.value == null ? 0 : this.value.length;
-    }
-
-    @Override
-    public ByteBuffer getValueByteBuffer() {
-      return ByteBuffer.wrap(this.value);
-    }
-
-    @Override
-    public int getValuePosition() {
-      return 0;
-    }
-
-    @Override
-    public long heapSize() {
-      long sum = ClassSize.REFERENCE + super.heapSize();
-      if (this.value != null) {
-        sum += ClassSize.sizeOf(this.value);
-      }
-      return sum;
-    }
-
-    @Override
-    public int write(OutputStream out, boolean withTags) throws IOException {
-      return ValueAndTagRewriteCell.write(out, withTags, this.cell, this.value, this.tags);
-    }
-
-    @Override
-    public int getSerializedSize(boolean withTags) {
-      return super.getSerializedSize(withTags) - this.cell.getValueLength() + this.value.length;
-    }
-
-    @Override
-    public void write(ByteBuffer buf, int offset) {
-      ValueAndTagRewriteCell.write(buf, offset, this.cell, this.value, this.tags);
-    }
-
-    @Override
-    public ExtendedCell deepClone() {
-      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
-      if (clonedBaseCell instanceof ByteBufferCell) {
-        return new ValueAndTagRewriteByteBufferCell((ByteBufferCell) clonedBaseCell, this.value,
-            this.tags);
-      }
-      return new ValueAndTagRewriteCell(clonedBaseCell, this.value, this.tags);
-    }
-  }
-
-  /**
-   * @param cellScannerables
-   * @return CellScanner interface over <code>cellIterables</code>
-   */
-  public static CellScanner createCellScanner(
-      final List<? extends CellScannable> cellScannerables) {
-    return new CellScanner() {
-      private final Iterator<? extends CellScannable> iterator = cellScannerables.iterator();
-      private CellScanner cellScanner = null;
-
-      @Override
-      public Cell current() {
-        return this.cellScanner != null? this.cellScanner.current(): null;
-      }
-
-      @Override
-      public boolean advance() throws IOException {
-        while (true) {
-          if (this.cellScanner == null) {
-            if (!this.iterator.hasNext()) return false;
-            this.cellScanner = this.iterator.next().cellScanner();
-          }
-          if (this.cellScanner.advance()) return true;
-          this.cellScanner = null;
-        }
-      }
-    };
-  }
-
-  /**
-   * @param cellIterable
-   * @return CellScanner interface over <code>cellIterable</code>
-   */
-  public static CellScanner createCellScanner(final Iterable<Cell> cellIterable) {
-    if (cellIterable == null) return null;
-    return createCellScanner(cellIterable.iterator());
-  }
-
-  /**
-   * @param cells
-   * @return CellScanner interface over <code>cellIterable</code> or null if <code>cells</code> is
-   * null
-   */
-  public static CellScanner createCellScanner(final Iterator<Cell> cells) {
-    if (cells == null) return null;
-    return new CellScanner() {
-      private final Iterator<Cell> iterator = cells;
-      private Cell current = null;
-
-      @Override
-      public Cell current() {
-        return this.current;
-      }
-
-      @Override
-      public boolean advance() {
-        boolean hasNext = this.iterator.hasNext();
-        this.current = hasNext? this.iterator.next(): null;
-        return hasNext;
-      }
-    };
-  }
-
-  /**
-   * @param cellArray
-   * @return CellScanner interface over <code>cellArray</code>
-   */
-  public static CellScanner createCellScanner(final Cell[] cellArray) {
-    return new CellScanner() {
-      private final Cell [] cells = cellArray;
-      private int index = -1;
-
-      @Override
-      public Cell current() {
-        if (cells == null) return null;
-        return (index < 0)? null: this.cells[index];
-      }
-
-      @Override
-      public boolean advance() {
-        if (cells == null) return false;
-        return ++index < this.cells.length;
-      }
-    };
-  }
-
-  /**
-   * Flatten the map of cells out under the CellScanner
-   * @param map Map of Cell Lists; for example, the map of families to Cells that is used
-   * inside Put, etc., keeping Cells organized by family.
-   * @return CellScanner interface over <code>cellIterable</code>
-   */
-  public static CellScanner createCellScanner(final NavigableMap<byte [], List<Cell>> map) {
-    return new CellScanner() {
-      private final Iterator<Entry<byte[], List<Cell>>> entries = map.entrySet().iterator();
-      private Iterator<Cell> currentIterator = null;
-      private Cell currentCell;
-
-      @Override
-      public Cell current() {
-        return this.currentCell;
-      }
-
-      @Override
-      public boolean advance() {
-        while(true) {
-          if (this.currentIterator == null) {
-            if (!this.entries.hasNext()) return false;
-            this.currentIterator = this.entries.next().getValue().iterator();
-          }
-          if (this.currentIterator.hasNext()) {
-            this.currentCell = this.currentIterator.next();
-            return true;
-          }
-          this.currentCell = null;
-          this.currentIterator = null;
-        }
-      }
-    };
-  }
-
-  /**
-   * @param left
-   * @param right
-   * @return True if the rows in <code>left</code> and <code>right</code> Cells match
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Instead use {@link #matchingRows(Cell, Cell)}
-   */
-  @Deprecated
-  public static boolean matchingRow(final Cell left, final Cell right) {
-    return matchingRows(left, right);
-  }
-
-  public static boolean matchingRow(final Cell left, final byte[] buf) {
-    if (buf == null) {
-      return left.getRowLength() == 0;
-    }
-    return matchingRow(left, buf, 0, buf.length);
-  }
-
-  public static boolean matchingRow(final Cell left, final byte[] buf, final int offset,
-      final int length) {
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
-          ((ByteBufferCell) left).getRowPosition(), left.getRowLength(), buf, offset,
-          length);
-    }
-    return Bytes.equals(left.getRowArray(), left.getRowOffset(), left.getRowLength(), buf, offset,
-        length);
-  }
-
-  public static boolean matchingFamily(final Cell left, final Cell right) {
-    byte lfamlength = left.getFamilyLength();
-    byte rfamlength = right.getFamilyLength();
-    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
-          ((ByteBufferCell) left).getFamilyPosition(), lfamlength,
-          ((ByteBufferCell) right).getFamilyByteBuffer(),
-          ((ByteBufferCell) right).getFamilyPosition(), rfamlength);
-    }
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
-          ((ByteBufferCell) left).getFamilyPosition(), lfamlength,
-          right.getFamilyArray(), right.getFamilyOffset(), rfamlength);
-    }
-    if (right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) right).getFamilyByteBuffer(),
-          ((ByteBufferCell) right).getFamilyPosition(), rfamlength,
-          left.getFamilyArray(), left.getFamilyOffset(), lfamlength);
-    }
-    return Bytes.equals(left.getFamilyArray(), left.getFamilyOffset(), lfamlength,
-        right.getFamilyArray(), right.getFamilyOffset(), rfamlength);
-  }
-
-  public static boolean matchingFamily(final Cell left, final byte[] buf) {
-    if (buf == null) {
-      return left.getFamilyLength() == 0;
-    }
-    return matchingFamily(left, buf, 0, buf.length);
-  }
-
-  public static boolean matchingFamily(final Cell left, final byte[] buf, final int offset,
-      final int length) {
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
-          ((ByteBufferCell) left).getFamilyPosition(), left.getFamilyLength(), buf,
-          offset, length);
-    }
-    return Bytes.equals(left.getFamilyArray(), left.getFamilyOffset(), left.getFamilyLength(), buf,
-        offset, length);
-  }
-
-  public static boolean matchingQualifier(final Cell left, final Cell right) {
-    int lqlength = left.getQualifierLength();
-    int rqlength = right.getQualifierLength();
-    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
-          ((ByteBufferCell) left).getQualifierPosition(), lqlength,
-          ((ByteBufferCell) right).getQualifierByteBuffer(),
-          ((ByteBufferCell) right).getQualifierPosition(), rqlength);
-    }
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
-          ((ByteBufferCell) left).getQualifierPosition(), lqlength,
-          right.getQualifierArray(), right.getQualifierOffset(), rqlength);
-    }
-    if (right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) right).getQualifierByteBuffer(),
-          ((ByteBufferCell) right).getQualifierPosition(), rqlength,
-          left.getQualifierArray(), left.getQualifierOffset(), lqlength);
-    }
-    return Bytes.equals(left.getQualifierArray(), left.getQualifierOffset(),
-        lqlength, right.getQualifierArray(), right.getQualifierOffset(),
-        rqlength);
-  }
-
-  /**
-   * Finds if the qualifier part of the cell and the KV serialized
-   * byte[] are equal
-   * @param left
-   * @param buf the serialized keyvalue format byte[]
-   * @return true if the qualifier matches, false otherwise
-   */
-  public static boolean matchingQualifier(final Cell left, final byte[] buf) {
-    if (buf == null) {
-      return left.getQualifierLength() == 0;
-    }
-    return matchingQualifier(left, buf, 0, buf.length);
-  }
-
-  /**
-   * Finds if the qualifier part of the cell and the KV serialized
-   * byte[] are equal
-   * @param left
-   * @param buf the serialized keyvalue format byte[]
-   * @param offset the offset of the qualifier in the byte[]
-   * @param length the length of the qualifier in the byte[]
-   * @return true if the qualifier matches, false otherwise
-   */
-  public static boolean matchingQualifier(final Cell left, final byte[] buf, final int offset,
-      final int length) {
-    if (buf == null) {
-      return left.getQualifierLength() == 0;
-    }
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
-          ((ByteBufferCell) left).getQualifierPosition(), left.getQualifierLength(),
-          buf, offset, length);
-    }
-    return Bytes.equals(left.getQualifierArray(), left.getQualifierOffset(),
-        left.getQualifierLength(), buf, offset, length);
-  }
-
-  public static boolean matchingColumn(final Cell left, final byte[] fam, final byte[] qual) {
-    if (!matchingFamily(left, fam))
-      return false;
-    return matchingQualifier(left, qual);
-  }
-
-  public static boolean matchingColumn(final Cell left, final byte[] fam, final int foffset,
-      final int flength, final byte[] qual, final int qoffset, final int qlength) {
-    if (!matchingFamily(left, fam, foffset, flength))
-      return false;
-    return matchingQualifier(left, qual, qoffset, qlength);
-  }
-
-  public static boolean matchingColumn(final Cell left, final Cell right) {
-    if (!matchingFamily(left, right))
-      return false;
-    return matchingQualifier(left, right);
-  }
-
-  public static boolean matchingValue(final Cell left, final Cell right) {
-    return matchingValue(left, right, left.getValueLength(), right.getValueLength());
-  }
-
-  public static boolean matchingValue(final Cell left, final Cell right, int lvlength,
-      int rvlength) {
-    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
-        ((ByteBufferCell) left).getValuePosition(), lvlength,
-        ((ByteBufferCell) right).getValueByteBuffer(),
-        ((ByteBufferCell) right).getValuePosition(), rvlength);
-    }
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
-        ((ByteBufferCell) left).getValuePosition(), lvlength, right.getValueArray(),
-        right.getValueOffset(), rvlength);
-    }
-    if (right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) right).getValueByteBuffer(),
-        ((ByteBufferCell) right).getValuePosition(), rvlength, left.getValueArray(),
-        left.getValueOffset(), lvlength);
-    }
-    return Bytes.equals(left.getValueArray(), left.getValueOffset(), lvlength,
-      right.getValueArray(), right.getValueOffset(), rvlength);
-  }
-
-  public static boolean matchingValue(final Cell left, final byte[] buf) {
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getValueByteBuffer(),
-          ((ByteBufferCell) left).getValuePosition(), left.getValueLength(), buf, 0,
-          buf.length) == 0;
-    }
-    return Bytes.equals(left.getValueArray(), left.getValueOffset(), left.getValueLength(), buf, 0,
-        buf.length);
-  }
-
-  /**
-   * @return True if a delete type, a {@link KeyValue.Type#Delete} or a
-   *         {KeyValue.Type#DeleteFamily} or a
-   *         {@link KeyValue.Type#DeleteColumn} KeyValue type.
-   */
-  public static boolean isDelete(final Cell cell) {
-    return isDelete(cell.getTypeByte());
-  }
-
-  /**
-   * @return True if a delete type, a {@link KeyValue.Type#Delete} or a
-   *         {KeyValue.Type#DeleteFamily} or a
-   *         {@link KeyValue.Type#DeleteColumn} KeyValue type.
-   */
-  public static boolean isDelete(final byte type) {
-    return Type.Delete.getCode() <= type
-        && type <= Type.DeleteFamily.getCode();
-  }
-
-  /**
-   * @return True if this cell is a {@link KeyValue.Type#Delete} type.
-   */
-  public static boolean isDeleteType(Cell cell) {
-    return cell.getTypeByte() == Type.Delete.getCode();
-  }
-
-  public static boolean isDeleteFamily(final Cell cell) {
-    return cell.getTypeByte() == Type.DeleteFamily.getCode();
-  }
-
-  public static boolean isDeleteFamilyVersion(final Cell cell) {
-    return cell.getTypeByte() == Type.DeleteFamilyVersion.getCode();
-  }
-
-  public static boolean isDeleteColumns(final Cell cell) {
-    return cell.getTypeByte() == Type.DeleteColumn.getCode();
-  }
-
-  public static boolean isDeleteColumnVersion(final Cell cell) {
-    return cell.getTypeByte() == Type.Delete.getCode();
-  }
-
-  /**
-   *
-   * @return True if this cell is a delete family or column type.
-   */
-  public static boolean isDeleteColumnOrFamily(Cell cell) {
-    int t = cell.getTypeByte();
-    return t == Type.DeleteColumn.getCode() || t == Type.DeleteFamily.getCode();
-  }
-
-  /**
-   * Estimate based on keyvalue's serialization format in the RPC layer. Note that there is an extra
-   * SIZEOF_INT added to the size here that indicates the actual length of the cell for cases where
-   * cell's are serialized in a contiguous format (For eg in RPCs).
-   * @param cell
-   * @return Estimate of the <code>cell</code> size in bytes plus an extra SIZEOF_INT indicating the
-   *         actual cell length.
-   */
-  public static int estimatedSerializedSizeOf(final Cell cell) {
-    if (cell instanceof ExtendedCell) {
-      return ((ExtendedCell) cell).getSerializedSize(true) + Bytes.SIZEOF_INT;
-    }
-
-    return getSumOfCellElementLengths(cell) +
-      // Use the KeyValue's infrastructure size presuming that another implementation would have
-      // same basic cost.
-      KeyValue.ROW_LENGTH_SIZE + KeyValue.FAMILY_LENGTH_SIZE +
-      // Serialization is probably preceded by a length (it is in the KeyValueCodec at least).
-      Bytes.SIZEOF_INT;
-  }
-
-  /**
-   * @param cell
-   * @return Sum of the lengths of all the elements in a Cell; does not count in any infrastructure
-   */
-  private static int getSumOfCellElementLengths(final Cell cell) {
-    return getSumOfCellKeyElementLengths(cell) + cell.getValueLength() + cell.getTagsLength();
-  }
-
-  /**
-   * @param cell
-   * @return Sum of all elements that make up a key; does not include infrastructure, tags or
-   * values.
-   */
-  private static int getSumOfCellKeyElementLengths(final Cell cell) {
-    return cell.getRowLength() + cell.getFamilyLength() +
-    cell.getQualifierLength() +
-    KeyValue.TIMESTAMP_TYPE_SIZE;
-  }
-
-  /**
-   * Calculates the serialized key size. We always serialize in the KeyValue's serialization
-   * format.
-   * @param cell the cell for which the key size has to be calculated.
-   * @return the key size
-   */
-  public static int estimatedSerializedSizeOfKey(final Cell cell) {
-    if (cell instanceof KeyValue) return ((KeyValue)cell).getKeyLength();
-    return cell.getRowLength() + cell.getFamilyLength() +
-        cell.getQualifierLength() +
-        KeyValue.KEY_INFRASTRUCTURE_SIZE;
-  }
-
-  /**
-   * This is an estimate of the heap space occupied by a cell. When the cell is of type
-   * {@link HeapSize} we call {@link HeapSize#heapSize()} so cell can give a correct value. In other
-   * cases we just consider the bytes occupied by the cell components ie. row, CF, qualifier,
-   * timestamp, type, value and tags.
-   * @param cell
-   * @return estimate of the heap space
-   */
-  public static long estimatedHeapSizeOf(final Cell cell) {
-    if (cell instanceof HeapSize) {
-      return ((HeapSize) cell).heapSize();
-    }
-    // TODO: Add sizing of references that hold the row, family, etc., arrays.
-    return estimatedSerializedSizeOf(cell);
-  }
-
-  /********************* tags *************************************/
-  /**
-   * Util method to iterate through the tags
-   *
-   * @param tags
-   * @param offset
-   * @param length
-   * @return iterator for the tags
-   * @deprecated As of 2.0.0 and will be removed in 3.0.0
-   *             Instead use {@link #tagsIterator(Cell)}
-   */
-  @Deprecated
-  public static Iterator<Tag> tagsIterator(final byte[] tags, final int offset, final int length) {
-    return new Iterator<Tag>() {
-      private int pos = offset;
-      private int endOffset = offset + length - 1;
-
-      @Override
-      public boolean hasNext() {
-        return this.pos < endOffset;
-      }
-
-      @Override
-      public Tag next() {
-        if (hasNext()) {
-          int curTagLen = Bytes.readAsInt(tags, this.pos, Tag.TAG_LENGTH_SIZE);
-          Tag tag = new ArrayBackedTag(tags, pos, curTagLen + TAG_LENGTH_SIZE);
-          this.pos += Bytes.SIZEOF_SHORT + curTagLen;
-          return tag;
-        }
-        return null;
-      }
-
-      @Override
-      public void remove() {
-        throw new UnsupportedOperationException();
-      }
-    };
-  }
-
-  private static Iterator<Tag> tagsIterator(final ByteBuffer tags, final int offset,
-      final int length) {
-    return new Iterator<Tag>() {
-      private int pos = offset;
-      private int endOffset = offset + length - 1;
-
-      @Override
-      public boolean hasNext() {
-        return this.pos < endOffset;
-      }
-
-      @Override
-      public Tag next() {
-        if (hasNext()) {
-          int curTagLen = ByteBufferUtils.readAsInt(tags, this.pos, Tag.TAG_LENGTH_SIZE);
-          Tag tag = new ByteBufferTag(tags, pos, curTagLen + Tag.TAG_LENGTH_SIZE);
-          this.pos += Bytes.SIZEOF_SHORT + curTagLen;
-          return tag;
-        }
-        return null;
-      }
-
-      @Override
-      public void remove() {
-        throw new UnsupportedOperationException();
-      }
-    };
-  }
-
-  /**
-   * Util method to iterate through the tags in the given cell.
-   *
-   * @param cell The Cell over which tags iterator is needed.
-   * @return iterator for the tags
-   */
-  public static Iterator<Tag> tagsIterator(final Cell cell) {
-    final int tagsLength = cell.getTagsLength();
-    // Save an object allocation where we can
-    if (tagsLength == 0) {
-      return TagUtil.EMPTY_TAGS_ITR;
-    }
-    if (cell instanceof ByteBufferCell) {
-      return tagsIterator(((ByteBufferCell) cell).getTagsByteBuffer(),
-          ((ByteBufferCell) cell).getTagsPosition(), tagsLength);
-    }
-    return tagsIterator(cell.getTagsArray(), cell.getTagsOffset(), tagsLength);
-  }
-
-  /**
-   * @param cell The Cell
-   * @return Tags in the given Cell as a List
-   */
-  public static List<Tag> getTags(Cell cell) {
-    List<Tag> tags = new ArrayList<>();
-    Iterator<Tag> tagsItr = tagsIterator(cell);
-    while (tagsItr.hasNext()) {
-      tags.add(tagsItr.next());
-    }
-    return tags;
-  }
-
-  /**
-   * Retrieve Cell's first tag, matching the passed in type
-   *
-   * @param cell The Cell
-   * @param type Type of the Tag to retrieve
-   * @return null if there is no tag of the passed in tag type
-   */
-  public static Tag getTag(Cell cell, byte type){
-    boolean bufferBacked = cell instanceof ByteBufferCell;
-    int length = cell.getTagsLength();
-    int offset = bufferBacked? ((ByteBufferCell)cell).getTagsPosition():cell.getTagsOffset();
-    int pos = offset;
-    while (pos < offset + length) {
-      int tagLen;
-      if (bufferBacked) {
-        ByteBuffer tagsBuffer = ((ByteBufferCell)cell).getTagsByteBuffer();
-        tagLen = ByteBufferUtils.readAsInt(tagsBuffer, pos, TAG_LENGTH_SIZE);
-        if (ByteBufferUtils.toByte(tagsBuffer, pos + TAG_LENGTH_SIZE) == type) {
-          return new ByteBufferTag(tagsBuffer, pos, tagLen + TAG_LENGTH_SIZE);
-        }
-      } else {
-        tagLen = Bytes.readAsInt(cell.getTagsArray(), pos, TAG_LENGTH_SIZE);
-        if (cell.getTagsArray()[pos + TAG_LENGTH_SIZE] == type) {
-          return new ArrayBackedTag(cell.getTagsArray(), pos, tagLen + TAG_LENGTH_SIZE);
-        }
-      }
-      pos += TAG_LENGTH_SIZE + tagLen;
-    }
-    return null;
-  }
-
-  /**
-   * Returns true if the first range start1...end1 overlaps with the second range
-   * start2...end2, assuming the byte arrays represent row keys
-   */
-  public static boolean overlappingKeys(final byte[] start1, final byte[] end1,
-      final byte[] start2, final byte[] end2) {
-    return (end2.length == 0 || start1.length == 0 || Bytes.compareTo(start1,
-        end2) < 0)
-        && (end1.length == 0 || start2.length == 0 || Bytes.compareTo(start2,
-            end1) < 0);
-  }
-
-  /**
-   * Sets the given seqId to the cell.
-   * Marked as audience Private as of 1.2.0.
-   * Setting a Cell sequenceid is an internal implementation detail not for general public use.
-   * @param cell
-   * @param seqId
-   * @throws IOException when the passed cell is not of type {@link SettableSequenceId}
-   */
-  @InterfaceAudience.Private
-  public static void setSequenceId(Cell cell, long seqId) throws IOException {
-    if (cell instanceof SettableSequenceId) {
-      ((SettableSequenceId) cell).setSequenceId(seqId);
-    } else {
-      throw new IOException(new UnsupportedOperationException("Cell is not of type "
-          + SettableSequenceId.class.getName()));
-    }
-  }
-
-  /**
-   * Sets the given timestamp to the cell.
-   * @param cell
-   * @param ts
-   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
-   */
-  public static void setTimestamp(Cell cell, long ts) throws IOException {
-    if (cell instanceof SettableTimestamp) {
-      ((SettableTimestamp) cell).setTimestamp(ts);
-    } else {
-      throw new IOException(new UnsupportedOperationException("Cell is not of type "
-          + SettableTimestamp.class.getName()));
-    }
-  }
-
-  /**
-   * Sets the given timestamp to the cell.
-   * @param cell
-   * @param ts buffer containing the timestamp value
-   * @param tsOffset offset to the new timestamp
-   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
-   */
-  public static void setTimestamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
-    if (cell instanceof SettableTimestamp) {
-      ((SettableTimestamp) cell).setTimestamp(ts, tsOffset);
-    } else {
-      throw new IOException(new UnsupportedOperationException("Cell is not of type "
-          + SettableTimestamp.class.getName()));
-    }
-  }
-
-  /**
-   * Sets the given timestamp to the cell iff current timestamp is
-   * {@link HConstants#LATEST_TIMESTAMP}.
-   * @param cell
-   * @param ts
-   * @return True if cell timestamp is modified.
-   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
-   */
-  public static boolean updateLatestStamp(Cell cell, long ts) throws IOException {
-    if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP) {
-      setTimestamp(cell, ts);
-      return true;
-    }
-    return false;
-  }
-
-  /**
-   * Sets the given timestamp to the cell iff current timestamp is
-   * {@link HConstants#LATEST_TIMESTAMP}.
-   * @param cell
-   * @param ts buffer containing the timestamp value
-   * @param tsOffset offset to the new timestamp
-   * @return True if cell timestamp is modified.
-   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
-   */
-  public static boolean updateLatestStamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
-    if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP) {
-      setTimestamp(cell, ts, tsOffset);
-      return true;
-    }
-    return false;
-  }
-
-  /**
-   * Writes the Cell's key part as it would have serialized in a KeyValue. The format is &lt;2 bytes
-   * rk len&gt;&lt;rk&gt;&lt;1 byte cf len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes
-   * timestamp&gt;&lt;1 byte type&gt;
-   * @param cell
-   * @param out
-   * @deprecated Use {@link #writeFlatKey(Cell, DataOutput)}
-   * @throws IOException
-   */
-  @Deprecated
-  public static void writeFlatKey(Cell cell, DataOutputStream out) throws IOException {
-    short rowLen = cell.getRowLength();
-    byte fLen = cell.getFamilyLength();
-    int qLen = cell.getQualifierLength();
-    // Using just one if/else loop instead of every time checking before writing every
-    // component of cell
-    if (cell instanceof ByteBufferCell) {
-      out.writeShort(rowLen);
-      ByteBufferUtils.copyBufferToStream((DataOutput) out,
-        ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
-        rowLen);
-      out.writeByte(fLen);
-      ByteBufferUtils.copyBufferToStream((DataOutput) out,
-        ((ByteBufferCell) cell).getFamilyByteBuffer(), ((ByteBufferCell) cell).getFamilyPosition(),
-        fLen);
-      ByteBufferUtils.copyBufferToStream((DataOutput) out,
-        ((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition(), qLen);
-    } else {
-      out.writeShort(rowLen);
-      out.write(cell.getRowArray(), cell.getRowOffset(), rowLen);
-      out.writeByte(fLen);
-      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), fLen);
-      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qLen);
-    }
-    out.writeLong(cell.getTimestamp());
-    out.writeByte(cell.getTypeByte());
-  }
-
-  /**
-   * Writes the Cell's key part as it would have serialized in a KeyValue. The format is &lt;2 bytes
-   * rk len&gt;&lt;rk&gt;&lt;1 byte cf len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes
-   * timestamp&gt;&lt;1 byte type&gt;
-   * @param cell
-   * @param out
-   * @throws IOException
-   */
-  public static void writeFlatKey(Cell cell, DataOutput out) throws IOException {
-    short rowLen = cell.getRowLength();
-    byte fLen = cell.getFamilyLength();
-    int qLen = cell.getQualifierLength();
-    // Using just one if/else loop instead of every time checking before writing every
-    // component of cell
-    if (cell instanceof ByteBufferCell) {
-      out.writeShort(rowLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), rowLen);
-      out.writeByte(fLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
-        ((ByteBufferCell) cell).getFamilyPosition(), fLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition(), qLen);
-    } else {
-      out.writeShort(rowLen);
-      out.write(cell.getRowArray(), cell.getRowOffset(), rowLen);
-      out.writeByte(fLen);
-      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), fLen);
-      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qLen);
-    }
-    out.writeLong(cell.getTimestamp());
-    out.writeByte(cell.getTypeByte());
-  }
-
-  /**
-   * Deep clones the given cell if the cell supports deep cloning
-   * @param cell the cell to be cloned
-   * @return the cloned cell
-   * @throws CloneNotSupportedException
-   */
-  public static Cell deepClone(Cell cell) throws CloneNotSupportedException {
-    if (cell instanceof ExtendedCell) {
-      return ((ExtendedCell) cell).deepClone();
-    }
-    throw new CloneNotSupportedException();
-  }
-
-  /**
-   * Writes the cell to the given OutputStream
-   * @param cell the cell to be written
-   * @param out the outputstream
-   * @param withTags if tags are to be written or not
-   * @return the total bytes written
-   * @throws IOException
-   */
-  public static int writeCell(Cell cell, OutputStream out, boolean withTags) throws IOException {
-    if (cell instanceof ExtendedCell) {
-      return ((ExtendedCell) cell).write(out, withTags);
-    } else {
-      ByteBufferUtils.putInt(out, CellUtil.estimatedSerializedSizeOfKey(cell));
-      ByteBufferUtils.putInt(out, cell.getValueLength());
-      CellUtil.writeFlatKey(cell, out);
-      CellUtil.writeValue(out, cell, cell.getValueLength());
-      int tagsLength = cell.getTagsLength();
-      if (withTags) {
-        byte[] len = new byte[Bytes.SIZEOF_SHORT];
-        Bytes.putAsShort(len, 0, tagsLength);
-        out.write(len);
-        if (tagsLength > 0) {
-          CellUtil.writeTags(out, cell, tagsLength);
-        }
-      }
-      int lenWritten = (2 * Bytes.SIZEOF_INT) + CellUtil.estimatedSerializedSizeOfKey(cell)
-          + cell.getValueLength();
-      if (withTags) {
-        lenWritten += Bytes.SIZEOF_SHORT + tagsLength;
-      }
-      return lenWritten;
-    }
-  }
-
-  /**
-   * Writes a cell to the buffer at the given offset
-   * @param cell the cell to be written
-   * @param buf the buffer to which the cell has to be wrriten
-   * @param offset the offset at which the cell should be written
-   */
-  public static void writeCellToBuffer(Cell cell, ByteBuffer buf, int offset) {
-    if (cell instanceof ExtendedCell) {
-      ((ExtendedCell) cell).write(buf, offset);
-    } else {
-      // Using the KVUtil
-      byte[] bytes = KeyValueUtil.copyToNewByteArray(cell);
-      ByteBufferUtils.copyFromArrayToBuffer(buf, offset, bytes, 0, bytes.length);
-    }
-  }
-
-  public static int writeFlatKey(Cell cell, OutputStream out) throws IOException {
-    short rowLen = cell.getRowLength();
-    byte fLen = cell.getFamilyLength();
-    int qLen = cell.getQualifierLength();
-    // Using just one if/else loop instead of every time checking before writing every
-    // component of cell
-    if (cell instanceof ByteBufferCell) {
-      StreamUtils.writeShort(out, rowLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), rowLen);
-      out.write(fLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
-        ((ByteBufferCell) cell).getFamilyPosition(), fLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition(), qLen);
-    } else {
-      StreamUtils.writeShort(out, rowLen);
-      out.write(cell.getRowArray(), cell.getRowOffset(), rowLen);
-      out.write(fLen);
-      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), fLen);
-      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qLen);
-    }
-    StreamUtils.writeLong(out, cell.getTimestamp());
-    out.write(cell.getTypeByte());
-    return Bytes.SIZEOF_SHORT + rowLen + Bytes.SIZEOF_BYTE + fLen + qLen + Bytes.SIZEOF_LONG
-        + Bytes.SIZEOF_BYTE;
-  }
-
-  /**
-   * Writes the row from the given cell to the output stream
-   * @param out The outputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param rlength the row length
-   * @throws IOException
-   */
-  public static void writeRow(OutputStream out, Cell cell, short rlength) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), rlength);
-    } else {
-      out.write(cell.getRowArray(), cell.getRowOffset(), rlength);
-    }
-  }
-
-  /**
-   * Writes the row from the given cell to the output stream excluding the common prefix
-   * @param out The dataoutputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param rlength the row length
-   * @throws IOException
-   */
-  public static void writeRowSkippingBytes(DataOutputStream out, Cell cell, short rlength,
-      int commonPrefix) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream((DataOutput)out, ((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition() + commonPrefix, rlength - commonPrefix);
-    } else {
-      out.write(cell.getRowArray(), cell.getRowOffset() + commonPrefix, rlength - commonPrefix);
-    }
-  }
-
-  /**
-   * Writes the family from the given cell to the output stream
-   * @param out The outputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param flength the family length
-   * @throws IOException
-   */
-  public static void writeFamily(OutputStream out, Cell cell, byte flength) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
-        ((ByteBufferCell) cell).getFamilyPosition(), flength);
-    } else {
-      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), flength);
-    }
-  }
-
-  /**
-   * Writes the qualifier from the given cell to the output stream
-   * @param out The outputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param qlength the qualifier length
-   * @throws IOException
-   */
-  public static void writeQualifier(OutputStream out, Cell cell, int qlength)
-      throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition(), qlength);
-    } else {
-      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qlength);
-    }
-  }
-
-  /**
-   * Writes the qualifier from the given cell to the output stream excluding the common prefix
-   * @param out The dataoutputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param qlength the qualifier length
-   * @throws IOException
-   */
-  public static void writeQualifierSkippingBytes(DataOutputStream out, Cell cell,
-      int qlength, int commonPrefix) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream((DataOutput)out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition() + commonPrefix, qlength - commonPrefix);
-    } else {
-      out.write(cell.getQualifierArray(), cell.getQualifierOffset() + commonPrefix,
-        qlength - commonPrefix);
-    }
-  }
-
-  /**
-   * Writes the value from the given cell to the output stream
-   * @param out The outputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param vlength the value length
-   * @throws IOException
-   */
-  public static void writeValue(OutputStream out, Cell cell, int vlength) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getValueByteBuffer(),
-        ((ByteBufferCell) cell).getValuePosition(), vlength);
-    } else {
-      out.write(cell.getValueArray(), cell.getValueOffset(), vlength);
-    }
-  }
-
-  /**
-   * Writes the tag from the given cell to the output stream
-   * @param out The outputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param tagsLength the tag length
-   * @throws IOException
-   */
-  public static void writeTags(OutputStream out, Cell cell, int tagsLength) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getTagsByteBuffer(),
-        ((ByteBufferCell) cell).getTagsPosition(), tagsLength);
-    } else {
-      out.write(cell.getTagsArray(), cell.getTagsOffset(), tagsLength);
-    }
-  }
-
-  /**
-   * @param cell
-   * @return The Key portion of the passed <code>cell</code> as a String.
-   */
-  public static String getCellKeyAsString(Cell cell) {
-    StringBuilder sb = new StringBuilder(Bytes.toStringBinary(
-      cell.getRowArray(), cell.getRowOffset(), cell.getRowLength()));
-    sb.append('/');
-    sb.append(cell.getFamilyLength() == 0? "":
-      Bytes.toStringBinary(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength()));
-    // KeyValue only added ':' if family is non-null.  Do same.
-    if (cell.getFamilyLength() > 0) sb.append(':');
-    sb.append(cell.getQualifierLength() == 0? "":
-      Bytes.toStringBinary(cell.getQualifierArray(), cell.getQualifierOffset(),
-        cell.getQualifierLength()));
-    sb.append('/');
-    sb.append(KeyValue.humanReadableTimestamp(cell.getTimestamp()));
-    sb.append('/');
-    sb.append(Type.codeToType(cell.getTypeByte()));
-    if (!(cell instanceof KeyValue.KeyOnlyKeyValue)) {
-      sb.append("/vlen=");
-      sb.append(cell.getValueLength());
-    }
-    sb.append("/seqid=");
-    sb.append(cell.getSequenceId());
-    return sb.toString();
-  }
-
-  /**
-   * This method exists just to encapsulate how we serialize keys.  To be replaced by a factory
-   * that we query to figure what the Cell implementation is and then, what serialization engine
-   * to use and further, how to serialize the key for inclusion in hfile index. TODO.
-   * @param cell
-   * @return The key portion of the Cell serialized in the old-school KeyValue way or null if
-   * passed a null <code>cell</code>
-   */
-  public static byte [] getCellKeySerializedAsKeyValueKey(final Cell cell) {
-    if (cell == null) return null;
-    byte [] b = new byte[KeyValueUtil.keyLength(cell)];
-    KeyValueUtil.appendKeyTo(cell, b, 0);
-    return b;
-  }
-
-  /**
-   * Write rowkey excluding the common part.
-   * @param cell
-   * @param rLen
-   * @param commonPrefix
-   * @param out
-   * @throws IOException
-   */
-  public static void writeRowKeyExcludingCommon(Cell cell, short rLen, int commonPrefix,
-      DataOutputStream out) throws IOException {
-    if (commonPrefix == 0) {
-      out.writeShort(rLen);
-    } else if (commonPrefix == 1) {
-      out.writeByte((byte) rLen);
-      commonPrefix--;
-    } else {
-      commonPrefix -= KeyValue.ROW_LENGTH_SIZE;
-    }
-    if (rLen > commonPrefix) {
-      writeRowSkippingBytes(out, cell, rLen, commonPrefix);
-    }
-  }
-
-  /**
-   * Find length of common prefix in keys of the cells, considering key as byte[] if serialized in
-   * {@link KeyValue}. The key format is &lt;2 bytes rk len&gt;&lt;rk&gt;&lt;1 byte cf
-   * len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes timestamp&gt;&lt;1 byte type&gt;
-   * @param c1
-   *          the cell
-   * @param c2
-   *          the cell
-   * @param bypassFamilyCheck
-   *          when true assume the family bytes same in both cells. Pass it as true when dealing
-   *          with Cells in same CF so as to avoid some checks
-   * @param withTsType
-   *          when true check timestamp and type bytes also.
-   * @return length of common prefix
-   */
-  public static int findCommonPrefixInFlatKey(Cell c1, Cell c2, boolean bypassFamilyCheck,
-      boolean withTsType) {
-    // Compare the 2 bytes in RK length part
-    short rLen1 = c1.getRowLength();
-    short rLen2 = c2.getRowLength();
-    int commonPrefix = KeyValue.ROW_LENGTH_SIZE;
-    if (rLen1 != rLen2) {
-      // early out when the RK length itself is not matching
-      return ByteBufferUtils.findCommonPrefix(Bytes.toBytes(rLen1), 0, KeyValue.ROW_LENGTH_SIZE,
-          Bytes.toBytes(rLen2), 0, KeyValue.ROW_LENGTH_SIZE);
-    }
-    // Compare the RKs
-    int rkCommonPrefix = 0;
-    if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
-      rkCommonPrefix = ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getRowByteBuffer(),
-        ((ByteBufferCell) c1).getRowPosition(), rLen1, ((ByteBufferCell) c2).getRowByteBuffer(),
-        ((ByteBufferCell) c2).getRowPosition(), rLen2);
-    } else {
-      // There cannot be a case where one cell is BBCell and other is KeyValue. This flow comes either
-      // in flush or compactions. In flushes both cells are KV and in case of compaction it will be either
-      // KV or BBCell
-      rkCommonPrefix = ByteBufferUtils.findCommonPrefix(c1.getRowArray(), c1.getRowOffset(),
-        rLen1, c2.getRowArray(), c2.getRowOffset(), rLen2);
-    }
-    commonPrefix += rkCommonPrefix;
-    if (rkCommonPrefix != rLen1) {
-      // Early out when RK is not fully matching.
-      return commonPrefix;
-    }
-    // Compare 1 byte CF length part
-    byte fLen1 = c1.getFamilyLength();
-    if (bypassFamilyCheck) {
-      // This flag will be true when caller is sure that the family will be same for both the cells
-      // Just make commonPrefix to increment by the family part
-      commonPrefix += KeyValue.FAMILY_LENGTH_SIZE + fLen1;
-    } else {
-      byte fLen2 = c2.getFamilyLength();
-      if (fLen1 != fLen2) {
-        // early out when the CF length itself is not matching
-        return commonPrefix;
-      }
-      // CF lengths are same so there is one more byte common in key part
-      commonPrefix += KeyValue.FAMILY_LENGTH_SIZE;
-      // Compare the CF names
-      int fCommonPrefix;
-      if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
-        fCommonPrefix =
-            ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getFamilyByteBuffer(),
-              ((ByteBufferCell) c1).getFamilyPosition(), fLen1,
-              ((ByteBufferCell) c2).getFamilyByteBuffer(),
-              ((ByteBufferCell) c2).getFamilyPosition(), fLen2);
-      } else {
-        fCommonPrefix = ByteBufferUtils.findCommonPrefix(c1.getFamilyArray(), c1.getFamilyOffset(),
-          fLen1, c2.getFamilyArray(), c2.getFamilyOffset(), fLen2);
-      }
-      commonPrefix += fCommonPrefix;
-      if (fCommonPrefix != fLen1) {
-        return commonPrefix;
-      }
-    }
-    // Compare the Qualifiers
-    int qLen1 = c1.getQualifierLength();
-    int qLen2 = c2.getQualifierLength();
-    int qCommon;
-    if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
-      qCommon = ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getQualifierByteBuffer(),
-        ((ByteBufferCell) c1).getQualifierPosition(), qLen1,
-        ((ByteBufferCell) c2).getQualifierByteBuffer(),
-        ((ByteBufferCell) c2).getQualifierPosition(), qLen2);
-    } else {
-      qCommon = ByteBufferUtils.findCommonPrefix(c1.getQualifierArray(), c1.getQualifierOffset(),
-        qLen1, c2.getQualifierArray(), c2.getQualifierOffset(), qLen2);
-    }
-    commonPrefix += qCommon;
-    if (!withTsType || Math.max(qLen1, qLen2) != qCommon) {
-      return commonPrefix;
-    }
-    // Compare the timestamp parts
-    int tsCommonPrefix = ByteBufferUtils.findCommonPrefix(Bytes.toBytes(c1.getTimestamp()), 0,
-        KeyValue.TIMESTAMP_SIZE, Bytes.toBytes(c2.getTimestamp()), 0, KeyValue.TIMESTAMP_SIZE);
-    commonPrefix += tsCommonPrefix;
-    if (tsCommonPrefix != KeyValue.TIMESTAMP_SIZE) {
-      return commonPrefix;
-    }
-    // Compare the type
-    if (c1.getTypeByte() == c2.getTypeByte()) {
-      commonPrefix += KeyValue.TYPE_SIZE;
-    }
-    return commonPrefix;
-  }
-
-  /** Returns a string representation of the cell */
-  public static String toString(Cell cell, boolean verbose) {
-    if (cell == null) {
-      return "";
-    }
-    StringBuilder builder = new StringBuilder();
-    String keyStr = getCellKeyAsString(cell);
-
-    String tag = null;
-    String value = null;
-    if (verbose) {
-      // TODO: pretty print tags as well
-      if (cell.getTagsLength() > 0) {
-        tag = Bytes.toStringBinary(cell.getTagsArray(), cell.getTagsOffset(), cell.getTagsLength());
-      }
-      if (!(cell instanceof KeyValue.KeyOnlyKeyValue)) {
-        value = Bytes.toStringBinary(cell.getValueArray(), cell.getValueOffset(),
-            cell.getValueLength());
-      }
-    }
-
-    builder
-      .append(keyStr);
-    if (tag != null && !tag.isEmpty()) {
-      builder.append("/").append(tag);
+  /**
+   * Finds if the qualifier part of the cell and the KV serialized byte[] are equal
+   * @param left
+   * @param buf the serialized keyvalue format byte[]
+   * @param offset the offset of the qualifier in the byte[]
+   * @param length the length of the qualifier in the byte[]
+   * @return true if the qualifier matches, false otherwise
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static boolean matchingQualifier(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    if (buf == null) {
+      return left.getQualifierLength() == 0;
     }
-    if (value != null) {
-      builder.append("/").append(value);
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
+        ((ByteBufferCell) left).getQualifierPosition(), left.getQualifierLength(), buf, offset,
+        length);
     }
-
-    return builder.toString();
+    return Bytes.equals(left.getQualifierArray(), left.getQualifierOffset(),
+      left.getQualifierLength(), buf, offset, length);
   }
 
-  /***************** special cases ****************************/
-
-  /**
-   * special case for Cell.equals
-   */
-  public static boolean equalsIgnoreMvccVersion(Cell a, Cell b) {
-    // row
-    boolean res = matchingRow(a, b);
-    if (!res)
-      return res;
-
-    // family
-    res = matchingColumn(a, b);
-    if (!res)
-      return res;
-
-    // timestamp: later sorts first
-    if (!matchingTimestamp(a, b))
-      return false;
-
-    // type
-    int c = (0xff & b.getTypeByte()) - (0xff & a.getTypeByte());
-    if (c != 0)
-      return false;
-    else return true;
+  public static boolean matchingColumn(final Cell left, final byte[] fam, final byte[] qual) {
+    if (!matchingFamily(left, fam)) return false;
+    return matchingQualifier(left, qual);
   }
 
-  /**************** equals ****************************/
-
-  public static boolean equals(Cell a, Cell b) {
-    return matchingRow(a, b) && matchingFamily(a, b) && matchingQualifier(a, b)
-        && matchingTimestamp(a, b) && matchingType(a, b);
+  public static boolean matchingColumn(final Cell left, final byte[] fam, final int foffset,
+      final int flength, final byte[] qual, final int qoffset, final int qlength) {
+    if (!InternalCellUtil.matchingFamily(left, fam, foffset, flength)) return false;
+    return InternalCellUtil.matchingQualifier(left, qual, qoffset, qlength);
   }
 
-  public static boolean matchingTimestamp(Cell a, Cell b) {
-    return CellComparatorImpl.COMPARATOR.compareTimestamps(a.getTimestamp(), b.getTimestamp()) == 0;
+  public static boolean matchingColumn(final Cell left, final Cell right) {
+    if (!matchingFamily(left, right)) return false;
+    return matchingQualifier(left, right);
   }
 
-  public static boolean matchingType(Cell a, Cell b) {
-    return a.getTypeByte() == b.getTypeByte();
+  public static boolean matchingValue(final Cell left, final Cell right) {
+    return InternalCellUtil.matchingValue(left, right, left.getValueLength(),
+      right.getValueLength());
   }
 
   /**
-   * Compares the row of two keyvalues for equality
-   *
    * @param left
    * @param right
-   * @return True if rows match.
+   * @param lvlength
+   * @param rvlength
+   * @return
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public static boolean matchingRows(final Cell left, final Cell right) {
-    short lrowlength = left.getRowLength();
-    short rrowlength = right.getRowLength();
-    if (lrowlength != rrowlength) return false;
+  @Deprecated
+  public static boolean matchingValue(final Cell left, final Cell right, int lvlength,
+      int rvlength) {
     if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
-          ((ByteBufferCell) left).getRowPosition(), lrowlength,
-          ((ByteBufferCell) right).getRowByteBuffer(),
-          ((ByteBufferCell) right).getRowPosition(), rrowlength);
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
+        ((ByteBufferCell) left).getValuePosition(), lvlength,
+        ((ByteBufferCell) right).getValueByteBuffer(), ((ByteBufferCell) right).getValuePosition(),
+        rvlength);
     }
     if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
-          ((ByteBufferCell) left).getRowPosition(), lrowlength, right.getRowArray(),
-          right.getRowOffset(), rrowlength);
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
+        ((ByteBufferCell) left).getValuePosition(), lvlength, right.getValueArray(),
+        right.getValueOffset(), rvlength);
     }
     if (right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) right).getRowByteBuffer(),
-          ((ByteBufferCell) right).getRowPosition(), rrowlength, left.getRowArray(),
-          left.getRowOffset(), lrowlength);
+      return ByteBufferUtils.equals(((ByteBufferCell) right).getValueByteBuffer(),
+        ((ByteBufferCell) right).getValuePosition(), rvlength, left.getValueArray(),
+        left.getValueOffset(), lvlength);
     }
-    return Bytes.equals(left.getRowArray(), left.getRowOffset(), lrowlength,
-        right.getRowArray(), right.getRowOffset(), rrowlength);
+    return Bytes.equals(left.getValueArray(), left.getValueOffset(), lvlength,
+      right.getValueArray(), right.getValueOffset(), rvlength);
   }
 
-  /**
-   * Compares the row and column of two keyvalues for equality
-   *
-   * @param left
-   * @param right
-   * @return True if same row and column.
-   */
-  public static boolean matchingRowColumn(final Cell left, final Cell right) {
-    if ((left.getRowLength() + left.getFamilyLength() + left.getQualifierLength()) != (right
-        .getRowLength() + right.getFamilyLength() + right.getQualifierLength())) {
-      return false;
-    }
-
-    if (!matchingRows(left, right)) {
-      return false;
+  public static boolean matchingValue(final Cell left, final byte[] buf) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getValueByteBuffer(),
+        ((ByteBufferCell) left).getValuePosition(), left.getValueLength(), buf, 0, buf.length) == 0;
     }
-    return matchingColumn(left, right);
+    return Bytes.equals(left.getValueArray(), left.getValueOffset(), left.getValueLength(), buf, 0,
+      buf.length);
   }
 
   /**
-   * Converts the rowkey bytes of the given cell into an int value
-   *
-   * @param cell
-   * @return rowkey as int
+   * @return True if a delete type, a {@link KeyValue.Type#Delete} or a {KeyValue.Type#DeleteFamily}
+   *         or a {@link KeyValue.Type#DeleteColumn} KeyValue type.
    */
-  public static int getRowAsInt(Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return ByteBufferUtils.toInt(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition());
-    }
-    return Bytes.toInt(cell.getRowArray(), cell.getRowOffset());
+  public static boolean isDelete(final Cell cell) {
+    return InternalCellUtil.isDelete(cell.getTypeByte());
   }
 
   /**
-   * Converts the value bytes of the given cell into a long value
-   *
-   * @param cell
-   * @return value as long
+   * @return True if a delete type, a {@link KeyValue.Type#Delete} or a {KeyValue.Type#DeleteFamily}
+   *         or a {@link KeyValue.Type#DeleteColumn} KeyValue type.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public static long getValueAsLong(Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return ByteBufferUtils.toLong(((ByteBufferCell) cell).getValueByteBuffer(),
-          ((ByteBufferCell) cell).getValuePosition());
-    }
-    return Bytes.toLong(cell.getValueArray(), cell.getValueOffset());
+  @Deprecated
+  public static boolean isDelete(final byte type) {
+    return Type.Delete.getCode() <= type && type <= Type.DeleteFamily.getCode();
   }
 
   /**
-   * Converts the value bytes of the given cell into a int value
-   *
-   * @param cell
-   * @return value as int
+   * @return True if this cell is a {@link KeyValue.Type#Delete} type.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public static int getValueAsInt(Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return ByteBufferUtils.toInt(((ByteBufferCell) cell).getValueByteBuffer(),
-          ((ByteBufferCell) cell).getValuePosition());
-    }
-    return Bytes.toInt(cell.getValueArray(), cell.getValueOffset());
+  @Deprecated
+  public static boolean isDeleteType(Cell cell) {
+    return cell.getTypeByte() == Type.Delete.getCode();
   }
 
   /**
-   * Converts the value bytes of the given cell into a double value
-   *
-   * @param cell
-   * @return value as double
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public static double getValueAsDouble(Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return ByteBufferUtils.toDouble(((ByteBufferCell) cell).getValueByteBuffer(),
-          ((ByteBufferCell) cell).getValuePosition());
-    }
-    return Bytes.toDouble(cell.getValueArray(), cell.getValueOffset());
+  @Deprecated
+  public static boolean isDeleteFamily(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteFamily.getCode();
   }
 
   /**
-   * Converts the value bytes of the given cell into a BigDecimal
-   *
-   * @param cell
-   * @return value as BigDecimal
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public static BigDecimal getValueAsBigDecimal(Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return ByteBufferUtils.toBigDecimal(((ByteBufferCell) cell).getValueByteBuffer(),
-          ((ByteBufferCell) cell).getValuePosition(), cell.getValueLength());
-    }
-    return Bytes.toBigDecimal(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
+  @Deprecated
+  public static boolean isDeleteFamilyVersion(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteFamilyVersion.getCode();
   }
 
   /**
-   * Create a Cell that is smaller than all other possible Cells for the given Cell's row.
-   *
-   * @param cell
-   * @return First possible Cell on passed Cell's row.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public static Cell createFirstOnRow(final Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return new FirstOnRowByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength());
-    }
-    return new FirstOnRowCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
+  @Deprecated
+  public static boolean isDeleteColumns(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteColumn.getCode();
   }
 
-  public static Cell createFirstOnRow(final byte [] row, int roffset, short rlength) {
-    return new FirstOnRowCell(row, roffset, rlength);
+  /**
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static boolean isDeleteColumnVersion(final Cell cell) {
+    return cell.getTypeByte() == Type.Delete.getCode();
   }
 
-  public static Cell createFirstOnRow(final byte[] row, final byte[] family, final byte[] col) {
-    return createFirstOnRow(row, 0, (short)row.length,
-        family, 0, (byte)family.length,
-        col, 0, col.length);
+  /**
+   * @return True if this cell is a delete family or column type.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static boolean isDeleteColumnOrFamily(Cell cell) {
+    int t = cell.getTypeByte();
+    return t == Type.DeleteColumn.getCode() || t == Type.DeleteFamily.getCode();
   }
 
-  public static Cell createFirstOnRow(final byte[] row, int roffset, short rlength,
-                                      final byte[] family, int foffset, byte flength,
-                                      final byte[] col, int coffset, int clength) {
-    return new FirstOnRowColCell(row, roffset, rlength,
-        family, foffset, flength,
-        col, coffset, clength);
-  }
+  /**
+   * Estimate based on keyvalue's serialization format in the RPC layer. Note that there is an extra
+   * SIZEOF_INT added to the size here that indicates the actual length of the cell for cases where
+   * cell's are serialized in a contiguous format (For eg in RPCs).
+   * @param cell
+   * @return Estimate of the <code>cell</code> size in bytes plus an extra SIZEOF_INT indicating the
+   *         actual cell length.
+   */
+  public static int estimatedSerializedSizeOf(final Cell cell) {
+    if (cell instanceof ExtendedCell) {
+      return ((ExtendedCell) cell).getSerializedSize(true) + Bytes.SIZEOF_INT;
+    }
 
-  public static Cell createFirstOnRow(final byte[] row) {
-    return createFirstOnRow(row, 0, (short)row.length);
+    return getSumOfCellElementLengths(cell) +
+    // Use the KeyValue's infrastructure size presuming that another implementation would have
+    // same basic cost.
+        KeyValue.ROW_LENGTH_SIZE + KeyValue.FAMILY_LENGTH_SIZE +
+        // Serialization is probably preceded by a length (it is in the KeyValueCodec at least).
+        Bytes.SIZEOF_INT;
   }
 
   /**
-   * @return Cell that is smaller than all other possible Cells for the given Cell's row and passed
-   *         family.
+   * @param cell
+   * @return Sum of the lengths of all the elements in a Cell; does not count in any infrastructure
    */
-  public static Cell createFirstOnRowFamily(Cell cell, byte[] fArray, int foff, int flen) {
-    if (cell instanceof ByteBufferCell) {
-      return new FirstOnRowColByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(), ByteBuffer.wrap(fArray),
-          foff, (byte) flen, HConstants.EMPTY_BYTE_BUFFER, 0, 0);
-    }
-    return new FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(),
-        fArray, foff, (byte) flen, HConstants.EMPTY_BYTE_ARRAY, 0, 0);
+  private static int getSumOfCellElementLengths(final Cell cell) {
+    return getSumOfCellKeyElementLengths(cell) + cell.getValueLength() + cell.getTagsLength();
   }
 
   /**
-   * Create a Cell that is smaller than all other possible Cells for the given Cell's row.
-   * The family length is considered to be 0
    * @param cell
-   * @return First possible Cell on passed Cell's row.
+   * @return Sum of all elements that make up a key; does not include infrastructure, tags or
+   *         values.
    */
-  public static Cell createFirstOnRowCol(final Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return new FirstOnRowColByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
-          HConstants.EMPTY_BYTE_BUFFER, 0, (byte) 0,
-          ((ByteBufferCell) cell).getQualifierByteBuffer(),
-          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
-    }
-    return new FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(),
-        cell.getRowLength(), HConstants.EMPTY_BYTE_ARRAY, 0, (byte)0, cell.getQualifierArray(),
-        cell.getQualifierOffset(), cell.getQualifierLength());
+  private static int getSumOfCellKeyElementLengths(final Cell cell) {
+    return cell.getRowLength() + cell.getFamilyLength() + cell.getQualifierLength()
+        + KeyValue.TIMESTAMP_TYPE_SIZE;
   }
+
   /**
-   * Create a Cell that is smaller than all other possible Cells for the given Cell row's next row.
-   * Makes the next row's rowkey by appending single byte 0x00 to the end of current row key.
-   */
-  public static Cell createFirstOnNextRow(final Cell cell) {
-    byte[] nextRow = new byte[cell.getRowLength() + 1];
-    copyRowTo(cell, nextRow, 0);
-    nextRow[nextRow.length - 1] = 0;// maybe not necessary
-    return new FirstOnRowCell(nextRow, 0, (short) nextRow.length);
+   * Calculates the serialized key size. We always serialize in the KeyValue's serialization format.
+   * @param cell the cell for which the key size has to be calculated.
+   * @return the key size
+   */
+  public static int estimatedSerializedSizeOfKey(final Cell cell) {
+    if (cell instanceof KeyValue) return ((KeyValue) cell).getKeyLength();
+    return cell.getRowLength() + cell.getFamilyLength() + cell.getQualifierLength()
+        + KeyValue.KEY_INFRASTRUCTURE_SIZE;
   }
 
   /**
-   * Create a Cell that is smaller than all other possible Cells for the given Cell's rk:cf and
-   * passed qualifier.
-   *
+   * This is an estimate of the heap space occupied by a cell. When the cell is of type
+   * {@link HeapSize} we call {@link HeapSize#heapSize()} so cell can give a correct value. In other
+   * cases we just consider the bytes occupied by the cell components ie. row, CF, qualifier,
+   * timestamp, type, value and tags.
    * @param cell
-   * @param qArray
-   * @param qoffest
-   * @param qlength
-   * @return Last possible Cell on passed Cell's rk:cf and passed qualifier.
+   * @return estimate of the heap space
    */
-  public static Cell createFirstOnRowCol(final Cell cell, byte[] qArray, int qoffest, int qlength) {
-    if(cell instanceof ByteBufferCell) {
-      return new FirstOnRowColByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
-          ((ByteBufferCell) cell).getFamilyByteBuffer(),
-          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
-          ByteBuffer.wrap(qArray), qoffest, qlength);
+  public static long estimatedHeapSizeOf(final Cell cell) {
+    if (cell instanceof HeapSize) {
+      return ((HeapSize) cell).heapSize();
     }
-    return new FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(),
-        cell.getRowLength(), cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
-        qArray, qoffest, qlength);
+    // TODO: Add sizing of references that hold the row, family, etc., arrays.
+    return estimatedSerializedSizeOf(cell);
   }
 
+  /********************* tags *************************************/
   /**
-   * Creates the first cell with the row/family/qualifier of this cell and the given timestamp.
-   * Uses the "maximum" type that guarantees that the new cell is the lowest possible for this
-   * combination of row, family, qualifier, and timestamp. This cell's own timestamp is ignored.
-   *
-   * @param cell - cell
-   * @param ts
+   * Util method to iterate through the tags
+   * @param tags
+   * @param offset
+   * @param length
+   * @return iterator for the tags
+   * @deprecated As of 2.0.0 and will be removed in 3.0.0 Instead use
+   *             {@link InternalCellUtil#tagsIterator(Cell)}
    */
-  public static Cell createFirstOnRowColTS(Cell cell, long ts) {
-    if(cell instanceof ByteBufferCell) {
-      return new FirstOnRowColTSByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
-          ((ByteBufferCell) cell).getFamilyByteBuffer(),
-          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
-          ((ByteBufferCell) cell).getQualifierByteBuffer(),
-          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength(),
-          ts);
-    }
-    return new FirstOnRowColTSCell(cell.getRowArray(), cell.getRowOffset(),
-        cell.getRowLength(), cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
-        cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength(), ts);
+  @Deprecated
+  public static Iterator<Tag> tagsIterator(final byte[] tags, final int offset, final int length) {
+    return new Iterator<Tag>() {
+      private int pos = offset;
+      private int endOffset = offset + length - 1;
+
+      @Override
+      public boolean hasNext() {
+        return this.pos < endOffset;
+      }
+
+      @Override
+      public Tag next() {
+        if (hasNext()) {
+          int curTagLen = Bytes.readAsInt(tags, this.pos, Tag.TAG_LENGTH_SIZE);
+          Tag tag = new ArrayBackedTag(tags, pos, curTagLen + TAG_LENGTH_SIZE);
+          this.pos += Bytes.SIZEOF_SHORT + curTagLen;
+          return tag;
+        }
+        return null;
+      }
+
+      @Override
+      public void remove() {
+        throw new UnsupportedOperationException();
+      }
+    };
   }
 
   /**
-   * Create a Cell that is larger than all other possible Cells for the given Cell's row.
-   *
-   * @param cell
-   * @return Last possible Cell on passed Cell's row.
+   * @param cell The Cell
+   * @return Tags in the given Cell as a List
+   * @deprecated As of 2.0.0 and will be removed in 3.0.0
    */
-  public static Cell createLastOnRow(final Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return new LastOnRowByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength());
+  @Deprecated
+  public static List<Tag> getTags(Cell cell) {
+    List<Tag> tags = new ArrayList<>();
+    Iterator<Tag> tagsItr = InternalCellUtil.tagsIterator(cell);
+    while (tagsItr.hasNext()) {
+      tags.add(tagsItr.next());
     }
-    return new LastOnRowCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
-  }
-
-  public static Cell createLastOnRow(final byte[] row) {
-    return new LastOnRowCell(row, 0, (short)row.length);
+    return tags;
   }
 
   /**
-   * Create a Cell that is larger than all other possible Cells for the given Cell's rk:cf:q. Used
-   * in creating "fake keys" for the multi-column Bloom filter optimization to skip the row/column
-   * we already know is not in the file.
-   *
-   * @param cell
-   * @return Last possible Cell on passed Cell's rk:cf:q.
+   * Retrieve Cell's first tag, matching the passed in type
+   * @param cell The Cell
+   * @param type Type of the Tag to retrieve
+   * @return null if there is no tag of the passed in tag type
+   * @deprecated As of 2.0.0 and will be removed in HBase-3.0.0
    */
-  public static Cell createLastOnRowCol(final Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return new LastOnRowColByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
-          ((ByteBufferCell) cell).getFamilyByteBuffer(),
-          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
-          ((ByteBufferCell) cell).getQualifierByteBuffer(),
-          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
+  @Deprecated
+  public static Tag getTag(Cell cell, byte type) {
+    boolean bufferBacked = cell instanceof ByteBufferCell;
+    int length = cell.getTagsLength();
+    int offset = bufferBacked ? ((ByteBufferCell) cell).getTagsPosition() : cell.getTagsOffset();
+    int pos = offset;
+    while (pos < offset + length) {
+      int tagLen;
+      if (bufferBacked) {
+        ByteBuffer tagsBuffer = ((ByteBufferCell) cell).getTagsByteBuffer();
+        tagLen = ByteBufferUtils.readAsInt(tagsBuffer, pos, TAG_LENGTH_SIZE);
+        if (ByteBufferUtils.toByte(tagsBuffer, pos + TAG_LENGTH_SIZE) == type) {
+          return new ByteBufferTag(tagsBuffer, pos, tagLen + TAG_LENGTH_SIZE);
+        }
+      } else {
+        tagLen = Bytes.readAsInt(cell.getTagsArray(), pos, TAG_LENGTH_SIZE);
+        if (cell.getTagsArray()[pos + TAG_LENGTH_SIZE] == type) {
+          return new ArrayBackedTag(cell.getTagsArray(), pos, tagLen + TAG_LENGTH_SIZE);
+        }
+      }
+      pos += TAG_LENGTH_SIZE + tagLen;
     }
-    return new LastOnRowColCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(),
-        cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
-        cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());
+    return null;
   }
 
   /**
-   * Create a Delete Family Cell for the specified row and family that would
-   * be smaller than all other possible Delete Family KeyValues that have the
-   * same row and family.
-   * Used for seeking.
-   * @param row - row key (arbitrary byte array)
-   * @param fam - family name
-   * @return First Delete Family possible key on passed <code>row</code>.
+   * Returns true if the first range start1...end1 overlaps with the second range start2...end2,
+   * assuming the byte arrays represent row keys
+   * @deprecated As of 2.0.0 and will be removed in 3.0.0
    */
-  public static Cell createFirstDeleteFamilyCellOnRow(final byte[] row, final byte[] fam) {
-    return new FirstOnRowDeleteFamilyCell(row, fam);
+  @Deprecated
+  public static boolean overlappingKeys(final byte[] start1, final byte[] end1, final byte[] start2,
+      final byte[] end2) {
+    return (end2.length == 0 || start1.length == 0 || Bytes.compareTo(start1, end2) < 0)
+        && (end1.length == 0 || start2.length == 0 || Bytes.compareTo(start2, end1) < 0);
   }
 
   /**
-   * Compresses the tags to the given outputstream using the TagcompressionContext
-   * @param out the outputstream to which the compression should happen
-   * @param cell the cell which has tags
-   * @param tagCompressionContext the TagCompressionContext
-   * @throws IOException can throw IOException if the compression encounters issue
+   * Sets the given seqId to the cell. Marked as audience Private as of 1.2.0. Setting a Cell
+   * sequenceid is an internal implementation detail not for general public use.
+   * @param cell
+   * @param seqId
+   * @throws IOException when the passed cell is not of type {@link SettableSequenceId}
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
    */
-  @InterfaceAudience.Private
-  public static void compressTags(OutputStream out, Cell cell,
-      TagCompressionContext tagCompressionContext) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      tagCompressionContext.compressTags(out, ((ByteBufferCell) cell).getTagsByteBuffer(),
-          ((ByteBufferCell) cell).getTagsPosition(), cell.getTagsLength());
+  @Deprecated
+  public static void setSequenceId(Cell cell, long seqId) throws IOException {
+    if (cell instanceof SettableSequenceId) {
+      ((SettableSequenceId) cell).setSequenceId(seqId);
     } else {
-      tagCompressionContext.compressTags(out, cell.getTagsArray(), cell.getTagsOffset(),
-          cell.getTagsLength());
+      throw new IOException(new UnsupportedOperationException(
+          "Cell is not of type " + SettableSequenceId.class.getName()));
     }
   }
 
-  @InterfaceAudience.Private
-  public static void compressRow(OutputStream out, Cell cell, Dictionary dict) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      Dictionary.write(out, ((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(), dict);
+  /**
+   * Sets the given timestamp to the cell.
+   * @param cell
+   * @param ts
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static void setTimestamp(Cell cell, long ts) throws IOException {
+    if (cell instanceof SettableTimestamp) {
+      ((SettableTimestamp) cell).setTimestamp(ts);
     } else {
-      Dictionary.write(out, cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(), dict);
+      throw new IOException(new UnsupportedOperationException(
+          "Cell is not of type " + SettableTimestamp.class.getName()));
     }
   }
 
-  @InterfaceAudience.Private
-  public static void compressFamily(OutputStream out, Cell cell, Dictionary dict)
-      throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      Dictionary.write(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
-        ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(), dict);
+  /**
+   * Sets the given timestamp to the cell.
+   * @param cell
+   * @param ts buffer containing the timestamp value
+   * @param tsOffset offset to the new timestamp
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static void setTimestamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
+    if (cell instanceof SettableTimestamp) {
+      ((SettableTimestamp) cell).setTimestamp(ts, tsOffset);
     } else {
-      Dictionary.write(out, cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
-        dict);
+      throw new IOException(new UnsupportedOperationException(
+          "Cell is not of type " + SettableTimestamp.class.getName()));
     }
   }
 
-  @InterfaceAudience.Private
-  public static void compressQualifier(OutputStream out, Cell cell, Dictionary dict)
-      throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      Dictionary.write(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength(), dict);
-    } else {
-      Dictionary.write(out, cell.getQualifierArray(), cell.getQualifierOffset(),
-        cell.getQualifierLength(), dict);
+  /**
+   * Sets the given timestamp to the cell iff current timestamp is
+   * {@link HConstants#LATEST_TIMESTAMP}.
+   * @param cell
+   * @param ts
+   * @return True if cell timestamp is modified.
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static boolean updateLatestStamp(Cell cell, long ts) throws IOException {
+    if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP) {
+      InternalCellUtil.setTimestamp(cell, ts);
+      return true;
     }
+    return false;
   }
 
   /**
-   * Compares only the key portion of a cell. It does not include the sequence id/mvcc of the cell
-   * @param left
-   * @param right
-   * @return an int greater than 0 if left &gt; than right lesser than 0 if left &lt; than right
-   *         equal to 0 if left is equal to right
-   */
-  public static final int compareKeyIgnoresMvcc(CellComparator comparator, Cell left, Cell right) {
-    return ((CellComparatorImpl) comparator).compare(left, right, true);
-  }
-
-  /**
-   * Used to compare two cells based on the column hint provided. This is specifically
-   * used when we need to optimize the seeks based on the next indexed key. This is an
-   * advanced usage API specifically needed for some optimizations.
-   * @param nextIndexedCell the next indexed cell
-   * @param currentCell the cell to be compared
-   * @param foff the family offset of the currentCell
-   * @param flen the family length of the currentCell
-   * @param colHint the column hint provided - could be null
-   * @param coff the offset of the column hint if provided, if not offset of the currentCell's
-   * qualifier
-   * @param clen the length of the column hint if provided, if not length of the currentCell's
-   * qualifier
-   * @param ts the timestamp to be seeked
-   * @param type the type to be seeked
-   * @return an int based on the given column hint
-   * TODO : To be moved out of here because this is a special API used in scan
-   * optimization.
-   */
-  // compare a key against row/fam/qual/ts/type
-  @InterfaceAudience.Private
-  public static final int compareKeyBasedOnColHint(CellComparator comparator, Cell nextIndexedCell,
-      Cell currentCell, int foff, int flen, byte[] colHint, int coff, int clen, long ts,
-      byte type) {
-    int compare = comparator.compareRows(nextIndexedCell, currentCell);
-    if (compare != 0) {
-      return compare;
-    }
-    // If the column is not specified, the "minimum" key type appears the
-    // latest in the sorted order, regardless of the timestamp. This is used
-    // for specifying the last key/value in a given row, because there is no
-    // "lexicographically last column" (it would be infinitely long). The
-    // "maximum" key type does not need this behavior.
-    if (nextIndexedCell.getFamilyLength() + nextIndexedCell.getQualifierLength() == 0
-        && nextIndexedCell.getTypeByte() == Type.Minimum.getCode()) {
-      // left is "bigger", i.e. it appears later in the sorted order
-      return 1;
-    }
-    if (flen + clen == 0 && type == Type.Minimum.getCode()) {
-      return -1;
-    }
-
-    compare = comparator.compareFamilies(nextIndexedCell, currentCell);
-    if (compare != 0) {
-      return compare;
-    }
-    if (colHint == null) {
-      compare = comparator.compareQualifiers(nextIndexedCell, currentCell);
-    } else {
-      compare = compareQualifiers(nextIndexedCell, colHint, coff, clen);
-    }
-    if (compare != 0) {
-      return compare;
-    }
-    // Next compare timestamps.
-    compare = comparator.compareTimestamps(nextIndexedCell.getTimestamp(), ts);
-    if (compare != 0) {
-      return compare;
+   * Sets the given timestamp to the cell iff current timestamp is
+   * {@link HConstants#LATEST_TIMESTAMP}.
+   * @param cell
+   * @param ts buffer containing the timestamp value
+   * @param tsOffset offset to the new timestamp
+   * @return True if cell timestamp is modified.
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static boolean updateLatestStamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
+    if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP) {
+      InternalCellUtil.setTimestamp(cell, ts, tsOffset);
+      return true;
     }
-
-    // Compare types. Let the delete types sort ahead of puts; i.e. types
-    // of higher numbers sort before those of lesser numbers. Maximum (255)
-    // appears ahead of everything, and minimum (0) appears after
-    // everything.
-    return (0xff & type) - (0xff & nextIndexedCell.getTypeByte());
+    return false;
   }
 
   /**
-   * Compares the cell's qualifier with the given byte[]
-   * @param left the cell for which the qualifier has to be compared
-   * @param right the byte[] having the qualifier
-   * @param rOffset the offset of the qualifier
-   * @param rLength the length of the qualifier
-   * @return greater than 0 if left cell's qualifier is bigger than byte[], lesser than 0 if left
-   *         cell's qualifier is lesser than byte[] and 0 otherwise
+   * Writes the Cell's key part as it would have serialized in a KeyValue. The format is &lt;2 bytes
+   * rk len&gt;&lt;rk&gt;&lt;1 byte cf len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes
+   * timestamp&gt;&lt;1 byte type&gt;
+   * @param cell
+   * @param out
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   * @throws IOException
    */
-  public final static int compareQualifiers(Cell left, byte[] right, int rOffset, int rLength) {
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getQualifierByteBuffer(),
-          ((ByteBufferCell) left).getQualifierPosition(), left.getQualifierLength(),
-          right, rOffset, rLength);
+  @Deprecated
+  public static void writeFlatKey(Cell cell, DataOutputStream out) throws IOException {
+    short rowLen = cell.getRowLength();
+    byte fLen = cell.getFamilyLength();
+    int qLen = cell.getQualifierLength();
+    // Using just one if/else loop instead of every time checking before writing every
+    // component of cell
+    if (cell instanceof ByteBufferCell) {
+      out.writeShort(rowLen);
+      ByteBufferUtils.copyBufferToStream((DataOutput) out,
+        ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+        rowLen);
+      out.writeByte(fLen);
+      ByteBufferUtils.copyBufferToStream((DataOutput) out,
+        ((ByteBufferCell) cell).getFamilyByteBuffer(), ((ByteBufferCell) cell).getFamilyPosition(),
+        fLen);
+      ByteBufferUtils.copyBufferToStream((DataOutput) out,
+        ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), qLen);
+    } else {
+      out.writeShort(rowLen);
+      out.write(cell.getRowArray(), cell.getRowOffset(), rowLen);
+      out.writeByte(fLen);
+      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), fLen);
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qLen);
     }
-    return Bytes.compareTo(left.getQualifierArray(), left.getQualifierOffset(),
-        left.getQualifierLength(), right, rOffset, rLength);
+    out.writeLong(cell.getTimestamp());
+    out.writeByte(cell.getTypeByte());
   }
 
   /**
-   * Compare cell's row against given comparator
-   * @param cell
-   * @param comparator
-   * @return result comparing cell's row
+   * Writes the row from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param rlength the row length
+   * @throws IOException
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
    */
-  @InterfaceAudience.Private
-  public static int compareRow(Cell cell, ByteArrayComparable comparator) {
+  @Deprecated
+  public static void writeRow(OutputStream out, Cell cell, short rlength) throws IOException {
     if (cell instanceof ByteBufferCell) {
-      return comparator.compareTo(((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength());
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), rlength);
+    } else {
+      out.write(cell.getRowArray(), cell.getRowOffset(), rlength);
     }
-    return comparator.compareTo(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
   }
 
   /**
-   * Compare cell's column family against given comparator
-   * @param cell
-   * @param comparator
-   * @return result comparing cell's column family
+   * Writes the row from the given cell to the output stream excluding the common prefix
+   * @param out The dataoutputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param rlength the row length
+   * @throws IOException
+   * @deprecated As of 2.0. Will be removed in hbase-3.0
    */
-  @InterfaceAudience.Private
-  public static int compareFamily(Cell cell, ByteArrayComparable comparator) {
+  @Deprecated
+  public static void writeRowSkippingBytes(DataOutputStream out, Cell cell, short rlength,
+      int commonPrefix) throws IOException {
     if (cell instanceof ByteBufferCell) {
-      return comparator.compareTo(((ByteBufferCell) cell).getFamilyByteBuffer(),
-        ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength());
+      ByteBufferUtils.copyBufferToStream((DataOutput) out,
+        ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition() + commonPrefix, rlength - commonPrefix);
+    } else {
+      out.write(cell.getRowArray(), cell.getRowOffset() + commonPrefix, rlength - commonPrefix);
     }
-    return comparator.compareTo(cell.getFamilyArray(), cell.getFamilyOffset(),
-      cell.getFamilyLength());
   }
 
   /**
-   * Compare cell's qualifier against given comparator
-   * @param cell
-   * @param comparator
-   * @return result comparing cell's qualifier
+   * Writes the family from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param flength the family length
+   * @throws IOException
+   * @deprecated As of 2.0. Will be removed in hbase-3.0
    */
-  @InterfaceAudience.Private
-  public static int compareQualifier(Cell cell, ByteArrayComparable comparator) {
+  @Deprecated
+  public static void writeFamily(OutputStream out, Cell cell, byte flength) throws IOException {
     if (cell instanceof ByteBufferCell) {
-      return comparator.compareTo(((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), flength);
+    } else {
+      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), flength);
     }
-    return comparator.compareTo(cell.getQualifierArray(), cell.getQualifierOffset(),
-      cell.getQualifierLength());
   }
 
   /**
-   * Compare cell's value against given comparator
-   * @param cell
-   * @param comparator
-   * @return result comparing cell's value
+   * Writes the qualifier from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param qlength the qualifier length
+   * @throws IOException
+   * @deprecated As of 2.0. Will be removed in hbase-3.0
    */
-  @InterfaceAudience.Private
-  public static int compareValue(Cell cell, ByteArrayComparable comparator) {
+  @Deprecated
+  public static void writeQualifier(OutputStream out, Cell cell, int qlength) throws IOException {
     if (cell instanceof ByteBufferCell) {
-      return comparator.compareTo(((ByteBufferCell) cell).getValueByteBuffer(),
-        ((ByteBufferCell) cell).getValuePosition(), cell.getValueLength());
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), qlength);
+    } else {
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qlength);
     }
-    return comparator.compareTo(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
   }
 
   /**
-   * Used when a cell needs to be compared with a key byte[] such as cases of
-   * finding the index from the index block, bloom keys from the bloom blocks
-   * This byte[] is expected to be serialized in the KeyValue serialization format
-   * If the KeyValue (Cell's) serialization format changes this method cannot be used.
-   * @param comparator the cell comparator
-   * @param left the cell to be compared
-   * @param key the serialized key part of a KeyValue
-   * @param offset the offset in the key byte[]
-   * @param length the length of the key byte[]
-   * @return an int greater than 0 if left is greater than right
-   *                lesser than 0 if left is lesser than right
-   *                equal to 0 if left is equal to right
+   * Writes the qualifier from the given cell to the output stream excluding the common prefix
+   * @param out The dataoutputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param qlength the qualifier length
+   * @throws IOException
+   * @deprecated As of 2.0. Will be removed in hbase-3.0 (Probably these type of methods don't need
+   *             depreciation cycle?)
    */
-  @VisibleForTesting
-  public static final int compare(CellComparator comparator, Cell left, byte[] key, int offset,
-      int length) {
-    // row
-    short rrowlength = Bytes.toShort(key, offset);
-    int c = comparator.compareRows(left, key, offset + Bytes.SIZEOF_SHORT, rrowlength);
-    if (c != 0) return c;
-
-    // Compare the rest of the two KVs without making any assumptions about
-    // the common prefix. This function will not compare rows anyway, so we
-    // don't need to tell it that the common prefix includes the row.
-    return compareWithoutRow(comparator, left, key, offset, length, rrowlength);
+  @Deprecated
+  public static void writeQualifierSkippingBytes(DataOutputStream out, Cell cell, int qlength,
+      int commonPrefix) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream((DataOutput) out,
+        ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition() + commonPrefix, qlength - commonPrefix);
+    } else {
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset() + commonPrefix,
+        qlength - commonPrefix);
+    }
   }
 
   /**
-   * Compare columnFamily, qualifier, timestamp, and key type (everything
-   * except the row). This method is used both in the normal comparator and
-   * the "same-prefix" comparator. Note that we are assuming that row portions
-   * of both KVs have already been parsed and found identical, and we don't
-   * validate that assumption here.
-   * @param commonPrefix
-   *          the length of the common prefix of the two key-values being
-   *          compared, including row length and row
-   */
-  private static final int compareWithoutRow(CellComparator comparator, Cell left,
-      byte[] right, int roffset, int rlength, short rowlength) {
-    /***
-     * KeyValue Format and commonLength:
-     * |_keyLen_|_valLen_|_rowLen_|_rowKey_|_famiLen_|_fami_|_Quali_|....
-     * ------------------|-------commonLength--------|--------------
-     */
-    int commonLength = KeyValue.ROW_LENGTH_SIZE + KeyValue.FAMILY_LENGTH_SIZE + rowlength;
-
-    // commonLength + TIMESTAMP_TYPE_SIZE
-    int commonLengthWithTSAndType = KeyValue.TIMESTAMP_TYPE_SIZE + commonLength;
-    // ColumnFamily + Qualifier length.
-    int lcolumnlength = left.getFamilyLength() + left.getQualifierLength();
-    int rcolumnlength = rlength - commonLengthWithTSAndType;
-
-    byte ltype = left.getTypeByte();
-    byte rtype = right[roffset + (rlength - 1)];
-
-    // If the column is not specified, the "minimum" key type appears the
-    // latest in the sorted order, regardless of the timestamp. This is used
-    // for specifying the last key/value in a given row, because there is no
-    // "lexicographically last column" (it would be infinitely long). The
-    // "maximum" key type does not need this behavior.
-    if (lcolumnlength == 0 && ltype == Type.Minimum.getCode()) {
-      // left is "bigger", i.e. it appears later in the sorted order
-      return 1;
-    }
-    if (rcolumnlength == 0 && rtype == Type.Minimum.getCode()) {
-      return -1;
-    }
-
-    int rfamilyoffset = commonLength + roffset;
-
-    // Column family length.
-    int lfamilylength = left.getFamilyLength();
-    int rfamilylength = right[rfamilyoffset - 1];
-    // If left family size is not equal to right family size, we need not
-    // compare the qualifiers.
-    boolean sameFamilySize = (lfamilylength == rfamilylength);
-    if (!sameFamilySize) {
-      // comparing column family is enough.
-      return compareFamilies(left, right, rfamilyoffset, rfamilylength);
-    }
-    // Compare family & qualifier together.
-    // Families are same. Compare on qualifiers.
-    int comparison = compareColumns(left, right, rfamilyoffset, rfamilylength,
-      rfamilyoffset + rfamilylength, (rcolumnlength - rfamilylength));
-    if (comparison != 0) {
-      return comparison;
-    }
-
-    // //
-    // Next compare timestamps.
-    long rtimestamp = Bytes.toLong(right, roffset + (rlength - KeyValue.TIMESTAMP_TYPE_SIZE));
-    int compare = comparator.compareTimestamps(left.getTimestamp(), rtimestamp);
-    if (compare != 0) {
-      return compare;
-    }
-
-    // Compare types. Let the delete types sort ahead of puts; i.e. types
-    // of higher numbers sort before those of lesser numbers. Maximum (255)
-    // appears ahead of everything, and minimum (0) appears after
-    // everything.
-    return (0xff & rtype) - (0xff & ltype);
+   * Writes the value from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param vlength the value length
+   * @throws IOException
+   * @deprecated As of 2.0. Will be removed in hbase-3.0
+   */
+  @Deprecated
+  public static void writeValue(OutputStream out, Cell cell, int vlength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition(), vlength);
+    } else {
+      out.write(cell.getValueArray(), cell.getValueOffset(), vlength);
+    }
   }
 
   /**
-   * Compares the cell's family with the given byte[]
-   * @param left the cell for which the family has to be compared
-   * @param right the byte[] having the family
-   * @param roffset the offset of the family
-   * @param rlength the length of the family
-   * @return greater than 0 if left cell's family is bigger than byte[], lesser than 0 if left
-   *         cell's family is lesser than byte[] and 0 otherwise
+   * Writes the tag from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param tagsLength the tag length
+   * @throws IOException
+   * @deprecated As of hbase-2.0. Will be removed in hbase-3.0
    */
-  public final static int compareFamilies(Cell left, byte[] right, int roffset, int rlength) {
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getFamilyByteBuffer(),
-        ((ByteBufferCell) left).getFamilyPosition(), left.getFamilyLength(), right, roffset,
-        rlength);
+  @Deprecated
+  public static void writeTags(OutputStream out, Cell cell, int tagsLength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getTagsByteBuffer(),
+        ((ByteBufferCell) cell).getTagsPosition(), tagsLength);
+    } else {
+      out.write(cell.getTagsArray(), cell.getTagsOffset(), tagsLength);
     }
-    return Bytes.compareTo(left.getFamilyArray(), left.getFamilyOffset(), left.getFamilyLength(),
-      right, roffset, rlength);
   }
 
   /**
-   * Compares the cell's column (family and qualifier) with the given byte[]
-   * @param left the cell for which the column has to be compared
-   * @param right the byte[] having the column
-   * @param rfoffset the offset of the family
-   * @param rflength the length of the family
-   * @param rqoffset the offset of the qualifier
-   * @param rqlength the length of the qualifier
-   * @return greater than 0 if left cell's column is bigger than byte[], lesser than 0 if left
-   *         cell's column is lesser than byte[] and 0 otherwise
+   * @param cell
+   * @return The Key portion of the passed <code>cell</code> as a String.
    */
-  public final static int compareColumns(Cell left, byte[] right, int rfoffset, int rflength,
-      int rqoffset, int rqlength) {
-    int diff = compareFamilies(left, right, rfoffset, rflength);
-    if (diff != 0) return diff;
-    return compareQualifiers(left, right, rqoffset, rqlength);
+  public static String getCellKeyAsString(Cell cell) {
+    StringBuilder sb = new StringBuilder(
+        Bytes.toStringBinary(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength()));
+    sb.append('/');
+    sb.append(cell.getFamilyLength() == 0 ? ""
+        : Bytes.toStringBinary(cell.getFamilyArray(), cell.getFamilyOffset(),
+          cell.getFamilyLength()));
+    // KeyValue only added ':' if family is non-null. Do same.
+    if (cell.getFamilyLength() > 0) sb.append(':');
+    sb.append(cell.getQualifierLength() == 0 ? ""
+        : Bytes.toStringBinary(cell.getQualifierArray(), cell.getQualifierOffset(),
+          cell.getQualifierLength()));
+    sb.append('/');
+    sb.append(KeyValue.humanReadableTimestamp(cell.getTimestamp()));
+    sb.append('/');
+    sb.append(Type.codeToType(cell.getTypeByte()));
+    if (!(cell instanceof KeyValue.KeyOnlyKeyValue)) {
+      sb.append("/vlen=");
+      sb.append(cell.getValueLength());
+    }
+    sb.append("/seqid=");
+    sb.append(cell.getSequenceId());
+    return sb.toString();
   }
 
-  @InterfaceAudience.Private
   /**
-   * These cells are used in reseeks/seeks to improve the read performance.
-   * They are not real cells that are returned back to the clients
+   * This method exists just to encapsulate how we serialize keys. To be replaced by a factory that
+   * we query to figure what the Cell implementation is and then, what serialization engine to use
+   * and further, how to serialize the key for inclusion in hfile index. TODO.
+   * @param cell
+   * @return The key portion of the Cell serialized in the old-school KeyValue way or null if passed
+   *         a null <code>cell</code>
    */
-  private static abstract class EmptyCell implements Cell, SettableSequenceId {
-
-    @Override
-    public void setSequenceId(long seqId) {
-      // Fake cells don't need seqId, so leaving it as a noop.
-    }
-    @Override
-    public byte[] getRowArray() {
-      return EMPTY_BYTE_ARRAY;
-    }
-
-    @Override
-    public int getRowOffset() {
-      return 0;
-    }
-
-    @Override
-    public short getRowLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getFamilyArray() {
-      return EMPTY_BYTE_ARRAY;
-    }
-
-    @Override
-    public int getFamilyOffset() {
-      return 0;
-    }
-
-    @Override
-    public byte getFamilyLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getQualifierArray() {
-      return EMPTY_BYTE_ARRAY;
-    }
-
-    @Override
-    public int getQualifierOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getQualifierLength() {
-      return 0;
-    }
-
-    @Override
-    public long getSequenceId() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getValueArray() {
-      return EMPTY_BYTE_ARRAY;
-    }
-
-    @Override
-    public int getValueOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getValueLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getTagsArray() {
-      return EMPTY_BYTE_ARRAY;
-    }
-
-    @Override
-    public int getTagsOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getTagsLength() {
-      return 0;
-    }
+  public static byte[] getCellKeySerializedAsKeyValueKey(final Cell cell) {
+    if (cell == null) return null;
+    byte[] b = new byte[KeyValueUtil.keyLength(cell)];
+    KeyValueUtil.appendKeyTo(cell, b, 0);
+    return b;
   }
 
-  @InterfaceAudience.Private
   /**
-   * These cells are used in reseeks/seeks to improve the read performance.
-   * They are not real cells that are returned back to the clients
+   * Write rowkey excluding the common part.
+   * @param cell
+   * @param rLen
+   * @param commonPrefix
+   * @param out
+   * @throws IOException
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
    */
-  private static abstract class EmptyByteBufferCell extends ByteBufferCell
-      implements SettableSequenceId {
-
-    @Override
-    public void setSequenceId(long seqId) {
-      // Fake cells don't need seqId, so leaving it as a noop.
-    }
-
-    @Override
-    public byte[] getRowArray() {
-      return CellUtil.cloneRow(this);
-    }
-
-    @Override
-    public int getRowOffset() {
-      return 0;
-    }
-
-    @Override
-    public short getRowLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getFamilyArray() {
-      return CellUtil.cloneFamily(this);
-    }
-
-    @Override
-    public int getFamilyOffset() {
-      return 0;
-    }
-
-    @Override
-    public byte getFamilyLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getQualifierArray() {
-      return CellUtil.cloneQualifier(this);
-    }
-
-    @Override
-    public int getQualifierOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getQualifierLength() {
-      return 0;
-    }
-
-    @Override
-    public long getSequenceId() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getValueArray() {
-      return CellUtil.cloneValue(this);
-    }
-
-    @Override
-    public int getValueOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getValueLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getTagsArray() {
-      return CellUtil.cloneTags(this);
-    }
-
-    @Override
-    public int getTagsOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getTagsLength() {
-      return 0;
-    }
-
-    @Override
-    public ByteBuffer getRowByteBuffer() {
-      return HConstants.EMPTY_BYTE_BUFFER;
-    }
-
-    @Override
-    public int getRowPosition() {
-      return 0;
-    }
-
-    @Override
-    public ByteBuffer getFamilyByteBuffer() {
-      return HConstants.EMPTY_BYTE_BUFFER;
-    }
-
-    @Override
-    public int getFamilyPosition() {
-      return 0;
-    }
-
-    @Override
-    public ByteBuffer getQualifierByteBuffer() {
-      return HConstants.EMPTY_BYTE_BUFFER;
-    }
-
-    @Override
-    public int getQualifierPosition() {
-      return 0;
-    }
-
-    @Override
-    public ByteBuffer getTagsByteBuffer() {
-      return HConstants.EMPTY_BYTE_BUFFER;
+  @Deprecated
+  public static void writeRowKeyExcludingCommon(Cell cell, short rLen, int commonPrefix,
+      DataOutputStream out) throws IOException {
+    if (commonPrefix == 0) {
+      out.writeShort(rLen);
+    } else if (commonPrefix == 1) {
+      out.writeByte((byte) rLen);
+      commonPrefix--;
+    } else {
+      commonPrefix -= KeyValue.ROW_LENGTH_SIZE;
     }
-
-    @Override
-    public int getTagsPosition() {
-      return 0;
+    if (rLen > commonPrefix) {
+      InternalCellUtil.writeRowSkippingBytes(out, cell, rLen, commonPrefix);
     }
+  }
 
-    @Override
-    public ByteBuffer getValueByteBuffer() {
-      return HConstants.EMPTY_BYTE_BUFFER;
+  /**
+   * Find length of common prefix in keys of the cells, considering key as byte[] if serialized in
+   * {@link KeyValue}. The key format is &lt;2 bytes rk len&gt;&lt;rk&gt;&lt;1 byte cf
+   * len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes timestamp&gt;&lt;1 byte type&gt;
+   * @param c1 the cell
+   * @param c2 the cell
+   * @param bypassFamilyCheck when true assume the family bytes same in both cells. Pass it as true
+   *          when dealing with Cells in same CF so as to avoid some checks
+   * @param withTsType when true check timestamp and type bytes also.
+   * @return length of common prefix
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static int findCommonPrefixInFlatKey(Cell c1, Cell c2, boolean bypassFamilyCheck,
+      boolean withTsType) {
+    // Compare the 2 bytes in RK length part
+    short rLen1 = c1.getRowLength();
+    short rLen2 = c2.getRowLength();
+    int commonPrefix = KeyValue.ROW_LENGTH_SIZE;
+    if (rLen1 != rLen2) {
+      // early out when the RK length itself is not matching
+      return ByteBufferUtils.findCommonPrefix(Bytes.toBytes(rLen1), 0, KeyValue.ROW_LENGTH_SIZE,
+        Bytes.toBytes(rLen2), 0, KeyValue.ROW_LENGTH_SIZE);
     }
-
-    @Override
-    public int getValuePosition() {
-      return 0;
+    // Compare the RKs
+    int rkCommonPrefix = 0;
+    if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
+      rkCommonPrefix = ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getRowByteBuffer(),
+        ((ByteBufferCell) c1).getRowPosition(), rLen1, ((ByteBufferCell) c2).getRowByteBuffer(),
+        ((ByteBufferCell) c2).getRowPosition(), rLen2);
+    } else {
+      // There cannot be a case where one cell is BBCell and other is KeyValue. This flow comes
+      // either
+      // in flush or compactions. In flushes both cells are KV and in case of compaction it will be
+      // either
+      // KV or BBCell
+      rkCommonPrefix = ByteBufferUtils.findCommonPrefix(c1.getRowArray(), c1.getRowOffset(), rLen1,
+        c2.getRowArray(), c2.getRowOffset(), rLen2);
     }
-  }
-
-  @InterfaceAudience.Private
-  private static class FirstOnRowCell extends EmptyCell {
-    private final byte[] rowArray;
-    private final int roffset;
-    private final short rlength;
-
-    public FirstOnRowCell(final byte[] row, int roffset, short rlength) {
-      this.rowArray = row;
-      this.roffset = roffset;
-      this.rlength = rlength;
+    commonPrefix += rkCommonPrefix;
+    if (rkCommonPrefix != rLen1) {
+      // Early out when RK is not fully matching.
+      return commonPrefix;
     }
-
-    @Override
-    public byte[] getRowArray() {
-      return this.rowArray;
+    // Compare 1 byte CF length part
+    byte fLen1 = c1.getFamilyLength();
+    if (bypassFamilyCheck) {
+      // This flag will be true when caller is sure that the family will be same for both the cells
+      // Just make commonPrefix to increment by the family part
+      commonPrefix += KeyValue.FAMILY_LENGTH_SIZE + fLen1;
+    } else {
+      byte fLen2 = c2.getFamilyLength();
+      if (fLen1 != fLen2) {
+        // early out when the CF length itself is not matching
+        return commonPrefix;
+      }
+      // CF lengths are same so there is one more byte common in key part
+      commonPrefix += KeyValue.FAMILY_LENGTH_SIZE;
+      // Compare the CF names
+      int fCommonPrefix;
+      if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
+        fCommonPrefix = ByteBufferUtils.findCommonPrefix(
+          ((ByteBufferCell) c1).getFamilyByteBuffer(), ((ByteBufferCell) c1).getFamilyPosition(),
+          fLen1, ((ByteBufferCell) c2).getFamilyByteBuffer(),
+          ((ByteBufferCell) c2).getFamilyPosition(), fLen2);
+      } else {
+        fCommonPrefix = ByteBufferUtils.findCommonPrefix(c1.getFamilyArray(), c1.getFamilyOffset(),
+          fLen1, c2.getFamilyArray(), c2.getFamilyOffset(), fLen2);
+      }
+      commonPrefix += fCommonPrefix;
+      if (fCommonPrefix != fLen1) {
+        return commonPrefix;
+      }
     }
-
-    @Override
-    public int getRowOffset() {
-      return this.roffset;
+    // Compare the Qualifiers
+    int qLen1 = c1.getQualifierLength();
+    int qLen2 = c2.getQualifierLength();
+    int qCommon;
+    if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
+      qCommon = ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getQualifierByteBuffer(),
+        ((ByteBufferCell) c1).getQualifierPosition(), qLen1,
+        ((ByteBufferCell) c2).getQualifierByteBuffer(),
+        ((ByteBufferCell) c2).getQualifierPosition(), qLen2);
+    } else {
+      qCommon = ByteBufferUtils.findCommonPrefix(c1.getQualifierArray(), c1.getQualifierOffset(),
+        qLen1, c2.getQualifierArray(), c2.getQualifierOffset(), qLen2);
     }
-
-    @Override
-    public short getRowLength() {
-      return this.rlength;
+    commonPrefix += qCommon;
+    if (!withTsType || Math.max(qLen1, qLen2) != qCommon) {
+      return commonPrefix;
     }
-
-    @Override
-    public long getTimestamp() {
-      return HConstants.LATEST_TIMESTAMP;
+    // Compare the timestamp parts
+    int tsCommonPrefix = ByteBufferUtils.findCommonPrefix(Bytes.toBytes(c1.getTimestamp()), 0,
+      KeyValue.TIMESTAMP_SIZE, Bytes.toBytes(c2.getTimestamp()), 0, KeyValue.TIMESTAMP_SIZE);
+    commonPrefix += tsCommonPrefix;
+    if (tsCommonPrefix != KeyValue.TIMESTAMP_SIZE) {
+      return commonPrefix;
     }
-
-    @Override
-    public byte getTypeByte() {
-      return Type.Maximum.getCode();
+    // Compare the type
+    if (c1.getTypeByte() == c2.getTypeByte()) {
+      commonPrefix += KeyValue.TYPE_SIZE;
     }
+    return commonPrefix;
   }
 
-  @InterfaceAudience.Private
-  private static class FirstOnRowByteBufferCell extends EmptyByteBufferCell {
-    private final ByteBuffer rowBuff;
-    private final int roffset;
-    private final short rlength;
-
-    public FirstOnRowByteBufferCell(final ByteBuffer row, int roffset, short rlength) {
-      this.rowBuff = row;
-      this.roffset = roffset;
-      this.rlength = rlength;
-    }
-
-    @Override
-    public ByteBuffer getRowByteBuffer() {
-      return this.rowBuff;
+  /** Returns a string representation of the cell */
+  public static String toString(Cell cell, boolean verbose) {
+    if (cell == null) {
+      return "";
     }
+    StringBuilder builder = new StringBuilder();
+    String keyStr = getCellKeyAsString(cell);
 
-    @Override
-    public int getRowPosition() {
-      return this.roffset;
+    String tag = null;
+    String value = null;
+    if (verbose) {
+      // TODO: pretty print tags as well
+      if (cell.getTagsLength() > 0) {
+        tag = Bytes.toStringBinary(cell.getTagsArray(), cell.getTagsOffset(), cell.getTagsLength());
+      }
+      if (!(cell instanceof KeyValue.KeyOnlyKeyValue)) {
+        value = Bytes.toStringBinary(cell.getValueArray(), cell.getValueOffset(),
+          cell.getValueLength());
+      }
     }
 
-    @Override
-    public short getRowLength() {
-      return this.rlength;
+    builder.append(keyStr);
+    if (tag != null && !tag.isEmpty()) {
+      builder.append("/").append(tag);
     }
-
-    @Override
-    public long getTimestamp() {
-      return HConstants.LATEST_TIMESTAMP;
+    if (value != null) {
+      builder.append("/").append(value);
     }
 
-    @Override
-    public byte getTypeByte() {
-      return Type.Maximum.getCode();
-    }
+    return builder.toString();
   }
 
-  @InterfaceAudience.Private
-  private static class LastOnRowByteBufferCell extends EmptyByteBufferCell {
-    private final ByteBuffer rowBuff;
-    private final int roffset;
-    private final short rlength;
+  /***************** special cases ****************************/
 
-    public LastOnRowByteBufferCell(final ByteBuffer row, int roffset, short rlength) {
-      this.rowBuff = row;
-      this.roffset = roffset;
-      this.rlength = rlength;
-    }
+  /**
+   * special case for Cell.equals
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static boolean equalsIgnoreMvccVersion(Cell a, Cell b) {
+    // row
+    boolean res = matchingRows(a, b);
+    if (!res) return res;
 
-    @Override
-    public ByteBuffer getRowByteBuffer() {
-      return this.rowBuff;
-    }
+    // family
+    res = matchingColumn(a, b);
+    if (!res) return res;
 
-    @Override
-    public int getRowPosition() {
-      return this.roffset;
-    }
+    // timestamp: later sorts first
+    if (!matchingTimestamp(a, b)) return false;
 
-    @Override
-    public short getRowLength() {
-      return this.rlength;
-    }
+    // type
+    int c = (0xff & b.getTypeByte()) - (0xff & a.getTypeByte());
+    if (c != 0) return false;
+    else return true;
+  }
 
-    @Override
-    public long getTimestamp() {
-      return HConstants.OLDEST_TIMESTAMP;
-    }
+  /**************** equals ****************************/
 
-    @Override
-    public byte getTypeByte() {
-      return Type.Minimum.getCode();
-    }
+  public static boolean equals(Cell a, Cell b) {
+    return matchingRows(a, b) && matchingFamily(a, b) && matchingQualifier(a, b)
+        && matchingTimestamp(a, b) && matchingType(a, b);
   }
 
-  @InterfaceAudience.Private
-  private static class FirstOnRowColByteBufferCell extends FirstOnRowByteBufferCell {
-    private final ByteBuffer famBuff;
-    private final int famOffset;
-    private final byte famLength;
-    private final ByteBuffer colBuff;
-    private final int colOffset;
-    private final int colLength;
-
-    public FirstOnRowColByteBufferCell(final ByteBuffer row, int roffset, short rlength,
-        final ByteBuffer famBuff, final int famOffset, final byte famLength, final ByteBuffer col,
-        final int colOffset, final int colLength) {
-      super(row, roffset, rlength);
-      this.famBuff = famBuff;
-      this.famOffset = famOffset;
-      this.famLength = famLength;
-      this.colBuff = col;
-      this.colOffset = colOffset;
-      this.colLength = colLength;
-    }
+  public static boolean matchingTimestamp(Cell a, Cell b) {
+    return CellComparatorImpl.COMPARATOR.compareTimestamps(a.getTimestamp(), b.getTimestamp()) == 0;
+  }
 
-    @Override
-    public ByteBuffer getFamilyByteBuffer() {
-      return this.famBuff;
-    }
+  public static boolean matchingType(Cell a, Cell b) {
+    return a.getTypeByte() == b.getTypeByte();
+  }
 
-    @Override
-    public int getFamilyPosition() {
-      return this.famOffset;
+  /**
+   * Compares the row of two keyvalues for equality
+   * @param left
+   * @param right
+   * @return True if rows match.
+   */
+  public static boolean matchingRows(final Cell left, final Cell right) {
+    short lrowlength = left.getRowLength();
+    short rrowlength = right.getRowLength();
+    if (lrowlength != rrowlength) return false;
+    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
+        ((ByteBufferCell) left).getRowPosition(), lrowlength,
+        ((ByteBufferCell) right).getRowByteBuffer(), ((ByteBufferCell) right).getRowPosition(),
+        rrowlength);
     }
-
-    @Override
-    public byte getFamilyLength() {
-      return famLength;
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
+        ((ByteBufferCell) left).getRowPosition(), lrowlength, right.getRowArray(),
+        right.getRowOffset(), rrowlength);
     }
-
-    @Override
-    public ByteBuffer getQualifierByteBuffer() {
-      return this.colBuff;
+    if (right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) right).getRowByteBuffer(),
+        ((ByteBufferCell) right).getRowPosition(), rrowlength, left.getRowArray(),
+        left.getRowOffset(), lrowlength);
     }
+    return Bytes.equals(left.getRowArray(), left.getRowOffset(), lrowlength, right.getRowArray(),
+      right.getRowOffset(), rrowlength);
+  }
 
-    @Override
-    public int getQualifierPosition() {
-      return this.colOffset;
+  /**
+   * Compares the row and column of two keyvalues for equality
+   * @param left
+   * @param right
+   * @return True if same row and column.
+   */
+  public static boolean matchingRowColumn(final Cell left, final Cell right) {
+    if ((left.getRowLength() + left.getFamilyLength()
+        + left.getQualifierLength()) != (right.getRowLength() + right.getFamilyLength()
+            + right.getQualifierLength())) {
+      return false;
     }
 
-    @Override
-    public int getQualifierLength() {
-      return this.colLength;
+    if (!matchingRows(left, right)) {
+      return false;
     }
+    return matchingColumn(left, right);
   }
 
-  @InterfaceAudience.Private
-  private static class FirstOnRowColCell extends FirstOnRowCell {
-    private final byte[] fArray;
-    private final int foffset;
-    private final byte flength;
-    private final byte[] qArray;
-    private final int qoffset;
-    private final int qlength;
-
-    public FirstOnRowColCell(byte[] rArray, int roffset, short rlength, byte[] fArray,
-        int foffset, byte flength, byte[] qArray, int qoffset, int qlength) {
-      super(rArray, roffset, rlength);
-      this.fArray = fArray;
-      this.foffset = foffset;
-      this.flength = flength;
-      this.qArray = qArray;
-      this.qoffset = qoffset;
-      this.qlength = qlength;
-    }
-
-    @Override
-    public byte[] getFamilyArray() {
-      return this.fArray;
+  /**
+   * Converts the rowkey bytes of the given cell into an int value
+   * @param cell
+   * @return rowkey as int
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static int getRowAsInt(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toInt(((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition());
     }
+    return Bytes.toInt(cell.getRowArray(), cell.getRowOffset());
+  }
 
-    @Override
-    public int getFamilyOffset() {
-      return this.foffset;
+  /**
+   * Converts the value bytes of the given cell into a long value
+   * @param cell
+   * @return value as long
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static long getValueAsLong(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toLong(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition());
     }
+    return Bytes.toLong(cell.getValueArray(), cell.getValueOffset());
+  }
 
-    @Override
-    public byte getFamilyLength() {
-      return this.flength;
+  /**
+   * Converts the value bytes of the given cell into a int value
+   * @param cell
+   * @return value as int
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static int getValueAsInt(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toInt(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition());
     }
+    return Bytes.toInt(cell.getValueArray(), cell.getValueOffset());
+  }
 
-    @Override
-    public byte[] getQualifierArray() {
-      return this.qArray;
+  /**
+   * Converts the value bytes of the given cell into a double value
+   * @param cell
+   * @return value as double
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static double getValueAsDouble(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toDouble(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition());
     }
+    return Bytes.toDouble(cell.getValueArray(), cell.getValueOffset());
+  }
 
-    @Override
-    public int getQualifierOffset() {
-      return this.qoffset;
+  /**
+   * Converts the value bytes of the given cell into a BigDecimal
+   * @param cell
+   * @return value as BigDecimal
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static BigDecimal getValueAsBigDecimal(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toBigDecimal(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition(), cell.getValueLength());
     }
+    return Bytes.toBigDecimal(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
+  }
 
-    @Override
-    public int getQualifierLength() {
-      return this.qlength;
+  /**
+   * Create a Cell that is smaller than all other possible Cells for the given Cell's row.
+   * @param cell
+   * @return First possible Cell on passed Cell's row.
+   */
+  public static Cell createFirstOnRow(final Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return new InternalCellUtil.FirstOnRowByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength());
     }
+    return new InternalCellUtil.FirstOnRowCell(cell.getRowArray(), cell.getRowOffset(),
+        cell.getRowLength());
   }
 
-  @InterfaceAudience.Private
-  private static class FirstOnRowColTSCell extends FirstOnRowColCell {
-
-    private long ts;
-
-    public FirstOnRowColTSCell(byte[] rArray, int roffset, short rlength, byte[] fArray,
-        int foffset, byte flength, byte[] qArray, int qoffset, int qlength, long ts) {
-      super(rArray, roffset, rlength, fArray, foffset, flength, qArray, qoffset, qlength);
-      this.ts = ts;
-    }
+  public static Cell createFirstOnRow(final byte[] row, int roffset, short rlength) {
+    return new InternalCellUtil.FirstOnRowCell(row, roffset, rlength);
+  }
 
-    @Override
-    public long getTimestamp() {
-      return this.ts;
-    }
+  public static Cell createFirstOnRow(final byte[] row, final byte[] family, final byte[] col) {
+    return createFirstOnRow(row, 0, (short) row.length, family, 0, (byte) family.length, col, 0,
+      col.length);
   }
 
-  @InterfaceAudience.Private
-  private static class FirstOnRowColTSByteBufferCell extends FirstOnRowColByteBufferCell {
+  public static Cell createFirstOnRow(final byte[] row, int roffset, short rlength,
+      final byte[] family, int foffset, byte flength, final byte[] col, int coffset, int clength) {
+    return new InternalCellUtil.FirstOnRowColCell(row, roffset, rlength, family, foffset, flength,
+        col, coffset, clength);
+  }
 
-    private long ts;
+  public static Cell createFirstOnRow(final byte[] row) {
+    return createFirstOnRow(row, 0, (short) row.length);
+  }
 
-    public FirstOnRowColTSByteBufferCell(ByteBuffer rBuffer, int roffset, short rlength,
-        ByteBuffer fBuffer, int foffset, byte flength, ByteBuffer qBuffer, int qoffset, int qlength,
-        long ts) {
-      super(rBuffer, roffset, rlength, fBuffer, foffset, flength, qBuffer, qoffset, qlength);
-      this.ts = ts;
+  /**
+   * @return Cell that is smaller than all other possible Cells for the given Cell's row and passed
+   *         family.
+   */
+  public static Cell createFirstOnRowFamily(Cell cell, byte[] fArray, int foff, int flen) {
+    if (cell instanceof ByteBufferCell) {
+      return new InternalCellUtil.FirstOnRowColByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength(), ByteBuffer.wrap(fArray), foff, (byte) flen,
+          HConstants.EMPTY_BYTE_BUFFER, 0, 0);
     }
+    return new InternalCellUtil.FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(),
+        cell.getRowLength(), fArray, foff, (byte) flen, HConstants.EMPTY_BYTE_ARRAY, 0, 0);
+  }
 
-    @Override
-    public long getTimestamp() {
-      return this.ts;
+  /**
+   * Create a Cell that is smaller than all other possible Cells for the given Cell's row. The
+   * family length is considered to be 0
+   * @param cell
+   * @return First possible Cell on passed Cell's row.
+   */
+  public static Cell createFirstOnRowCol(final Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return new InternalCellUtil.FirstOnRowColByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength(), HConstants.EMPTY_BYTE_BUFFER, 0, (byte) 0,
+          ((ByteBufferCell) cell).getQualifierByteBuffer(),
+          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
     }
+    return new InternalCellUtil.FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(),
+        cell.getRowLength(), HConstants.EMPTY_BYTE_ARRAY, 0, (byte) 0, cell.getQualifierArray(),
+        cell.getQualifierOffset(), cell.getQualifierLength());
   }
 
-  @InterfaceAudience.Private
-  private static class LastOnRowCell extends EmptyCell {
-    private final byte[] rowArray;
-    private final int roffset;
-    private final short rlength;
+  /**
+   * Create a Cell that is smaller than all other possible Cells for the given Cell row's next row.
+   * Makes the next row's rowkey by appending single byte 0x00 to the end of current row key.
+   */
+  public static Cell createFirstOnNextRow(final Cell cell) {
+    byte[] nextRow = new byte[cell.getRowLength() + 1];
+    copyRowTo(cell, nextRow, 0);
+    nextRow[nextRow.length - 1] = 0;// maybe not necessary
+    return new InternalCellUtil.FirstOnRowCell(nextRow, 0, (short) nextRow.length);
+  }
 
-    public LastOnRowCell(byte[] row, int roffset, short rlength) {
-      this.rowArray = row;
-      this.roffset = roffset;
-      this.rlength = rlength;
+  /**
+   * Create a Cell that is smaller than all other possible Cells for the given Cell's rk:cf and
+   * passed qualifier.
+   * @param cell
+   * @param qArray
+   * @param qoffest
+   * @param qlength
+   * @return Last possible Cell on passed Cell's rk:cf and passed qualifier.
+   */
+  public static Cell createFirstOnRowCol(final Cell cell, byte[] qArray, int qoffest, int qlength) {
+    if (cell instanceof ByteBufferCell) {
+      return new InternalCellUtil.FirstOnRowColByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength(), ((ByteBufferCell) cell).getFamilyByteBuffer(),
+          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
+          ByteBuffer.wrap(qArray), qoffest, qlength);
     }
+    return new InternalCellUtil.FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(),
+        cell.getRowLength(), cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
+        qArray, qoffest, qlength);
+  }
 
-    @Override
-    public byte[] getRowArray() {
-      return this.rowArray;
+  /**
+   * Creates the first cell with the row/family/qualifier of this cell and the given timestamp. Uses
+   * the "maximum" type that guarantees that the new cell is the lowest possible for this
+   * combination of row, family, qualifier, and timestamp. This cell's own timestamp is ignored.
+   * @param cell - cell
+   * @param ts
+   */
+  public static Cell createFirstOnRowColTS(Cell cell, long ts) {
+    if (cell instanceof ByteBufferCell) {
+      return new InternalCellUtil.FirstOnRowColTSByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength(), ((ByteBufferCell) cell).getFamilyByteBuffer(),
+          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
+          ((ByteBufferCell) cell).getQualifierByteBuffer(),
+          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength(), ts);
     }
+    return new InternalCellUtil.FirstOnRowColTSCell(cell.getRowArray(), cell.getRowOffset(),
+        cell.getRowLength(), cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
+        cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength(), ts);
+  }
 
-    @Override
-    public int getRowOffset() {
-      return this.roffset;
+  /**
+   * Create a Cell that is larger than all other possible Cells for the given Cell's row.
+   * @param cell
+   * @return Last possible Cell on passed Cell's row.
+   */
+  public static Cell createLastOnRow(final Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return new InternalCellUtil.LastOnRowByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength());
     }
+    return new InternalCellUtil.LastOnRowCell(cell.getRowArray(), cell.getRowOffset(),
+        cell.getRowLength());
+  }
 
-    @Override
-    public short getRowLength() {
-      return this.rlength;
-    }
+  public static Cell createLastOnRow(final byte[] row) {
+    return new InternalCellUtil.LastOnRowCell(row, 0, (short) row.length);
+  }
 
-    @Override
-    public long getTimestamp() {
-      return HConstants.OLDEST_TIMESTAMP;
+  /**
+   * Create a Cell that is larger than all other possible Cells for the given Cell's rk:cf:q. Used
+   * in creating "fake keys" for the multi-column Bloom filter optimization to skip the row/column
+   * we already know is not in the file.
+   * @param cell
+   * @return Last possible Cell on passed Cell's rk:cf:q.
+   */
+  public static Cell createLastOnRowCol(final Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return new InternalCellUtil.LastOnRowColByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength(), ((ByteBufferCell) cell).getFamilyByteBuffer(),
+          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
+          ((ByteBufferCell) cell).getQualifierByteBuffer(),
+          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
     }
+    return new InternalCellUtil.LastOnRowColCell(cell.getRowArray(), cell.getRowOffset(),
+        cell.getRowLength(), cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
+        cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());
+  }
 
-    @Override
-    public byte getTypeByte() {
-      return Type.Minimum.getCode();
-    }
+  /**
+   * Create a Delete Family Cell for the specified row and family that would be smaller than all
+   * other possible Delete Family KeyValues that have the same row and family. Used for seeking.
+   * @param row - row key (arbitrary byte array)
+   * @param fam - family name
+   * @return First Delete Family possible key on passed <code>row</code>.
+   */
+  public static Cell createFirstDeleteFamilyCellOnRow(final byte[] row, final byte[] fam) {
+    return new InternalCellUtil.FirstOnRowDeleteFamilyCell(row, fam);
   }
 
+  /**
+   * Compresses the tags to the given outputstream using the TagcompressionContext
+   * @param out the outputstream to which the compression should happen
+   * @param cell the cell which has tags
+   * @param tagCompressionContext the TagCompressionContext
+   * @throws IOException can throw IOException if the compression encounters issue
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
   @InterfaceAudience.Private
-  private static class LastOnRowColCell extends LastOnRowCell {
-    private final byte[] fArray;
-    private final int foffset;
-    private final byte flength;
-    private final byte[] qArray;
-    private final int qoffset;
-    private final int qlength;
-
-    public LastOnRowColCell(byte[] rArray, int roffset, short rlength, byte[] fArray,
-        int foffset, byte flength, byte[] qArray, int qoffset, int qlength) {
-      super(rArray, roffset, rlength);
-      this.fArray = fArray;
-      this.foffset = foffset;
-      this.flength = flength;
-      this.qArray = qArray;
-      this.qoffset = qoffset;
-      this.qlength = qlength;
-    }
-
-    @Override
-    public byte[] getFamilyArray() {
-      return this.fArray;
-    }
-
-    @Override
-    public int getFamilyOffset() {
-      return this.foffset;
-    }
-
-    @Override
-    public byte getFamilyLength() {
-      return this.flength;
-    }
-
-    @Override
-    public byte[] getQualifierArray() {
-      return this.qArray;
-    }
-
-    @Override
-    public int getQualifierOffset() {
-      return this.qoffset;
-    }
-
-    @Override
-    public int getQualifierLength() {
-      return this.qlength;
+  public static void compressTags(OutputStream out, Cell cell,
+      TagCompressionContext tagCompressionContext) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      tagCompressionContext.compressTags(out, ((ByteBufferCell) cell).getTagsByteBuffer(),
+        ((ByteBufferCell) cell).getTagsPosition(), cell.getTagsLength());
+    } else {
+      tagCompressionContext.compressTags(out, cell.getTagsArray(), cell.getTagsOffset(),
+        cell.getTagsLength());
     }
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
   @InterfaceAudience.Private
-  private static class LastOnRowColByteBufferCell extends LastOnRowByteBufferCell {
-    private final ByteBuffer fBuffer;
-    private final int foffset;
-    private final byte flength;
-    private final ByteBuffer qBuffer;
-    private final int qoffset;
-    private final int qlength;
-
-    public LastOnRowColByteBufferCell(ByteBuffer rBuffer, int roffset, short rlength,
-        ByteBuffer fBuffer, int foffset, byte flength, ByteBuffer qBuffer, int qoffset,
-        int qlength) {
-      super(rBuffer, roffset, rlength);
-      this.fBuffer = fBuffer;
-      this.foffset = foffset;
-      this.flength = flength;
-      this.qBuffer = qBuffer;
-      this.qoffset = qoffset;
-      this.qlength = qlength;
-    }
-
-    @Override
-    public ByteBuffer getFamilyByteBuffer() {
-      return this.fBuffer;
-    }
-
-    @Override
-    public int getFamilyPosition() {
-      return this.foffset;
-    }
-
-    @Override
-    public byte getFamilyLength() {
-      return this.flength;
-    }
-
-    @Override
-    public ByteBuffer getQualifierByteBuffer() {
-      return this.qBuffer;
-    }
-
-    @Override
-    public int getQualifierPosition() {
-      return this.qoffset;
-    }
-
-    @Override
-    public int getQualifierLength() {
-      return this.qlength;
+  @Deprecated
+  public static void compressRow(OutputStream out, Cell cell, Dictionary dict) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      Dictionary.write(out, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(), dict);
+    } else {
+      Dictionary.write(out, cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(), dict);
     }
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
   @InterfaceAudience.Private
-  private static class FirstOnRowDeleteFamilyCell extends EmptyCell {
-    private final byte[] row;
-    private final byte[] fam;
-
-    public FirstOnRowDeleteFamilyCell(byte[] row, byte[] fam) {
-      this.row = row;
-      this.fam = fam;
-    }
-
-    @Override
-    public byte[] getRowArray() {
-      return this.row;
-    }
-
-    @Override
-    public short getRowLength() {
-      return (short) this.row.length;
+  @Deprecated
+  public static void compressFamily(OutputStream out, Cell cell, Dictionary dict)
+      throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      Dictionary.write(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(), dict);
+    } else {
+      Dictionary.write(out, cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
+        dict);
     }
+  }
 
-    @Override
-    public byte[] getFamilyArray() {
-      return this.fam;
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @InterfaceAudience.Private
+  @Deprecated
+  public static void compressQualifier(OutputStream out, Cell cell, Dictionary dict)
+      throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      Dictionary.write(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength(), dict);
+    } else {
+      Dictionary.write(out, cell.getQualifierArray(), cell.getQualifierOffset(),
+        cell.getQualifierLength(), dict);
     }
+  }
 
-    @Override
-    public byte getFamilyLength() {
-      return (byte) this.fam.length;
+  /**
+   * Compares the cell's qualifier with the given byte[]
+   * @param left the cell for which the qualifier has to be compared
+   * @param right the byte[] having the qualifier
+   * @param rOffset the offset of the qualifier
+   * @param rLength the length of the qualifier
+   * @return greater than 0 if left cell's qualifier is bigger than byte[], lesser than 0 if left
+   *         cell's qualifier is lesser than byte[] and 0 otherwise
+   */
+  public final static int compareQualifiers(Cell left, byte[] right, int rOffset, int rLength) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getQualifierByteBuffer(),
+        ((ByteBufferCell) left).getQualifierPosition(), left.getQualifierLength(), right, rOffset,
+        rLength);
     }
+    return Bytes.compareTo(left.getQualifierArray(), left.getQualifierOffset(),
+      left.getQualifierLength(), right, rOffset, rLength);
+  }
 
-    @Override
-    public long getTimestamp() {
-      return HConstants.LATEST_TIMESTAMP;
-    }
+  /**
+   * Used when a cell needs to be compared with a key byte[] such as cases of finding the index from
+   * the index block, bloom keys from the bloom blocks This byte[] is expected to be serialized in
+   * the KeyValue serialization format If the KeyValue (Cell's) serialization format changes this
+   * method cannot be used.
+   * @param comparator the cell comparator
+   * @param left the cell to be compared
+   * @param key the serialized key part of a KeyValue
+   * @param offset the offset in the key byte[]
+   * @param length the length of the key byte[]
+   * @return an int greater than 0 if left is greater than right lesser than 0 if left is lesser
+   *         than right equal to 0 if left is equal to right
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @VisibleForTesting
+  @Deprecated
+  public static final int compare(CellComparator comparator, Cell left, byte[] key, int offset,
+      int length) {
+    // row
+    short rrowlength = Bytes.toShort(key, offset);
+    int c = comparator.compareRows(left, key, offset + Bytes.SIZEOF_SHORT, rrowlength);
+    if (c != 0) return c;
 
-    @Override
-    public byte getTypeByte() {
-      return Type.DeleteFamily.getCode();
-    }
+    // Compare the rest of the two KVs without making any assumptions about
+    // the common prefix. This function will not compare rows anyway, so we
+    // don't need to tell it that the common prefix includes the row.
+    return InternalCellUtil.compareWithoutRow(comparator, left, key, offset, length, rrowlength);
   }
 
   /**
-   * @return An new cell is located following input cell. If both of type and timestamp are
-   *         minimum, the input cell will be returned directly.
+   * Compares the cell's family with the given byte[]
+   * @param left the cell for which the family has to be compared
+   * @param right the byte[] having the family
+   * @param roffset the offset of the family
+   * @param rlength the length of the family
+   * @return greater than 0 if left cell's family is bigger than byte[], lesser than 0 if left
+   *         cell's family is lesser than byte[] and 0 otherwise
    */
-  @InterfaceAudience.Private
-  public static Cell createNextOnRowCol(Cell cell) {
-    long ts = cell.getTimestamp();
-    byte type = cell.getTypeByte();
-    if (type != Type.Minimum.getCode()) {
-      type = KeyValue.Type.values()[KeyValue.Type.codeToType(type).ordinal() - 1].getCode();
-    } else if (ts != HConstants.OLDEST_TIMESTAMP) {
-      ts = ts - 1;
-      type = Type.Maximum.getCode();
-    } else {
-      return cell;
+  public final static int compareFamilies(Cell left, byte[] right, int roffset, int rlength) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getFamilyByteBuffer(),
+        ((ByteBufferCell) left).getFamilyPosition(), left.getFamilyLength(), right, roffset,
+        rlength);
     }
-    return createNextOnRowCol(cell, ts, type);
+    return Bytes.compareTo(left.getFamilyArray(), left.getFamilyOffset(), left.getFamilyLength(),
+      right, roffset, rlength);
   }
 
-  private static Cell createNextOnRowCol(Cell cell, long ts, byte type) {
-    if (cell instanceof ByteBufferCell) {
-      return new LastOnRowColByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-              ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
-              ((ByteBufferCell) cell).getFamilyByteBuffer(),
-              ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
-              ((ByteBufferCell) cell).getQualifierByteBuffer(),
-              ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength()) {
-        @Override
-        public long getTimestamp() {
-          return ts;
-        }
-
-        @Override
-        public byte getTypeByte() {
-          return type;
-        }
-      };
-    }
-    return new LastOnRowColCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(),
-            cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
-            cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength()) {
-      @Override
-      public long getTimestamp() {
-        return ts;
-      }
-
-      @Override
-      public byte getTypeByte() {
-        return type;
-      }
-    };
+  /**
+   * Compares the cell's column (family and qualifier) with the given byte[]
+   * @param left the cell for which the column has to be compared
+   * @param right the byte[] having the column
+   * @param rfoffset the offset of the family
+   * @param rflength the length of the family
+   * @param rqoffset the offset of the qualifier
+   * @param rqlength the length of the qualifier
+   * @return greater than 0 if left cell's column is bigger than byte[], lesser than 0 if left
+   *         cell's column is lesser than byte[] and 0 otherwise
+   */
+  public final static int compareColumns(Cell left, byte[] right, int rfoffset, int rflength,
+      int rqoffset, int rqlength) {
+    int diff = compareFamilies(left, right, rfoffset, rflength);
+    if (diff != 0) return diff;
+    return compareQualifiers(left, right, rqoffset, rqlength);
   }
 }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/IndividualBytesFieldCell.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/IndividualBytesFieldCell.java
index 14e35df..e3f30a9 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/IndividualBytesFieldCell.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/IndividualBytesFieldCell.java
@@ -24,7 +24,6 @@ import java.io.IOException;
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 
-import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.util.ArrayUtils;
 import org.apache.hadoop.hbase.util.ByteBufferUtils;
 import org.apache.hadoop.hbase.util.Bytes;
@@ -144,7 +143,7 @@ public class IndividualBytesFieldCell implements ExtendedCell {
     ByteBufferUtils.putInt(out, getValueLength());
 
     // Key
-    CellUtil.writeFlatKey(this, out);
+    InternalCellUtil.writeFlatKey(this, out);
 
     // Value
     out.write(getValueArray());
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/InternalCellUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/InternalCellUtil.java
new file mode 100644
index 0000000..bedfcf1
--- /dev/null
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/InternalCellUtil.java
@@ -0,0 +1,2491 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase;
+
+import static org.apache.hadoop.hbase.HConstants.EMPTY_BYTE_ARRAY;
+import static org.apache.hadoop.hbase.Tag.TAG_LENGTH_SIZE;
+
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue.Type;
+import org.apache.hadoop.hbase.filter.ByteArrayComparable;
+import org.apache.hadoop.hbase.io.TagCompressionContext;
+import org.apache.hadoop.hbase.io.util.Dictionary;
+import org.apache.hadoop.hbase.io.util.StreamUtils;
+import org.apache.hadoop.hbase.util.ByteBufferUtils;
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.ClassSize;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.yetus.audience.InterfaceAudience.Private;
+
+import com.google.common.annotations.VisibleForTesting;
+
+@InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.COPROC)
+public class InternalCellUtil {
+
+  /**
+   * Private constructor to keep this class from being instantiated.
+   */
+  private InternalCellUtil() {
+
+  }
+
+  /******************* ByteRange *******************************/
+
+  public static ByteRange fillRowRange(Cell cell, ByteRange range) {
+    return range.set(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
+  }
+
+  public static ByteRange fillFamilyRange(Cell cell, ByteRange range) {
+    return range.set(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());
+  }
+
+  public static ByteRange fillQualifierRange(Cell cell, ByteRange range) {
+    return range.set(cell.getQualifierArray(), cell.getQualifierOffset(),
+      cell.getQualifierLength());
+  }
+
+  public static ByteRange fillValueRange(Cell cell, ByteRange range) {
+    return range.set(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
+  }
+
+  public static ByteRange fillTagRange(Cell cell, ByteRange range) {
+    return range.set(cell.getTagsArray(), cell.getTagsOffset(), cell.getTagsLength());
+  }
+
+  /**
+   * Returns tag value in a new byte array. If server-side, use {@link Tag#getValueArray()} with
+   * appropriate {@link Tag#getValueOffset()} and {@link Tag#getValueLength()} instead to save on
+   * allocations.
+   * @param cell
+   * @return tag value in a new byte array.
+   */
+  public static byte[] getTagArray(Cell cell) {
+    byte[] output = new byte[cell.getTagsLength()];
+    InternalCellUtil.copyTagTo(cell, output, 0);
+    return output;
+  }
+
+  /**
+   * Copies the tags info into the tag portion of the cell
+   * @param cell
+   * @param destination
+   * @param destinationOffset
+   * @return position after tags
+   */
+  public static int copyTagTo(Cell cell, byte[] destination, int destinationOffset) {
+    int tlen = cell.getTagsLength();
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyFromBufferToArray(destination,
+        ((ByteBufferCell) cell).getTagsByteBuffer(), ((ByteBufferCell) cell).getTagsPosition(),
+        destinationOffset, tlen);
+    } else {
+      System.arraycopy(cell.getTagsArray(), cell.getTagsOffset(), destination, destinationOffset,
+        tlen);
+    }
+    return destinationOffset + tlen;
+  }
+
+  /**
+   * Copies the tags info into the tag portion of the cell
+   * @param cell
+   * @param destination
+   * @param destinationOffset
+   * @return
+   */
+  public static int copyTagTo(Cell cell, ByteBuffer destination, int destinationOffset) {
+    int tlen = cell.getTagsLength();
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getTagsByteBuffer(),
+        destination, ((ByteBufferCell) cell).getTagsPosition(), destinationOffset, tlen);
+    } else {
+      ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset, cell.getTagsArray(),
+        cell.getTagsOffset(), tlen);
+    }
+    return destinationOffset + tlen;
+  }
+
+  /********************* misc *************************************/
+
+  @Private
+  public static byte getRowByte(Cell cell, int index) {
+    if (cell instanceof ByteBufferCell) {
+      return ((ByteBufferCell) cell).getRowByteBuffer()
+          .get(((ByteBufferCell) cell).getRowPosition() + index);
+    }
+    return cell.getRowArray()[cell.getRowOffset() + index];
+  }
+
+  @Private
+  public static byte getQualifierByte(Cell cell, int index) {
+    if (cell instanceof ByteBufferCell) {
+      return ((ByteBufferCell) cell).getQualifierByteBuffer()
+          .get(((ByteBufferCell) cell).getQualifierPosition() + index);
+    }
+    return cell.getQualifierArray()[cell.getQualifierOffset() + index];
+  }
+
+  public static ByteBuffer getValueBufferShallowCopy(Cell cell) {
+    ByteBuffer buffer =
+        ByteBuffer.wrap(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
+    return buffer;
+  }
+
+  /**
+   * @return A new cell which is having the extra tags also added to it.
+   */
+  public static Cell createCell(Cell cell, List<Tag> tags) {
+    return createCell(cell, TagUtil.fromList(tags));
+  }
+
+  /**
+   * @return A new cell which is having the extra tags also added to it.
+   */
+  public static Cell createCell(Cell cell, byte[] tags) {
+    if (cell instanceof ByteBufferCell) {
+      return new TagRewriteByteBufferCell((ByteBufferCell) cell, tags);
+    }
+    return new TagRewriteCell(cell, tags);
+  }
+
+  public static Cell createCell(Cell cell, byte[] value, byte[] tags) {
+    if (cell instanceof ByteBufferCell) {
+      return new ValueAndTagRewriteByteBufferCell((ByteBufferCell) cell, value, tags);
+    }
+    return new ValueAndTagRewriteCell(cell, value, tags);
+  }
+
+  /**
+   * This can be used when a Cell has to change with addition/removal of one or more tags. This is
+   * an efficient way to do so in which only the tags bytes part need to recreated and copied. All
+   * other parts, refer to the original Cell.
+   */
+  static class TagRewriteCell implements ExtendedCell {
+    protected Cell cell;
+    protected byte[] tags;
+    private static final long HEAP_SIZE_OVERHEAD = ClassSize.OBJECT + 2 * ClassSize.REFERENCE;
+
+    /**
+     * @param cell The original Cell which it rewrites
+     * @param tags the tags bytes. The array suppose to contain the tags bytes alone.
+     */
+    public TagRewriteCell(Cell cell, byte[] tags) {
+      assert cell instanceof ExtendedCell;
+      assert tags != null;
+      this.cell = cell;
+      this.tags = tags;
+      // tag offset will be treated as 0 and length this.tags.length
+      if (this.cell instanceof TagRewriteCell) {
+        // Cleaning the ref so that the byte[] can be GCed
+        ((TagRewriteCell) this.cell).tags = null;
+      }
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return cell.getRowArray();
+    }
+
+    @Override
+    public int getRowOffset() {
+      return cell.getRowOffset();
+    }
+
+    @Override
+    public short getRowLength() {
+      return cell.getRowLength();
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return cell.getFamilyArray();
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return cell.getFamilyOffset();
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return cell.getFamilyLength();
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return cell.getQualifierArray();
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return cell.getQualifierOffset();
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return cell.getQualifierLength();
+    }
+
+    @Override
+    public long getTimestamp() {
+      return cell.getTimestamp();
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return cell.getTypeByte();
+    }
+
+    @Override
+    public long getSequenceId() {
+      return cell.getSequenceId();
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return cell.getValueArray();
+    }
+
+    @Override
+    public int getValueOffset() {
+      return cell.getValueOffset();
+    }
+
+    @Override
+    public int getValueLength() {
+      return cell.getValueLength();
+    }
+
+    @Override
+    public byte[] getTagsArray() {
+      return this.tags;
+    }
+
+    @Override
+    public int getTagsOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getTagsLength() {
+      if (null == this.tags) {
+        // Nulled out tags array optimization in constructor
+        return 0;
+      }
+      return this.tags.length;
+    }
+
+    @Override
+    public long heapSize() {
+      long sum = HEAP_SIZE_OVERHEAD + CellUtil.estimatedHeapSizeOf(cell);
+      if (this.tags != null) {
+        sum += ClassSize.sizeOf(this.tags);
+      }
+      return sum;
+    }
+
+    @Override
+    public void setTimestamp(long ts) throws IOException {
+      // The incoming cell is supposed to be SettableTimestamp type.
+      InternalCellUtil.setTimestamp(cell, ts);
+    }
+
+    @Override
+    public void setTimestamp(byte[] ts, int tsOffset) throws IOException {
+      // The incoming cell is supposed to be SettableTimestamp type.
+      InternalCellUtil.setTimestamp(cell, ts, tsOffset);
+    }
+
+    @Override
+    public void setSequenceId(long seqId) throws IOException {
+      // The incoming cell is supposed to be SettableSequenceId type.
+      InternalCellUtil.setSequenceId(cell, seqId);
+    }
+
+    @Override
+    public int write(OutputStream out, boolean withTags) throws IOException {
+      int len = ((ExtendedCell) this.cell).write(out, false);
+      if (withTags && this.tags != null) {
+        // Write the tagsLength 2 bytes
+        out.write((byte) (0xff & (this.tags.length >> 8)));
+        out.write((byte) (0xff & this.tags.length));
+        out.write(this.tags);
+        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
+      }
+      return len;
+    }
+
+    @Override
+    public int getSerializedSize(boolean withTags) {
+      int len = ((ExtendedCell) this.cell).getSerializedSize(false);
+      if (withTags && this.tags != null) {
+        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
+      }
+      return len;
+    }
+
+    @Override
+    public void write(ByteBuffer buf, int offset) {
+      offset = KeyValueUtil.appendTo(this.cell, buf, offset, false);
+      int tagsLen = this.tags == null ? 0 : this.tags.length;
+      if (tagsLen > 0) {
+        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
+        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, this.tags, 0, tagsLen);
+      }
+    }
+
+    @Override
+    public ExtendedCell deepClone() {
+      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
+      return new TagRewriteCell(clonedBaseCell, this.tags);
+    }
+  }
+
+  @InterfaceAudience.Private
+  static class TagRewriteByteBufferCell extends ByteBufferCell implements ExtendedCell {
+
+    protected ByteBufferCell cell;
+    protected byte[] tags;
+    private static final long HEAP_SIZE_OVERHEAD = ClassSize.OBJECT + 2 * ClassSize.REFERENCE;
+
+    /**
+     * @param cell The original ByteBufferCell which it rewrites
+     * @param tags the tags bytes. The array suppose to contain the tags bytes alone.
+     */
+    public TagRewriteByteBufferCell(ByteBufferCell cell, byte[] tags) {
+      assert cell instanceof ExtendedCell;
+      assert tags != null;
+      this.cell = cell;
+      this.tags = tags;
+      // tag offset will be treated as 0 and length this.tags.length
+      if (this.cell instanceof TagRewriteByteBufferCell) {
+        // Cleaning the ref so that the byte[] can be GCed
+        ((TagRewriteByteBufferCell) this.cell).tags = null;
+      }
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return this.cell.getRowArray();
+    }
+
+    @Override
+    public int getRowOffset() {
+      return this.cell.getRowOffset();
+    }
+
+    @Override
+    public short getRowLength() {
+      return this.cell.getRowLength();
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return this.cell.getFamilyArray();
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return this.cell.getFamilyOffset();
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return this.cell.getFamilyLength();
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return this.cell.getQualifierArray();
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return this.cell.getQualifierOffset();
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return this.cell.getQualifierLength();
+    }
+
+    @Override
+    public long getTimestamp() {
+      return this.cell.getTimestamp();
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return this.cell.getTypeByte();
+    }
+
+    @Override
+    public long getSequenceId() {
+      return this.cell.getSequenceId();
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return this.cell.getValueArray();
+    }
+
+    @Override
+    public int getValueOffset() {
+      return this.cell.getValueOffset();
+    }
+
+    @Override
+    public int getValueLength() {
+      return this.cell.getValueLength();
+    }
+
+    @Override
+    public byte[] getTagsArray() {
+      return this.tags;
+    }
+
+    @Override
+    public int getTagsOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getTagsLength() {
+      if (null == this.tags) {
+        // Nulled out tags array optimization in constructor
+        return 0;
+      }
+      return this.tags.length;
+    }
+
+    @Override
+    public void setSequenceId(long seqId) throws IOException {
+      InternalCellUtil.setSequenceId(this.cell, seqId);
+    }
+
+    @Override
+    public void setTimestamp(long ts) throws IOException {
+      InternalCellUtil.setTimestamp(this.cell, ts);
+    }
+
+    @Override
+    public void setTimestamp(byte[] ts, int tsOffset) throws IOException {
+      InternalCellUtil.setTimestamp(this.cell, ts, tsOffset);
+    }
+
+    @Override
+    public long heapSize() {
+      long sum = HEAP_SIZE_OVERHEAD + CellUtil.estimatedHeapSizeOf(cell);
+      // this.tags is on heap byte[]
+      if (this.tags != null) {
+        sum += ClassSize.sizeOf(this.tags);
+      }
+      return sum;
+    }
+
+    @Override
+    public int write(OutputStream out, boolean withTags) throws IOException {
+      int len = ((ExtendedCell) this.cell).write(out, false);
+      if (withTags && this.tags != null) {
+        // Write the tagsLength 2 bytes
+        out.write((byte) (0xff & (this.tags.length >> 8)));
+        out.write((byte) (0xff & this.tags.length));
+        out.write(this.tags);
+        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
+      }
+      return len;
+    }
+
+    @Override
+    public int getSerializedSize(boolean withTags) {
+      int len = ((ExtendedCell) this.cell).getSerializedSize(false);
+      if (withTags && this.tags != null) {
+        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
+      }
+      return len;
+    }
+
+    @Override
+    public void write(ByteBuffer buf, int offset) {
+      offset = KeyValueUtil.appendTo(this.cell, buf, offset, false);
+      int tagsLen = this.tags == null ? 0 : this.tags.length;
+      if (tagsLen > 0) {
+        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
+        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, this.tags, 0, tagsLen);
+      }
+    }
+
+    @Override
+    public ExtendedCell deepClone() {
+      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
+      if (clonedBaseCell instanceof ByteBufferCell) {
+        return new TagRewriteByteBufferCell((ByteBufferCell) clonedBaseCell, this.tags);
+      }
+      return new TagRewriteCell(clonedBaseCell, this.tags);
+    }
+
+    @Override
+    public ByteBuffer getRowByteBuffer() {
+      return this.cell.getRowByteBuffer();
+    }
+
+    @Override
+    public int getRowPosition() {
+      return this.cell.getRowPosition();
+    }
+
+    @Override
+    public ByteBuffer getFamilyByteBuffer() {
+      return this.cell.getFamilyByteBuffer();
+    }
+
+    @Override
+    public int getFamilyPosition() {
+      return this.cell.getFamilyPosition();
+    }
+
+    @Override
+    public ByteBuffer getQualifierByteBuffer() {
+      return this.cell.getQualifierByteBuffer();
+    }
+
+    @Override
+    public int getQualifierPosition() {
+      return this.cell.getQualifierPosition();
+    }
+
+    @Override
+    public ByteBuffer getValueByteBuffer() {
+      return this.cell.getValueByteBuffer();
+    }
+
+    @Override
+    public int getValuePosition() {
+      return this.cell.getValuePosition();
+    }
+
+    @Override
+    public ByteBuffer getTagsByteBuffer() {
+      return this.tags == null ? HConstants.EMPTY_BYTE_BUFFER : ByteBuffer.wrap(this.tags);
+    }
+
+    @Override
+    public int getTagsPosition() {
+      return 0;
+    }
+  }
+
+  static class ValueAndTagRewriteCell extends TagRewriteCell {
+
+    protected byte[] value;
+
+    public ValueAndTagRewriteCell(Cell cell, byte[] value, byte[] tags) {
+      super(cell, tags);
+      this.value = value;
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return this.value;
+    }
+
+    @Override
+    public int getValueOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getValueLength() {
+      return this.value == null ? 0 : this.value.length;
+    }
+
+    @Override
+    public long heapSize() {
+      long sum = ClassSize.REFERENCE + super.heapSize();
+      if (this.value != null) {
+        sum += ClassSize.sizeOf(this.value);
+      }
+      return sum;
+    }
+
+    @Override
+    public int write(OutputStream out, boolean withTags) throws IOException {
+      return write(out, withTags, this.cell, this.value, this.tags);
+    }
+
+    // Made into a static method so as to reuse the logic within ValueAndTagRewriteByteBufferCell
+    static int write(OutputStream out, boolean withTags, Cell cell, byte[] value, byte[] tags)
+        throws IOException {
+      int valLen = value == null ? 0 : value.length;
+      ByteBufferUtils.putInt(out, KeyValueUtil.keyLength(cell));// Key length
+      ByteBufferUtils.putInt(out, valLen);// Value length
+      int len = 2 * Bytes.SIZEOF_INT;
+      len += writeFlatKey(cell, out);// Key
+      if (valLen > 0) out.write(value);// Value
+      len += valLen;
+      if (withTags && tags != null) {
+        // Write the tagsLength 2 bytes
+        out.write((byte) (0xff & (tags.length >> 8)));
+        out.write((byte) (0xff & tags.length));
+        out.write(tags);
+        len += KeyValue.TAGS_LENGTH_SIZE + tags.length;
+      }
+      return len;
+    }
+
+    @Override
+    public int getSerializedSize(boolean withTags) {
+      return super.getSerializedSize(withTags) - this.cell.getValueLength() + this.value.length;
+    }
+
+    @Override
+    public void write(ByteBuffer buf, int offset) {
+      write(buf, offset, this.cell, this.value, this.tags);
+    }
+
+    // Made into a static method so as to reuse the logic within ValueAndTagRewriteByteBufferCell
+    static void write(ByteBuffer buf, int offset, Cell cell, byte[] value, byte[] tags) {
+      offset = ByteBufferUtils.putInt(buf, offset, KeyValueUtil.keyLength(cell));// Key length
+      offset = ByteBufferUtils.putInt(buf, offset, value.length);// Value length
+      offset = KeyValueUtil.appendKeyTo(cell, buf, offset);
+      ByteBufferUtils.copyFromArrayToBuffer(buf, offset, value, 0, value.length);
+      offset += value.length;
+      int tagsLen = tags == null ? 0 : tags.length;
+      if (tagsLen > 0) {
+        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
+        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, tags, 0, tagsLen);
+      }
+    }
+
+    @Override
+    public ExtendedCell deepClone() {
+      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
+      return new ValueAndTagRewriteCell(clonedBaseCell, this.value, this.tags);
+    }
+  }
+
+  static class ValueAndTagRewriteByteBufferCell extends TagRewriteByteBufferCell {
+
+    protected byte[] value;
+
+    public ValueAndTagRewriteByteBufferCell(ByteBufferCell cell, byte[] value, byte[] tags) {
+      super(cell, tags);
+      this.value = value;
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return this.value;
+    }
+
+    @Override
+    public int getValueOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getValueLength() {
+      return this.value == null ? 0 : this.value.length;
+    }
+
+    @Override
+    public ByteBuffer getValueByteBuffer() {
+      return ByteBuffer.wrap(this.value);
+    }
+
+    @Override
+    public int getValuePosition() {
+      return 0;
+    }
+
+    @Override
+    public long heapSize() {
+      long sum = ClassSize.REFERENCE + super.heapSize();
+      if (this.value != null) {
+        sum += ClassSize.sizeOf(this.value);
+      }
+      return sum;
+    }
+
+    @Override
+    public int write(OutputStream out, boolean withTags) throws IOException {
+      return ValueAndTagRewriteCell.write(out, withTags, this.cell, this.value, this.tags);
+    }
+
+    @Override
+    public int getSerializedSize(boolean withTags) {
+      return super.getSerializedSize(withTags) - this.cell.getValueLength() + this.value.length;
+    }
+
+    @Override
+    public void write(ByteBuffer buf, int offset) {
+      ValueAndTagRewriteCell.write(buf, offset, this.cell, this.value, this.tags);
+    }
+
+    @Override
+    public ExtendedCell deepClone() {
+      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
+      if (clonedBaseCell instanceof ByteBufferCell) {
+        return new ValueAndTagRewriteByteBufferCell((ByteBufferCell) clonedBaseCell, this.value,
+            this.tags);
+      }
+      return new ValueAndTagRewriteCell(clonedBaseCell, this.value, this.tags);
+    }
+  }
+
+  public static boolean matchingRow(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
+        ((ByteBufferCell) left).getRowPosition(), left.getRowLength(), buf, offset, length);
+    }
+    return Bytes.equals(left.getRowArray(), left.getRowOffset(), left.getRowLength(), buf, offset,
+      length);
+  }
+
+  public static boolean matchingFamily(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
+        ((ByteBufferCell) left).getFamilyPosition(), left.getFamilyLength(), buf, offset, length);
+    }
+    return Bytes.equals(left.getFamilyArray(), left.getFamilyOffset(), left.getFamilyLength(), buf,
+      offset, length);
+  }
+
+  /**
+   * Finds if the qualifier part of the cell and the KV serialized byte[] are equal
+   * @param left
+   * @param buf the serialized keyvalue format byte[]
+   * @param offset the offset of the qualifier in the byte[]
+   * @param length the length of the qualifier in the byte[]
+   * @return true if the qualifier matches, false otherwise
+   */
+  public static boolean matchingQualifier(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    if (buf == null) {
+      return left.getQualifierLength() == 0;
+    }
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
+        ((ByteBufferCell) left).getQualifierPosition(), left.getQualifierLength(), buf, offset,
+        length);
+    }
+    return Bytes.equals(left.getQualifierArray(), left.getQualifierOffset(),
+      left.getQualifierLength(), buf, offset, length);
+  }
+
+  public static boolean matchingValue(final Cell left, final Cell right, int lvlength,
+      int rvlength) {
+    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
+        ((ByteBufferCell) left).getValuePosition(), lvlength,
+        ((ByteBufferCell) right).getValueByteBuffer(), ((ByteBufferCell) right).getValuePosition(),
+        rvlength);
+    }
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
+        ((ByteBufferCell) left).getValuePosition(), lvlength, right.getValueArray(),
+        right.getValueOffset(), rvlength);
+    }
+    if (right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) right).getValueByteBuffer(),
+        ((ByteBufferCell) right).getValuePosition(), rvlength, left.getValueArray(),
+        left.getValueOffset(), lvlength);
+    }
+    return Bytes.equals(left.getValueArray(), left.getValueOffset(), lvlength,
+      right.getValueArray(), right.getValueOffset(), rvlength);
+  }
+
+  /**
+   * @return True if a delete type, a {@link KeyValue.Type#Delete} or a {KeyValue.Type#DeleteFamily}
+   *         or a {@link KeyValue.Type#DeleteColumn} KeyValue type.
+   */
+  public static boolean isDelete(final byte type) {
+    return Type.Delete.getCode() <= type && type <= Type.DeleteFamily.getCode();
+  }
+
+  /**
+   * @return True if this cell is a {@link KeyValue.Type#Delete} type.
+   */
+  public static boolean isDeleteType(Cell cell) {
+    return cell.getTypeByte() == Type.Delete.getCode();
+  }
+
+  public static boolean isDeleteFamily(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteFamily.getCode();
+  }
+
+  public static boolean isDeleteFamilyVersion(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteFamilyVersion.getCode();
+  }
+
+  public static boolean isDeleteColumns(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteColumn.getCode();
+  }
+
+  public static boolean isDeleteColumnVersion(final Cell cell) {
+    return cell.getTypeByte() == Type.Delete.getCode();
+  }
+
+  /**
+   * @return True if this cell is a delete family or column type.
+   */
+  public static boolean isDeleteColumnOrFamily(Cell cell) {
+    int t = cell.getTypeByte();
+    return t == Type.DeleteColumn.getCode() || t == Type.DeleteFamily.getCode();
+  }
+
+  private static Iterator<Tag> tagsIterator(final ByteBuffer tags, final int offset,
+      final int length) {
+    return new Iterator<Tag>() {
+      private int pos = offset;
+      private int endOffset = offset + length - 1;
+
+      @Override
+      public boolean hasNext() {
+        return this.pos < endOffset;
+      }
+
+      @Override
+      public Tag next() {
+        if (hasNext()) {
+          int curTagLen = ByteBufferUtils.readAsInt(tags, this.pos, Tag.TAG_LENGTH_SIZE);
+          Tag tag = new ByteBufferTag(tags, pos, curTagLen + Tag.TAG_LENGTH_SIZE);
+          this.pos += Bytes.SIZEOF_SHORT + curTagLen;
+          return tag;
+        }
+        return null;
+      }
+
+      @Override
+      public void remove() {
+        throw new UnsupportedOperationException();
+      }
+    };
+  }
+
+  /**
+   * Util method to iterate through the tags in the given cell.
+   * @param cell The Cell over which tags iterator is needed.
+   * @return iterator for the tags
+   */
+  public static Iterator<Tag> tagsIterator(final Cell cell) {
+    final int tagsLength = cell.getTagsLength();
+    // Save an object allocation where we can
+    if (tagsLength == 0) {
+      return TagUtil.EMPTY_TAGS_ITR;
+    }
+    if (cell instanceof ByteBufferCell) {
+      return tagsIterator(((ByteBufferCell) cell).getTagsByteBuffer(),
+        ((ByteBufferCell) cell).getTagsPosition(), tagsLength);
+    }
+    return tagsIterator(cell);
+  }
+
+  /**
+   * @param cell The Cell
+   * @return Tags in the given Cell as a List
+   */
+  public static List<Tag> getTags(Cell cell) {
+    List<Tag> tags = new ArrayList<>();
+    Iterator<Tag> tagsItr = tagsIterator(cell);
+    while (tagsItr.hasNext()) {
+      tags.add(tagsItr.next());
+    }
+    return tags;
+  }
+
+  /**
+   * Retrieve Cell's first tag, matching the passed in type
+   * @param cell The Cell
+   * @param type Type of the Tag to retrieve
+   * @return null if there is no tag of the passed in tag type
+   */
+  public static Tag getTag(Cell cell, byte type) {
+    boolean bufferBacked = cell instanceof ByteBufferCell;
+    int length = cell.getTagsLength();
+    int offset = bufferBacked ? ((ByteBufferCell) cell).getTagsPosition() : cell.getTagsOffset();
+    int pos = offset;
+    while (pos < offset + length) {
+      int tagLen;
+      if (bufferBacked) {
+        ByteBuffer tagsBuffer = ((ByteBufferCell) cell).getTagsByteBuffer();
+        tagLen = ByteBufferUtils.readAsInt(tagsBuffer, pos, TAG_LENGTH_SIZE);
+        if (ByteBufferUtils.toByte(tagsBuffer, pos + TAG_LENGTH_SIZE) == type) {
+          return new ByteBufferTag(tagsBuffer, pos, tagLen + TAG_LENGTH_SIZE);
+        }
+      } else {
+        tagLen = Bytes.readAsInt(cell.getTagsArray(), pos, TAG_LENGTH_SIZE);
+        if (cell.getTagsArray()[pos + TAG_LENGTH_SIZE] == type) {
+          return new ArrayBackedTag(cell.getTagsArray(), pos, tagLen + TAG_LENGTH_SIZE);
+        }
+      }
+      pos += TAG_LENGTH_SIZE + tagLen;
+    }
+    return null;
+  }
+
+  /**
+   * Returns true if the first range start1...end1 overlaps with the second range start2...end2,
+   * assuming the byte arrays represent row keys
+   */
+  public static boolean overlappingKeys(final byte[] start1, final byte[] end1, final byte[] start2,
+      final byte[] end2) {
+    return (end2.length == 0 || start1.length == 0 || Bytes.compareTo(start1, end2) < 0)
+        && (end1.length == 0 || start2.length == 0 || Bytes.compareTo(start2, end1) < 0);
+  }
+
+  /**
+   * Write rowkey excluding the common part.
+   * @param cell
+   * @param rLen
+   * @param commonPrefix
+   * @param out
+   * @throws IOException
+   */
+  public static void writeRowKeyExcludingCommon(Cell cell, short rLen, int commonPrefix,
+      DataOutputStream out) throws IOException {
+    if (commonPrefix == 0) {
+      out.writeShort(rLen);
+    } else if (commonPrefix == 1) {
+      out.writeByte((byte) rLen);
+      commonPrefix--;
+    } else {
+      commonPrefix -= KeyValue.ROW_LENGTH_SIZE;
+    }
+    if (rLen > commonPrefix) {
+      writeRowSkippingBytes(out, cell, rLen, commonPrefix);
+    }
+  }
+
+  /**
+   * Writes the row from the given cell to the output stream excluding the common prefix
+   * @param out The dataoutputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param rlength the row length
+   * @throws IOException
+   */
+  public static void writeRowSkippingBytes(DataOutputStream out, Cell cell, short rlength,
+      int commonPrefix) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream((DataOutput) out,
+        ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition() + commonPrefix, rlength - commonPrefix);
+    } else {
+      out.write(cell.getRowArray(), cell.getRowOffset() + commonPrefix, rlength - commonPrefix);
+    }
+  }
+
+  /**
+   * Find length of common prefix in keys of the cells, considering key as byte[] if serialized in
+   * {@link KeyValue}. The key format is &lt;2 bytes rk len&gt;&lt;rk&gt;&lt;1 byte cf
+   * len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes timestamp&gt;&lt;1 byte type&gt;
+   * @param c1 the cell
+   * @param c2 the cell
+   * @param bypassFamilyCheck when true assume the family bytes same in both cells. Pass it as true
+   *          when dealing with Cells in same CF so as to avoid some checks
+   * @param withTsType when true check timestamp and type bytes also.
+   * @return length of common prefix
+   */
+  public static int findCommonPrefixInFlatKey(Cell c1, Cell c2, boolean bypassFamilyCheck,
+      boolean withTsType) {
+    // Compare the 2 bytes in RK length part
+    short rLen1 = c1.getRowLength();
+    short rLen2 = c2.getRowLength();
+    int commonPrefix = KeyValue.ROW_LENGTH_SIZE;
+    if (rLen1 != rLen2) {
+      // early out when the RK length itself is not matching
+      return ByteBufferUtils.findCommonPrefix(Bytes.toBytes(rLen1), 0, KeyValue.ROW_LENGTH_SIZE,
+        Bytes.toBytes(rLen2), 0, KeyValue.ROW_LENGTH_SIZE);
+    }
+    // Compare the RKs
+    int rkCommonPrefix = 0;
+    if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
+      rkCommonPrefix = ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getRowByteBuffer(),
+        ((ByteBufferCell) c1).getRowPosition(), rLen1, ((ByteBufferCell) c2).getRowByteBuffer(),
+        ((ByteBufferCell) c2).getRowPosition(), rLen2);
+    } else {
+      // There cannot be a case where one cell is BBCell and other is KeyValue. This flow comes
+      // either
+      // in flush or compactions. In flushes both cells are KV and in case of compaction it will be
+      // either
+      // KV or BBCell
+      rkCommonPrefix = ByteBufferUtils.findCommonPrefix(c1.getRowArray(), c1.getRowOffset(), rLen1,
+        c2.getRowArray(), c2.getRowOffset(), rLen2);
+    }
+    commonPrefix += rkCommonPrefix;
+    if (rkCommonPrefix != rLen1) {
+      // Early out when RK is not fully matching.
+      return commonPrefix;
+    }
+    // Compare 1 byte CF length part
+    byte fLen1 = c1.getFamilyLength();
+    if (bypassFamilyCheck) {
+      // This flag will be true when caller is sure that the family will be same for both the cells
+      // Just make commonPrefix to increment by the family part
+      commonPrefix += KeyValue.FAMILY_LENGTH_SIZE + fLen1;
+    } else {
+      byte fLen2 = c2.getFamilyLength();
+      if (fLen1 != fLen2) {
+        // early out when the CF length itself is not matching
+        return commonPrefix;
+      }
+      // CF lengths are same so there is one more byte common in key part
+      commonPrefix += KeyValue.FAMILY_LENGTH_SIZE;
+      // Compare the CF names
+      int fCommonPrefix;
+      if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
+        fCommonPrefix = ByteBufferUtils.findCommonPrefix(
+          ((ByteBufferCell) c1).getFamilyByteBuffer(), ((ByteBufferCell) c1).getFamilyPosition(),
+          fLen1, ((ByteBufferCell) c2).getFamilyByteBuffer(),
+          ((ByteBufferCell) c2).getFamilyPosition(), fLen2);
+      } else {
+        fCommonPrefix = ByteBufferUtils.findCommonPrefix(c1.getFamilyArray(), c1.getFamilyOffset(),
+          fLen1, c2.getFamilyArray(), c2.getFamilyOffset(), fLen2);
+      }
+      commonPrefix += fCommonPrefix;
+      if (fCommonPrefix != fLen1) {
+        return commonPrefix;
+      }
+    }
+    // Compare the Qualifiers
+    int qLen1 = c1.getQualifierLength();
+    int qLen2 = c2.getQualifierLength();
+    int qCommon;
+    if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
+      qCommon = ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getQualifierByteBuffer(),
+        ((ByteBufferCell) c1).getQualifierPosition(), qLen1,
+        ((ByteBufferCell) c2).getQualifierByteBuffer(),
+        ((ByteBufferCell) c2).getQualifierPosition(), qLen2);
+    } else {
+      qCommon = ByteBufferUtils.findCommonPrefix(c1.getQualifierArray(), c1.getQualifierOffset(),
+        qLen1, c2.getQualifierArray(), c2.getQualifierOffset(), qLen2);
+    }
+    commonPrefix += qCommon;
+    if (!withTsType || Math.max(qLen1, qLen2) != qCommon) {
+      return commonPrefix;
+    }
+    // Compare the timestamp parts
+    int tsCommonPrefix = ByteBufferUtils.findCommonPrefix(Bytes.toBytes(c1.getTimestamp()), 0,
+      KeyValue.TIMESTAMP_SIZE, Bytes.toBytes(c2.getTimestamp()), 0, KeyValue.TIMESTAMP_SIZE);
+    commonPrefix += tsCommonPrefix;
+    if (tsCommonPrefix != KeyValue.TIMESTAMP_SIZE) {
+      return commonPrefix;
+    }
+    // Compare the type
+    if (c1.getTypeByte() == c2.getTypeByte()) {
+      commonPrefix += KeyValue.TYPE_SIZE;
+    }
+    return commonPrefix;
+  }
+
+  /**
+   * Used to compare two cells based on the column hint provided. This is specifically used when we
+   * need to optimize the seeks based on the next indexed key. This is an advanced usage API
+   * specifically needed for some optimizations.
+   * @param nextIndexedCell the next indexed cell
+   * @param currentCell the cell to be compared
+   * @param foff the family offset of the currentCell
+   * @param flen the family length of the currentCell
+   * @param colHint the column hint provided - could be null
+   * @param coff the offset of the column hint if provided, if not offset of the currentCell's
+   *          qualifier
+   * @param clen the length of the column hint if provided, if not length of the currentCell's
+   *          qualifier
+   * @param ts the timestamp to be seeked
+   * @param type the type to be seeked
+   * @return an int based on the given column hint TODO : To be moved out of here because this is a
+   *         special API used in scan optimization.
+   */
+  // compare a key against row/fam/qual/ts/type
+  @InterfaceAudience.Private
+  public static final int compareKeyBasedOnColHint(CellComparator comparator, Cell nextIndexedCell,
+      Cell currentCell, int foff, int flen, byte[] colHint, int coff, int clen, long ts,
+      byte type) {
+    int compare = comparator.compareRows(nextIndexedCell, currentCell);
+    if (compare != 0) {
+      return compare;
+    }
+    // If the column is not specified, the "minimum" key type appears the
+    // latest in the sorted order, regardless of the timestamp. This is used
+    // for specifying the last key/value in a given row, because there is no
+    // "lexicographically last column" (it would be infinitely long). The
+    // "maximum" key type does not need this behavior.
+    if (nextIndexedCell.getFamilyLength() + nextIndexedCell.getQualifierLength() == 0
+        && nextIndexedCell.getTypeByte() == Type.Minimum.getCode()) {
+      // left is "bigger", i.e. it appears later in the sorted order
+      return 1;
+    }
+    if (flen + clen == 0 && type == Type.Minimum.getCode()) {
+      return -1;
+    }
+
+    compare = comparator.compareFamilies(nextIndexedCell, currentCell);
+    if (compare != 0) {
+      return compare;
+    }
+    if (colHint == null) {
+      compare = comparator.compareQualifiers(nextIndexedCell, currentCell);
+    } else {
+      compare = CellUtil.compareQualifiers(nextIndexedCell, colHint, coff, clen);
+    }
+    if (compare != 0) {
+      return compare;
+    }
+    // Next compare timestamps.
+    compare = comparator.compareTimestamps(nextIndexedCell.getTimestamp(), ts);
+    if (compare != 0) {
+      return compare;
+    }
+
+    // Compare types. Let the delete types sort ahead of puts; i.e. types
+    // of higher numbers sort before those of lesser numbers. Maximum (255)
+    // appears ahead of everything, and minimum (0) appears after
+    // everything.
+    return (0xff & type) - (0xff & nextIndexedCell.getTypeByte());
+  }
+
+  /**
+   * Compares only the key portion of a cell. It does not include the sequence id/mvcc of the cell
+   * @param left
+   * @param right
+   * @return an int greater than 0 if left &gt; than right lesser than 0 if left &lt; than right
+   *         equal to 0 if left is equal to right
+   */
+  public static final int compareKeyIgnoresMvcc(CellComparator comparator, Cell left, Cell right) {
+    return ((CellComparatorImpl) comparator).compare(left, right, true);
+  }
+
+  /**
+   * Compare cell's row against given comparator
+   * @param cell
+   * @param comparator
+   * @return result comparing cell's row
+   */
+  public static int compareRow(Cell cell, ByteArrayComparable comparator) {
+    if (cell instanceof ByteBufferCell) {
+      return comparator.compareTo(((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength());
+    }
+    return comparator.compareTo(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
+  }
+
+  /**
+   * Compare cell's column family against given comparator
+   * @param cell
+   * @param comparator
+   * @return result comparing cell's column family
+   */
+  public static int compareFamily(Cell cell, ByteArrayComparable comparator) {
+    if (cell instanceof ByteBufferCell) {
+      return comparator.compareTo(((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength());
+    }
+    return comparator.compareTo(cell.getFamilyArray(), cell.getFamilyOffset(),
+      cell.getFamilyLength());
+  }
+
+  /**
+   * Compare cell's qualifier against given comparator
+   * @param cell
+   * @param comparator
+   * @return result comparing cell's qualifier
+   */
+  public static int compareQualifier(Cell cell, ByteArrayComparable comparator) {
+    if (cell instanceof ByteBufferCell) {
+      return comparator.compareTo(((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
+    }
+    return comparator.compareTo(cell.getQualifierArray(), cell.getQualifierOffset(),
+      cell.getQualifierLength());
+  }
+
+  /**
+   * Compare cell's value against given comparator
+   * @param cell
+   * @param comparator
+   * @return result comparing cell's value
+   */
+  public static int compareValue(Cell cell, ByteArrayComparable comparator) {
+    if (cell instanceof ByteBufferCell) {
+      return comparator.compareTo(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition(), cell.getValueLength());
+    }
+    return comparator.compareTo(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
+  }
+
+  /**
+   * These cells are used in reseeks/seeks to improve the read performance. They are not real cells
+   * that are returned back to the clients
+   */
+  private static abstract class EmptyCell implements Cell, SettableSequenceId {
+
+    @Override
+    public void setSequenceId(long seqId) {
+      // Fake cells don't need seqId, so leaving it as a noop.
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return EMPTY_BYTE_ARRAY;
+    }
+
+    @Override
+    public int getRowOffset() {
+      return 0;
+    }
+
+    @Override
+    public short getRowLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return EMPTY_BYTE_ARRAY;
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return 0;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return EMPTY_BYTE_ARRAY;
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return 0;
+    }
+
+    @Override
+    public long getSequenceId() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return EMPTY_BYTE_ARRAY;
+    }
+
+    @Override
+    public int getValueOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getValueLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getTagsArray() {
+      return EMPTY_BYTE_ARRAY;
+    }
+
+    @Override
+    public int getTagsOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getTagsLength() {
+      return 0;
+    }
+  }
+
+  /**
+   * These cells are used in reseeks/seeks to improve the read performance. They are not real cells
+   * that are returned back to the clients
+   */
+  private static abstract class EmptyByteBufferCell extends ByteBufferCell
+      implements SettableSequenceId {
+
+    @Override
+    public void setSequenceId(long seqId) {
+      // Fake cells don't need seqId, so leaving it as a noop.
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return CellUtil.cloneRow(this);
+    }
+
+    @Override
+    public int getRowOffset() {
+      return 0;
+    }
+
+    @Override
+    public short getRowLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return CellUtil.cloneFamily(this);
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return 0;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return CellUtil.cloneQualifier(this);
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return 0;
+    }
+
+    @Override
+    public long getSequenceId() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return CellUtil.cloneValue(this);
+    }
+
+    @Override
+    public int getValueOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getValueLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getTagsArray() {
+      return CellUtil.cloneTags(this);
+    }
+
+    @Override
+    public int getTagsOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getTagsLength() {
+      return 0;
+    }
+
+    @Override
+    public ByteBuffer getRowByteBuffer() {
+      return HConstants.EMPTY_BYTE_BUFFER;
+    }
+
+    @Override
+    public int getRowPosition() {
+      return 0;
+    }
+
+    @Override
+    public ByteBuffer getFamilyByteBuffer() {
+      return HConstants.EMPTY_BYTE_BUFFER;
+    }
+
+    @Override
+    public int getFamilyPosition() {
+      return 0;
+    }
+
+    @Override
+    public ByteBuffer getQualifierByteBuffer() {
+      return HConstants.EMPTY_BYTE_BUFFER;
+    }
+
+    @Override
+    public int getQualifierPosition() {
+      return 0;
+    }
+
+    @Override
+    public ByteBuffer getTagsByteBuffer() {
+      return HConstants.EMPTY_BYTE_BUFFER;
+    }
+
+    @Override
+    public int getTagsPosition() {
+      return 0;
+    }
+
+    @Override
+    public ByteBuffer getValueByteBuffer() {
+      return HConstants.EMPTY_BYTE_BUFFER;
+    }
+
+    @Override
+    public int getValuePosition() {
+      return 0;
+    }
+  }
+
+  static class FirstOnRowCell extends EmptyCell {
+    private final byte[] rowArray;
+    private final int roffset;
+    private final short rlength;
+
+    public FirstOnRowCell(final byte[] row, int roffset, short rlength) {
+      this.rowArray = row;
+      this.roffset = roffset;
+      this.rlength = rlength;
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return this.rowArray;
+    }
+
+    @Override
+    public int getRowOffset() {
+      return this.roffset;
+    }
+
+    @Override
+    public short getRowLength() {
+      return this.rlength;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return HConstants.LATEST_TIMESTAMP;
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return Type.Maximum.getCode();
+    }
+  }
+
+  static class FirstOnRowByteBufferCell extends EmptyByteBufferCell {
+    private final ByteBuffer rowBuff;
+    private final int roffset;
+    private final short rlength;
+
+    public FirstOnRowByteBufferCell(final ByteBuffer row, int roffset, short rlength) {
+      this.rowBuff = row;
+      this.roffset = roffset;
+      this.rlength = rlength;
+    }
+
+    @Override
+    public ByteBuffer getRowByteBuffer() {
+      return this.rowBuff;
+    }
+
+    @Override
+    public int getRowPosition() {
+      return this.roffset;
+    }
+
+    @Override
+    public short getRowLength() {
+      return this.rlength;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return HConstants.LATEST_TIMESTAMP;
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return Type.Maximum.getCode();
+    }
+  }
+
+  static class LastOnRowByteBufferCell extends EmptyByteBufferCell {
+    private final ByteBuffer rowBuff;
+    private final int roffset;
+    private final short rlength;
+
+    public LastOnRowByteBufferCell(final ByteBuffer row, int roffset, short rlength) {
+      this.rowBuff = row;
+      this.roffset = roffset;
+      this.rlength = rlength;
+    }
+
+    @Override
+    public ByteBuffer getRowByteBuffer() {
+      return this.rowBuff;
+    }
+
+    @Override
+    public int getRowPosition() {
+      return this.roffset;
+    }
+
+    @Override
+    public short getRowLength() {
+      return this.rlength;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return HConstants.OLDEST_TIMESTAMP;
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return Type.Minimum.getCode();
+    }
+  }
+
+  static class FirstOnRowColByteBufferCell extends FirstOnRowByteBufferCell {
+    private final ByteBuffer famBuff;
+    private final int famOffset;
+    private final byte famLength;
+    private final ByteBuffer colBuff;
+    private final int colOffset;
+    private final int colLength;
+
+    public FirstOnRowColByteBufferCell(final ByteBuffer row, int roffset, short rlength,
+        final ByteBuffer famBuff, final int famOffset, final byte famLength, final ByteBuffer col,
+        final int colOffset, final int colLength) {
+      super(row, roffset, rlength);
+      this.famBuff = famBuff;
+      this.famOffset = famOffset;
+      this.famLength = famLength;
+      this.colBuff = col;
+      this.colOffset = colOffset;
+      this.colLength = colLength;
+    }
+
+    @Override
+    public ByteBuffer getFamilyByteBuffer() {
+      return this.famBuff;
+    }
+
+    @Override
+    public int getFamilyPosition() {
+      return this.famOffset;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return famLength;
+    }
+
+    @Override
+    public ByteBuffer getQualifierByteBuffer() {
+      return this.colBuff;
+    }
+
+    @Override
+    public int getQualifierPosition() {
+      return this.colOffset;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return this.colLength;
+    }
+  }
+
+  static class FirstOnRowColCell extends FirstOnRowCell {
+    private final byte[] fArray;
+    private final int foffset;
+    private final byte flength;
+    private final byte[] qArray;
+    private final int qoffset;
+    private final int qlength;
+
+    public FirstOnRowColCell(byte[] rArray, int roffset, short rlength, byte[] fArray, int foffset,
+        byte flength, byte[] qArray, int qoffset, int qlength) {
+      super(rArray, roffset, rlength);
+      this.fArray = fArray;
+      this.foffset = foffset;
+      this.flength = flength;
+      this.qArray = qArray;
+      this.qoffset = qoffset;
+      this.qlength = qlength;
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return this.fArray;
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return this.foffset;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return this.flength;
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return this.qArray;
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return this.qoffset;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return this.qlength;
+    }
+  }
+
+  static class FirstOnRowColTSCell extends FirstOnRowColCell {
+
+    private long ts;
+
+    public FirstOnRowColTSCell(byte[] rArray, int roffset, short rlength, byte[] fArray,
+        int foffset, byte flength, byte[] qArray, int qoffset, int qlength, long ts) {
+      super(rArray, roffset, rlength, fArray, foffset, flength, qArray, qoffset, qlength);
+      this.ts = ts;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return this.ts;
+    }
+  }
+
+  static class FirstOnRowColTSByteBufferCell extends FirstOnRowColByteBufferCell {
+
+    private long ts;
+
+    public FirstOnRowColTSByteBufferCell(ByteBuffer rBuffer, int roffset, short rlength,
+        ByteBuffer fBuffer, int foffset, byte flength, ByteBuffer qBuffer, int qoffset, int qlength,
+        long ts) {
+      super(rBuffer, roffset, rlength, fBuffer, foffset, flength, qBuffer, qoffset, qlength);
+      this.ts = ts;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return this.ts;
+    }
+  }
+
+  static class LastOnRowCell extends EmptyCell {
+    private final byte[] rowArray;
+    private final int roffset;
+    private final short rlength;
+
+    public LastOnRowCell(byte[] row, int roffset, short rlength) {
+      this.rowArray = row;
+      this.roffset = roffset;
+      this.rlength = rlength;
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return this.rowArray;
+    }
+
+    @Override
+    public int getRowOffset() {
+      return this.roffset;
+    }
+
+    @Override
+    public short getRowLength() {
+      return this.rlength;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return HConstants.OLDEST_TIMESTAMP;
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return Type.Minimum.getCode();
+    }
+  }
+
+  static class LastOnRowColCell extends LastOnRowCell {
+    private final byte[] fArray;
+    private final int foffset;
+    private final byte flength;
+    private final byte[] qArray;
+    private final int qoffset;
+    private final int qlength;
+
+    public LastOnRowColCell(byte[] rArray, int roffset, short rlength, byte[] fArray, int foffset,
+        byte flength, byte[] qArray, int qoffset, int qlength) {
+      super(rArray, roffset, rlength);
+      this.fArray = fArray;
+      this.foffset = foffset;
+      this.flength = flength;
+      this.qArray = qArray;
+      this.qoffset = qoffset;
+      this.qlength = qlength;
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return this.fArray;
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return this.foffset;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return this.flength;
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return this.qArray;
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return this.qoffset;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return this.qlength;
+    }
+  }
+
+  static class LastOnRowColByteBufferCell extends LastOnRowByteBufferCell {
+    private final ByteBuffer fBuffer;
+    private final int foffset;
+    private final byte flength;
+    private final ByteBuffer qBuffer;
+    private final int qoffset;
+    private final int qlength;
+
+    public LastOnRowColByteBufferCell(ByteBuffer rBuffer, int roffset, short rlength,
+        ByteBuffer fBuffer, int foffset, byte flength, ByteBuffer qBuffer, int qoffset,
+        int qlength) {
+      super(rBuffer, roffset, rlength);
+      this.fBuffer = fBuffer;
+      this.foffset = foffset;
+      this.flength = flength;
+      this.qBuffer = qBuffer;
+      this.qoffset = qoffset;
+      this.qlength = qlength;
+    }
+
+    @Override
+    public ByteBuffer getFamilyByteBuffer() {
+      return this.fBuffer;
+    }
+
+    @Override
+    public int getFamilyPosition() {
+      return this.foffset;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return this.flength;
+    }
+
+    @Override
+    public ByteBuffer getQualifierByteBuffer() {
+      return this.qBuffer;
+    }
+
+    @Override
+    public int getQualifierPosition() {
+      return this.qoffset;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return this.qlength;
+    }
+  }
+
+  static class FirstOnRowDeleteFamilyCell extends EmptyCell {
+    private final byte[] row;
+    private final byte[] fam;
+
+    public FirstOnRowDeleteFamilyCell(byte[] row, byte[] fam) {
+      this.row = row;
+      this.fam = fam;
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return this.row;
+    }
+
+    @Override
+    public short getRowLength() {
+      return (short) this.row.length;
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return this.fam;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return (byte) this.fam.length;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return HConstants.LATEST_TIMESTAMP;
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return Type.DeleteFamily.getCode();
+    }
+  }
+
+  /**
+   * Writes the Cell's key part as it would have serialized in a KeyValue. The format is &lt;2 bytes
+   * rk len&gt;&lt;rk&gt;&lt;1 byte cf len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes
+   * timestamp&gt;&lt;1 byte type&gt;
+   * @param cell
+   * @param out
+   * @throws IOException
+   */
+  public static void writeFlatKey(Cell cell, DataOutput out) throws IOException {
+    short rowLen = cell.getRowLength();
+    byte fLen = cell.getFamilyLength();
+    int qLen = cell.getQualifierLength();
+    // Using just one if/else loop instead of every time checking before writing every
+    // component of cell
+    if (cell instanceof ByteBufferCell) {
+      out.writeShort(rowLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), rowLen);
+      out.writeByte(fLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), fLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), qLen);
+    } else {
+      out.writeShort(rowLen);
+      out.write(cell.getRowArray(), cell.getRowOffset(), rowLen);
+      out.writeByte(fLen);
+      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), fLen);
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qLen);
+    }
+    out.writeLong(cell.getTimestamp());
+    out.writeByte(cell.getTypeByte());
+  }
+
+  /**
+   * Deep clones the given cell if the cell supports deep cloning
+   * @param cell the cell to be cloned
+   * @return the cloned cell
+   * @throws CloneNotSupportedException
+   */
+  public static Cell deepClone(Cell cell) throws CloneNotSupportedException {
+    if (cell instanceof ExtendedCell) {
+      return ((ExtendedCell) cell).deepClone();
+    }
+    throw new CloneNotSupportedException();
+  }
+
+  /**
+   * Writes the cell to the given OutputStream
+   * @param cell the cell to be written
+   * @param out the outputstream
+   * @param withTags if tags are to be written or not
+   * @return the total bytes written
+   * @throws IOException
+   */
+  public static int writeCell(Cell cell, OutputStream out, boolean withTags) throws IOException {
+    if (cell instanceof ExtendedCell) {
+      return ((ExtendedCell) cell).write(out, withTags);
+    } else {
+      ByteBufferUtils.putInt(out, CellUtil.estimatedSerializedSizeOfKey(cell));
+      ByteBufferUtils.putInt(out, cell.getValueLength());
+      writeFlatKey(cell, out);
+      writeValue(out, cell, cell.getValueLength());
+      int tagsLength = cell.getTagsLength();
+      if (withTags) {
+        byte[] len = new byte[Bytes.SIZEOF_SHORT];
+        Bytes.putAsShort(len, 0, tagsLength);
+        out.write(len);
+        if (tagsLength > 0) {
+          writeTags(out, cell, tagsLength);
+        }
+      }
+      int lenWritten = (2 * Bytes.SIZEOF_INT) + CellUtil.estimatedSerializedSizeOfKey(cell)
+          + cell.getValueLength();
+      if (withTags) {
+        lenWritten += Bytes.SIZEOF_SHORT + tagsLength;
+      }
+      return lenWritten;
+    }
+  }
+
+  /**
+   * Writes a cell to the buffer at the given offset
+   * @param cell the cell to be written
+   * @param buf the buffer to which the cell has to be wrriten
+   * @param offset the offset at which the cell should be written
+   */
+  public static void writeCellToBuffer(Cell cell, ByteBuffer buf, int offset) {
+    if (cell instanceof ExtendedCell) {
+      ((ExtendedCell) cell).write(buf, offset);
+    } else {
+      // Using the KVUtil
+      byte[] bytes = KeyValueUtil.copyToNewByteArray(cell);
+      ByteBufferUtils.copyFromArrayToBuffer(buf, offset, bytes, 0, bytes.length);
+    }
+  }
+
+  public static int writeFlatKey(Cell cell, OutputStream out) throws IOException {
+    short rowLen = cell.getRowLength();
+    byte fLen = cell.getFamilyLength();
+    int qLen = cell.getQualifierLength();
+    // Using just one if/else loop instead of every time checking before writing every
+    // component of cell
+    if (cell instanceof ByteBufferCell) {
+      StreamUtils.writeShort(out, rowLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), rowLen);
+      out.write(fLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), fLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), qLen);
+    } else {
+      StreamUtils.writeShort(out, rowLen);
+      out.write(cell.getRowArray(), cell.getRowOffset(), rowLen);
+      out.write(fLen);
+      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), fLen);
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qLen);
+    }
+    StreamUtils.writeLong(out, cell.getTimestamp());
+    out.write(cell.getTypeByte());
+    return Bytes.SIZEOF_SHORT + rowLen + Bytes.SIZEOF_BYTE + fLen + qLen + Bytes.SIZEOF_LONG
+        + Bytes.SIZEOF_BYTE;
+  }
+
+  /**
+   * Sets the given seqId to the cell. Marked as audience Private as of 1.2.0. Setting a Cell
+   * sequenceid is an internal implementation detail not for general public use.
+   * @param cell
+   * @param seqId
+   * @throws IOException when the passed cell is not of type {@link SettableSequenceId}
+   */
+  public static void setSequenceId(Cell cell, long seqId) throws IOException {
+    if (cell instanceof SettableSequenceId) {
+      ((SettableSequenceId) cell).setSequenceId(seqId);
+    } else {
+      throw new IOException(new UnsupportedOperationException(
+          "Cell is not of type " + SettableSequenceId.class.getName()));
+    }
+  }
+
+  /**
+   * Sets the given timestamp to the cell.
+   * @param cell
+   * @param ts
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   */
+  public static void setTimestamp(Cell cell, long ts) throws IOException {
+    if (cell instanceof SettableTimestamp) {
+      ((SettableTimestamp) cell).setTimestamp(ts);
+    } else {
+      throw new IOException(new UnsupportedOperationException(
+          "Cell is not of type " + SettableTimestamp.class.getName()));
+    }
+  }
+
+  /**
+   * Sets the given timestamp to the cell.
+   * @param cell
+   * @param ts buffer containing the timestamp value
+   * @param tsOffset offset to the new timestamp
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   */
+  public static void setTimestamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
+    if (cell instanceof SettableTimestamp) {
+      ((SettableTimestamp) cell).setTimestamp(ts, tsOffset);
+    } else {
+      throw new IOException(new UnsupportedOperationException(
+          "Cell is not of type " + SettableTimestamp.class.getName()));
+    }
+  }
+
+  /**
+   * Sets the given timestamp to the cell iff current timestamp is
+   * {@link HConstants#LATEST_TIMESTAMP}.
+   * @param cell
+   * @param ts
+   * @return True if cell timestamp is modified.
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   */
+  public static boolean updateLatestStamp(Cell cell, long ts) throws IOException {
+    if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP) {
+      InternalCellUtil.setTimestamp(cell, ts);
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Sets the given timestamp to the cell iff current timestamp is
+   * {@link HConstants#LATEST_TIMESTAMP}.
+   * @param cell
+   * @param ts buffer containing the timestamp value
+   * @param tsOffset offset to the new timestamp
+   * @return True if cell timestamp is modified.
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   */
+  public static boolean updateLatestStamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
+    if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP) {
+      InternalCellUtil.setTimestamp(cell, ts, tsOffset);
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Writes the row from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param rlength the row length
+   * @throws IOException
+   */
+  public static void writeRow(OutputStream out, Cell cell, short rlength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), rlength);
+    } else {
+      out.write(cell.getRowArray(), cell.getRowOffset(), rlength);
+    }
+  }
+
+  /**
+   * Writes the family from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param flength the family length
+   * @throws IOException
+   */
+  public static void writeFamily(OutputStream out, Cell cell, byte flength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), flength);
+    } else {
+      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), flength);
+    }
+  }
+
+  /**
+   * Writes the qualifier from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param qlength the qualifier length
+   * @throws IOException
+   */
+  public static void writeQualifier(OutputStream out, Cell cell, int qlength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), qlength);
+    } else {
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qlength);
+    }
+  }
+
+  /**
+   * Writes the qualifier from the given cell to the output stream excluding the common prefix
+   * @param out The dataoutputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param qlength the qualifier length
+   * @throws IOException
+   */
+  public static void writeQualifierSkippingBytes(DataOutputStream out, Cell cell, int qlength,
+      int commonPrefix) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream((DataOutput) out,
+        ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition() + commonPrefix, qlength - commonPrefix);
+    } else {
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset() + commonPrefix,
+        qlength - commonPrefix);
+    }
+  }
+
+  /**
+   * Writes the value from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param vlength the value length
+   * @throws IOException
+   */
+  public static void writeValue(OutputStream out, Cell cell, int vlength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition(), vlength);
+    } else {
+      out.write(cell.getValueArray(), cell.getValueOffset(), vlength);
+    }
+  }
+
+  /**
+   * Writes the tag from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param tagsLength the tag length
+   * @throws IOException
+   */
+  public static void writeTags(OutputStream out, Cell cell, int tagsLength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getTagsByteBuffer(),
+        ((ByteBufferCell) cell).getTagsPosition(), tagsLength);
+    } else {
+      out.write(cell.getTagsArray(), cell.getTagsOffset(), tagsLength);
+    }
+  }
+
+  /**
+   * special case for Cell.equals
+   */
+  public static boolean equalsIgnoreMvccVersion(Cell a, Cell b) {
+    // row
+    boolean res = CellUtil.matchingRows(a, b);
+    if (!res) return res;
+
+    // family
+    res = CellUtil.matchingColumn(a, b);
+    if (!res) return res;
+
+    // timestamp: later sorts first
+    if (!CellUtil.matchingTimestamp(a, b)) return false;
+
+    // type
+    int c = (0xff & b.getTypeByte()) - (0xff & a.getTypeByte());
+    if (c != 0) return false;
+    else return true;
+  }
+
+  /**
+   * Converts the rowkey bytes of the given cell into an int value
+   * @param cell
+   * @return rowkey as int
+   */
+  public static int getRowAsInt(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toInt(((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition());
+    }
+    return Bytes.toInt(cell.getRowArray(), cell.getRowOffset());
+  }
+
+  /**
+   * Converts the value bytes of the given cell into a long value
+   * @param cell
+   * @return value as long
+   */
+  public static long getValueAsLong(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toLong(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition());
+    }
+    return Bytes.toLong(cell.getValueArray(), cell.getValueOffset());
+  }
+
+  /**
+   * Converts the value bytes of the given cell into a int value
+   * @param cell
+   * @return value as int
+   */
+  public static int getValueAsInt(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toInt(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition());
+    }
+    return Bytes.toInt(cell.getValueArray(), cell.getValueOffset());
+  }
+
+  /**
+   * Converts the value bytes of the given cell into a double value
+   * @param cell
+   * @return value as double
+   */
+  public static double getValueAsDouble(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toDouble(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition());
+    }
+    return Bytes.toDouble(cell.getValueArray(), cell.getValueOffset());
+  }
+
+  /**
+   * Converts the value bytes of the given cell into a BigDecimal
+   * @param cell
+   * @return value as BigDecimal
+   */
+  public static BigDecimal getValueAsBigDecimal(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toBigDecimal(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition(), cell.getValueLength());
+    }
+    return Bytes.toBigDecimal(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
+  }
+
+  /**
+   * Compresses the tags to the given outputstream using the TagcompressionContext
+   * @param out the outputstream to which the compression should happen
+   * @param cell the cell which has tags
+   * @param tagCompressionContext the TagCompressionContext
+   * @throws IOException can throw IOException if the compression encounters issue
+   */
+  public static void compressTags(OutputStream out, Cell cell,
+      TagCompressionContext tagCompressionContext) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      tagCompressionContext.compressTags(out, ((ByteBufferCell) cell).getTagsByteBuffer(),
+        ((ByteBufferCell) cell).getTagsPosition(), cell.getTagsLength());
+    } else {
+      tagCompressionContext.compressTags(out, cell.getTagsArray(), cell.getTagsOffset(),
+        cell.getTagsLength());
+    }
+  }
+
+  public static void compressRow(OutputStream out, Cell cell, Dictionary dict) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      Dictionary.write(out, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(), dict);
+    } else {
+      Dictionary.write(out, cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(), dict);
+    }
+  }
+
+  public static void compressFamily(OutputStream out, Cell cell, Dictionary dict)
+      throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      Dictionary.write(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(), dict);
+    } else {
+      Dictionary.write(out, cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
+        dict);
+    }
+  }
+
+  public static void compressQualifier(OutputStream out, Cell cell, Dictionary dict)
+      throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      Dictionary.write(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength(), dict);
+    } else {
+      Dictionary.write(out, cell.getQualifierArray(), cell.getQualifierOffset(),
+        cell.getQualifierLength(), dict);
+    }
+  }
+
+  /**
+   * Used when a cell needs to be compared with a key byte[] such as cases of finding the index from
+   * the index block, bloom keys from the bloom blocks This byte[] is expected to be serialized in
+   * the KeyValue serialization format If the KeyValue (Cell's) serialization format changes this
+   * method cannot be used.
+   * @param comparator the cell comparator
+   * @param left the cell to be compared
+   * @param key the serialized key part of a KeyValue
+   * @param offset the offset in the key byte[]
+   * @param length the length of the key byte[]
+   * @return an int greater than 0 if left is greater than right lesser than 0 if left is lesser
+   *         than right equal to 0 if left is equal to right
+   */
+  @VisibleForTesting
+  public static final int compare(CellComparator comparator, Cell left, byte[] key, int offset,
+      int length) {
+    // row
+    short rrowlength = Bytes.toShort(key, offset);
+    int c = comparator.compareRows(left, key, offset + Bytes.SIZEOF_SHORT, rrowlength);
+    if (c != 0) return c;
+
+    // Compare the rest of the two KVs without making any assumptions about
+    // the common prefix. This function will not compare rows anyway, so we
+    // don't need to tell it that the common prefix includes the row.
+    return compareWithoutRow(comparator, left, key, offset, length, rrowlength);
+  }
+
+  /**
+   * Compare columnFamily, qualifier, timestamp, and key type (everything except the row). This
+   * method is used both in the normal comparator and the "same-prefix" comparator. Note that we are
+   * assuming that row portions of both KVs have already been parsed and found identical, and we
+   * don't validate that assumption here.
+   * @param commonPrefix the length of the common prefix of the two key-values being compared,
+   *          including row length and row
+   */
+  static final int compareWithoutRow(CellComparator comparator, Cell left, byte[] right,
+      int roffset, int rlength, short rowlength) {
+    /***
+     * KeyValue Format and commonLength:
+     * |_keyLen_|_valLen_|_rowLen_|_rowKey_|_famiLen_|_fami_|_Quali_|....
+     * ------------------|-------commonLength--------|--------------
+     */
+    int commonLength = KeyValue.ROW_LENGTH_SIZE + KeyValue.FAMILY_LENGTH_SIZE + rowlength;
+
+    // commonLength + TIMESTAMP_TYPE_SIZE
+    int commonLengthWithTSAndType = KeyValue.TIMESTAMP_TYPE_SIZE + commonLength;
+    // ColumnFamily + Qualifier length.
+    int lcolumnlength = left.getFamilyLength() + left.getQualifierLength();
+    int rcolumnlength = rlength - commonLengthWithTSAndType;
+
+    byte ltype = left.getTypeByte();
+    byte rtype = right[roffset + (rlength - 1)];
+
+    // If the column is not specified, the "minimum" key type appears the
+    // latest in the sorted order, regardless of the timestamp. This is used
+    // for specifying the last key/value in a given row, because there is no
+    // "lexicographically last column" (it would be infinitely long). The
+    // "maximum" key type does not need this behavior.
+    if (lcolumnlength == 0 && ltype == Type.Minimum.getCode()) {
+      // left is "bigger", i.e. it appears later in the sorted order
+      return 1;
+    }
+    if (rcolumnlength == 0 && rtype == Type.Minimum.getCode()) {
+      return -1;
+    }
+
+    int rfamilyoffset = commonLength + roffset;
+
+    // Column family length.
+    int lfamilylength = left.getFamilyLength();
+    int rfamilylength = right[rfamilyoffset - 1];
+    // If left family size is not equal to right family size, we need not
+    // compare the qualifiers.
+    boolean sameFamilySize = (lfamilylength == rfamilylength);
+    if (!sameFamilySize) {
+      // comparing column family is enough.
+      return CellUtil.compareFamilies(left, right, rfamilyoffset, rfamilylength);
+    }
+    // Compare family & qualifier together.
+    // Families are same. Compare on qualifiers.
+    int comparison = CellUtil.compareColumns(left, right, rfamilyoffset, rfamilylength,
+      rfamilyoffset + rfamilylength, (rcolumnlength - rfamilylength));
+    if (comparison != 0) {
+      return comparison;
+    }
+
+    // //
+    // Next compare timestamps.
+    long rtimestamp = Bytes.toLong(right, roffset + (rlength - KeyValue.TIMESTAMP_TYPE_SIZE));
+    int compare = comparator.compareTimestamps(left.getTimestamp(), rtimestamp);
+    if (compare != 0) {
+      return compare;
+    }
+
+    // Compare types. Let the delete types sort ahead of puts; i.e. types
+    // of higher numbers sort before those of lesser numbers. Maximum (255)
+    // appears ahead of everything, and minimum (0) appears after
+    // everything.
+    return (0xff & rtype) - (0xff & ltype);
+  }
+
+  /**
+   * @return An new cell is located following input cell. If both of type and timestamp are minimum,
+   *         the input cell will be returned directly.
+   */
+  public static Cell createNextOnRowCol(Cell cell) {
+    long ts = cell.getTimestamp();
+    byte type = cell.getTypeByte();
+    if (type != Type.Minimum.getCode()) {
+      type = KeyValue.Type.values()[KeyValue.Type.codeToType(type).ordinal() - 1].getCode();
+    } else if (ts != HConstants.OLDEST_TIMESTAMP) {
+      ts = ts - 1;
+      type = Type.Maximum.getCode();
+    } else {
+      return cell;
+    }
+    return createNextOnRowCol(cell, ts, type);
+  }
+
+  static Cell createNextOnRowCol(Cell cell, long ts, byte type) {
+    if (cell instanceof ByteBufferCell) {
+      return new InternalCellUtil.LastOnRowColByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength(), ((ByteBufferCell) cell).getFamilyByteBuffer(),
+          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
+          ((ByteBufferCell) cell).getQualifierByteBuffer(),
+          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength()) {
+        @Override
+        public long getTimestamp() {
+          return ts;
+        }
+
+        @Override
+        public byte getTypeByte() {
+          return type;
+        }
+      };
+    }
+    return new InternalCellUtil.LastOnRowColCell(cell.getRowArray(), cell.getRowOffset(),
+        cell.getRowLength(), cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
+        cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength()) {
+      @Override
+      public long getTimestamp() {
+        return ts;
+      }
+
+      @Override
+      public byte getTypeByte() {
+        return type;
+      }
+    };
+  }
+}
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
index 6154045..6bc3f25 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
@@ -1617,7 +1617,7 @@ public class KeyValue implements ExtendedCell {
      */
     @Override
     public int compare(final Cell left, final Cell right) {
-      return CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.META_COMPARATOR, left, right);
+      return InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.META_COMPARATOR, left, right);
     }
 
     @Override
@@ -1839,7 +1839,7 @@ public class KeyValue implements ExtendedCell {
     }
 
     public int compareOnlyKeyPortion(Cell left, Cell right) {
-      return CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, right);
+      return InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, right);
     }
 
     /**
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueTestUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueTestUtil.java
index c8bed3e..34f6e96 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueTestUtil.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueTestUtil.java
@@ -85,7 +85,7 @@ public class KeyValueTestUtil {
     for (Cell kv1 : kvCollection1) {
       boolean found = false;
       for (Cell kv2 : kvCollection2) {
-        if (CellUtil.equalsIgnoreMvccVersion(kv1, kv2)) found = true;
+        if (InternalCellUtil.equalsIgnoreMvccVersion(kv1, kv2)) found = true;
       }
       if (!found) return false;
     }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueUtil.java
index f1f03eb..47a44e8 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueUtil.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueUtil.java
@@ -163,7 +163,7 @@ public class KeyValueUtil {
     pos = CellUtil.copyValueTo(cell, output, pos);
     if (withTags && (cell.getTagsLength() > 0)) {
       pos = Bytes.putAsShort(output, pos, cell.getTagsLength());
-      pos = CellUtil.copyTagTo(cell, output, pos);
+      pos = InternalCellUtil.copyTagTo(cell, output, pos);
     }
     return pos;
   }
@@ -179,7 +179,7 @@ public class KeyValueUtil {
     int tagsLength = cell.getTagsLength();
     if (withTags && (tagsLength > 0)) {
       offset = ByteBufferUtils.putAsShort(buf, offset, tagsLength);// Tags length
-      offset = CellUtil.copyTagTo(cell, buf, offset);// Tags bytes
+      offset = InternalCellUtil.copyTagTo(cell, buf, offset);// Tags bytes
     }
     return offset;
   }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/TagUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/TagUtil.java
index 0f010a0..847b1fb 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/TagUtil.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/TagUtil.java
@@ -232,7 +232,7 @@ public final class TagUtil {
    * Add to <code>tagsOrNull</code> any Tags <code>cell</code> is carrying or null if none.
    */
   public static List<Tag> carryForwardTags(final List<Tag> tagsOrNull, final Cell cell) {
-    Iterator<Tag> itr = CellUtil.tagsIterator(cell);
+    Iterator<Tag> itr = InternalCellUtil.tagsIterator(cell);
     if (itr == EMPTY_TAGS_ITR) {
       // If no Tags, return early.
       return tagsOrNull;
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java
index ec3bfd5..a497c44 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java
@@ -29,6 +29,7 @@ import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.ExtendedCell;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.KeyValueUtil;
@@ -749,7 +750,7 @@ abstract class BufferedDataBlockEncoder extends AbstractDataBlockEncoder {
     @Override
     public int compareKey(CellComparator comparator, Cell key) {
       keyOnlyKV.setKey(current.keyBuffer, 0, current.keyLength);
-      return CellUtil.compareKeyIgnoresMvcc(comparator, key, keyOnlyKV);
+      return InternalCellUtil.compareKeyIgnoresMvcc(comparator, key, keyOnlyKV);
     }
 
     @Override
@@ -1027,9 +1028,9 @@ abstract class BufferedDataBlockEncoder extends AbstractDataBlockEncoder {
         // the tags using Dictionary compression in such a case
         if (tagCompressionContext != null) {
           // Not passing tagsLength considering that parsing of the tagsLength is not costly
-          CellUtil.compressTags(out, cell, tagCompressionContext);
+          InternalCellUtil.compressTags(out, cell, tagCompressionContext);
         } else {
-          CellUtil.writeTags(out, cell, tagsLength);
+          InternalCellUtil.writeTags(out, cell, tagsLength);
         }
       }
       size += tagsLength + KeyValue.TAGS_LENGTH_SIZE;
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java
index bd644c1..8f35825 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java
@@ -23,7 +23,7 @@ import java.nio.ByteBuffer;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -229,11 +229,11 @@ public class DiffKeyDeltaEncoder extends BufferedDataBlockEncoder {
       // put column family
       byte familyLength = cell.getFamilyLength();
       out.write(familyLength);
-      CellUtil.writeFamily(out, cell, familyLength);
+      InternalCellUtil.writeFamily(out, cell, familyLength);
     } else {
       // Finding common prefix
       int preKeyLength = KeyValueUtil.keyLength(prevCell);
-      commonPrefix = CellUtil.findCommonPrefixInFlatKey(cell, prevCell, true, false);
+      commonPrefix = InternalCellUtil.findCommonPrefixInFlatKey(cell, prevCell, true, false);
       if (kLength == preKeyLength) {
         flag |= FLAG_SAME_KEY_LENGTH;
       }
@@ -281,8 +281,8 @@ public class DiffKeyDeltaEncoder extends BufferedDataBlockEncoder {
     if (commonPrefix < rLen + KeyValue.ROW_LENGTH_SIZE) {
       // Previous and current rows are different. Copy the differing part of
       // the row, skip the column family, and copy the qualifier.
-      CellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
-      CellUtil.writeQualifier(out, cell, cell.getQualifierLength());
+      InternalCellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
+      InternalCellUtil.writeQualifier(out, cell, cell.getQualifierLength());
     } else {
       // The common part includes the whole row. As the column family is the
       // same across the whole file, it will automatically be included in the
@@ -290,7 +290,7 @@ public class DiffKeyDeltaEncoder extends BufferedDataBlockEncoder {
       // What we write here is the non common part of the qualifier
       int commonQualPrefix = commonPrefix - (rLen + KeyValue.ROW_LENGTH_SIZE)
           - (cell.getFamilyLength() + KeyValue.FAMILY_LENGTH_SIZE);
-      CellUtil.writeQualifierSkippingBytes(out, cell, cell.getQualifierLength(),
+      InternalCellUtil.writeQualifierSkippingBytes(out, cell, cell.getQualifierLength(),
         commonQualPrefix);
     }
     if ((flag & FLAG_TIMESTAMP_IS_DIFF) == 0) {
@@ -302,7 +302,7 @@ public class DiffKeyDeltaEncoder extends BufferedDataBlockEncoder {
     if ((flag & FLAG_SAME_TYPE) == 0) {
       out.write(cell.getTypeByte());
     }
-    CellUtil.writeValue(out, cell, vLength);
+    InternalCellUtil.writeValue(out, cell, vLength);
     return kLength + vLength + KeyValue.KEYVALUE_INFRASTRUCTURE_SIZE;
   }
 
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java
index 03cf768..c404980 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java
@@ -24,7 +24,7 @@ import java.nio.ByteBuffer;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -263,14 +263,14 @@ public class FastDiffDeltaEncoder extends BufferedDataBlockEncoder {
       ByteBufferUtils.putCompressedInt(out, kLength);
       ByteBufferUtils.putCompressedInt(out, vLength);
       ByteBufferUtils.putCompressedInt(out, 0);
-      CellUtil.writeFlatKey(cell, (DataOutput)out);
+      InternalCellUtil.writeFlatKey(cell, (DataOutput)out);
       // Write the value part
-      CellUtil.writeValue(out, cell, cell.getValueLength());
+      InternalCellUtil.writeValue(out, cell, cell.getValueLength());
     } else {
       int preKeyLength = KeyValueUtil.keyLength(prevCell);
       int preValLength = prevCell.getValueLength();
       // find a common prefix and skip it
-      int commonPrefix = CellUtil.findCommonPrefixInFlatKey(cell, prevCell, true, false);
+      int commonPrefix = InternalCellUtil.findCommonPrefixInFlatKey(cell, prevCell, true, false);
 
       if (kLength == preKeyLength) {
         flag |= FLAG_SAME_KEY_LENGTH;
@@ -291,7 +291,7 @@ public class FastDiffDeltaEncoder extends BufferedDataBlockEncoder {
       // Check if current and previous values are the same. Compare value
       // length first as an optimization.
       if (vLength == preValLength
-          && CellUtil.matchingValue(cell, prevCell, vLength, preValLength)) {
+          && InternalCellUtil.matchingValue(cell, prevCell, vLength, preValLength)) {
         flag |= FLAG_SAME_VALUE;
       }
 
@@ -307,8 +307,8 @@ public class FastDiffDeltaEncoder extends BufferedDataBlockEncoder {
       if (commonPrefix < rLen + KeyValue.ROW_LENGTH_SIZE) {
         // Previous and current rows are different. Copy the differing part of
         // the row, skip the column family, and copy the qualifier.
-        CellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
-        CellUtil.writeQualifier(out, cell, cell.getQualifierLength());
+        InternalCellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
+        InternalCellUtil.writeQualifier(out, cell, cell.getQualifierLength());
       } else {
         // The common part includes the whole row. As the column family is the
         // same across the whole file, it will automatically be included in the
@@ -316,7 +316,7 @@ public class FastDiffDeltaEncoder extends BufferedDataBlockEncoder {
         // What we write here is the non common part of the qualifier
         int commonQualPrefix = commonPrefix - (rLen + KeyValue.ROW_LENGTH_SIZE)
             - (cell.getFamilyLength() + KeyValue.FAMILY_LENGTH_SIZE);
-        CellUtil.writeQualifierSkippingBytes(out, cell, cell.getQualifierLength(),
+        InternalCellUtil.writeQualifierSkippingBytes(out, cell, cell.getQualifierLength(),
           commonQualPrefix);
       }
       // Write non common ts part
@@ -329,7 +329,7 @@ public class FastDiffDeltaEncoder extends BufferedDataBlockEncoder {
 
       // Write the value if it is not the same as before.
       if ((flag & FLAG_SAME_VALUE) == 0) {
-        CellUtil.writeValue(out, cell, vLength);
+        InternalCellUtil.writeValue(out, cell, vLength);
       }
     }
     return kLength + vLength + KeyValue.KEYVALUE_INFRASTRUCTURE_SIZE;
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/NoneEncoder.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/NoneEncoder.java
index 56e0837..fa38fb1 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/NoneEncoder.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/NoneEncoder.java
@@ -22,7 +22,7 @@ import java.io.DataOutputStream;
 import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -50,7 +50,7 @@ public class NoneEncoder {
       int tagsLength = cell.getTagsLength();
       out.writeShort(tagsLength);
       if (tagsLength > 0) {
-        CellUtil.writeTags(out, cell, tagsLength);
+        InternalCellUtil.writeTags(out, cell, tagsLength);
       }
       size += tagsLength + KeyValue.TAGS_LENGTH_SIZE;
     }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java
index 8edb305..d0a5a5b 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java
@@ -24,7 +24,7 @@ import java.nio.ByteBuffer;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -60,17 +60,17 @@ public class PrefixKeyDeltaEncoder extends BufferedDataBlockEncoder {
       ByteBufferUtils.putCompressedInt(out, klength);
       ByteBufferUtils.putCompressedInt(out, vlength);
       ByteBufferUtils.putCompressedInt(out, 0);
-      CellUtil.writeFlatKey(cell, (DataOutput)out);
+      InternalCellUtil.writeFlatKey(cell, (DataOutput)out);
     } else {
       // find a common prefix and skip it
-      int common = CellUtil.findCommonPrefixInFlatKey(cell, state.prevCell, true, true);
+      int common = InternalCellUtil.findCommonPrefixInFlatKey(cell, state.prevCell, true, true);
       ByteBufferUtils.putCompressedInt(out, klength - common);
       ByteBufferUtils.putCompressedInt(out, vlength);
       ByteBufferUtils.putCompressedInt(out, common);
       writeKeyExcludingCommon(cell, common, out);
     }
     // Write the value part
-    CellUtil.writeValue(out, cell, vlength);
+    InternalCellUtil.writeValue(out, cell, vlength);
     int size = klength + vlength + KeyValue.KEYVALUE_INFRASTRUCTURE_SIZE;
     size += afterEncodingKeyValue(cell, out, encodingContext);
     state.prevCell = cell;
@@ -83,11 +83,11 @@ public class PrefixKeyDeltaEncoder extends BufferedDataBlockEncoder {
     if (commonPrefix < rLen + KeyValue.ROW_LENGTH_SIZE) {
       // Previous and current rows are different. Need to write the differing part followed by
       // cf,q,ts and type
-      CellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
+      InternalCellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
       byte fLen = cell.getFamilyLength();
       out.writeByte(fLen);
-      CellUtil.writeFamily(out, cell, fLen);
-      CellUtil.writeQualifier(out, cell, cell.getQualifierLength());
+      InternalCellUtil.writeFamily(out, cell, fLen);
+      InternalCellUtil.writeQualifier(out, cell, cell.getQualifierLength());
       out.writeLong(cell.getTimestamp());
       out.writeByte(cell.getTypeByte());
     } else {
@@ -99,7 +99,7 @@ public class PrefixKeyDeltaEncoder extends BufferedDataBlockEncoder {
       int commonQualPrefix = Math.min(commonPrefix, qLen);
       int qualPartLenToWrite = qLen - commonQualPrefix;
       if (qualPartLenToWrite > 0) {
-        CellUtil.writeQualifierSkippingBytes(out, cell, qLen, commonQualPrefix);
+        InternalCellUtil.writeQualifierSkippingBytes(out, cell, qLen, commonQualPrefix);
       }
       commonPrefix -= commonQualPrefix;
       // Common part in TS also?
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/RowIndexSeekerV1.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/RowIndexSeekerV1.java
index 8611b34..b7863ed 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/RowIndexSeekerV1.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/RowIndexSeekerV1.java
@@ -24,6 +24,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.ByteBufferKeyValue;
 import org.apache.hadoop.hbase.SizeCachedKeyValue;
@@ -190,7 +191,7 @@ public class RowIndexSeekerV1 extends AbstractEncodedSeeker {
     }
     do {
       int comp;
-      comp = CellUtil.compareKeyIgnoresMvcc(comparator, seekCell, current.currentKey);
+      comp = InternalCellUtil.compareKeyIgnoresMvcc(comparator, seekCell, current.currentKey);
       if (comp == 0) { // exact match
         if (seekBefore) {
           if (!previous.isValid()) {
@@ -244,7 +245,7 @@ public class RowIndexSeekerV1 extends AbstractEncodedSeeker {
 
   @Override
   public int compareKey(CellComparator comparator, Cell key) {
-    return CellUtil.compareKeyIgnoresMvcc(comparator, key, current.currentKey);
+    return InternalCellUtil.compareKeyIgnoresMvcc(comparator, key, current.currentKey);
   }
 
   protected void decodeFirst() {
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowBloomHashKey.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowBloomHashKey.java
index 6007b92..50bbbe0 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowBloomHashKey.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowBloomHashKey.java
@@ -19,6 +19,7 @@ package org.apache.hadoop.hbase.util;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 
 @InterfaceAudience.Private
@@ -30,7 +31,7 @@ public class RowBloomHashKey extends CellHashKey {
 
   @Override
   public byte get(int offset) {
-    return CellUtil.getRowByte(t, offset);
+    return InternalCellUtil.getRowByte(t, offset);
   }
 
   @Override
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowColBloomHashKey.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowColBloomHashKey.java
index 82aba07..96dcb02 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowColBloomHashKey.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowColBloomHashKey.java
@@ -19,6 +19,7 @@ package org.apache.hadoop.hbase.util;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.yetus.audience.InterfaceAudience;
 
@@ -57,7 +58,7 @@ public class RowColBloomHashKey extends CellHashKey {
     }
     int refLen = Bytes.SIZEOF_SHORT + rowLength;
     if (offset < refLen) {
-      return CellUtil.getRowByte(t, offset - Bytes.SIZEOF_SHORT);
+      return InternalCellUtil.getRowByte(t, offset - Bytes.SIZEOF_SHORT);
     }
     if (offset == refLen) {
       // The fam length should return 0 assuming there is no column family.
@@ -67,7 +68,7 @@ public class RowColBloomHashKey extends CellHashKey {
     refLen += qualLength + Bytes.SIZEOF_BYTE;
     // skip the family len because actual cells may have family also
     if (offset < refLen) {
-      return CellUtil.getQualifierByte(t,
+      return InternalCellUtil.getQualifierByte(t,
         offset - (Bytes.SIZEOF_SHORT + rowLength + Bytes.SIZEOF_BYTE));
     }
     // TODO : check if ts and type can be removed
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestByteBufferKeyValue.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestByteBufferKeyValue.java
index ff6c4f7..f6a592c 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestByteBufferKeyValue.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestByteBufferKeyValue.java
@@ -166,9 +166,9 @@ public class TestByteBufferKeyValue {
     Tag tag2 = resTags.get(1);
     assertEquals(tag2.getType(), tag2.getType());
     assertEquals(TagUtil.getValueAsString(t2), TagUtil.getValueAsString(tag2));
-    Tag res = CellUtil.getTag(offheapKV, (byte) 2);
+    Tag res = InternalCellUtil.getTag(offheapKV, (byte) 2);
     assertEquals(TagUtil.getValueAsString(t2), TagUtil.getValueAsString(tag2));
-    res = CellUtil.getTag(offheapKV, (byte) 3);
+    res = InternalCellUtil.getTag(offheapKV, (byte) 3);
     assertNull(res);
   }
 
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java
index b4226ce..138db30 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java
@@ -72,23 +72,28 @@ public class TestCellComparator {
   public void testCompareCellWithKey() throws Exception {
     KeyValue kv1 = new KeyValue(row1, fam1, qual1, val);
     KeyValue kv2 = new KeyValue(row2, fam1, qual1, val);
-    assertTrue((CellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) < 0);
+    assertTrue(
+      (InternalCellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) < 0);
 
     kv1 = new KeyValue(row1, fam2, qual1, val);
     kv2 = new KeyValue(row1, fam1, qual1, val);
-    assertTrue((CellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
+    assertTrue(
+      (InternalCellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
 
     kv1 = new KeyValue(row1, fam1, qual1, 1l, val);
     kv2 = new KeyValue(row1, fam1, qual1, 2l, val);
-    assertTrue((CellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
+    assertTrue(
+      (InternalCellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
 
     kv1 = new KeyValue(row1, fam1, qual1, 1l, Type.Put);
     kv2 = new KeyValue(row1, fam1, qual1, 1l, Type.Maximum);
-    assertTrue((CellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
+    assertTrue(
+      (InternalCellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
 
     kv1 = new KeyValue(row1, fam1, qual1, 1l, Type.Put);
     kv2 = new KeyValue(row1, fam1, qual1, 1l, Type.Put);
-    assertTrue((CellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) == 0);
+    assertTrue(
+      (InternalCellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) == 0);
   }
 
   @Test
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellUtil.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellUtil.java
index 3bd1b66..74d3067 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellUtil.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellUtil.java
@@ -23,7 +23,6 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
 import java.math.BigDecimal;
 import java.nio.ByteBuffer;
@@ -266,43 +265,43 @@ public class TestCellUtil {
     byte[] d = Bytes.toBytes("d");
 
     // overlaps
-    Assert.assertTrue(CellUtil.overlappingKeys(a, b, a, b));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, c, a, b));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, b, a, c));
-    Assert.assertTrue(CellUtil.overlappingKeys(b, c, a, c));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, c, b, c));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, d, b, c));
-    Assert.assertTrue(CellUtil.overlappingKeys(b, c, a, d));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(a, b, a, b));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(a, c, a, b));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(a, b, a, c));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(b, c, a, c));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(a, c, b, c));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(a, d, b, c));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(b, c, a, d));
 
-    Assert.assertTrue(CellUtil.overlappingKeys(empty, b, a, b));
-    Assert.assertTrue(CellUtil.overlappingKeys(empty, b, a, c));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(empty, b, a, b));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(empty, b, a, c));
 
-    Assert.assertTrue(CellUtil.overlappingKeys(a, b, empty, b));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, b, empty, c));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(a, b, empty, b));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(a, b, empty, c));
 
-    Assert.assertTrue(CellUtil.overlappingKeys(a, empty, a, b));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, empty, a, c));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(a, empty, a, b));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(a, empty, a, c));
 
-    Assert.assertTrue(CellUtil.overlappingKeys(a, b, empty, empty));
-    Assert.assertTrue(CellUtil.overlappingKeys(empty, empty, a, b));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(a, b, empty, empty));
+    Assert.assertTrue(InternalCellUtil.overlappingKeys(empty, empty, a, b));
 
     // non overlaps
-    Assert.assertFalse(CellUtil.overlappingKeys(a, b, c, d));
-    Assert.assertFalse(CellUtil.overlappingKeys(c, d, a, b));
-
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, c, d));
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, c, empty));
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, d, empty));
-    Assert.assertFalse(CellUtil.overlappingKeys(c, d, b, c));
-    Assert.assertFalse(CellUtil.overlappingKeys(c, empty, b, c));
-    Assert.assertFalse(CellUtil.overlappingKeys(d, empty, b, c));
-
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, a, b));
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, empty, b));
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, empty, a));
-    Assert.assertFalse(CellUtil.overlappingKeys(a,b, b, c));
-    Assert.assertFalse(CellUtil.overlappingKeys(empty, b, b, c));
-    Assert.assertFalse(CellUtil.overlappingKeys(empty, a, b, c));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(a, b, c, d));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(c, d, a, b));
+
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(b, c, c, d));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(b, c, c, empty));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(b, c, d, empty));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(c, d, b, c));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(c, empty, b, c));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(d, empty, b, c));
+
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(b, c, a, b));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(b, c, empty, b));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(b, c, empty, a));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(a,b, b, c));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(empty, b, b, c));
+    Assert.assertFalse(InternalCellUtil.overlappingKeys(empty, a, b, c));
   }
 
   @Test
@@ -310,43 +309,43 @@ public class TestCellUtil {
     // The whole key matching case
     KeyValue kv1 = new KeyValue("r1".getBytes(), "f1".getBytes(), "q1".getBytes(), null);
     Assert.assertEquals(kv1.getKeyLength(),
-        CellUtil.findCommonPrefixInFlatKey(kv1, kv1, true, true));
+      InternalCellUtil.findCommonPrefixInFlatKey(kv1, kv1, true, true));
     Assert.assertEquals(kv1.getKeyLength(),
-        CellUtil.findCommonPrefixInFlatKey(kv1, kv1, false, true));
+      InternalCellUtil.findCommonPrefixInFlatKey(kv1, kv1, false, true));
     Assert.assertEquals(kv1.getKeyLength() - KeyValue.TIMESTAMP_TYPE_SIZE,
-        CellUtil.findCommonPrefixInFlatKey(kv1, kv1, true, false));
+      InternalCellUtil.findCommonPrefixInFlatKey(kv1, kv1, true, false));
     // The rk length itself mismatch
     KeyValue kv2 = new KeyValue("r12".getBytes(), "f1".getBytes(), "q1".getBytes(), null);
-    Assert.assertEquals(1, CellUtil.findCommonPrefixInFlatKey(kv1, kv2, true, true));
+    Assert.assertEquals(1, InternalCellUtil.findCommonPrefixInFlatKey(kv1, kv2, true, true));
     // part of rk is same
     KeyValue kv3 = new KeyValue("r14".getBytes(), "f1".getBytes(), "q1".getBytes(), null);
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + "r1".getBytes().length,
-        CellUtil.findCommonPrefixInFlatKey(kv2, kv3, true, true));
+      InternalCellUtil.findCommonPrefixInFlatKey(kv2, kv3, true, true));
     // entire rk is same but different cf name
     KeyValue kv4 = new KeyValue("r14".getBytes(), "f2".getBytes(), "q1".getBytes(), null);
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + kv3.getRowLength() + KeyValue.FAMILY_LENGTH_SIZE
-        + "f".getBytes().length, CellUtil.findCommonPrefixInFlatKey(kv3, kv4, false, true));
+        + "f".getBytes().length, InternalCellUtil.findCommonPrefixInFlatKey(kv3, kv4, false, true));
     // rk and family are same and part of qualifier
     KeyValue kv5 = new KeyValue("r14".getBytes(), "f2".getBytes(), "q123".getBytes(), null);
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + kv3.getRowLength() + KeyValue.FAMILY_LENGTH_SIZE
         + kv4.getFamilyLength() + kv4.getQualifierLength(),
-        CellUtil.findCommonPrefixInFlatKey(kv4, kv5, true, true));
+        InternalCellUtil.findCommonPrefixInFlatKey(kv4, kv5, true, true));
     // rk, cf and q are same. ts differs
     KeyValue kv6 = new KeyValue("rk".getBytes(), 1234L);
     KeyValue kv7 = new KeyValue("rk".getBytes(), 1235L);
     // only last byte out of 8 ts bytes in ts part differs
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + kv6.getRowLength() + KeyValue.FAMILY_LENGTH_SIZE
         + kv6.getFamilyLength() + kv6.getQualifierLength() + 7,
-        CellUtil.findCommonPrefixInFlatKey(kv6, kv7, true, true));
+        InternalCellUtil.findCommonPrefixInFlatKey(kv6, kv7, true, true));
     // rk, cf, q and ts are same. Only type differs
     KeyValue kv8 = new KeyValue("rk".getBytes(), 1234L, Type.Delete);
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + kv6.getRowLength() + KeyValue.FAMILY_LENGTH_SIZE
         + kv6.getFamilyLength() + kv6.getQualifierLength() + KeyValue.TIMESTAMP_SIZE,
-        CellUtil.findCommonPrefixInFlatKey(kv6, kv8, true, true));
+        InternalCellUtil.findCommonPrefixInFlatKey(kv6, kv8, true, true));
     // With out TS_TYPE check
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + kv6.getRowLength() + KeyValue.FAMILY_LENGTH_SIZE
         + kv6.getFamilyLength() + kv6.getQualifierLength(),
-        CellUtil.findCommonPrefixInFlatKey(kv6, kv8, true, false));
+        InternalCellUtil.findCommonPrefixInFlatKey(kv6, kv8, true, false));
   }
 
   /**
@@ -427,7 +426,7 @@ public class TestCellUtil {
     byte[] vDest = CellUtil.cloneValue(bbCell);
     assertTrue(Bytes.equals(v, vDest));
     byte[] tDest = new byte[tags.length];
-    CellUtil.copyTagTo(bbCell, tDest, 0);
+    InternalCellUtil.copyTagTo(bbCell, tDest, 0);
     assertTrue(Bytes.equals(tags, tDest));
   }
 
@@ -475,20 +474,20 @@ public class TestCellUtil {
     KeyValue kv = new KeyValue(r, f, q, v);
     ByteBuffer buffer = ByteBuffer.wrap(kv.getBuffer());
     Cell bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertEquals(ri, CellUtil.getRowAsInt(bbCell));
-    assertEquals(vl, CellUtil.getValueAsLong(bbCell));
+    assertEquals(ri, InternalCellUtil.getRowAsInt(bbCell));
+    assertEquals(vl, InternalCellUtil.getValueAsLong(bbCell));
     double vd = 3005.5;
     v = Bytes.toBytes(vd);
     kv = new KeyValue(r, f, q, v);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertEquals(vd, CellUtil.getValueAsDouble(bbCell), 0.0);
+    assertEquals(vd, InternalCellUtil.getValueAsDouble(bbCell), 0.0);
     BigDecimal bd = new BigDecimal(9999);
     v = Bytes.toBytes(bd);
     kv = new KeyValue(r, f, q, v);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertEquals(bd, CellUtil.getValueAsBigDecimal(bbCell));
+    assertEquals(bd, InternalCellUtil.getValueAsBigDecimal(bbCell));
   }
 
   @Test
@@ -502,7 +501,7 @@ public class TestCellUtil {
     KeyValue kv = new KeyValue(r, f, q1, 0, q1.length, 1234L, Type.Put, v, 0, v.length, tags);
     NonExtendedCell nonExtCell = new NonExtendedCell(kv);
     ByteArrayOutputStream os = new ByteArrayOutputStream();
-    int writeCell = CellUtil.writeCell(nonExtCell, os, true);
+    int writeCell = InternalCellUtil.writeCell(nonExtCell, os, true);
     byte[] byteArray = os.toByteArray();
     KeyValue res = new KeyValue(byteArray);
     assertTrue(CellUtil.equals(kv, res));
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java
index b13a8d2..cc4a3e8 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java
@@ -470,7 +470,7 @@ public class TestKeyValue extends TestCase {
     }
     assertTrue(meta1Ok);
     assertTrue(meta2Ok);
-    Iterator<Tag> tagItr = CellUtil.tagsIterator(kv);
+    Iterator<Tag> tagItr = InternalCellUtil.tagsIterator(kv);
     //Iterator<Tag> tagItr = kv.tagsIterator();
     assertTrue(tagItr.hasNext());
     Tag next = tagItr.next();
@@ -484,7 +484,7 @@ public class TestKeyValue extends TestCase {
     Bytes.equals(TagUtil.cloneValue(next), metaValue2);
     assertFalse(tagItr.hasNext());
 
-    tagItr = CellUtil.tagsIterator(kv);
+    tagItr = InternalCellUtil.tagsIterator(kv);
     assertTrue(tagItr.hasNext());
     next = tagItr.next();
     assertEquals(10, next.getValueLength());
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSerialization.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSerialization.java
index 6f4419e..092ac99 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSerialization.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSerialization.java
@@ -25,7 +25,7 @@ import java.io.OutputStream;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
-import org.apache.hadoop.hbase.ExtendedCell;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.util.Bytes;
@@ -90,7 +90,7 @@ public class CellSerialization implements Serialization<Cell> {
     @Override
     public void serialize(Cell kv) throws IOException {
       dos.writeInt(CellUtil.estimatedSerializedSizeOf(kv) - Bytes.SIZEOF_INT);
-      CellUtil.writeCell(kv, dos, true);
+      InternalCellUtil.writeCell(kv, dos, true);
     }
   }
 }
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSortReducer.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSortReducer.java
index 5c2b41f..905801c 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSortReducer.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSortReducer.java
@@ -23,7 +23,7 @@ import java.util.TreeSet;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.io.ImmutableBytesWritable;
 import org.apache.hadoop.hbase.util.MapReduceCell;
 import org.apache.hadoop.mapreduce.Reducer;
@@ -45,7 +45,7 @@ public class CellSortReducer
     TreeSet<Cell> map = new TreeSet<>(CellComparatorImpl.COMPARATOR);
     for (Cell kv : kvs) {
       try {
-        map.add(CellUtil.deepClone(kv));
+        map.add(InternalCellUtil.deepClone(kv));
       } catch (CloneNotSupportedException e) {
         throw new IOException(e);
       }
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java
index e666f90..d1f3c40 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java
@@ -51,8 +51,8 @@ import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionLocation;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
-import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.client.ColumnFamilyDescriptor;
 import org.apache.hadoop.hbase.client.ColumnFamilyDescriptorBuilder;
@@ -337,7 +337,7 @@ public class HFileOutputFormat2
 
         // we now have the proper WAL writer. full steam ahead
         // TODO : Currently in SettableTimeStamp but this will also move to ExtendedCell
-        CellUtil.updateLatestStamp(cell, this.now);
+        InternalCellUtil.updateLatestStamp(cell, this.now);
         wl.writer.append(kv);
         wl.written += length;
 
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/Import.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/Import.java
index e533041..643ff0b 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/Import.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/Import.java
@@ -43,6 +43,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.TableName;
@@ -208,7 +209,7 @@ public class Import extends Configured implements Tool {
     public void write(DataOutput out) throws IOException {
       out.writeInt(CellUtil.estimatedSerializedSizeOfKey(kv));
       out.writeInt(0);
-      CellUtil.writeFlatKey(kv, out);
+      InternalCellUtil.writeFlatKey(kv, out);
     }
 
     @Override
@@ -555,7 +556,7 @@ public class Import extends Configured implements Tool {
          * submit multiple DeleteFamily tombstones in single Delete request then we are maintaining
          * only newest in hbase table and ignoring other. Check - HBASE-12065
          */
-        if (CellUtil.isDeleteFamily(kv)) {
+        if (InternalCellUtil.isDeleteFamily(kv)) {
           Delete deleteFamily = new Delete(key.get());
           deleteFamily.add(kv);
           if (durability != null) {
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/TableSnapshotInputFormatImpl.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/TableSnapshotInputFormatImpl.java
index bcaa448..76a465f 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/TableSnapshotInputFormatImpl.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/TableSnapshotInputFormatImpl.java
@@ -25,10 +25,10 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HDFSBlocksDistribution;
 import org.apache.hadoop.hbase.HDFSBlocksDistribution.HostAndWeight;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.client.ClientSideRegionScanner;
 import org.apache.hadoop.hbase.client.IsolationLevel;
@@ -363,7 +363,7 @@ public class TableSnapshotInputFormatImpl {
       if (numSplits > 1) {
         byte[][] sp = sa.split(hri.getStartKey(), hri.getEndKey(), numSplits, true);
         for (int i = 0; i < sp.length - 1; i++) {
-          if (CellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(), sp[i],
+          if (InternalCellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(), sp[i],
                   sp[i + 1])) {
             // compute HDFS locations from snapshot files (which will get the locations for
             // referred hfiles)
@@ -379,8 +379,8 @@ public class TableSnapshotInputFormatImpl {
           }
         }
       } else {
-        if (CellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(), hri.getStartKey(),
-                hri.getEndKey())) {
+        if (InternalCellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(),
+          hri.getStartKey(), hri.getEndKey())) {
           // compute HDFS locations from snapshot files (which will get the locations for
           // referred hfiles)
           List<String> hosts = getBestLocations(conf,
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/WALPlayer.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/WALPlayer.java
index 02c4640..eff50ce 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/WALPlayer.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/WALPlayer.java
@@ -211,7 +211,7 @@ public class WALPlayer extends Configured implements Tool {
               // Aggregate as much as possible into a single Put/Delete
               // operation before writing to the context.
               if (lastCell == null || lastCell.getTypeByte() != cell.getTypeByte()
-                  || !CellUtil.matchingRow(lastCell, cell)) {
+                  || !CellUtil.matchingRows(lastCell, cell)) {
                 // row or type changed, write out aggregate KVs.
                 if (put != null) {
                   context.write(tableOut, put);
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/util/MapReduceCell.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/util/MapReduceCell.java
index c0f74a5..60c9511 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/util/MapReduceCell.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/util/MapReduceCell.java
@@ -25,6 +25,7 @@ import org.apache.hadoop.hbase.ByteBufferCell;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.ExtendedCell;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 
 /**
@@ -226,17 +227,17 @@ public class MapReduceCell extends ByteBufferCell implements ExtendedCell {
 
   @Override
   public void setSequenceId(long seqId) throws IOException {
-    CellUtil.setSequenceId(cell, seqId);
+    InternalCellUtil.setSequenceId(cell, seqId);
   }
 
   @Override
   public void setTimestamp(long ts) throws IOException {
-    CellUtil.setTimestamp(cell, ts);
+    InternalCellUtil.setTimestamp(cell, ts);
   }
 
   @Override
   public void setTimestamp(byte[] ts, int tsOffset) throws IOException {
-    CellUtil.setTimestamp(cell, ts, tsOffset);
+    InternalCellUtil.setTimestamp(cell, ts, tsOffset);
   }
 
   @Override
@@ -246,7 +247,7 @@ public class MapReduceCell extends ByteBufferCell implements ExtendedCell {
 
   @Override
   public int write(OutputStream out, boolean withTags) throws IOException {
-    return CellUtil.writeCell(cell, out, withTags);
+    return InternalCellUtil.writeCell(cell, out, withTags);
   }
 
   @Override
@@ -256,13 +257,13 @@ public class MapReduceCell extends ByteBufferCell implements ExtendedCell {
 
   @Override
   public void write(ByteBuffer buf, int offset) {
-    CellUtil.writeCellToBuffer(cell, buf, offset);
+    InternalCellUtil.writeCellToBuffer(cell, buf, offset);
   }
 
   @Override
   public ExtendedCell deepClone() {
     try {
-      return (ExtendedCell) CellUtil.deepClone(cell);
+      return (ExtendedCell) InternalCellUtil.deepClone(cell);
     } catch (CloneNotSupportedException e) {
       throw new RuntimeException(e);
     }
diff --git a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestCellBasedHFileOutputFormat2.java b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestCellBasedHFileOutputFormat2.java
index 28a7be1..c6311f2 100644
--- a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestCellBasedHFileOutputFormat2.java
+++ b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestCellBasedHFileOutputFormat2.java
@@ -715,7 +715,7 @@ public class TestCellBasedHFileOutputFormat2  {
             assertEquals(FAMILIES.length, res.rawCells().length);
             Cell first = res.rawCells()[0];
             for (Cell kv : res.rawCells()) {
-              assertTrue(CellUtil.matchingRow(first, kv));
+              assertTrue(CellUtil.matchingRows(first, kv));
               assertTrue(Bytes.equals(CellUtil.cloneValue(first), CellUtil.cloneValue(kv)));
             }
           }
diff --git a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestCellBasedImportExport2.java b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestCellBasedImportExport2.java
index 59fb553..6e48627 100644
--- a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestCellBasedImportExport2.java
+++ b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestCellBasedImportExport2.java
@@ -44,6 +44,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeepDeletedCells;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.TableName;
@@ -375,7 +376,7 @@ public class TestCellBasedImportExport2 {
       ResultScanner scanner = t.getScanner(s);
       Result r = scanner.next();
       Cell[] res = r.rawCells();
-      assertTrue(CellUtil.isDeleteFamily(res[0]));
+      assertTrue(InternalCellUtil.isDeleteFamily(res[0]));
       assertEquals(now+4, res[1].getTimestamp());
       assertEquals(now+3, res[2].getTimestamp());
       assertTrue(CellUtil.isDelete(res[3]));
diff --git a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestHFileOutputFormat2.java b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestHFileOutputFormat2.java
index ec19b2e..464cf79 100644
--- a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestHFileOutputFormat2.java
+++ b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestHFileOutputFormat2.java
@@ -716,7 +716,7 @@ public class TestHFileOutputFormat2  {
             assertEquals(FAMILIES.length, res.rawCells().length);
             Cell first = res.rawCells()[0];
             for (Cell kv : res.rawCells()) {
-              assertTrue(CellUtil.matchingRow(first, kv));
+              assertTrue(CellUtil.matchingRows(first, kv));
               assertTrue(Bytes.equals(CellUtil.cloneValue(first), CellUtil.cloneValue(kv)));
             }
           }
diff --git a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java
index 1928e81..3460c8e 100644
--- a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java
+++ b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java
@@ -44,6 +44,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeepDeletedCells;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.TableName;
@@ -375,7 +376,7 @@ public class TestImportExport {
       ResultScanner scanner = t.getScanner(s);
       Result r = scanner.next();
       Cell[] res = r.rawCells();
-      assertTrue(CellUtil.isDeleteFamily(res[0]));
+      assertTrue(InternalCellUtil.isDeleteFamily(res[0]));
       assertEquals(now+4, res[1].getTimestamp());
       assertEquals(now+3, res[2].getTimestamp());
       assertTrue(CellUtil.isDelete(res[3]));
diff --git a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestSyncTable.java b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestSyncTable.java
index 9a0c160..1e940d4 100644
--- a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestSyncTable.java
+++ b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestSyncTable.java
@@ -145,7 +145,7 @@ public class TestSyncTable {
         Cell sourceCell = sourceCells[j];
         Cell targetCell = targetCells[j];
         try {
-          if (!CellUtil.matchingRow(sourceCell, targetCell)) {
+          if (!CellUtil.matchingRows(sourceCell, targetCell)) {
             Assert.fail("Rows don't match");
           }
           if (!CellUtil.matchingFamily(sourceCell, targetCell)) {
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/PrefixTreeSeeker.java b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/PrefixTreeSeeker.java
index 4fbb8a6..f04fa29 100644
--- a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/PrefixTreeSeeker.java
+++ b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/PrefixTreeSeeker.java
@@ -24,6 +24,7 @@ import org.apache.hadoop.hbase.ByteBufferCell;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.SettableSequenceId;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -81,7 +82,7 @@ public class PrefixTreeSeeker implements EncodedSeeker {
 
   @Override
   public ByteBuffer getValueShallowCopy() {
-    return CellUtil.getValueBufferShallowCopy(ptSearcher.current());
+    return InternalCellUtil.getValueBufferShallowCopy(ptSearcher.current());
   }
 
   /**
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArrayScanner.java b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArrayScanner.java
index 44d2852..f22528e 100644
--- a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArrayScanner.java
+++ b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArrayScanner.java
@@ -22,6 +22,7 @@ import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellScanner;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.codec.prefixtree.PrefixTreeBlockMeta;
 import org.apache.hadoop.hbase.codec.prefixtree.decode.column.ColumnReader;
 import org.apache.hadoop.hbase.codec.prefixtree.decode.row.RowNodeReader;
@@ -420,7 +421,7 @@ public class PrefixTreeArrayScanner extends PrefixTreeCell implements CellScanne
 
   protected int populateNonRowFieldsAndCompareTo(int cellNum, Cell key) {
     populateNonRowFields(cellNum);
-    return CellUtil.compareKeyIgnoresMvcc(comparator, this, key);
+    return InternalCellUtil.compareKeyIgnoresMvcc(comparator, this, key);
   }
 
   protected void populateFirstNonRowFields() {
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArraySearcher.java b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArraySearcher.java
index c993d12..3ce1b15 100644
--- a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArraySearcher.java
+++ b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArraySearcher.java
@@ -21,6 +21,7 @@ package org.apache.hadoop.hbase.codec.prefixtree.decode;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.codec.prefixtree.PrefixTreeBlockMeta;
 import org.apache.hadoop.hbase.codec.prefixtree.scanner.CellScannerPosition;
 import org.apache.hadoop.hbase.codec.prefixtree.scanner.CellSearcher;
@@ -91,7 +92,7 @@ public class PrefixTreeArraySearcher extends PrefixTreeArrayReversibleScanner im
       }
 
       //keep hunting for the rest of the row
-      byte searchForByte = CellUtil.getRowByte(key, currentNodeDepth);
+      byte searchForByte = InternalCellUtil.getRowByte(key, currentNodeDepth);
       fanIndex = currentRowNode.whichFanNode(searchForByte);
       if(fanIndex < 0){//no matching row.  return early
         int insertionPoint = -fanIndex - 1;
@@ -140,7 +141,7 @@ public class PrefixTreeArraySearcher extends PrefixTreeArrayReversibleScanner im
       }
 
       //keep hunting for the rest of the row
-      byte searchForByte = CellUtil.getRowByte(key, currentNodeDepth);
+      byte searchForByte = InternalCellUtil.getRowByte(key, currentNodeDepth);
       fanIndex = currentRowNode.whichFanNode(searchForByte);
       if(fanIndex < 0){//no matching row.  return early
         int insertionPoint = -fanIndex - 1;
@@ -287,7 +288,7 @@ public class PrefixTreeArraySearcher extends PrefixTreeArrayReversibleScanner im
       if (i >= key.getRowLength()) {// key was shorter, so it's first
         return -1;
       }
-      byte keyByte = CellUtil.getRowByte(key, i);
+      byte keyByte = InternalCellUtil.getRowByte(key, i);
       byte thisByte = rowBuffer[i];
       if (keyByte == thisByte) {
         continue;
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeCell.java b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeCell.java
index ca8c378..cfd444a 100644
--- a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeCell.java
+++ b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeCell.java
@@ -24,7 +24,7 @@ import org.apache.hadoop.hbase.ByteBufferCell;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellComparatorImpl;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.SettableSequenceId;
@@ -107,7 +107,7 @@ public class PrefixTreeCell extends ByteBufferCell implements SettableSequenceId
       return false;
     }
     // Temporary hack to maintain backwards compatibility with KeyValue.equals
-    return CellUtil.equalsIgnoreMvccVersion(this, (Cell) obj);
+    return InternalCellUtil.equalsIgnoreMvccVersion(this, (Cell) obj);
 
     // TODO return CellComparator.equals(this, (Cell)obj);//see HBASE-6907
   }
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/encode/PrefixTreeEncoder.java b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/encode/PrefixTreeEncoder.java
index 5c4eed8..65839e2 100644
--- a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/encode/PrefixTreeEncoder.java
+++ b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/encode/PrefixTreeEncoder.java
@@ -26,6 +26,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.codec.prefixtree.PrefixTreeBlockMeta;
 import org.apache.hadoop.hbase.codec.prefixtree.encode.column.ColumnSectionWriter;
@@ -274,7 +275,7 @@ public class PrefixTreeEncoder implements CellOutputStream {
   public void write(Cell cell) {
     ensurePerCellCapacities();
 
-    rowTokenizer.addSorted(CellUtil.fillRowRange(cell, rowRange));
+    rowTokenizer.addSorted(InternalCellUtil.fillRowRange(cell, rowRange));
     addFamilyPart(cell);
     addQualifierPart(cell);
     addTagPart(cell);
@@ -283,7 +284,7 @@ public class PrefixTreeEncoder implements CellOutputStream {
 
 
   private void addTagPart(Cell cell) {
-    CellUtil.fillTagRange(cell, tagsRange);
+    InternalCellUtil.fillTagRange(cell, tagsRange);
     tagsDeduplicator.add(tagsRange);
   }
 
@@ -329,13 +330,13 @@ public class PrefixTreeEncoder implements CellOutputStream {
 
   private void addFamilyPart(Cell cell) {
     if (MULITPLE_FAMILIES_POSSIBLE || totalCells == 0) {
-      CellUtil.fillFamilyRange(cell, familyRange);
+      InternalCellUtil.fillFamilyRange(cell, familyRange);
       familyDeduplicator.add(familyRange);
     }
   }
 
   private void addQualifierPart(Cell cell) {
-    CellUtil.fillQualifierRange(cell, qualifierRange);
+    InternalCellUtil.fillQualifierRange(cell, qualifierRange);
     qualifierDeduplicator.add(qualifierRange);
   }
 
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/BaseTestRowData.java b/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/BaseTestRowData.java
index 95df90f..d006740 100644
--- a/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/BaseTestRowData.java
+++ b/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/BaseTestRowData.java
@@ -37,7 +37,7 @@ public abstract class BaseTestRowData implements TestRowData {
     for (int i = 1; i < inputs.size(); ++i) {
       KeyValue lastKv = inputs.get(i - 1);
       KeyValue kv = inputs.get(i);
-      if (!CellUtil.matchingRow(lastKv, kv)) {
+      if (!CellUtil.matchingRows(lastKv, kv)) {
         rowStartIndexes.add(i);
       }
     }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/client/TableSnapshotScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/client/TableSnapshotScanner.java
index ab361c1..23b2809 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/client/TableSnapshotScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/client/TableSnapshotScanner.java
@@ -30,6 +30,7 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.snapshot.RestoreSnapshotHelper;
 import org.apache.hadoop.hbase.util.FSUtils;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -128,7 +129,7 @@ public class TableSnapshotScanner extends AbstractClientScanner {
       if (hri.isOffline() && (hri.isSplit() || hri.isSplitParent())) {
         continue;
       }
-      if (CellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(), hri.getStartKey(),
+      if (InternalCellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(), hri.getStartKey(),
         hri.getEndKey())) {
         regions.add(hri);
       }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
index fec17bc..0aac2d6 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
@@ -32,6 +32,7 @@ import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.Scan;
 import org.apache.hadoop.hbase.io.hfile.CacheConfig;
@@ -210,11 +211,11 @@ public class HalfStoreFileReader extends StoreFileReader {
       @Override
       public int seekTo(Cell key) throws IOException {
         if (top) {
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) < 0) {
+          if (InternalCellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) < 0) {
             return -1;
           }
         } else {
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
+          if (InternalCellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
             // we would place the scanner in the second half.
             // it might be an error to return false here ever...
             boolean res = delegate.seekBefore(splitCell);
@@ -235,11 +236,11 @@ public class HalfStoreFileReader extends StoreFileReader {
         // except
         // that we call reseekTo (and not seekTo) on the delegate.
         if (top) {
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) < 0) {
+          if (InternalCellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) < 0) {
             return -1;
           }
         } else {
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
+          if (InternalCellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
             // we would place the scanner in the second half.
             // it might be an error to return false here ever...
             boolean res = delegate.seekBefore(splitCell);
@@ -261,13 +262,13 @@ public class HalfStoreFileReader extends StoreFileReader {
       public boolean seekBefore(Cell key) throws IOException {
         if (top) {
           Optional<Cell> fk = getFirstKey();
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, fk.get()) <= 0) {
+          if (InternalCellUtil.compareKeyIgnoresMvcc(getComparator(), key, fk.get()) <= 0) {
             return false;
           }
         } else {
           // The equals sign isn't strictly necessary just here to be consistent
           // with seekTo
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
+          if (InternalCellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
             boolean ret = this.delegate.seekBefore(splitCell);
             if (ret) {
               atEnd = false;
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlockIndex.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlockIndex.java
index ead156b..d58fa66 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlockIndex.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlockIndex.java
@@ -39,6 +39,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 //import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.KeyOnlyKeyValue;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -767,7 +768,7 @@ public class HFileBlockIndex {
         // TODO avoid array call.
         nonRootIndex.asSubByteBuffer(midKeyOffset, midLength, pair);
         nonRootIndexkeyOnlyKV.setKey(pair.getFirst(), pair.getSecond(), midLength);
-        int cmp = CellUtil.compareKeyIgnoresMvcc(comparator, key, nonRootIndexkeyOnlyKV);
+        int cmp = InternalCellUtil.compareKeyIgnoresMvcc(comparator, key, nonRootIndexkeyOnlyKV);
 
         // key lives above the midpoint
         if (cmp > 0)
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java
index 7068fe1..73fdce3 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java
@@ -37,6 +37,7 @@ import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.ByteBufferKeyValue;
 import org.apache.hadoop.hbase.SizeCachedKeyValue;
@@ -728,7 +729,8 @@ public class HFileReaderImpl implements HFile.Reader, Configurable {
         offsetFromPos += Bytes.SIZEOF_LONG;
         blockBuffer.asSubByteBuffer(blockBuffer.position() + offsetFromPos, klen, pair);
         bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), klen);
-        int comp = CellUtil.compareKeyIgnoresMvcc(reader.getComparator(), key, bufBackedKeyOnlyKv);
+        int comp =
+            InternalCellUtil.compareKeyIgnoresMvcc(reader.getComparator(), key, bufBackedKeyOnlyKv);
         offsetFromPos += klen + vlen;
         if (this.reader.getFileContext().isIncludesTags()) {
           // Read short as unsigned, high byte first
@@ -811,7 +813,7 @@ public class HFileReaderImpl implements HFile.Reader, Configurable {
         } else {
           // The comparison with no_next_index_key has to be checked
           if (this.nextIndexedKey != null &&
-              (this.nextIndexedKey == KeyValueScanner.NO_NEXT_INDEXED_KEY || CellUtil
+              (this.nextIndexedKey == KeyValueScanner.NO_NEXT_INDEXED_KEY || InternalCellUtil
                   .compareKeyIgnoresMvcc(reader.getComparator(), key, nextIndexedKey) < 0)) {
             // The reader shall continue to scan the current data block instead
             // of querying the
@@ -865,7 +867,7 @@ public class HFileReaderImpl implements HFile.Reader, Configurable {
         return false;
       }
       Cell firstKey = getFirstKeyCellInBlock(seekToBlock);
-      if (CellUtil.compareKeyIgnoresMvcc(reader.getComparator(), firstKey, key) >= 0) {
+      if (InternalCellUtil.compareKeyIgnoresMvcc(reader.getComparator(), firstKey, key) >= 0) {
         long previousBlockOffset = seekToBlock.getPrevBlockOffset();
         // The key we are interested in
         if (previousBlockOffset == -1) {
@@ -1229,7 +1231,7 @@ public class HFileReaderImpl implements HFile.Reader, Configurable {
     public int compareKey(CellComparator comparator, Cell key) {
       blockBuffer.asSubByteBuffer(blockBuffer.position() + KEY_VALUE_LEN_SIZE, currKeyLen, pair);
       this.bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), currKeyLen);
-      return CellUtil.compareKeyIgnoresMvcc(comparator, key, this.bufBackedKeyOnlyKv);
+      return InternalCellUtil.compareKeyIgnoresMvcc(comparator, key, this.bufBackedKeyOnlyKv);
     }
 
     @Override
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java
index 33cfa1d..cb1c123 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java
@@ -39,6 +39,7 @@ import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.CellComparatorImpl.MetaCellComparator;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -239,7 +240,7 @@ public class HFileWriterImpl implements HFile.Writer {
       throw new IOException("Key cannot be null or empty");
     }
     if (lastCell != null) {
-      int keyComp = CellUtil.compareKeyIgnoresMvcc(comparator, lastCell, cell);
+      int keyComp = InternalCellUtil.compareKeyIgnoresMvcc(comparator, lastCell, cell);
 
       if (keyComp > 0) {
         throw new IOException("Added a key not lexically larger than"
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/DefaultMobStoreCompactor.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/DefaultMobStoreCompactor.java
index 502a446..6593cf3 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/DefaultMobStoreCompactor.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/DefaultMobStoreCompactor.java
@@ -30,6 +30,7 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.regionserver.CellSink;
@@ -248,7 +249,7 @@ public class DefaultMobStoreCompactor extends DefaultCompactor {
                 Cell mobCell = mobStore.resolve(c, false);
                 if (mobCell.getValueLength() != 0) {
                   // put the mob data back to the store file
-                  CellUtil.setSequenceId(mobCell, c.getSequenceId());
+                  InternalCellUtil.setSequenceId(mobCell, c.getSequenceId());
                   writer.append(mobCell);
                   cellsCountCompactedFromMob++;
                   cellsSizeCompactedFromMob += mobCell.getValueLength();
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java
index c66c571..027d580 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java
@@ -45,6 +45,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagType;
@@ -175,7 +176,7 @@ public final class MobUtils {
    */
   public static boolean isMobReferenceCell(Cell cell) {
     if (cell.getTagsLength() > 0) {
-      Tag tag = CellUtil.getTag(cell, TagType.MOB_REFERENCE_TAG_TYPE);
+      Tag tag = InternalCellUtil.getTag(cell, TagType.MOB_REFERENCE_TAG_TYPE);
       return tag != null;
     }
     return false;
@@ -188,7 +189,7 @@ public final class MobUtils {
    */
   public static Tag getTableNameTag(Cell cell) {
     if (cell.getTagsLength() > 0) {
-      return CellUtil.getTag(cell, TagType.MOB_TABLE_NAME_TAG_TYPE);
+      return InternalCellUtil.getTag(cell, TagType.MOB_TABLE_NAME_TAG_TYPE);
     }
     return null;
   }
@@ -501,7 +502,7 @@ public final class MobUtils {
 
   public static Cell createMobRefCell(Cell cell, byte[] fileName, byte[] refCellTags) {
     byte[] refValue = Bytes.add(Bytes.toBytes(cell.getValueLength()), fileName);
-    return CellUtil.createCell(cell, refValue, TagUtil.concatTags(refCellTags, cell));
+    return InternalCellUtil.createCell(cell, refValue, TagUtil.concatTags(refCellTags, cell));
   }
 
   /**
@@ -761,7 +762,7 @@ public final class MobUtils {
    * @return The real mob value length.
    */
   public static int getMobValueLength(Cell cell) {
-    return CellUtil.getValueAsInt(cell);
+    return InternalCellUtil.getValueAsInt(cell);
   }
 
   /**
@@ -891,7 +892,7 @@ public final class MobUtils {
    * @return A delete marker with the ref tag.
    */
   public static Cell createMobRefDeleteMarker(Cell cell) {
-    return CellUtil.createCell(cell, TagUtil.concatTags(REF_DELETE_MARKER_TAG_BYTES, cell));
+    return InternalCellUtil.createCell(cell, TagUtil.concatTags(REF_DELETE_MARKER_TAG_BYTES, cell));
   }
 
   /**
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
index 99f5c35..5ee29dc 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
@@ -91,6 +91,7 @@ import org.apache.hadoop.hbase.ExtendedCellBuilderFactory;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HConstants.OperationStatusCode;
 import org.apache.hadoop.hbase.HDFSBlocksDistribution;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.NamespaceDescriptor;
@@ -2944,7 +2945,8 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
         Cell cell = cells.get(i);
         //  Check if time is LATEST, change to time of most recent addition if so
         //  This is expensive.
-        if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP && CellUtil.isDeleteType(cell)) {
+        if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP
+            && InternalCellUtil.isDeleteType(cell)) {
           byte[] qual = CellUtil.cloneQualifier(cell);
 
           Integer count = kvCount.get(qual);
@@ -2967,7 +2969,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
             updateDeleteLatestVersionTimeStamp(cell, get, count, byteNow);
           }
         } else {
-          CellUtil.updateLatestStamp(cell, byteNow, 0);
+          InternalCellUtil.updateLatestStamp(cell, byteNow, 0);
         }
       }
     }
@@ -2979,14 +2981,14 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
 
     if (result.size() < count) {
       // Nothing to delete
-      CellUtil.updateLatestStamp(cell, byteNow, 0);
+      InternalCellUtil.updateLatestStamp(cell, byteNow, 0);
       return;
     }
     if (result.size() > count) {
       throw new RuntimeException("Unexpected size: " + result.size());
     }
     Cell getCell = result.get(count - 1);
-    CellUtil.setTimestamp(cell, getCell.getTimestamp());
+    InternalCellUtil.setTimestamp(cell, getCell.getTimestamp());
   }
 
   @Override
@@ -3739,7 +3741,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
         } else if (result.size() == 1 && !valueIsNull) {
           Cell kv = result.get(0);
           cellTs = kv.getTimestamp();
-          int compareResult = CellUtil.compareValue(kv, comparator);
+          int compareResult = InternalCellUtil.compareValue(kv, comparator);
           matches = matches(op, compareResult);
         }
         // If matches put the new put or delete the new delete
@@ -3862,7 +3864,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
     for (List<Cell> cells: cellItr) {
       if (cells == null) return;
       for (Cell cell : cells) {
-        CellUtil.setSequenceId(cell, sequenceId);
+        InternalCellUtil.setSequenceId(cell, sequenceId);
       }
     }
   }
@@ -3880,7 +3882,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
       assert cells instanceof RandomAccess;
       int listSize = cells.size();
       for (int i = 0; i < listSize; i++) {
-        CellUtil.updateLatestStamp(cells.get(i), now, 0);
+        InternalCellUtil.updateLatestStamp(cells.get(i), now, 0);
       }
     }
   }
@@ -3905,7 +3907,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
         List<Tag> newTags = TagUtil.carryForwardTags(null, cell);
         newTags = TagUtil.carryForwardTTLTag(newTags, m.getTTL());
         // Rewrite the cell with the updated set of tags
-        cells.set(i, CellUtil.createCell(cell, newTags));
+        cells.set(i, InternalCellUtil.createCell(cell, newTags));
       }
     }
   }
@@ -4388,7 +4390,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
               skippedEdits++;
               continue;
             }
-            CellUtil.setSequenceId(cell, currentReplaySeqId);
+            InternalCellUtil.setSequenceId(cell, currentReplaySeqId);
 
             restoreEdit(store, cell, memstoreSize);
             editsCount++;
@@ -6157,7 +6159,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
      * @return true When there are more cells in the row to be read
      */
     private boolean moreCellsInRow(final Cell nextKv, Cell currentRowCell) {
-      return nextKv != null && CellUtil.matchingRow(nextKv, currentRowCell);
+      return nextKv != null && CellUtil.matchingRows(nextKv, currentRowCell);
     }
 
     /*
@@ -6398,7 +6400,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
         throws IOException {
       Cell nextJoinedKv = joinedHeap.peek();
       boolean matchCurrentRow =
-          nextJoinedKv != null && CellUtil.matchingRow(nextJoinedKv, currentRowCell);
+          nextJoinedKv != null && CellUtil.matchingRows(nextJoinedKv, currentRowCell);
       boolean matchAfterSeek = false;
 
       // If the next value in the joined heap does not match the current row, try to seek to the
@@ -6408,7 +6410,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
         boolean seekSuccessful = this.joinedHeap.requestSeek(firstOnCurrentRow, true, true);
         matchAfterSeek =
             seekSuccessful && joinedHeap.peek() != null
-                && CellUtil.matchingRow(joinedHeap.peek(), currentRowCell);
+                && CellUtil.matchingRows(joinedHeap.peek(), currentRowCell);
       }
 
       return matchCurrentRow || matchAfterSeek;
@@ -6436,7 +6438,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
       assert this.joinedContinuationRow == null: "Trying to go to next row during joinedHeap read.";
       Cell next;
       while ((next = this.storeHeap.peek()) != null &&
-             CellUtil.matchingRow(next, curRowCell)) {
+             CellUtil.matchingRows(next, curRowCell)) {
         this.storeHeap.next(MOCKED_LIST);
       }
       resetFilters();
@@ -7156,7 +7158,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
               if (walEdit.isEmpty()) {
                 // If walEdit is empty, we put nothing in WAL. WAL stamps Cells with sequence id.
                 // If no WAL, need to stamp it here.
-                CellUtil.setSequenceId(cell, sequenceId);
+                InternalCellUtil.setSequenceId(cell, sequenceId);
               }
               applyToMemStore(getStore(cell), cell, memstoreSize);
             }
@@ -7575,8 +7577,8 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
               .setTags(TagUtil.fromList(tags))
               .build();
     } else {
-      CellUtil.updateLatestStamp(delta, now);
-      return CollectionUtils.isEmpty(tags) ? delta : CellUtil.createCell(delta, tags);
+      InternalCellUtil.updateLatestStamp(delta, now);
+      return CollectionUtils.isEmpty(tags) ? delta : InternalCellUtil.createCell(delta, tags);
     }
   }
 
@@ -7589,7 +7591,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
       // throw DoNotRetryIOException instead of IllegalArgumentException
       throw new DoNotRetryIOException("Field is not a long, it's " + len + " bytes wide");
     }
-    return CellUtil.getValueAsLong(cell);
+    return InternalCellUtil.getValueAsLong(cell);
   }
 
   /**
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedKeyValueHeap.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedKeyValueHeap.java
index 4d2ab9b..3997741 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedKeyValueHeap.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedKeyValueHeap.java
@@ -107,7 +107,7 @@ public class ReversedKeyValueHeap extends KeyValueHeap {
     KeyValueScanner scanner;
     while ((scanner = heap.poll()) != null) {
       Cell topKey = scanner.peek();
-      if ((CellUtil.matchingRow(seekKey, topKey) && comparator
+      if ((CellUtil.matchingRows(seekKey, topKey) && comparator
           .getComparator().compare(seekKey, topKey) <= 0)
           || comparator.getComparator().compareRows(seekKey, topKey) > 0) {
         heap.add(scanner);
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
index f52eb39..f6ae702 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
@@ -35,6 +35,7 @@ import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.yetus.audience.InterfaceStability;
 import org.apache.hadoop.hbase.client.Scan;
@@ -262,7 +263,7 @@ public class StoreFileScanner implements KeyValueScanner {
   protected void setCurrentCell(Cell newVal) throws IOException {
     this.cur = newVal;
     if (this.cur != null && this.reader.isBulkLoaded() && !this.reader.isSkipResetSeqId()) {
-      CellUtil.setSequenceId(cur, this.reader.getSequenceID());
+      InternalCellUtil.setSequenceId(cur, this.reader.getSequenceID());
     }
   }
 
@@ -381,7 +382,8 @@ public class StoreFileScanner implements KeyValueScanner {
       if (reader.getBloomFilterType() == BloomType.ROWCOL) {
         haveToSeek = reader.passesGeneralRowColBloomFilter(kv);
       } else if (canOptimizeForNonNullColumn
-          && ((CellUtil.isDeleteFamily(kv) || CellUtil.isDeleteFamilyVersion(kv)))) {
+          && ((InternalCellUtil.isDeleteFamily(kv)
+              || InternalCellUtil.isDeleteFamilyVersion(kv)))) {
         // if there is no such delete family kv in the store file,
         // then no need to seek.
         haveToSeek = reader.passesDeleteFamilyBloomFilter(kv.getRowArray(), kv.getRowOffset(),
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java
index 29bd3af..27546ae 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java
@@ -40,6 +40,7 @@ import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.ColumnFamilyDescriptorBuilder;
 import org.apache.hadoop.hbase.io.hfile.CacheConfig;
@@ -217,7 +218,7 @@ public class StoreFileWriter implements CellSink, ShipperListener {
 
   private void appendDeleteFamilyBloomFilter(final Cell cell)
       throws IOException {
-    if (!CellUtil.isDeleteFamily(cell) && !CellUtil.isDeleteFamilyVersion(cell)) {
+    if (!InternalCellUtil.isDeleteFamily(cell) && !InternalCellUtil.isDeleteFamilyVersion(cell)) {
       return;
     }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java
index 0456980..4686353 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java
@@ -29,6 +29,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.util.Bytes;
 
@@ -297,7 +298,7 @@ public abstract class StripeMultiFileWriter extends AbstractMultiFileWriter {
         sanityCheckLeft(left, cell);
         doCreateWriter = true;
       } else if (lastRowInCurrentWriter != null
-          && !CellUtil.matchingRow(cell, lastRowInCurrentWriter, 0,
+          && !InternalCellUtil.matchingRow(cell, lastRowInCurrentWriter, 0,
             lastRowInCurrentWriter.length)) {
         if (LOG.isDebugEnabled()) {
           LOG.debug("Stopping to use a writer after [" + Bytes.toString(lastRowInCurrentWriter)
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/TimeRangeTracker.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/TimeRangeTracker.java
index cefbd9a..ce1a839 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/TimeRangeTracker.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/TimeRangeTracker.java
@@ -25,6 +25,7 @@ import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.io.TimeRange;
 import org.apache.hadoop.hbase.util.Writables;
 import org.apache.hadoop.io.Writable;
@@ -101,7 +102,7 @@ public abstract class TimeRangeTracker implements Writable {
    */
   public void includeTimestamp(final Cell cell) {
     includeTimestamp(cell.getTimestamp());
-    if (CellUtil.isDeleteColumnOrFamily(cell)) {
+    if (InternalCellUtil.isDeleteColumnOrFamily(cell)) {
       includeTimestamp(0);
     }
   }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java
index f9efd98..f5474f9 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java
@@ -33,8 +33,8 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.io.compress.Compression;
 import org.apache.hadoop.hbase.io.hfile.HFile;
@@ -391,7 +391,7 @@ public abstract class Compactor<T extends CellSink> {
           if (cleanSeqId && c.getSequenceId() <= smallestReadPoint) {
             lastCleanCell = c;
             lastCleanCellSeqId = c.getSequenceId();
-            CellUtil.setSequenceId(c, 0);
+            InternalCellUtil.setSequenceId(c, 0);
           } else {
             lastCleanCell = null;
             lastCleanCellSeqId = 0;
@@ -421,7 +421,7 @@ public abstract class Compactor<T extends CellSink> {
               // HBASE-16931, set back sequence id to avoid affecting scan order unexpectedly.
               // ShipperListener will do a clone of the last cells it refer, so need to set back
               // sequence id before ShipperListener.beforeShipped
-              CellUtil.setSequenceId(lastCleanCell, lastCleanCellSeqId);
+              InternalCellUtil.setSequenceId(lastCleanCell, lastCleanCellSeqId);
             }
             // Clone the cells that are in the writer so that they are freed of references,
             // if they are holding any.
@@ -438,7 +438,7 @@ public abstract class Compactor<T extends CellSink> {
         }
         if (lastCleanCell != null) {
           // HBASE-16931, set back sequence id to avoid affecting scan order unexpectedly
-          CellUtil.setSequenceId(lastCleanCell, lastCleanCellSeqId);
+          InternalCellUtil.setSequenceId(lastCleanCell, lastCleanCellSeqId);
         }
         // Log the progress of long running compactions every minute if
         // logging at DEBUG level
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ExplicitColumnTracker.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ExplicitColumnTracker.java
index 16a22da..8de963c 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ExplicitColumnTracker.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ExplicitColumnTracker.java
@@ -23,6 +23,7 @@ import java.util.NavigableSet;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.querymatcher.ScanQueryMatcher.MatchCode;
 
@@ -103,7 +104,7 @@ public class ExplicitColumnTracker implements ColumnTracker {
   public ScanQueryMatcher.MatchCode checkColumn(Cell cell, byte type) {
     // delete markers should never be passed to an
     // *Explicit*ColumnTracker
-    assert !CellUtil.isDelete(type);
+    assert !InternalCellUtil.isDelete(type);
     do {
       // No more columns left, we are done with this query
       if (done()) {
@@ -152,7 +153,7 @@ public class ExplicitColumnTracker implements ColumnTracker {
   @Override
   public ScanQueryMatcher.MatchCode checkVersions(Cell cell, long timestamp, byte type,
       boolean ignoreCount) throws IOException {
-    assert !CellUtil.isDelete(type);
+    assert !InternalCellUtil.isDelete(type);
     if (ignoreCount) {
       return ScanQueryMatcher.MatchCode.INCLUDE;
     }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java
index 5d4077f..99f7a0e 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.ScanInfo;
 
@@ -58,7 +59,7 @@ public class MajorCompactionScanQueryMatcher extends DropDeletesCompactionScanQu
     // 7. Delete marker need to be version counted together with puts
     // they affect
     //
-    if (CellUtil.isDelete(typeByte)) {
+    if (InternalCellUtil.isDelete(typeByte)) {
       if (mvccVersion > maxReadPointToTrackVersions) {
         // We can not drop this delete marker yet, and also we should not use this delete marker to
         // mask any cell yet.
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java
index 989ea12..9e74ee7 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.ScanInfo;
 
@@ -43,7 +44,7 @@ public class MinorCompactionScanQueryMatcher extends CompactionScanQueryMatcher
     }
     long mvccVersion = cell.getSequenceId();
     byte typeByte = cell.getTypeByte();
-    if (CellUtil.isDelete(typeByte)) {
+    if (InternalCellUtil.isDelete(typeByte)) {
       if (mvccVersion > maxReadPointToTrackVersions) {
         // we should not use this delete marker to mask any cell yet.
         return MatchCode.INCLUDE;
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NewVersionBehaviorTracker.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NewVersionBehaviorTracker.java
index d7bec80..ba4eca9 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NewVersionBehaviorTracker.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NewVersionBehaviorTracker.java
@@ -30,6 +30,7 @@ import java.util.TreeSet;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.querymatcher.ScanQueryMatcher.MatchCode;
@@ -165,7 +166,8 @@ public class NewVersionBehaviorTracker implements ColumnTracker, DeleteTracker {
    * Else return MAX_VALUE.
    */
   protected long prepare(Cell cell) {
-    boolean matchCq = CellUtil.matchingQualifier(cell, lastCqArray, lastCqOffset, lastCqLength);
+    boolean matchCq =
+        InternalCellUtil.matchingQualifier(cell, lastCqArray, lastCqOffset, lastCqLength);
     if (!matchCq) {
       // The last cell is family-level delete and this is not, or the cq is changed,
       // we should construct delColMap as a deep copy of delFamMap.
@@ -175,7 +177,7 @@ public class NewVersionBehaviorTracker implements ColumnTracker, DeleteTracker {
       }
       countCurrentCol = 0;
     }
-    if (matchCq && !CellUtil.isDelete(lastCqType) && lastCqType == cell.getTypeByte()
+    if (matchCq && !InternalCellUtil.isDelete(lastCqType) && lastCqType == cell.getTypeByte()
         && lastCqTs == cell.getTimestamp()) {
       // Put with duplicate timestamp, ignore.
       return lastCqMvcc;
@@ -300,7 +302,7 @@ public class NewVersionBehaviorTracker implements ColumnTracker, DeleteTracker {
   @Override
   public MatchCode checkVersions(Cell cell, long timestamp, byte type,
       boolean ignoreCount) throws IOException {
-    assert !CellUtil.isDelete(type);
+    assert !InternalCellUtil.isDelete(type);
     // We drop old version in #isDeleted, so here we won't SKIP because of versioning. But we should
     // consider TTL.
     if (ignoreCount) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java
index c633bc5..a8a23d3 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeepDeletedCells;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.client.Scan;
@@ -66,7 +67,7 @@ public abstract class NormalUserScanQueryMatcher extends UserScanQueryMatcher {
     }
     long timestamp = cell.getTimestamp();
     byte typeByte = cell.getTypeByte();
-    if (CellUtil.isDelete(typeByte)) {
+    if (InternalCellUtil.isDelete(typeByte)) {
       boolean includeDeleteMarker = seePastDeleteMarkers ? tr.withinTimeRange(timestamp)
           : tr.withinOrAfterTimeRange(timestamp);
       if (includeDeleteMarker) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanQueryMatcher.java
index 8c1c4a3..16f289f 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanQueryMatcher.java
@@ -25,6 +25,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.KeyValueUtil;
@@ -148,7 +149,7 @@ public abstract class ScanQueryMatcher implements ShipperListener {
     // Look for a TTL tag first. Use it instead of the family setting if
     // found. If a cell has multiple TTLs, resolve the conflict by using the
     // first tag encountered.
-    Iterator<Tag> i = CellUtil.tagsIterator(cell);
+    Iterator<Tag> i = InternalCellUtil.tagsIterator(cell);
     while (i.hasNext()) {
       Tag t = i.next();
       if (TagType.TTL_TAG_TYPE == t.getType()) {
@@ -296,7 +297,7 @@ public abstract class ScanQueryMatcher implements ShipperListener {
     // see TestFromClientSide3#testScanAfterDeletingSpecifiedRow
     // see TestFromClientSide3#testScanAfterDeletingSpecifiedRowV2
     if (cell.getQualifierLength() == 0) {
-      Cell nextKey = CellUtil.createNextOnRowCol(cell);
+      Cell nextKey = InternalCellUtil.createNextOnRowCol(cell);
       if (nextKey != cell) {
         return nextKey;
       }
@@ -318,7 +319,7 @@ public abstract class ScanQueryMatcher implements ShipperListener {
    * @return result of the compare between the indexed key and the key portion of the passed cell
    */
   public int compareKeyForNextRow(Cell nextIndexed, Cell currentCell) {
-    return CellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell, 0, 0, null, 0,
+    return InternalCellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell, 0, 0, null, 0,
       0, HConstants.OLDEST_TIMESTAMP, Type.Minimum.getCode());
   }
 
@@ -330,10 +331,10 @@ public abstract class ScanQueryMatcher implements ShipperListener {
   public int compareKeyForNextColumn(Cell nextIndexed, Cell currentCell) {
     ColumnCount nextColumn = columns.getColumnHint();
     if (nextColumn == null) {
-      return CellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell, 0, 0, null,
+      return InternalCellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell, 0, 0, null,
         0, 0, HConstants.OLDEST_TIMESTAMP, Type.Minimum.getCode());
     } else {
-      return CellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell,
+      return InternalCellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell,
         currentCell.getFamilyOffset(), currentCell.getFamilyLength(), nextColumn.getBuffer(),
         nextColumn.getOffset(), nextColumn.getLength(), HConstants.LATEST_TIMESTAMP,
         Type.Maximum.getCode());
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanWildcardColumnTracker.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanWildcardColumnTracker.java
index 02267bf..037d215 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanWildcardColumnTracker.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanWildcardColumnTracker.java
@@ -24,6 +24,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.querymatcher.ScanQueryMatcher.MatchCode;
@@ -130,7 +131,7 @@ public class ScanWildcardColumnTracker implements ColumnTracker {
    * delete
    */
   private MatchCode checkVersion(byte type, long timestamp) {
-    if (!CellUtil.isDelete(type)) {
+    if (!InternalCellUtil.isDelete(type)) {
       currentCount++;
     }
     if (currentCount > maxVersions) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java
index ed0123d..d8cfb46 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.ScanInfo;
 
@@ -56,7 +57,7 @@ public class StripeCompactionScanQueryMatcher extends DropDeletesCompactionScanQ
     }
     long mvccVersion = cell.getSequenceId();
     byte typeByte = cell.getTypeByte();
-    if (CellUtil.isDelete(typeByte)) {
+    if (InternalCellUtil.isDelete(typeByte)) {
       if (mvccVersion > maxReadPointToTrackVersions) {
         return MatchCode.INCLUDE;
       }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/FSWALEntry.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/FSWALEntry.java
index 0b798a8..2e81b91 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/FSWALEntry.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/FSWALEntry.java
@@ -28,6 +28,7 @@ import java.util.TreeSet;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.client.RegionInfo;
 import org.apache.hadoop.hbase.regionserver.MultiVersionConcurrencyControl;
 import org.apache.hadoop.hbase.util.Bytes;
@@ -116,7 +117,7 @@ class FSWALEntry extends Entry {
     long regionSequenceId = we.getWriteNumber();
     if (!this.getEdit().isReplay() && inMemstore) {
       for (Cell c : getEdit().getCells()) {
-        CellUtil.setSequenceId(c, regionSequenceId);
+        InternalCellUtil.setSequenceId(c, regionSequenceId);
       }
     }
     getKey().setWriteEntry(we);
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/SecureWALCellCodec.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/SecureWALCellCodec.java
index eec0497..64950eb 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/SecureWALCellCodec.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/SecureWALCellCodec.java
@@ -28,7 +28,7 @@ import org.apache.commons.io.IOUtils;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.codec.KeyValueCodecWithTags;
@@ -208,19 +208,19 @@ public class SecureWALCellCodec extends WALCellCodec {
       // Write row, qualifier, and family
       short rowLength = cell.getRowLength();
       StreamUtils.writeRawVInt32(bos, rowLength);
-      CellUtil.writeRow(bos, cell, rowLength);
+      InternalCellUtil.writeRow(bos, cell, rowLength);
       byte familyLength = cell.getFamilyLength();
       StreamUtils.writeRawVInt32(bos, familyLength);
-      CellUtil.writeFamily(bos, cell, familyLength);
+      InternalCellUtil.writeFamily(bos, cell, familyLength);
       int qualifierLength = cell.getQualifierLength();
       StreamUtils.writeRawVInt32(bos, qualifierLength);
-      CellUtil.writeQualifier(bos, cell, qualifierLength);
+      InternalCellUtil.writeQualifier(bos, cell, qualifierLength);
       // Write the rest ie. ts, type, value and tags parts
       StreamUtils.writeLong(bos, cell.getTimestamp());
       bos.write(cell.getTypeByte());
-      CellUtil.writeValue(bos, cell, cell.getValueLength());
+      InternalCellUtil.writeValue(bos, cell, cell.getValueLength());
       if (tlen > 0) {
-        CellUtil.writeTags(bos, cell, tlen);
+        InternalCellUtil.writeTags(bos, cell, tlen);
       }
       bos.close();
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/WALCellCodec.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/WALCellCodec.java
index 50f8e13..8f46b1c 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/WALCellCodec.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/WALCellCodec.java
@@ -26,6 +26,7 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -208,21 +209,21 @@ public class WALCellCodec implements Codec {
       // To support tags
       int tagsLength = cell.getTagsLength();
       StreamUtils.writeRawVInt32(out, tagsLength);
-      CellUtil.compressRow(out, cell, compression.rowDict);
-      CellUtil.compressFamily(out, cell, compression.familyDict);
-      CellUtil.compressQualifier(out, cell, compression.qualifierDict);
+      InternalCellUtil.compressRow(out, cell, compression.rowDict);
+      InternalCellUtil.compressFamily(out, cell, compression.familyDict);
+      InternalCellUtil.compressQualifier(out, cell, compression.qualifierDict);
       // Write timestamp, type and value as uncompressed.
       StreamUtils.writeLong(out, cell.getTimestamp());
       out.write(cell.getTypeByte());
-      CellUtil.writeValue(out, cell, cell.getValueLength());
+      InternalCellUtil.writeValue(out, cell, cell.getValueLength());
       if (tagsLength > 0) {
         if (compression.tagCompressionContext != null) {
           // Write tags using Dictionary compression
-          CellUtil.compressTags(out, cell, compression.tagCompressionContext);
+          InternalCellUtil.compressTags(out, cell, compression.tagCompressionContext);
         } else {
           // Tag compression is disabled within the WAL compression. Just write the tags bytes as
           // it is.
-          CellUtil.writeTags(out, cell, tagsLength);
+          InternalCellUtil.writeTags(out, cell, tagsLength);
         }
       }
     }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSink.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSink.java
index 0fbc74f..05b1f21 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSink.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSink.java
@@ -305,7 +305,7 @@ public class ReplicationSink {
    */
   private boolean isNewRowOrType(final Cell previousCell, final Cell cell) {
     return previousCell == null || previousCell.getTypeByte() != cell.getTypeByte() ||
-        !CellUtil.matchingRow(previousCell, cell);
+        !CellUtil.matchingRows(previousCell, cell);
   }
 
   private java.util.UUID toUUID(final HBaseProtos.UUID uuid) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlFilter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlFilter.java
index 9a3353c..c452b05 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlFilter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlFilter.java
@@ -24,6 +24,7 @@ import java.util.Map;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.filter.FilterBase;
@@ -97,7 +98,7 @@ class AccessControlFilter extends FilterBase {
       return ReturnCode.INCLUDE;
     }
     if (prevFam.getBytes() == null
-        || !(CellUtil.matchingFamily(cell, prevFam.getBytes(), prevFam.getOffset(),
+        || !(InternalCellUtil.matchingFamily(cell, prevFam.getBytes(), prevFam.getOffset(),
             prevFam.getLength()))) {
       prevFam.set(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());
       // Similar to VisibilityLabelFilter
@@ -106,7 +107,7 @@ class AccessControlFilter extends FilterBase {
       prevQual.unset();
     }
     if (prevQual.getBytes() == null
-        || !(CellUtil.matchingQualifier(cell, prevQual.getBytes(), prevQual.getOffset(),
+        || !(InternalCellUtil.matchingQualifier(cell, prevQual.getBytes(), prevQual.getOffset(),
             prevQual.getLength()))) {
       prevQual.set(cell.getQualifierArray(), cell.getQualifierOffset(),
           cell.getQualifierLength());
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java
index 6c2eb60..490ef04 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java
@@ -19,6 +19,7 @@
 package org.apache.hadoop.hbase.security.access;
 
 import org.apache.hadoop.hbase.CompareOperator;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.client.Admin;
 import org.apache.hadoop.hbase.shaded.com.google.common.collect.ArrayListMultimap;
 import org.apache.hadoop.hbase.shaded.com.google.common.collect.ListMultimap;
@@ -739,7 +740,7 @@ public class AccessControlLists {
       return null;
     }
     List<Permission> results = Lists.newArrayList();
-    Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsIterator = InternalCellUtil.tagsIterator(cell);
     while (tagsIterator.hasNext()) {
       Tag tag = tagsIterator.next();
       if (tag.getType() == ACL_TAG_TYPE) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java
index be027c5..265734a 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java
@@ -52,6 +52,7 @@ import org.apache.hadoop.hbase.CoprocessorEnvironment;
 import org.apache.hadoop.hbase.DoNotRetryIOException;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.NamespaceDescriptor;
@@ -896,11 +897,11 @@ public class AccessController implements MasterCoprocessor, RegionCoprocessor,
         // Prepend the supplied perms in a new ACL tag to an update list of tags for the cell
         List<Tag> tags = new ArrayList<>();
         tags.add(new ArrayBackedTag(AccessControlLists.ACL_TAG_TYPE, perms));
-        Iterator<Tag> tagIterator = CellUtil.tagsIterator(cell);
+        Iterator<Tag> tagIterator = InternalCellUtil.tagsIterator(cell);
         while (tagIterator.hasNext()) {
           tags.add(tagIterator.next());
         }
-        newCells.add(CellUtil.createCell(cell, tags));
+        newCells.add(InternalCellUtil.createCell(cell, tags));
       }
       // This is supposed to be safe, won't CME
       e.setValue(newCells);
@@ -925,7 +926,7 @@ public class AccessController implements MasterCoprocessor, RegionCoprocessor,
       return;
     }
     for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {
-      Iterator<Tag> tagsItr = CellUtil.tagsIterator(cellScanner.current());
+      Iterator<Tag> tagsItr = InternalCellUtil.tagsIterator(cellScanner.current());
       while (tagsItr.hasNext()) {
         if (tagsItr.next().getType() == AccessControlLists.ACL_TAG_TYPE) {
           throw new AccessDeniedException("Mutation contains cell with reserved type tag");
@@ -2096,7 +2097,7 @@ public class AccessController implements MasterCoprocessor, RegionCoprocessor,
     List<Tag> aclTags = Lists.newArrayList();
     ListMultimap<String,Permission> perms = ArrayListMultimap.create();
     if (oldCell != null) {
-      Iterator<Tag> tagIterator = CellUtil.tagsIterator(oldCell);
+      Iterator<Tag> tagIterator = InternalCellUtil.tagsIterator(oldCell);
       while (tagIterator.hasNext()) {
         Tag tag = tagIterator.next();
         if (tag.getType() != AccessControlLists.ACL_TAG_TYPE) {
@@ -2135,7 +2136,7 @@ public class AccessController implements MasterCoprocessor, RegionCoprocessor,
       return newCell;
     }
 
-    Cell rewriteCell = CellUtil.createCell(newCell, tags);
+    Cell rewriteCell = InternalCellUtil.createCell(newCell, tags);
     return rewriteCell;
   }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/DefaultVisibilityLabelServiceImpl.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/DefaultVisibilityLabelServiceImpl.java
index 5bd7c3f..c470aa8 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/DefaultVisibilityLabelServiceImpl.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/DefaultVisibilityLabelServiceImpl.java
@@ -47,6 +47,7 @@ import org.apache.hadoop.hbase.AuthUtil;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants.OperationStatusCode;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagType;
 import org.apache.hadoop.hbase.TagUtil;
@@ -184,7 +185,7 @@ public class DefaultVisibilityLabelServiceImpl implements VisibilityLabelService
         if (CellUtil.matchingQualifier(cell, LABEL_QUALIFIER)) {
           labels.put(
               Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()),
-              CellUtil.getRowAsInt(cell));
+              InternalCellUtil.getRowAsInt(cell));
         } else {
           // These are user cells who has authorization for this label
           String user = Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(),
@@ -194,7 +195,7 @@ public class DefaultVisibilityLabelServiceImpl implements VisibilityLabelService
             auths = new ArrayList<>();
             userAuths.put(user, auths);
           }
-          auths.add(CellUtil.getRowAsInt(cell));
+          auths.add(InternalCellUtil.getRowAsInt(cell));
         }
       }
     }
@@ -350,7 +351,7 @@ public class DefaultVisibilityLabelServiceImpl implements VisibilityLabelService
         scanner.next(results);
         if (results.isEmpty()) break;
         Cell cell = results.get(0);
-        int ordinal = CellUtil.getRowAsInt(cell);
+        int ordinal = InternalCellUtil.getRowAsInt(cell);
         String label = this.labelsCache.getLabel(ordinal);
         if (label != null) {
           auths.add(label);
@@ -387,7 +388,7 @@ public class DefaultVisibilityLabelServiceImpl implements VisibilityLabelService
         scanner.next(results);
         if (results.isEmpty()) break;
         Cell cell = results.get(0);
-        int ordinal = CellUtil.getRowAsInt(cell);
+        int ordinal = InternalCellUtil.getRowAsInt(cell);
         String label = this.labelsCache.getLabel(ordinal);
         if (label != null) {
           auths.add(label);
@@ -491,7 +492,7 @@ public class DefaultVisibilityLabelServiceImpl implements VisibilityLabelService
       @Override
       public boolean evaluate(Cell cell) throws IOException {
         boolean visibilityTagPresent = false;
-        Iterator<Tag> tagsItr = CellUtil.tagsIterator(cell);
+        Iterator<Tag> tagsItr = InternalCellUtil.tagsIterator(cell);
         while (tagsItr.hasNext()) {
           boolean includeKV = true;
           Tag tag = tagsItr.next();
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java
index b6742be..c11a4e6 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java
@@ -44,13 +44,13 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.AuthUtil;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellScanner;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.CoprocessorEnvironment;
 import org.apache.hadoop.hbase.DoNotRetryIOException;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
 import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.MetaTableAccessor;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.Tag;
@@ -58,7 +58,6 @@ import org.apache.hadoop.hbase.TagType;
 import org.apache.hadoop.hbase.TagUtil;
 import org.apache.hadoop.hbase.client.Admin;
 import org.apache.hadoop.hbase.client.Append;
-import org.apache.hadoop.hbase.client.ColumnFamilyDescriptor;
 import org.apache.hadoop.hbase.client.Delete;
 import org.apache.hadoop.hbase.client.Get;
 import org.apache.hadoop.hbase.client.Increment;
@@ -369,13 +368,13 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
             List<Cell> updatedCells = new ArrayList<>();
             for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {
               Cell cell = cellScanner.current();
-              List<Tag> tags = CellUtil.getTags(cell);
+              List<Tag> tags = InternalCellUtil.getTags(cell);
               if (modifiedTagFound) {
                 // Rewrite the tags by removing the modified tags.
                 removeReplicationVisibilityTag(tags);
               }
               tags.addAll(visibilityTags);
-              Cell updatedCell = CellUtil.createCell(cell, tags);
+              Cell updatedCell = InternalCellUtil.createCell(cell, tags);
               updatedCells.add(updatedCell);
             }
             m.getFamilyCellMap().clear();
@@ -428,7 +427,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
 
     if (result.size() < get.getMaxVersions()) {
       // Nothing to delete
-      CellUtil.updateLatestStamp(cell, byteNow, 0);
+      InternalCellUtil.updateLatestStamp(cell, byteNow, 0);
       return;
     }
     if (result.size() > get.getMaxVersions()) {
@@ -436,7 +435,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
           + ". Results more than the max versions obtained.");
     }
     Cell getCell = result.get(get.getMaxVersions() - 1);
-    CellUtil.setTimestamp(cell, getCell.getTimestamp());
+    InternalCellUtil.setTimestamp(cell, getCell.getTimestamp());
 
     // We are bypassing here because in the HRegion.updateDeleteLatestVersionTimeStamp we would
     // update with the current timestamp after again doing a get. As the hook as already determined
@@ -472,7 +471,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
       // cell visiblilty tags
       // have been modified
       Tag modifiedTag = null;
-      Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+      Iterator<Tag> tagsIterator = InternalCellUtil.tagsIterator(cell);
       while (tagsIterator.hasNext()) {
         Tag tag = tagsIterator.next();
         if (tag.getType() == TagType.STRING_VIS_TAG_TYPE) {
@@ -484,7 +483,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
       pair.setSecond(modifiedTag);
       return pair;
     }
-    Iterator<Tag> tagsItr = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsItr = InternalCellUtil.tagsIterator(cell);
     while (tagsItr.hasNext()) {
       if (RESERVED_VIS_TAG_TYPES.contains(tagsItr.next().getType())) {
         return pair;
@@ -514,7 +513,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
     if (isSystemOrSuperUser()) {
       return true;
     }
-    Iterator<Tag> tagsItr = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsItr = InternalCellUtil.tagsIterator(cell);
     while (tagsItr.hasNext()) {
       if (RESERVED_VIS_TAG_TYPES.contains(tagsItr.next().getType())) {
         return false;
@@ -731,7 +730,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
     tags.addAll(this.visibilityLabelService.createVisibilityExpTags(cellVisibility.getExpression(),
         true, authCheck));
     // Carry forward all other tags
-    Iterator<Tag> tagsItr = CellUtil.tagsIterator(newCell);
+    Iterator<Tag> tagsItr = InternalCellUtil.tagsIterator(newCell);
     while (tagsItr.hasNext()) {
       Tag tag = tagsItr.next();
       if (tag.getType() != TagType.VISIBILITY_TAG_TYPE
@@ -740,7 +739,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
       }
     }
 
-    Cell rewriteCell = CellUtil.createCell(newCell, tags);
+    Cell rewriteCell = InternalCellUtil.createCell(newCell, tags);
     return rewriteCell;
   }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityLabelFilter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityLabelFilter.java
index dcd301f..fd634df 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityLabelFilter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityLabelFilter.java
@@ -23,6 +23,7 @@ import java.util.Map;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.filter.FilterBase;
 import org.apache.hadoop.hbase.util.ByteRange;
 import org.apache.hadoop.hbase.util.SimpleMutableByteRange;
@@ -58,7 +59,7 @@ class VisibilityLabelFilter extends FilterBase {
   @Override
   public ReturnCode filterKeyValue(Cell cell) throws IOException {
     if (curFamily.getBytes() == null
-        || !(CellUtil.matchingFamily(cell, curFamily.getBytes(), curFamily.getOffset(),
+        || !(InternalCellUtil.matchingFamily(cell, curFamily.getBytes(), curFamily.getOffset(),
             curFamily.getLength()))) {
       curFamily.set(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());
       // For this family, all the columns can have max of curFamilyMaxVersions versions. No need to
@@ -68,9 +69,8 @@ class VisibilityLabelFilter extends FilterBase {
       // Family is changed. Just unset curQualifier.
       curQualifier.unset();
     }
-    if (curQualifier.getBytes() == null
-        || !(CellUtil.matchingQualifier(cell, curQualifier.getBytes(), curQualifier.getOffset(),
-            curQualifier.getLength()))) {
+    if (curQualifier.getBytes() == null || !(InternalCellUtil.matchingQualifier(cell,
+      curQualifier.getBytes(), curQualifier.getOffset(), curQualifier.getLength()))) {
       curQualifier.set(cell.getQualifierArray(), cell.getQualifierOffset(),
           cell.getQualifierLength());
       curQualMetVersions = 0;
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityReplicationEndpoint.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityReplicationEndpoint.java
index b9a1203..444fcac 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityReplicationEndpoint.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityReplicationEndpoint.java
@@ -29,6 +29,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.hbase.ArrayBackedTag;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagType;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -101,7 +102,7 @@ public class VisibilityReplicationEndpoint implements ReplicationEndpoint {
                 continue;
               }
               // Recreate the cell with the new tags and the existing tags
-              Cell newCell = CellUtil.createCell(cell, nonVisTags);
+              Cell newCell = InternalCellUtil.createCell(cell, nonVisTags);
               newEdit.add(newCell);
             } else {
               newEdit.add(cell);
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java
index 964c0f7..cf905fd 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java
@@ -40,6 +40,7 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.ArrayBackedTag;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagType;
 import org.apache.hadoop.hbase.TagUtil;
@@ -212,7 +213,7 @@ public class VisibilityUtils {
    */
   public static Byte extractVisibilityTags(Cell cell, List<Tag> tags) {
     Byte serializationFormat = null;
-    Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsIterator = InternalCellUtil.tagsIterator(cell);
     while (tagsIterator.hasNext()) {
       Tag tag = tagsIterator.next();
       if (tag.getType() == TagType.VISIBILITY_EXP_SERIALIZATION_FORMAT_TAG_TYPE) {
@@ -239,7 +240,7 @@ public class VisibilityUtils {
   public static Byte extractAndPartitionTags(Cell cell, List<Tag> visTags,
       List<Tag> nonVisTags) {
     Byte serializationFormat = null;
-    Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsIterator = InternalCellUtil.tagsIterator(cell);
     while (tagsIterator.hasNext()) {
       Tag tag = tagsIterator.next();
       if (tag.getType() == TagType.VISIBILITY_EXP_SERIALIZATION_FORMAT_TAG_TYPE) {
@@ -255,7 +256,7 @@ public class VisibilityUtils {
   }
 
   public static boolean isVisibilityTagsPresent(Cell cell) {
-    Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsIterator = InternalCellUtil.tagsIterator(cell);
     while (tagsIterator.hasNext()) {
       Tag tag = tagsIterator.next();
       if (tag.getType() == VISIBILITY_TAG_TYPE) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALPrettyPrinter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALPrettyPrinter.java
index d4c320b..2f5781c 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALPrettyPrinter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALPrettyPrinter.java
@@ -41,6 +41,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseConfiguration;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -339,7 +340,7 @@ public class WALPrettyPrinter {
     stringMap.put("vlen", cell.getValueLength());
     if (cell.getTagsLength() > 0) {
       List<String> tagsString = new ArrayList<>();
-      Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+      Iterator<Tag> tagsIterator = InternalCellUtil.tagsIterator(cell);
       while (tagsIterator.hasNext()) {
         Tag tag = tagsIterator.next();
         tagsString.add((tag.getType()) + ":" + Bytes.toStringBinary(TagUtil.cloneValue(tag)));
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALSplitter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALSplitter.java
index aeacd9d..350468b 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALSplitter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALSplitter.java
@@ -2357,7 +2357,7 @@ public class WALSplitter {
 
       boolean isNewRowOrType =
           previousCell == null || previousCell.getTypeByte() != cell.getTypeByte()
-              || !CellUtil.matchingRow(previousCell, cell);
+              || !CellUtil.matchingRows(previousCell, cell);
       if (isNewRowOrType) {
         // Create new mutation
         if (CellUtil.isDelete(cell)) {
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/TestTagRewriteCell.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/TestTagRewriteCell.java
index 54ae775..18de1ba 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/TestTagRewriteCell.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/TestTagRewriteCell.java
@@ -31,7 +31,7 @@ public class TestTagRewriteCell {
   public void testHeapSize() {
     Cell originalCell = CellUtil.createCell(Bytes.toBytes("row"), Bytes.toBytes("value"));
     final int fakeTagArrayLength = 10;
-    Cell trCell = CellUtil.createCell(originalCell, new byte[fakeTagArrayLength]);
+    Cell trCell = InternalCellUtil.createCell(originalCell, new byte[fakeTagArrayLength]);
 
     // Get the heapSize before the internal tags array in trCell are nuked
     long trCellHeapSize = ((HeapSize)trCell).heapSize();
@@ -39,7 +39,7 @@ public class TestTagRewriteCell {
     // Make another TagRewriteCell with the original TagRewriteCell
     // This happens on systems with more than one RegionObserver/Coproc loaded (such as
     // VisibilityController and AccessController)
-    Cell trCell2 = CellUtil.createCell(trCell, new byte[fakeTagArrayLength]);
+    Cell trCell2 = InternalCellUtil.createCell(trCell, new byte[fakeTagArrayLength]);
 
     assertTrue("TagRewriteCell containing a TagRewriteCell's heapsize should be larger than a " +
         "single TagRewriteCell's heapsize", trCellHeapSize < ((HeapSize)trCell2).heapSize());
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java
index 85d84de..c8bad92 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java
@@ -59,6 +59,7 @@ import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
 import org.apache.hadoop.hbase.HRegionLocation;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeepDeletedCells;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.MiniHBaseCluster;
@@ -263,7 +264,7 @@ public class TestFromClientSide {
      s.setMaxVersions();
      scanner = h.getScanner(s);
      kvs = scanner.next().rawCells();
-     assertTrue(CellUtil.isDeleteFamily(kvs[0]));
+     assertTrue(InternalCellUtil.isDeleteFamily(kvs[0]));
      assertArrayEquals(T3, CellUtil.cloneValue(kvs[1]));
      assertTrue(CellUtil.isDelete(kvs[2]));
      assertArrayEquals(T2, CellUtil.cloneValue(kvs[3]));
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFilter.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFilter.java
index d225b8d..8c0d7a8 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFilter.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFilter.java
@@ -1720,7 +1720,7 @@ public class TestFilter {
       for (Cell kv : results) {
         LOG.info("row=" + row + ", result=" + kv.toString() +
             ", match=" + kvs[idx].toString());
-        assertTrue("Row mismatch", CellUtil.matchingRow(kv, kvs[idx]));
+        assertTrue("Row mismatch", CellUtil.matchingRows(kv, kvs[idx]));
         assertTrue("Family mismatch", CellUtil.matchingFamily(kv, kvs[idx]));
         assertTrue("Qualifier mismatch", CellUtil.matchingQualifier(kv, kvs[idx]));
         assertTrue("Value mismatch", CellUtil.matchingValue(kv, kvs[idx]));
@@ -1752,7 +1752,7 @@ public class TestFilter {
         LOG.info("row=" + row + ", result=" + kv.toString() +
             ", match=" + kvs[idx].toString());
 
-        assertTrue("Row mismatch", CellUtil.matchingRow(kv, kvs[idx]));
+        assertTrue("Row mismatch", CellUtil.matchingRows(kv, kvs[idx]));
         assertTrue("Family mismatch", CellUtil.matchingFamily(kv, kvs[idx]));
         assertTrue("Qualifier mismatch", CellUtil.matchingQualifier(kv, kvs[idx]));
         assertFalse("Should not have returned whole value", CellUtil.matchingValue(kv, kvs[idx]));
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestDataBlockEncoders.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestDataBlockEncoders.java
index 635d192..ca2620b 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestDataBlockEncoders.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestDataBlockEncoders.java
@@ -39,6 +39,7 @@ import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.KeyValueUtil;
@@ -292,9 +293,9 @@ public class TestDataBlockEncoders {
       do {
         KeyValue expectedKeyValue = sampleKv.get(i);
         Cell cell = seeker.getCell();
-        if (CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, expectedKeyValue,
+        if (InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, expectedKeyValue,
           cell) != 0) {
-          int commonPrefix = CellUtil
+          int commonPrefix = InternalCellUtil
               .findCommonPrefixInFlatKey(expectedKeyValue, cell, false, true);
           fail(String.format("next() produces wrong results "
               + "encoder: %s i: %d commonPrefix: %d" + "\n expected %s\n actual      %s", encoder
@@ -327,8 +328,8 @@ public class TestDataBlockEncoders {
           getEncodingContext(Compression.Algorithm.NONE, encoding), this.useOffheapData);
       Cell key = encoder.getFirstKeyCellInBlock(new SingleByteBuff(encodedBuffer));
       KeyValue firstKv = sampleKv.get(0);
-      if (0 != CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, key, firstKv)) {
-        int commonPrefix = CellUtil.findCommonPrefixInFlatKey(key, firstKv, false, true);
+      if (0 != InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, key, firstKv)) {
+        int commonPrefix = InternalCellUtil.findCommonPrefixInFlatKey(key, firstKv, false, true);
         fail(String.format("Bug in '%s' commonPrefix %d", encoder.toString(), commonPrefix));
       }
     }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFile.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFile.java
index 39419ca..e748844 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFile.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFile.java
@@ -46,6 +46,7 @@ import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseCommonTestingUtility;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.KeyValueUtil;
@@ -487,8 +488,8 @@ public class TestHFile  {
         KeyValue.Type.Maximum.getCode(),
         HConstants.EMPTY_BYTE_ARRAY);
     Cell mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) <= 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) == 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) <= 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) == 0);
   }
 
   @Test
@@ -496,53 +497,53 @@ public class TestHFile  {
     Cell left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     Cell right = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     Cell mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) <= 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) <= 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("b"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
 
     left = CellUtil.createCell(Bytes.toBytes("g"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("i"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("bbbbbbb"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
     assertEquals(1, mid.getRowLength());
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("b"), Bytes.toBytes("a"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("aaaaaaaa"), Bytes.toBytes("b"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
     assertEquals(2, mid.getFamilyLength());
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("aaaaaaaaa"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
     assertEquals(2, mid.getQualifierLength());
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("b"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
     assertEquals(1, mid.getQualifierLength());
 
     // Assert that if meta comparator, it returns the right cell -- i.e. no
@@ -550,8 +551,8 @@ public class TestHFile  {
     left = CellUtil.createCell(Bytes.toBytes("g"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("i"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.META_COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) == 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) == 0);
 
     /**
      * See HBASE-7845
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlockIndex.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlockIndex.java
index 01dcc18..7dfbdca 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlockIndex.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlockIndex.java
@@ -46,6 +46,7 @@ import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseCommonTestingUtility;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.fs.HFileSystem;
@@ -230,8 +231,8 @@ public class TestHFileBlockIndex {
       HFileBlock b =
           indexReader.seekToDataBlock(keyOnlyKey, null, true,
             true, false, null);
-      if (CellUtil.compare(CellComparatorImpl.COMPARATOR, keyOnlyKey, firstKeyInFile,
-          0, firstKeyInFile.length) < 0) {
+      if (InternalCellUtil.compare(CellComparatorImpl.COMPARATOR, keyOnlyKey, firstKeyInFile, 0,
+        firstKeyInFile.length) < 0) {
         assertTrue(b == null);
         ++i;
         continue;
@@ -636,7 +637,7 @@ public class TestHFileBlockIndex {
           values[i] = CellUtil.cloneValue(kv);
           keyStrSet.add(Bytes.toStringBinary(k));
           if (i > 0) {
-            assertTrue((CellUtil.compare(CellComparatorImpl.COMPARATOR, kv, keys[i - 1],
+            assertTrue((InternalCellUtil.compare(CellComparatorImpl.COMPARATOR, kv, keys[i - 1],
                 0, keys[i - 1].length)) > 0);
           }
         }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestScannerFromBucketCache.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestScannerFromBucketCache.java
index 6c7d686..df8ec7d 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestScannerFromBucketCache.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestScannerFromBucketCache.java
@@ -32,9 +32,9 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.ByteBufferKeyValue;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.client.Durability;
@@ -122,14 +122,14 @@ public class TestScannerFromBucketCache {
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
       // do the scan again and verify. This time it should be from the lru cache
       actual = performScan(row1, fam1);
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
 
     } finally {
@@ -160,7 +160,7 @@ public class TestScannerFromBucketCache {
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
       // Wait for the bucket cache threads to move the data to offheap
       Thread.sleep(500);
@@ -169,7 +169,7 @@ public class TestScannerFromBucketCache {
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertTrue(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
 
     } catch (InterruptedException e) {
@@ -201,7 +201,7 @@ public class TestScannerFromBucketCache {
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
       // Wait for the bucket cache threads to move the data to offheap
       Thread.sleep(500);
@@ -253,14 +253,14 @@ public class TestScannerFromBucketCache {
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
       // do the scan again and verify. This time it should be from the bucket cache in onheap mode
       actual = performScan(row1, fam1);
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
 
     } finally {
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekTo.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekTo.java
index 5f8a6c3..fee5ddb 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekTo.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekTo.java
@@ -37,9 +37,9 @@ import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.ByteBufferKeyValue;
 import org.apache.hadoop.hbase.Tag;
@@ -173,7 +173,7 @@ public class TestSeekTo {
     assertEquals("i", toRowStr(scanner.getCell()));
     Cell cell = scanner.getCell();
     if (tagUsage != TagUsage.NO_TAG && cell.getTagsLength() > 0) {
-      Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+      Iterator<Tag> tagsIterator = InternalCellUtil.tagsIterator(cell);
       while (tagsIterator.hasNext()) {
         Tag next = tagsIterator.next();
         assertEquals("myTag1", Bytes.toString(TagUtil.cloneValue(next)));
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
index 24e42bb..8cbcad8 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
@@ -86,6 +86,7 @@ import org.apache.hadoop.hbase.HConstants.OperationStatusCode;
 import org.apache.hadoop.hbase.HDFSBlocksDistribution;
 import org.apache.hadoop.hbase.HRegionInfo;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.MiniHBaseCluster;
@@ -2607,7 +2608,7 @@ public class TestHRegion {
       Result res = region.get(get);
       assertEquals(expected.length, res.size());
       for (int i = 0; i < res.size(); i++) {
-        assertTrue(CellUtil.matchingRow(expected[i], res.rawCells()[i]));
+        assertTrue(CellUtil.matchingRows(expected[i], res.rawCells()[i]));
         assertTrue(CellUtil.matchingFamily(expected[i], res.rawCells()[i]));
         assertTrue(CellUtil.matchingQualifier(expected[i], res.rawCells()[i]));
       }
@@ -2882,7 +2883,7 @@ public class TestHRegion {
       res = new ArrayList<>();
       is.next(res);
       for (int i = 0; i < res.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected1.get(i), res.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected1.get(i), res.get(i)));
       }
 
       // Result 2
@@ -2893,7 +2894,7 @@ public class TestHRegion {
       res = new ArrayList<>();
       is.next(res);
       for (int i = 0; i < res.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected2.get(i), res.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected2.get(i), res.get(i)));
       }
     } finally {
       HBaseTestingUtility.closeRegionAndWAL(this.region);
@@ -3013,7 +3014,7 @@ public class TestHRegion {
 
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
     } finally {
       HBaseTestingUtility.closeRegionAndWAL(this.region);
@@ -3095,7 +3096,7 @@ public class TestHRegion {
 
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
     } finally {
       HBaseTestingUtility.closeRegionAndWAL(this.region);
@@ -3215,7 +3216,7 @@ public class TestHRegion {
 
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
     } finally {
       HBaseTestingUtility.closeRegionAndWAL(this.region);
@@ -3341,7 +3342,7 @@ public class TestHRegion {
 
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(InternalCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
     } finally {
       HBaseTestingUtility.closeRegionAndWAL(this.region);
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStore.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStore.java
index eeed73c..7c35ea9 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStore.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStore.java
@@ -69,6 +69,7 @@ import org.apache.hadoop.hbase.HBaseConfiguration;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.MemoryCompactionPolicy;
 import org.apache.hadoop.hbase.TableName;
@@ -1049,13 +1050,13 @@ public class TestHStore {
     Cell cell0 = CellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row).setFamily(family)
         .setQualifier(qf1).setTimestamp(timestamp).setType(CellBuilder.DataType.Put)
         .setValue(qf1).build();
-    CellUtil.setSequenceId(cell0, seqId);
+    InternalCellUtil.setSequenceId(cell0, seqId);
     testNumberOfMemStoreScannersAfterFlush(Arrays.asList(cell0), Collections.emptyList());
 
     Cell cell1 = CellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row).setFamily(family)
         .setQualifier(qf2).setTimestamp(timestamp).setType(CellBuilder.DataType.Put)
         .setValue(qf1).build();
-    CellUtil.setSequenceId(cell1, seqId);
+    InternalCellUtil.setSequenceId(cell1, seqId);
     testNumberOfMemStoreScannersAfterFlush(Arrays.asList(cell0), Arrays.asList(cell1));
 
     seqId = 101;
@@ -1063,7 +1064,7 @@ public class TestHStore {
     Cell cell2 = CellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row2).setFamily(family)
         .setQualifier(qf2).setTimestamp(timestamp).setType(CellBuilder.DataType.Put)
         .setValue(qf1).build();
-     CellUtil.setSequenceId(cell2, seqId);
+    InternalCellUtil.setSequenceId(cell2, seqId);
     testNumberOfMemStoreScannersAfterFlush(Arrays.asList(cell0), Arrays.asList(cell1, cell2));
   }
 
@@ -1118,7 +1119,7 @@ public class TestHStore {
     Cell c = CellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row).setFamily(family)
         .setQualifier(qualifier).setTimestamp(ts).setType(CellBuilder.DataType.Put)
         .setValue(value).build();
-    CellUtil.setSequenceId(c, sequenceId);
+    InternalCellUtil.setSequenceId(c, sequenceId);
     return c;
   }
 
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStoreFile.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStoreFile.java
index edc27a1..bfe7cac 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStoreFile.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStoreFile.java
@@ -42,6 +42,7 @@ import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.TableName;
@@ -375,7 +376,7 @@ public class TestHStoreFile extends HBaseTestCase {
              (topScanner.isSeeked() && topScanner.next())) {
         key = ByteBuffer.wrap(((KeyValue) topScanner.getKey()).getKey());
 
-        if ((CellUtil.compare(topScanner.getReader().getComparator(), midKV, key.array(),
+        if ((InternalCellUtil.compare(topScanner.getReader().getComparator(), midKV, key.array(),
           key.arrayOffset(), key.limit())) > 0) {
           fail("key=" + Bytes.toStringBinary(key) + " < midkey=" +
               midkey);
@@ -428,8 +429,8 @@ public class TestHStoreFile extends HBaseTestCase {
           topScanner.next()) {
         key = ByteBuffer.wrap(((KeyValue) topScanner.getKey()).getKey());
         keyOnlyKV.setKey(key.array(), 0 + key.arrayOffset(), key.limit());
-        assertTrue(CellUtil.compare(topScanner.getReader().getComparator(), keyOnlyKV, badmidkey, 0,
-          badmidkey.length) >= 0);
+        assertTrue(InternalCellUtil.compare(topScanner.getReader().getComparator(), keyOnlyKV,
+          badmidkey, 0, badmidkey.length) >= 0);
         if (first) {
           first = false;
           KeyValue keyKV = KeyValueUtil.createKeyValueFromKey(key);
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestKeepDeletes.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestKeepDeletes.java
index aabfa16..3a436e8 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestKeepDeletes.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestKeepDeletes.java
@@ -33,6 +33,7 @@ import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeepDeletedCells;
 import org.apache.hadoop.hbase.client.Delete;
 import org.apache.hadoop.hbase.client.Get;
@@ -349,15 +350,15 @@ public class TestKeepDeletes {
     List<Cell> kvs = new ArrayList<>();
     scan.next(kvs);
     assertEquals(8, kvs.size());
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(0)));
+    assertTrue(InternalCellUtil.isDeleteFamily(kvs.get(0)));
     assertArrayEquals(CellUtil.cloneValue(kvs.get(1)), T3);
     assertTrue(CellUtil.isDelete(kvs.get(2)));
     assertTrue(CellUtil.isDelete(kvs.get(3))); // .isDeleteType());
     assertArrayEquals(CellUtil.cloneValue(kvs.get(4)), T2);
     assertArrayEquals(CellUtil.cloneValue(kvs.get(5)), T1);
     // we have 3 CFs, so there are two more delete markers
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(6)));
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(7)));
+    assertTrue(InternalCellUtil.isDeleteFamily(kvs.get(6)));
+    assertTrue(InternalCellUtil.isDeleteFamily(kvs.get(7)));
 
     // verify that raw scans honor the passed timerange
     s = new Scan();
@@ -379,11 +380,11 @@ public class TestKeepDeletes {
     kvs = new ArrayList<>();
     scan.next(kvs);
     assertEquals(4, kvs.size());
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(0)));
+    assertTrue(InternalCellUtil.isDeleteFamily(kvs.get(0)));
     assertArrayEquals(CellUtil.cloneValue(kvs.get(1)), T1);
     // we have 3 CFs
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(2)));
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(3)));
+    assertTrue(InternalCellUtil.isDeleteFamily(kvs.get(2)));
+    assertTrue(InternalCellUtil.isDeleteFamily(kvs.get(3)));
 
     // filter old delete markers
     s = new Scan();
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMultiColumnScanner.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMultiColumnScanner.java
index b23e0c5..f32525c 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMultiColumnScanner.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMultiColumnScanner.java
@@ -42,6 +42,7 @@ import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueTestUtil;
 import org.apache.hadoop.hbase.client.Delete;
@@ -265,8 +266,8 @@ public class TestMultiColumnScanner {
             }
             assertTrue("Scanner returned additional key/value: " + kv + ", "
                 + queryInfo + deleteInfo + ";", kvPos < kvs.size());
-            assertTrue("Scanner returned wrong key/value; " + queryInfo
-                + deleteInfo + ";", CellUtil.equalsIgnoreMvccVersion(kvs.get(kvPos), (kv)));
+            assertTrue("Scanner returned wrong key/value; " + queryInfo + deleteInfo + ";",
+              InternalCellUtil.equalsIgnoreMvccVersion(kvs.get(kvPos), (kv)));
             ++kvPos;
             ++numResults;
           }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRecoveredEdits.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRecoveredEdits.java
index 45dc786..e443446 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRecoveredEdits.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRecoveredEdits.java
@@ -37,6 +37,7 @@ import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.MemoryCompactionPolicy;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.client.Get;
@@ -187,7 +188,8 @@ public class TestRecoveredEdits {
           boolean found = false;
           for (CellScanner scanner = r.cellScanner(); scanner.advance();) {
             Cell current = scanner.current();
-            if (CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, cell, current) == 0) {
+            if (InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, cell,
+              current) == 0) {
               found = true;
               break;
             }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestSeekOptimizations.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestSeekOptimizations.java
index eb3fe44..126f675 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestSeekOptimizations.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestSeekOptimizations.java
@@ -40,6 +40,7 @@ import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.Delete;
 import org.apache.hadoop.hbase.client.Put;
@@ -459,7 +460,7 @@ public class TestSeekOptimizations {
 
     int i;
     for (i = 0; i < minLen
-        && CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, expected.get(i),
+        && InternalCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, expected.get(i),
           actual.get(i)) == 0; ++i) {
     }
 
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/ExpAsStringVisibilityLabelServiceImpl.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/ExpAsStringVisibilityLabelServiceImpl.java
index 7adeb9e..d942f54 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/ExpAsStringVisibilityLabelServiceImpl.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/ExpAsStringVisibilityLabelServiceImpl.java
@@ -39,6 +39,7 @@ import org.apache.hadoop.hbase.AuthUtil;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants.OperationStatusCode;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.ArrayBackedTag;
 import org.apache.hadoop.hbase.TagType;
@@ -284,7 +285,7 @@ public class ExpAsStringVisibilityLabelServiceImpl implements VisibilityLabelSer
         boolean visibilityTagPresent = false;
         // Save an object allocation where we can
         if (cell.getTagsLength() > 0) {
-          Iterator<Tag> tagsItr = CellUtil.tagsIterator(cell);
+          Iterator<Tag> tagsItr = InternalCellUtil.tagsIterator(cell);
           while (tagsItr.hasNext()) {
             boolean includeKV = true;
             Tag tag = tagsItr.next();
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsReplication.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsReplication.java
index a3d7507..b40efcb 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsReplication.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsReplication.java
@@ -40,6 +40,7 @@ import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.TableName;
@@ -417,7 +418,7 @@ public class TestVisibilityLabelsReplication {
             List<Tag> tagList = new ArrayList<>(kv.getTags().size() + 1);
             tagList.add(tag);
             tagList.addAll(kv.getTags());
-            Cell newcell = CellUtil.createCell(kv, tagList);
+            Cell newcell = InternalCellUtil.createCell(kv, tagList);
             ((List<Cell>) updatedCells).add(newcell);
           }
         }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/util/HFileTestUtil.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/util/HFileTestUtil.java
index acf555b..9163b99 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/util/HFileTestUtil.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/util/HFileTestUtil.java
@@ -33,6 +33,7 @@ import org.apache.hadoop.hbase.ArrayBackedTag;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagType;
@@ -136,7 +137,7 @@ public class HFileTestUtil {
           kv = MobUtils.createMobRefCell(kv, key, tableNameTag);
 
           // verify that the kv has the tag.
-          Tag t = CellUtil.getTag(kv, TagType.MOB_TABLE_NAME_TAG_TYPE);
+          Tag t = InternalCellUtil.getTag(kv, TagType.MOB_TABLE_NAME_TAG_TYPE);
           if (t == null) {
             throw new IllegalStateException("Tag didn't stick to KV " + kv.toString());
           }
@@ -160,7 +161,7 @@ public class HFileTestUtil {
     ResultScanner s = table.getScanner(new Scan());
     for (Result r : s) {
       for (Cell c : r.listCells()) {
-        Tag t = CellUtil.getTag(c, TagType.MOB_TABLE_NAME_TAG_TYPE);
+        Tag t = InternalCellUtil.getTag(c, TagType.MOB_TABLE_NAME_TAG_TYPE);
         if (t == null) {
           fail(c.toString() + " has null tag");
           continue;
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java
index 271b70c..cf4dfa4 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java
@@ -30,6 +30,7 @@ import org.apache.commons.collections4.MapUtils;
 import org.apache.hadoop.hbase.CompareOperator;
 import org.apache.hadoop.hbase.HRegionInfo;
 import org.apache.hadoop.hbase.HRegionLocation;
+import org.apache.hadoop.hbase.InternalCellUtil;
 import org.apache.hadoop.hbase.ServerName;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
@@ -171,7 +172,7 @@ public class ThriftUtilities {
       col.setTimestamp(kv.getTimestamp());
       col.setValue(CellUtil.cloneValue(kv));
       if (kv.getTagsLength() > 0) {
-        col.setTags(CellUtil.getTagArray(kv));
+        col.setTags(InternalCellUtil.getTagArray(kv));
       }
       columnValues.add(col);
     }
