diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AllowPartialScanResultCache.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AllowPartialScanResultCache.java
index aa79132..8d21994 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AllowPartialScanResultCache.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/AllowPartialScanResultCache.java
@@ -69,7 +69,7 @@ class AllowPartialScanResultCache implements ScanResultCache {
     if (i == results.length) {
       return EMPTY_RESULT_ARRAY;
     }
-    if (lastResultPartial && !CellUtil.matchingRow(lastCell, results[0].getRow())) {
+    if (lastResultPartial && !CellUtil.matchingRows(lastCell, results[0].getRow())) {
       // there is a row change, so increase numberOfCompleteRows
       numberOfCompleteRows++;
     }
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/BatchScanResultCache.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/BatchScanResultCache.java
index 5759a3e..3b27298 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/BatchScanResultCache.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/BatchScanResultCache.java
@@ -135,7 +135,7 @@ public class BatchScanResultCache implements ScanResultCache {
           // there is a row change
           regroupedResults.add(createCompletedResult());
         }
-      } else if (lastResultPartial && !CellUtil.matchingRow(lastCell, result.getRow())) {
+      } else if (lastResultPartial && !CellUtil.matchingRows(lastCell, result.getRow())) {
         // As for batched scan we may return partial results to user if we reach the batch limit, so
         // here we need to use lastCell to determine if there is row change and increase
         // numberOfCompleteRows.
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java
index 4f22402..5e0e3b7 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java
@@ -40,9 +40,9 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.MasterNotRunningException;
 import org.apache.hadoop.hbase.ServerName;
 import org.apache.hadoop.hbase.TableName;
@@ -320,7 +320,7 @@ public final class ConnectionUtils {
     long estimatedHeapSizeOfResult = 0;
     // We don't make Iterator here
     for (Cell cell : rs.rawCells()) {
-      estimatedHeapSizeOfResult += CellUtil.estimatedHeapSizeOf(cell);
+      estimatedHeapSizeOfResult += PrivateCellUtil.estimatedHeapSizeOf(cell);
     }
     return estimatedHeapSizeOfResult;
   }
@@ -331,7 +331,7 @@ public final class ConnectionUtils {
       return result;
     }
     // not the same row
-    if (!CellUtil.matchingRow(keepCellsAfter, result.getRow(), 0, result.getRow().length)) {
+    if (!PrivateCellUtil.matchingRows(keepCellsAfter, result.getRow(), 0, result.getRow().length)) {
       return result;
     }
     Cell[] rawCells = result.rawCells();
@@ -462,7 +462,7 @@ public final class ConnectionUtils {
     long resultSize = 0;
     for (Result rr : rrs) {
       for (Cell cell : rr.rawCells()) {
-        resultSize += CellUtil.estimatedSerializedSizeOf(cell);
+        resultSize += PrivateCellUtil.estimatedSerializedSizeOf(cell);
       }
     }
     scanMetrics.countOfBytesInResults.addAndGet(resultSize);
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java
index 68aa381..27116a5 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Delete.java
@@ -20,7 +20,6 @@
 package org.apache.hadoop.hbase.client;
 
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.NavigableMap;
@@ -175,7 +174,7 @@ public class Delete extends Mutation implements Comparable<Row> {
       throw new IOException("The recently added KeyValue is not of type "
           + "delete. Rowkey: " + Bytes.toStringBinary(this.row));
     }
-    if (!CellUtil.matchingRow(kv, this.row)) {
+    if (!CellUtil.matchingRows(kv, this.row)) {
       throw new WrongRowIOException("The row in " + kv.toString() +
         " doesn't match the original one " +  Bytes.toStringBinary(this.row));
     }
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Increment.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Increment.java
index 7a5ae01..d9cfea7 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Increment.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Increment.java
@@ -96,7 +96,7 @@ public class Increment extends Mutation implements Comparable<Row> {
     byte [] family = CellUtil.cloneFamily(cell);
     List<Cell> list = getCellList(family);
     //Checking that the row of the kv is the same as the put
-    if (!CellUtil.matchingRow(cell, this.row)) {
+    if (!CellUtil.matchingRows(cell, this.row)) {
       throw new WrongRowIOException("The row in " + cell +
         " doesn't match the original one " +  Bytes.toStringBinary(this.row));
     }
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Mutation.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Mutation.java
index 426cf2a..dd2c2f0 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Mutation.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Mutation.java
@@ -34,6 +34,7 @@ import org.apache.hadoop.hbase.CellScannable;
 import org.apache.hadoop.hbase.CellScanner;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagUtil;
@@ -225,7 +226,7 @@ public abstract class Mutation extends OperationWithAttributes implements Row, C
                 c.getQualifierLength()));
     stringMap.put("timestamp", c.getTimestamp());
     stringMap.put("vlen", c.getValueLength());
-    List<Tag> tags = CellUtil.getTags(c);
+    List<Tag> tags = PrivateCellUtil.getTags(c);
     if (tags != null) {
       List<String> tagsString = new ArrayList<>(tags.size());
       for (Tag t : tags) {
@@ -437,7 +438,7 @@ public abstract class Mutation extends OperationWithAttributes implements Row, C
           size * ClassSize.REFERENCE);
 
       for(Cell cell : entry.getValue()) {
-        heapsize += CellUtil.estimatedHeapSizeOf(cell);
+        heapsize += PrivateCellUtil.estimatedHeapSizeOf(cell);
       }
     }
     heapsize += getAttributeSize();
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Put.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Put.java
index 9ee6555..94c6a98 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Put.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Put.java
@@ -318,7 +318,7 @@ public class Put extends Mutation implements HeapSize, Comparable<Row> {
     byte [] family = CellUtil.cloneFamily(kv);
     List<Cell> list = getCellList(family);
     //Checking that the row of the kv is the same as the put
-    if (!CellUtil.matchingRow(kv, this.row)) {
+    if (!CellUtil.matchingRows(kv, this.row)) {
       throw new WrongRowIOException("The row in " + kv.toString() +
         " doesn't match the original one " +  Bytes.toStringBinary(this.row));
     }
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Result.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Result.java
index c238aee..cc21ec8 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Result.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Result.java
@@ -40,6 +40,7 @@ import org.apache.hadoop.hbase.CellScannable;
 import org.apache.hadoop.hbase.CellScanner;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -297,7 +298,7 @@ public class Result implements CellScannable, CellScanner {
     byte[] familyNotNull = notNullBytes(family);
     byte[] qualifierNotNull = notNullBytes(qualifier);
     Cell searchTerm =
-        CellUtil.createFirstOnRow(kvs[0].getRowArray(),
+        PrivateCellUtil.createFirstOnRow(kvs[0].getRowArray(),
             kvs[0].getRowOffset(), kvs[0].getRowLength(),
             familyNotNull, 0, (byte)familyNotNull.length,
             qualifierNotNull, 0, qualifierNotNull.length);
@@ -408,7 +409,8 @@ public class Result implements CellScannable, CellScanner {
     if (pos == -1) {
       return null;
     }
-    if (CellUtil.matchingColumn(kvs[pos], family, foffset, flength, qualifier, qoffset, qlength)) {
+    if (PrivateCellUtil.matchingColumn(kvs[pos], family, foffset, flength, qualifier, qoffset,
+      qlength)) {
       return kvs[pos];
     }
     return null;
@@ -858,7 +860,7 @@ public class Result implements CellScannable, CellScanner {
       return size;
     }
     for (Cell c : result.rawCells()) {
-      size += CellUtil.estimatedHeapSizeOf(c);
+      size += PrivateCellUtil.estimatedHeapSizeOf(c);
     }
     return size;
   }
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/BigDecimalColumnInterpreter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/BigDecimalColumnInterpreter.java
index 31162ac..fb7dcd1 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/BigDecimalColumnInterpreter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/BigDecimalColumnInterpreter.java
@@ -25,6 +25,7 @@ import java.math.RoundingMode;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.yetus.audience.InterfaceStability;
 import org.apache.hadoop.hbase.coprocessor.ColumnInterpreter;
@@ -49,7 +50,7 @@ public class BigDecimalColumnInterpreter extends ColumnInterpreter<BigDecimal, B
     if (kv == null || CellUtil.cloneValue(kv) == null) {
       return null;
     }
-    return CellUtil.getValueAsBigDecimal(kv).setScale(2, RoundingMode.HALF_EVEN);
+    return PrivateCellUtil.getValueAsBigDecimal(kv).setScale(2, RoundingMode.HALF_EVEN);
   }
 
   @Override
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/DoubleColumnInterpreter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/DoubleColumnInterpreter.java
index b484664..fbcfa59 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/DoubleColumnInterpreter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/DoubleColumnInterpreter.java
@@ -21,8 +21,8 @@ package org.apache.hadoop.hbase.client.coprocessor;
 import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.yetus.audience.InterfaceStability;
 import org.apache.hadoop.hbase.coprocessor.ColumnInterpreter;
@@ -48,7 +48,7 @@ public class DoubleColumnInterpreter extends ColumnInterpreter<Double, Double,
       throws IOException {
     if (c == null || c.getValueLength() != Bytes.SIZEOF_DOUBLE)
       return null;
-    return CellUtil.getValueAsDouble(c);
+    return PrivateCellUtil.getValueAsDouble(c);
   }
 
   @Override
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/LongColumnInterpreter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/LongColumnInterpreter.java
index 553ce2c..18b3c5b 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/LongColumnInterpreter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/coprocessor/LongColumnInterpreter.java
@@ -21,8 +21,8 @@ package org.apache.hadoop.hbase.client.coprocessor;
 import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.yetus.audience.InterfaceStability;
 import org.apache.hadoop.hbase.coprocessor.ColumnInterpreter;
@@ -47,7 +47,7 @@ public class LongColumnInterpreter extends ColumnInterpreter<Long, Long,
       throws IOException {
     if (kv == null || kv.getValueLength() != Bytes.SIZEOF_LONG)
       return null;
-    return CellUtil.getValueAsLong(kv);
+    return PrivateCellUtil.getValueAsLong(kv);
   }
 
    @Override
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnPaginationFilter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnPaginationFilter.java
index f61f418..0ab8f1a 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnPaginationFilter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnPaginationFilter.java
@@ -23,6 +23,7 @@ import java.util.ArrayList;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.shaded.protobuf.generated.FilterProtos;
@@ -147,7 +148,7 @@ public class ColumnPaginationFilter extends FilterBase {
 
   @Override
   public Cell getNextCellHint(Cell cell) {
-    return CellUtil.createFirstOnRowCol(cell, columnOffset, 0, columnOffset.length);
+    return PrivateCellUtil.createFirstOnRowCol(cell, columnOffset, 0, columnOffset.length);
   }
 
   @Override
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnPrefixFilter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnPrefixFilter.java
index e571bb3..393f66d 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnPrefixFilter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnPrefixFilter.java
@@ -24,7 +24,7 @@ import java.util.ArrayList;
 
 import org.apache.hadoop.hbase.ByteBufferCell;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.shaded.protobuf.generated.FilterProtos;
@@ -152,7 +152,7 @@ public class ColumnPrefixFilter extends FilterBase {
 
   @Override
   public Cell getNextCellHint(Cell cell) {
-    return CellUtil.createFirstOnRowCol(cell, prefix, 0, prefix.length);
+    return PrivateCellUtil.createFirstOnRowCol(cell, prefix, 0, prefix.length);
   }
 
   @Override
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnRangeFilter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnRangeFilter.java
index e3da170..2cd360f 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnRangeFilter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/ColumnRangeFilter.java
@@ -26,6 +26,7 @@ import java.util.ArrayList;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.shaded.com.google.protobuf.InvalidProtocolBufferException;
@@ -224,7 +225,7 @@ public class ColumnRangeFilter extends FilterBase {
 
   @Override
   public Cell getNextCellHint(Cell cell) {
-    return CellUtil.createFirstOnRowCol(cell, this.minColumn, 0, len(this.minColumn));
+    return PrivateCellUtil.createFirstOnRowCol(cell, this.minColumn, 0, len(this.minColumn));
   }
 
   @Override
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/CompareFilter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/CompareFilter.java
index 8145f01..cbf2b0d 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/CompareFilter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/CompareFilter.java
@@ -23,8 +23,8 @@ import java.io.IOException;
 import java.util.ArrayList;
 
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.CompareOperator;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil;
 import org.apache.hadoop.hbase.shaded.protobuf.generated.FilterProtos;
@@ -137,7 +137,7 @@ public abstract class CompareFilter extends FilterBase {
     if (compareOp == CompareOp.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareRow(cell, comparator);
+    int compareResult = PrivateCellUtil.compareRow(cell, comparator);
     return compare(compareOp, compareResult);
   }
 
@@ -146,7 +146,7 @@ public abstract class CompareFilter extends FilterBase {
     if (op == CompareOperator.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareRow(cell, comparator);
+    int compareResult = PrivateCellUtil.compareRow(cell, comparator);
     return compare(op, compareResult);
   }
 
@@ -160,7 +160,7 @@ public abstract class CompareFilter extends FilterBase {
     if (compareOp == CompareOp.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareFamily(cell, comparator);
+    int compareResult = PrivateCellUtil.compareFamily(cell, comparator);
     return compare(compareOp, compareResult);
   }
 
@@ -169,7 +169,7 @@ public abstract class CompareFilter extends FilterBase {
     if (op == CompareOperator.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareFamily(cell, comparator);
+    int compareResult = PrivateCellUtil.compareFamily(cell, comparator);
     return compare(op, compareResult);
   }
 
@@ -184,7 +184,7 @@ public abstract class CompareFilter extends FilterBase {
     if (compareOp == CompareOp.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareQualifier(cell, comparator);
+    int compareResult = PrivateCellUtil.compareQualifier(cell, comparator);
     return compare(compareOp, compareResult);
   }
 
@@ -194,7 +194,7 @@ public abstract class CompareFilter extends FilterBase {
     if (op == CompareOperator.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareQualifier(cell, comparator);
+    int compareResult = PrivateCellUtil.compareQualifier(cell, comparator);
     return compare(op, compareResult);
   }
 
@@ -209,7 +209,7 @@ public abstract class CompareFilter extends FilterBase {
     if (compareOp == CompareOp.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareValue(cell, comparator);
+    int compareResult = PrivateCellUtil.compareValue(cell, comparator);
     return compare(compareOp, compareResult);
   }
 
@@ -218,7 +218,7 @@ public abstract class CompareFilter extends FilterBase {
     if (op == CompareOperator.NO_OP) {
       return true;
     }
-    int compareResult = CellUtil.compareValue(cell, comparator);
+    int compareResult = PrivateCellUtil.compareValue(cell, comparator);
     return compare(op, compareResult);
   }
 
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FuzzyRowFilter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FuzzyRowFilter.java
index 62099e4..79c3193 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FuzzyRowFilter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/FuzzyRowFilter.java
@@ -26,6 +26,7 @@ import java.util.PriorityQueue;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.shaded.com.google.protobuf.InvalidProtocolBufferException;
@@ -187,7 +188,7 @@ public class FuzzyRowFilter extends FilterBase {
       return null;
     }
     byte[] nextRowKey = tracker.nextRow();
-    return CellUtil.createFirstOnRow(nextRowKey, 0, (short) nextRowKey.length);
+    return PrivateCellUtil.createFirstOnRow(nextRowKey, 0, (short) nextRowKey.length);
   }
 
   /**
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/MultiRowRangeFilter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/MultiRowRangeFilter.java
index a3f4159..d025349 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/MultiRowRangeFilter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/MultiRowRangeFilter.java
@@ -24,6 +24,7 @@ import java.util.List;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.shaded.com.google.protobuf.InvalidProtocolBufferException;
@@ -138,7 +139,7 @@ public class MultiRowRangeFilter extends FilterBase {
   @Override
   public Cell getNextCellHint(Cell currentKV) {
     // skip to the next range's start row
-    return CellUtil.createFirstOnRow(range.startRow, 0,
+    return PrivateCellUtil.createFirstOnRow(range.startRow, 0,
         (short) range.startRow.length);
   }
 
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/MultipleColumnPrefixFilter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/MultipleColumnPrefixFilter.java
index 83d56a3..88af4f4 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/MultipleColumnPrefixFilter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/MultipleColumnPrefixFilter.java
@@ -24,6 +24,7 @@ import java.util.TreeSet;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.shaded.com.google.protobuf.InvalidProtocolBufferException;
@@ -164,7 +165,7 @@ public class MultipleColumnPrefixFilter extends FilterBase {
 
   @Override
   public Cell getNextCellHint(Cell cell) {
-    return CellUtil.createFirstOnRowCol(cell, hint, 0, hint.length);
+    return PrivateCellUtil.createFirstOnRowCol(cell, hint, 0, hint.length);
   }
 
   public TreeSet<byte []> createTreeSet() {
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.java
index a66c209..498b58f 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.java
@@ -25,6 +25,7 @@ import java.util.ArrayList;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.CompareOperator;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.filter.CompareFilter.CompareOp;
@@ -273,7 +274,7 @@ public class SingleColumnValueFilter extends FilterBase {
   }
 
   private boolean filterColumnValue(final Cell cell) {
-    int compareResult = CellUtil.compareValue(cell, this.comparator);
+    int compareResult = PrivateCellUtil.compareValue(cell, this.comparator);
     return CompareFilter.compare(this.op, compareResult);
   }
 
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/TimestampsFilter.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/TimestampsFilter.java
index 491d2ed..2742c7f 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/TimestampsFilter.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/filter/TimestampsFilter.java
@@ -23,7 +23,7 @@ import java.util.List;
 import java.util.TreeSet;
 
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.shaded.protobuf.generated.FilterProtos;
@@ -150,14 +150,14 @@ public class TimestampsFilter extends FilterBase {
       // but it's always better to be extra safe and protect against future
       // behavioral changes.
 
-      return CellUtil.createLastOnRowCol(currentCell);
+      return PrivateCellUtil.createLastOnRowCol(currentCell);
     }
 
     // Since we know the nextTimestampObject isn't null here there must still be
     // timestamps that can be included. Cast the Long to a long and return the
     // a cell with the current row/cf/col and the next found timestamp.
     long nextTimestamp = nextTimestampObject;
-    return CellUtil.createFirstOnRowColTS(currentCell, nextTimestamp);
+    return PrivateCellUtil.createFirstOnRowColTS(currentCell, nextTimestamp);
   }
 
   public static Filter createFilterFromArguments(ArrayList<byte []> filterArguments) {
diff --git a/hbase-client/src/test/java/org/apache/hadoop/hbase/filter/TestComparators.java b/hbase-client/src/test/java/org/apache/hadoop/hbase/filter/TestComparators.java
index f640c5e..e3a6927 100644
--- a/hbase-client/src/test/java/org/apache/hadoop/hbase/filter/TestComparators.java
+++ b/hbase-client/src/test/java/org/apache/hadoop/hbase/filter/TestComparators.java
@@ -25,6 +25,7 @@ import org.apache.hadoop.hbase.ByteBufferKeyValue;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.testclassification.MiscTests;
 import org.apache.hadoop.hbase.testclassification.SmallTests;
@@ -53,44 +54,44 @@ public class TestComparators {
     ByteBuffer buffer = ByteBuffer.wrap(kv.getBuffer());
     Cell bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
     ByteArrayComparable comparable = new BinaryComparator(r1);
-    assertEquals(0, CellUtil.compareRow(bbCell, comparable));
-    assertEquals(0, CellUtil.compareRow(kv, comparable));
+    assertEquals(0, PrivateCellUtil.compareRow(bbCell, comparable));
+    assertEquals(0, PrivateCellUtil.compareRow(kv, comparable));
     kv = new KeyValue(r0, f, q1, v1);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertTrue(CellUtil.compareRow(bbCell, comparable) > 0);
-    assertTrue(CellUtil.compareRow(kv, comparable) > 0);
+    assertTrue(PrivateCellUtil.compareRow(bbCell, comparable) > 0);
+    assertTrue(PrivateCellUtil.compareRow(kv, comparable) > 0);
     kv = new KeyValue(r2, f, q1, v1);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertTrue(CellUtil.compareRow(bbCell, comparable) < 0);
-    assertTrue(CellUtil.compareRow(kv, comparable) < 0);
+    assertTrue(PrivateCellUtil.compareRow(bbCell, comparable) < 0);
+    assertTrue(PrivateCellUtil.compareRow(kv, comparable) < 0);
     // Qualifier compare
     comparable = new BinaryPrefixComparator(Bytes.toBytes("qual"));
-    assertEquals(0, CellUtil.compareQualifier(bbCell, comparable));
-    assertEquals(0, CellUtil.compareQualifier(kv, comparable));
+    assertEquals(0, PrivateCellUtil.compareQualifier(bbCell, comparable));
+    assertEquals(0, PrivateCellUtil.compareQualifier(kv, comparable));
     kv = new KeyValue(r2, f, q2, v1);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertEquals(0, CellUtil.compareQualifier(bbCell, comparable));
-    assertEquals(0, CellUtil.compareQualifier(kv, comparable));
+    assertEquals(0, PrivateCellUtil.compareQualifier(bbCell, comparable));
+    assertEquals(0, PrivateCellUtil.compareQualifier(kv, comparable));
     kv = new KeyValue(r2, f, q3, v1);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertTrue(CellUtil.compareQualifier(bbCell, comparable) < 0);
-    assertTrue(CellUtil.compareQualifier(kv, comparable) < 0);
+    assertTrue(PrivateCellUtil.compareQualifier(bbCell, comparable) < 0);
+    assertTrue(PrivateCellUtil.compareQualifier(kv, comparable) < 0);
     // Value compare
     comparable = new LongComparator(l1);
-    assertEquals(0, CellUtil.compareValue(bbCell, comparable));
-    assertEquals(0, CellUtil.compareValue(kv, comparable));
+    assertEquals(0, PrivateCellUtil.compareValue(bbCell, comparable));
+    assertEquals(0, PrivateCellUtil.compareValue(kv, comparable));
     kv = new KeyValue(r1, f, q1, v2);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertTrue(CellUtil.compareValue(bbCell, comparable) < 0);
-    assertTrue(CellUtil.compareValue(kv, comparable) < 0);
+    assertTrue(PrivateCellUtil.compareValue(bbCell, comparable) < 0);
+    assertTrue(PrivateCellUtil.compareValue(kv, comparable) < 0);
     // Family compare
     comparable = new SubstringComparator("cf");
-    assertEquals(0, CellUtil.compareFamily(bbCell, comparable));
-    assertEquals(0, CellUtil.compareFamily(kv, comparable));
+    assertEquals(0, PrivateCellUtil.compareFamily(bbCell, comparable));
+    assertEquals(0, PrivateCellUtil.compareFamily(kv, comparable));
   }
 }
diff --git a/hbase-client/src/test/java/org/apache/hadoop/hbase/ipc/TestCellBlockBuilder.java b/hbase-client/src/test/java/org/apache/hadoop/hbase/ipc/TestCellBlockBuilder.java
index 164bc85..6fdb864 100644
--- a/hbase-client/src/test/java/org/apache/hadoop/hbase/ipc/TestCellBlockBuilder.java
+++ b/hbase-client/src/test/java/org/apache/hadoop/hbase/ipc/TestCellBlockBuilder.java
@@ -31,6 +31,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellScanner;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.codec.Codec;
 import org.apache.hadoop.hbase.codec.KeyValueCodec;
@@ -91,7 +92,7 @@ public class TestCellBlockBuilder {
   static CellScanner getSizedCellScanner(final Cell[] cells) {
     int size = -1;
     for (Cell cell : cells) {
-      size += CellUtil.estimatedSerializedSizeOf(cell);
+      size += PrivateCellUtil.estimatedSerializedSizeOf(cell);
     }
     final int totalSize = ClassSize.align(size);
     final CellScanner cellScanner = CellUtil.createCellScanner(cells);
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java
index 12f6a30..20c217f 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellUtil.java
@@ -18,7 +18,6 @@
 
 package org.apache.hadoop.hbase;
 
-import static org.apache.hadoop.hbase.HConstants.EMPTY_BYTE_ARRAY;
 import static org.apache.hadoop.hbase.Tag.TAG_LENGTH_SIZE;
 import static org.apache.hadoop.hbase.KeyValue.COLUMN_FAMILY_DELIMITER;
 import static org.apache.hadoop.hbase.KeyValue.getDelimiter;
@@ -28,9 +27,7 @@ import java.io.DataOutput;
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.math.BigDecimal;
 import java.nio.ByteBuffer;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
@@ -38,25 +35,20 @@ import java.util.Map.Entry;
 import java.util.NavigableMap;
 
 import org.apache.hadoop.hbase.KeyValue.Type;
-import org.apache.hadoop.hbase.filter.ByteArrayComparable;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.yetus.audience.InterfaceAudience.Private;
 
 import com.google.common.annotations.VisibleForTesting;
 
 import org.apache.hadoop.hbase.io.HeapSize;
-import org.apache.hadoop.hbase.io.TagCompressionContext;
-import org.apache.hadoop.hbase.io.util.Dictionary;
-import org.apache.hadoop.hbase.io.util.StreamUtils;
 import org.apache.hadoop.hbase.util.ByteBufferUtils;
 import org.apache.hadoop.hbase.util.ByteRange;
 import org.apache.hadoop.hbase.util.Bytes;
-import org.apache.hadoop.hbase.util.ClassSize;
 
 /**
- * Utility methods helpful slinging {@link Cell} instances.
- * Some methods below are for internal use only and are marked InterfaceAudience.Private at the
- * method level.
+ * Utility methods helpful for slinging {@link Cell} instances. Some methods below are for internal
+ * use only and are marked InterfaceAudience.Private at the method level. Note that all such methods
+ * have been marked deprecated in HBase-2.0 which will be subsequently removed in HBase-3.0
  */
 @InterfaceAudience.Public
 public final class CellUtil {
@@ -64,74 +56,96 @@ public final class CellUtil {
   /**
    * Private constructor to keep this class from being instantiated.
    */
-  private CellUtil(){}
+  private CellUtil() {
+  }
 
   /******************* ByteRange *******************************/
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.
+   */
+  @Deprecated
   public static ByteRange fillRowRange(Cell cell, ByteRange range) {
-    return range.set(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
+    return PrivateCellUtil.fillRowRange(cell, range);
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.
+   */
+  @Deprecated
   public static ByteRange fillFamilyRange(Cell cell, ByteRange range) {
-    return range.set(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());
+    return PrivateCellUtil.fillFamilyRange(cell, range);
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.
+   */
+  @Deprecated
   public static ByteRange fillQualifierRange(Cell cell, ByteRange range) {
-    return range.set(cell.getQualifierArray(), cell.getQualifierOffset(),
-      cell.getQualifierLength());
+    return PrivateCellUtil.fillQualifierRange(cell, range);
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.
+   */
+  @Deprecated
   public static ByteRange fillValueRange(Cell cell, ByteRange range) {
-    return range.set(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
+    return PrivateCellUtil.fillValueRange(cell, range);
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.
+   */
+  @Deprecated
   public static ByteRange fillTagRange(Cell cell, ByteRange range) {
-    return range.set(cell.getTagsArray(), cell.getTagsOffset(), cell.getTagsLength());
+    return PrivateCellUtil.fillTagRange(cell, range);
   }
 
   /***************** get individual arrays for tests ************/
 
-  public static byte[] cloneRow(Cell cell){
+  public static byte[] cloneRow(Cell cell) {
     byte[] output = new byte[cell.getRowLength()];
     copyRowTo(cell, output, 0);
     return output;
   }
 
-  public static byte[] cloneFamily(Cell cell){
+  public static byte[] cloneFamily(Cell cell) {
     byte[] output = new byte[cell.getFamilyLength()];
     copyFamilyTo(cell, output, 0);
     return output;
   }
 
-  public static byte[] cloneQualifier(Cell cell){
+  public static byte[] cloneQualifier(Cell cell) {
     byte[] output = new byte[cell.getQualifierLength()];
     copyQualifierTo(cell, output, 0);
     return output;
   }
 
-  public static byte[] cloneValue(Cell cell){
+  public static byte[] cloneValue(Cell cell) {
     byte[] output = new byte[cell.getValueLength()];
     copyValueTo(cell, output, 0);
     return output;
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.
+   */
+  @Deprecated
   public static byte[] cloneTags(Cell cell) {
-    byte[] output = new byte[cell.getTagsLength()];
-    copyTagTo(cell, output, 0);
-    return output;
+    return PrivateCellUtil.cloneTags(cell);
   }
 
   /**
-   * Returns tag value in a new byte array. If server-side, use
-   * {@link Tag#getValueArray()} with appropriate {@link Tag#getValueOffset()} and
-   * {@link Tag#getValueLength()} instead to save on allocations.
+   * Returns tag value in a new byte array. If server-side, use {@link Tag#getValueArray()} with
+   * appropriate {@link Tag#getValueOffset()} and {@link Tag#getValueLength()} instead to save on
+   * allocations.
    * @param cell
    * @return tag value in a new byte array.
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
    */
-  public static byte[] getTagArray(Cell cell){
-    byte[] output = new byte[cell.getTagsLength()];
-    copyTagTo(cell, output, 0);
-    return output;
+  @Deprecated
+  public static byte[] getTagArray(Cell cell) {
+    return PrivateCellUtil.getTagsArray(cell);
   }
 
   /**
@@ -142,7 +156,7 @@ public final class CellUtil {
    * @param qualifier
    * @return family:qualifier
    */
-  public static byte [] makeColumn(byte [] family, byte [] qualifier) {
+  public static byte[] makeColumn(byte[] family, byte[] qualifier) {
     return Bytes.add(family, COLUMN_FAMILY_DELIM_ARRAY, qualifier);
   }
 
@@ -159,20 +173,20 @@ public final class CellUtil {
    * @param c The column.
    * @return The parsed column.
    */
-  public static byte [][] parseColumn(byte [] c) {
+  public static byte[][] parseColumn(byte[] c) {
     final int index = getDelimiter(c, 0, c.length, COLUMN_FAMILY_DELIMITER);
     if (index == -1) {
       // If no delimiter, return array of size 1
-      return new byte [][] { c };
-    } else if(index == c.length - 1) {
+      return new byte[][] { c };
+    } else if (index == c.length - 1) {
       // family with empty qualifier, return array size 2
-      byte [] family = new byte[c.length-1];
+      byte[] family = new byte[c.length - 1];
       System.arraycopy(c, 0, family, 0, family.length);
-      return new byte [][] { family, HConstants.EMPTY_BYTE_ARRAY};
+      return new byte[][] { family, HConstants.EMPTY_BYTE_ARRAY };
     }
     // Family and column, return array size 2
-    final byte [][] result = new byte [2][];
-    result[0] = new byte [index];
+    final byte[][] result = new byte[2][];
+    result[0] = new byte[index];
     System.arraycopy(c, 0, result[0], 0, index);
     final int len = c.length - (index + 1);
     result[1] = new byte[len];
@@ -182,27 +196,40 @@ public final class CellUtil {
 
   /******************** copyTo **********************************/
 
+  /**
+   * Copies the row to the given byte[]
+   * @param cell the cell whose row has to be copied
+   * @param destination the destination byte[] to which the row has to be copied
+   * @param destinationOffset the offset in the destination byte[]
+   * @return the offset of the byte[] after the copy has happened
+   */
   public static int copyRowTo(Cell cell, byte[] destination, int destinationOffset) {
     short rowLen = cell.getRowLength();
     if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyFromBufferToArray(destination,
-          ((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), destinationOffset, rowLen);
+      ByteBufferUtils.copyFromBufferToArray(destination, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), destinationOffset, rowLen);
     } else {
       System.arraycopy(cell.getRowArray(), cell.getRowOffset(), destination, destinationOffset,
-          rowLen);
+        rowLen);
     }
     return destinationOffset + rowLen;
   }
 
+  /**
+   * Copies the row to the given bytebuffer
+   * @param cell cell the cell whose row has to be copied
+   * @param destination the destination bytebuffer to which the row has to be copied
+   * @param destinationOffset the offset in the destination byte[]
+   * @return the offset of the bytebuffer after the copy has happened
+   */
   public static int copyRowTo(Cell cell, ByteBuffer destination, int destinationOffset) {
     short rowLen = cell.getRowLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getRowByteBuffer(),
-          destination, ((ByteBufferCell) cell).getRowPosition(), destinationOffset, rowLen);
+        destination, ((ByteBufferCell) cell).getRowPosition(), destinationOffset, rowLen);
     } else {
       ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset, cell.getRowArray(),
-          cell.getRowOffset(), rowLen);
+        cell.getRowOffset(), rowLen);
     }
     return destinationOffset + rowLen;
   }
@@ -223,77 +250,119 @@ public final class CellUtil {
     }
   }
 
+  /**
+   * Copies the family to the given byte[]
+   * @param cell the cell whose family has to be copied
+   * @param destination the destination byte[] to which the family has to be copied
+   * @param destinationOffset the offset in the destination byte[]
+   * @return the offset of the byte[] after the copy has happened
+   */
   public static int copyFamilyTo(Cell cell, byte[] destination, int destinationOffset) {
     byte fLen = cell.getFamilyLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToArray(destination,
-          ((ByteBufferCell) cell).getFamilyByteBuffer(),
-          ((ByteBufferCell) cell).getFamilyPosition(), destinationOffset, fLen);
+        ((ByteBufferCell) cell).getFamilyByteBuffer(), ((ByteBufferCell) cell).getFamilyPosition(),
+        destinationOffset, fLen);
     } else {
       System.arraycopy(cell.getFamilyArray(), cell.getFamilyOffset(), destination,
-          destinationOffset, fLen);
+        destinationOffset, fLen);
     }
     return destinationOffset + fLen;
   }
 
+  /**
+   * Copies the family to the given bytebuffer
+   * @param cell the cell whose family has to be copied
+   * @param destination the destination bytebuffer to which the family has to be copied
+   * @param destinationOffset the offset in the destination bytebuffer
+   * @return the offset of the bytebuffer after the copy has happened
+   */
   public static int copyFamilyTo(Cell cell, ByteBuffer destination, int destinationOffset) {
     byte fLen = cell.getFamilyLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getFamilyByteBuffer(),
-          destination, ((ByteBufferCell) cell).getFamilyPosition(), destinationOffset, fLen);
+        destination, ((ByteBufferCell) cell).getFamilyPosition(), destinationOffset, fLen);
     } else {
       ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset, cell.getFamilyArray(),
-          cell.getFamilyOffset(), fLen);
+        cell.getFamilyOffset(), fLen);
     }
     return destinationOffset + fLen;
   }
 
+  /**
+   * Copies the qualifier to the given byte[]
+   * @param cell the cell whose qualifier has to be copied
+   * @param destination the destination byte[] to which the qualifier has to be copied
+   * @param destinationOffset the offset in the destination byte[]
+   * @return the offset of the byte[] after the copy has happened
+   */
   public static int copyQualifierTo(Cell cell, byte[] destination, int destinationOffset) {
     int qlen = cell.getQualifierLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToArray(destination,
-          ((ByteBufferCell) cell).getQualifierByteBuffer(),
-          ((ByteBufferCell) cell).getQualifierPosition(), destinationOffset, qlen);
+        ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), destinationOffset, qlen);
     } else {
       System.arraycopy(cell.getQualifierArray(), cell.getQualifierOffset(), destination,
-          destinationOffset, qlen);
+        destinationOffset, qlen);
     }
     return destinationOffset + qlen;
   }
 
+  /**
+   * Copies the qualifier to the given bytebuffer
+   * @param cell the cell whose qualifier has to be copied
+   * @param destination the destination bytebuffer to which the qualifier has to be copied
+   * @param destinationOffset the offset in the destination bytebuffer
+   * @return the offset of the bytebuffer after the copy has happened
+   */
   public static int copyQualifierTo(Cell cell, ByteBuffer destination, int destinationOffset) {
     int qlen = cell.getQualifierLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getQualifierByteBuffer(),
-          destination, ((ByteBufferCell) cell).getQualifierPosition(), destinationOffset, qlen);
+        destination, ((ByteBufferCell) cell).getQualifierPosition(), destinationOffset, qlen);
     } else {
       ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset,
-          cell.getQualifierArray(), cell.getQualifierOffset(), qlen);
+        cell.getQualifierArray(), cell.getQualifierOffset(), qlen);
     }
     return destinationOffset + qlen;
   }
 
+  /**
+   * Copies the value to the given byte[]
+   * @param cell the cell whose value has to be copied
+   * @param destination the destination byte[] to which the value has to be copied
+   * @param destinationOffset the offset in the destination byte[]
+   * @return the offset of the byte[] after the copy has happened
+   */
   public static int copyValueTo(Cell cell, byte[] destination, int destinationOffset) {
     int vlen = cell.getValueLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToArray(destination,
-          ((ByteBufferCell) cell).getValueByteBuffer(),
-          ((ByteBufferCell) cell).getValuePosition(), destinationOffset, vlen);
+        ((ByteBufferCell) cell).getValueByteBuffer(), ((ByteBufferCell) cell).getValuePosition(),
+        destinationOffset, vlen);
     } else {
       System.arraycopy(cell.getValueArray(), cell.getValueOffset(), destination, destinationOffset,
-          vlen);
+        vlen);
     }
     return destinationOffset + vlen;
   }
 
+  /**
+   * Copies the value to the given bytebuffer
+   * @param cell the cell whose value has to be copied
+   * @param destination the destination bytebuffer to which the value has to be copied
+   * @param destinationOffset the offset in the destination bytebuffer
+   * @return the offset of the bytebuffer after the copy has happened
+   */
   public static int copyValueTo(Cell cell, ByteBuffer destination, int destinationOffset) {
     int vlen = cell.getValueLength();
     if (cell instanceof ByteBufferCell) {
       ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getValueByteBuffer(),
-          destination, ((ByteBufferCell) cell).getValuePosition(), destinationOffset, vlen);
+        destination, ((ByteBufferCell) cell).getValuePosition(), destinationOffset, vlen);
     } else {
       ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset, cell.getValueArray(),
-          cell.getValueOffset(), vlen);
+        cell.getValueOffset(), vlen);
     }
     return destinationOffset + vlen;
   }
@@ -304,56 +373,43 @@ public final class CellUtil {
    * @param destination
    * @param destinationOffset
    * @return position after tags
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.
    */
+  @Deprecated
   public static int copyTagTo(Cell cell, byte[] destination, int destinationOffset) {
-    int tlen = cell.getTagsLength();
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyFromBufferToArray(destination,
-          ((ByteBufferCell) cell).getTagsByteBuffer(),
-          ((ByteBufferCell) cell).getTagsPosition(), destinationOffset, tlen);
-    } else {
-      System.arraycopy(cell.getTagsArray(), cell.getTagsOffset(), destination, destinationOffset,
-          tlen);
-    }
-    return destinationOffset + tlen;
+    return PrivateCellUtil.copyTagsTo(cell, destination, destinationOffset);
   }
 
+  /**
+   * Copies the tags info into the tag portion of the cell
+   * @param cell
+   * @param destination
+   * @param destinationOffset
+   * @return position after tags
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
+   */
+  @Deprecated
   public static int copyTagTo(Cell cell, ByteBuffer destination, int destinationOffset) {
-    int tlen = cell.getTagsLength();
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getTagsByteBuffer(),
-          destination, ((ByteBufferCell) cell).getTagsPosition(), destinationOffset, tlen);
-    } else {
-      ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset, cell.getTagsArray(),
-          cell.getTagsOffset(), tlen);
-    }
-    return destinationOffset + tlen;
+    return PrivateCellUtil.copyTagsTo(cell, destination, destinationOffset);
   }
 
   /********************* misc *************************************/
 
   @Private
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.
+   */
+  @Deprecated
   public static byte getRowByte(Cell cell, int index) {
-    if (cell instanceof ByteBufferCell) {
-      return ((ByteBufferCell) cell).getRowByteBuffer().get(
-          ((ByteBufferCell) cell).getRowPosition() + index);
-    }
-    return cell.getRowArray()[cell.getRowOffset() + index];
-  }
-
-  @Private
-  public static byte getQualifierByte(Cell cell, int index) {
-    if (cell instanceof ByteBufferCell) {
-      return ((ByteBufferCell) cell).getQualifierByteBuffer().get(
-          ((ByteBufferCell) cell).getQualifierPosition() + index);
-    }
-    return cell.getQualifierArray()[cell.getQualifierOffset() + index];
+    return PrivateCellUtil.getRowByte(cell, index);
   }
 
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in 3.0.
+   */
+  @Deprecated
   public static ByteBuffer getValueBufferShallowCopy(Cell cell) {
-    ByteBuffer buffer = ByteBuffer.wrap(cell.getValueArray(), cell.getValueOffset(),
-      cell.getValueLength());
-    return buffer;
+    return PrivateCellUtil.getValueBufferShallowCopy(cell);
   }
 
   /**
@@ -365,17 +421,17 @@ public final class CellUtil {
   public static ByteBuffer getQualifierBufferShallowCopy(Cell cell) {
     // No usage of this in code.
     ByteBuffer buffer = ByteBuffer.wrap(cell.getQualifierArray(), cell.getQualifierOffset(),
-        cell.getQualifierLength());
+      cell.getQualifierLength());
     return buffer;
   }
 
   /**
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link CellBuilder} instead
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}
+   *             instead
    */
   @Deprecated
-  public static Cell createCell(final byte [] row, final byte [] family, final byte [] qualifier,
-      final long timestamp, final byte type, final byte [] value) {
+  public static Cell createCell(final byte[] row, final byte[] family, final byte[] qualifier,
+      final long timestamp, final byte type, final byte[] value) {
     return ExtendedCellBuilderFactory.create(CellBuilderType.DEEP_COPY)
             .setRow(row)
             .setFamily(family)
@@ -388,13 +444,13 @@ public final class CellUtil {
 
   /**
    * Creates a cell with deep copy of all passed bytes.
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link CellBuilder} instead
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}
+   *             instead
    */
   @Deprecated
-  public static Cell createCell(final byte [] rowArray, final int rowOffset, final int rowLength,
-      final byte [] familyArray, final int familyOffset, final int familyLength,
-      final byte [] qualifierArray, final int qualifierOffset, final int qualifierLength) {
+  public static Cell createCell(final byte[] rowArray, final int rowOffset, final int rowLength,
+      final byte[] familyArray, final int familyOffset, final int familyLength,
+      final byte[] qualifierArray, final int qualifierOffset, final int qualifierLength) {
     // See createCell(final byte [] row, final byte [] value) for why we default Maximum type.
     return ExtendedCellBuilderFactory.create(CellBuilderType.DEEP_COPY)
             .setRow(rowArray, rowOffset, rowLength)
@@ -408,10 +464,10 @@ public final class CellUtil {
 
   /**
    * Marked as audience Private as of 1.2.0.
-   * Creating a Cell with a memstoreTS/mvcc is an internal implementation detail not for
-   * public use.
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link ExtendedCellBuilder} instead
+   * Creating a Cell with a memstoreTS/mvcc is an internal
+   * implementation detail not for public use.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use
+   *             {@link ExtendedCellBuilder} instead
    */
   @InterfaceAudience.Private
   @Deprecated
@@ -422,10 +478,10 @@ public final class CellUtil {
 
   /**
    * Marked as audience Private as of 1.2.0.
-   * Creating a Cell with tags and a memstoreTS/mvcc is an internal implementation detail not for
-   * public use.
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link ExtendedCellBuilder} instead
+   * Creating a Cell with tags and a memstoreTS/mvcc is an
+   * internal implementation detail not for public use.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use
+   *             {@link ExtendedCellBuilder} instead
    */
   @InterfaceAudience.Private
   @Deprecated
@@ -446,43 +502,41 @@ public final class CellUtil {
 
   /**
    * Marked as audience Private as of 1.2.0.
-   * Creating a Cell with tags is an internal implementation detail not for
-   * public use.
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link ExtendedCellBuilder} instead
+   * Creating a Cell with tags is an internal implementation detail not for public use.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use
+   *             {@link ExtendedCellBuilder} instead
    */
   @InterfaceAudience.Private
   @Deprecated
   public static Cell createCell(final byte[] row, final byte[] family, final byte[] qualifier,
       final long timestamp, Type type, final byte[] value, byte[] tags) {
-    return createCell(row, family, qualifier, timestamp, type.getCode(), value,
-            tags, 0);
+    return createCell(row, family, qualifier, timestamp, type.getCode(), value, tags, 0);
   }
 
   /**
-   * Create a Cell with specific row.  Other fields defaulted.
+   * Create a Cell with specific row. Other fields defaulted.
    * @param row
    * @return Cell with passed row but all other fields are arbitrary
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link CellBuilder} instead
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}
+   *             instead
    */
   @Deprecated
-  public static Cell createCell(final byte [] row) {
+  public static Cell createCell(final byte[] row) {
     return createCell(row, HConstants.EMPTY_BYTE_ARRAY);
   }
 
   /**
-   * Create a Cell with specific row and value.  Other fields are defaulted.
+   * Create a Cell with specific row and value. Other fields are defaulted.
    * @param row
    * @param value
    * @return Cell with passed row and value but all other fields are arbitrary
-   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Use {@link CellBuilder} instead
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}
+   *             instead
    */
   @Deprecated
-  public static Cell createCell(final byte [] row, final byte [] value) {
+  public static Cell createCell(final byte[] row, final byte[] value) {
     // An empty family + empty qualifier + Type.Minimum is used as flag to indicate last on row.
-    // See the CellComparator and KeyValue comparator.  Search for compareWithoutRow.
+    // See the CellComparator and KeyValue comparator. Search for compareWithoutRow.
     // Lets not make a last-on-row key as default but at same time, if you are making a key
     // without specifying type, etc., flag it as weird by setting type to be Maximum.
     return createCell(row, HConstants.EMPTY_BYTE_ARRAY, HConstants.EMPTY_BYTE_ARRAY,
@@ -517,3112 +571,889 @@ public final class CellUtil {
    */
   public static Cell createCell(Cell cell, byte[] tags) {
     if (cell instanceof ByteBufferCell) {
-      return new TagRewriteByteBufferCell((ByteBufferCell) cell, tags);
+      return new PrivateCellUtil.TagRewriteByteBufferCell((ByteBufferCell) cell, tags);
     }
-    return new TagRewriteCell(cell, tags);
+    return new PrivateCellUtil.TagRewriteCell(cell, tags);
   }
 
   public static Cell createCell(Cell cell, byte[] value, byte[] tags) {
     if (cell instanceof ByteBufferCell) {
-      return new ValueAndTagRewriteByteBufferCell((ByteBufferCell) cell, value, tags);
+      return new PrivateCellUtil.ValueAndTagRewriteByteBufferCell((ByteBufferCell) cell, value,
+          tags);
     }
-    return new ValueAndTagRewriteCell(cell, value, tags);
+    return new PrivateCellUtil.ValueAndTagRewriteCell(cell, value, tags);
   }
 
   /**
-   * This can be used when a Cell has to change with addition/removal of one or more tags. This is an
-   * efficient way to do so in which only the tags bytes part need to recreated and copied. All other
-   * parts, refer to the original Cell.
+   * @param cellScannerables
+   * @return CellScanner interface over <code>cellIterables</code>
    */
-  @InterfaceAudience.Private
-  private static class TagRewriteCell implements ExtendedCell {
-    protected Cell cell;
-    protected byte[] tags;
-    private static final long HEAP_SIZE_OVERHEAD = ClassSize.OBJECT + 2 * ClassSize.REFERENCE;
-
-    /**
-     * @param cell The original Cell which it rewrites
-     * @param tags the tags bytes. The array suppose to contain the tags bytes alone.
-     */
-    public TagRewriteCell(Cell cell, byte[] tags) {
-      assert cell instanceof ExtendedCell;
-      assert tags != null;
-      this.cell = cell;
-      this.tags = tags;
-      // tag offset will be treated as 0 and length this.tags.length
-      if (this.cell instanceof TagRewriteCell) {
-        // Cleaning the ref so that the byte[] can be GCed
-        ((TagRewriteCell) this.cell).tags = null;
+  public static CellScanner createCellScanner(
+      final List<? extends CellScannable> cellScannerables) {
+    return new CellScanner() {
+      private final Iterator<? extends CellScannable> iterator = cellScannerables.iterator();
+      private CellScanner cellScanner = null;
+
+      @Override
+      public Cell current() {
+        return this.cellScanner != null? this.cellScanner.current(): null;
       }
-    }
 
-    @Override
-    public byte[] getRowArray() {
-      return cell.getRowArray();
-    }
+      @Override
+      public boolean advance() throws IOException {
+        while (true) {
+          if (this.cellScanner == null) {
+            if (!this.iterator.hasNext()) return false;
+            this.cellScanner = this.iterator.next().cellScanner();
+          }
+          if (this.cellScanner.advance()) return true;
+          this.cellScanner = null;
+        }
+      }
+    };
+  }
 
-    @Override
-    public int getRowOffset() {
-      return cell.getRowOffset();
-    }
+  /**
+   * @param cellIterable
+   * @return CellScanner interface over <code>cellIterable</code>
+   */
+  public static CellScanner createCellScanner(final Iterable<Cell> cellIterable) {
+    if (cellIterable == null) return null;
+    return createCellScanner(cellIterable.iterator());
+  }
 
-    @Override
-    public short getRowLength() {
-      return cell.getRowLength();
-    }
+  /**
+   * @param cells
+   * @return CellScanner interface over <code>cellIterable</code> or null if <code>cells</code> is
+   * null
+   */
+  public static CellScanner createCellScanner(final Iterator<Cell> cells) {
+    if (cells == null) return null;
+    return new CellScanner() {
+      private final Iterator<Cell> iterator = cells;
+      private Cell current = null;
 
-    @Override
-    public byte[] getFamilyArray() {
-      return cell.getFamilyArray();
-    }
+      @Override
+      public Cell current() {
+        return this.current;
+      }
 
-    @Override
-    public int getFamilyOffset() {
-      return cell.getFamilyOffset();
-    }
+      @Override
+      public boolean advance() {
+        boolean hasNext = this.iterator.hasNext();
+        this.current = hasNext? this.iterator.next(): null;
+        return hasNext;
+      }
+    };
+  }
 
-    @Override
-    public byte getFamilyLength() {
-      return cell.getFamilyLength();
-    }
+  /**
+   * @param cellArray
+   * @return CellScanner interface over <code>cellArray</code>
+   */
+  public static CellScanner createCellScanner(final Cell[] cellArray) {
+    return new CellScanner() {
+      private final Cell [] cells = cellArray;
+      private int index = -1;
 
-    @Override
-    public byte[] getQualifierArray() {
-      return cell.getQualifierArray();
-    }
+      @Override
+      public Cell current() {
+        if (cells == null) return null;
+        return (index < 0)? null: this.cells[index];
+      }
 
-    @Override
-    public int getQualifierOffset() {
-      return cell.getQualifierOffset();
-    }
+      @Override
+      public boolean advance() {
+        if (cells == null) return false;
+        return ++index < this.cells.length;
+      }
+    };
+  }
 
-    @Override
-    public int getQualifierLength() {
-      return cell.getQualifierLength();
-    }
+  /**
+   * Flatten the map of cells out under the CellScanner
+   * @param map Map of Cell Lists; for example, the map of families to Cells that is used
+   * inside Put, etc., keeping Cells organized by family.
+   * @return CellScanner interface over <code>cellIterable</code>
+   */
+  public static CellScanner createCellScanner(final NavigableMap<byte [], List<Cell>> map) {
+    return new CellScanner() {
+      private final Iterator<Entry<byte[], List<Cell>>> entries = map.entrySet().iterator();
+      private Iterator<Cell> currentIterator = null;
+      private Cell currentCell;
 
-    @Override
-    public long getTimestamp() {
-      return cell.getTimestamp();
-    }
+      @Override
+      public Cell current() {
+        return this.currentCell;
+      }
 
-    @Override
-    public byte getTypeByte() {
-      return cell.getTypeByte();
-    }
+      @Override
+      public boolean advance() {
+        while(true) {
+          if (this.currentIterator == null) {
+            if (!this.entries.hasNext()) return false;
+            this.currentIterator = this.entries.next().getValue().iterator();
+          }
+          if (this.currentIterator.hasNext()) {
+            this.currentCell = this.currentIterator.next();
+            return true;
+          }
+          this.currentCell = null;
+          this.currentIterator = null;
+        }
+      }
+    };
+  }
 
-    @Override
-    public long getSequenceId() {
-      return cell.getSequenceId();
-    }
+  /**
+   * @param left
+   * @param right
+   * @return True if the rows in <code>left</code> and <code>right</code> Cells match
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   *             Instead use {@link #matchingRows(Cell, Cell)}
+   */
+  @Deprecated
+  public static boolean matchingRow(final Cell left, final Cell right) {
+    return matchingRows(left, right);
+  }
 
-    @Override
-    public byte[] getValueArray() {
-      return cell.getValueArray();
-    }
+  /**
+   *  @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   *             Instead use {@link #matchingRows(Cell, byte[])}
+   */
+  @Deprecated
+  public static boolean matchingRow(final Cell left, final byte[] buf) {
+    return matchingRows(left, buf);
+  }
 
-    @Override
-    public int getValueOffset() {
-      return cell.getValueOffset();
+  public static boolean matchingRows(final Cell left, final byte[] buf) {
+    if (buf == null) {
+      return left.getRowLength() == 0;
     }
+    return PrivateCellUtil.matchingRows(left, buf, 0, buf.length);
+  }
 
-    @Override
-    public int getValueLength() {
-      return cell.getValueLength();
-    }
+  public static boolean matchingRow(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    return PrivateCellUtil.matchingRows(left, buf, offset, length);
+  }
 
-    @Override
-    public byte[] getTagsArray() {
-      return this.tags;
+  public static boolean matchingFamily(final Cell left, final Cell right) {
+    byte lfamlength = left.getFamilyLength();
+    byte rfamlength = right.getFamilyLength();
+    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
+          ((ByteBufferCell) left).getFamilyPosition(), lfamlength,
+          ((ByteBufferCell) right).getFamilyByteBuffer(),
+          ((ByteBufferCell) right).getFamilyPosition(), rfamlength);
     }
-
-    @Override
-    public int getTagsOffset() {
-      return 0;
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
+          ((ByteBufferCell) left).getFamilyPosition(), lfamlength,
+          right.getFamilyArray(), right.getFamilyOffset(), rfamlength);
     }
-
-    @Override
-    public int getTagsLength() {
-      if (null == this.tags) {
-        // Nulled out tags array optimization in constructor
-        return 0;
-      }
-      return this.tags.length;
+    if (right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) right).getFamilyByteBuffer(),
+          ((ByteBufferCell) right).getFamilyPosition(), rfamlength,
+          left.getFamilyArray(), left.getFamilyOffset(), lfamlength);
     }
+    return Bytes.equals(left.getFamilyArray(), left.getFamilyOffset(), lfamlength,
+        right.getFamilyArray(), right.getFamilyOffset(), rfamlength);
+  }
 
-    @Override
-    public long heapSize() {
-      long sum = HEAP_SIZE_OVERHEAD + CellUtil.estimatedHeapSizeOf(cell);
-      if (this.tags != null) {
-        sum += ClassSize.sizeOf(this.tags);
-      }
-      return sum;
+  public static boolean matchingFamily(final Cell left, final byte[] buf) {
+    if (buf == null) {
+      return left.getFamilyLength() == 0;
     }
+    return matchingFamily(left, buf, 0, buf.length);
+  }
 
-    @Override
-    public void setTimestamp(long ts) throws IOException {
-      // The incoming cell is supposed to be SettableTimestamp type.
-      CellUtil.setTimestamp(cell, ts);
-    }
-
-    @Override
-    public void setTimestamp(byte[] ts, int tsOffset) throws IOException {
-      // The incoming cell is supposed to be SettableTimestamp type.
-      CellUtil.setTimestamp(cell, ts, tsOffset);
-    }
-
-    @Override
-    public void setSequenceId(long seqId) throws IOException {
-      // The incoming cell is supposed to be SettableSequenceId type.
-      CellUtil.setSequenceId(cell, seqId);
-    }
-
-    @Override
-    public int write(OutputStream out, boolean withTags) throws IOException {
-      int len = ((ExtendedCell) this.cell).write(out, false);
-      if (withTags && this.tags != null) {
-        // Write the tagsLength 2 bytes
-        out.write((byte) (0xff & (this.tags.length >> 8)));
-        out.write((byte) (0xff & this.tags.length));
-        out.write(this.tags);
-        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
-      }
-      return len;
-    }
+  /**
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static boolean matchingFamily(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    return PrivateCellUtil.matchingFamily(left, buf, offset, length);
+  }
 
-    @Override
-    public int getSerializedSize(boolean withTags) {
-      int len = ((ExtendedCell) this.cell).getSerializedSize(false);
-      if (withTags && this.tags != null) {
-        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
-      }
-      return len;
+  public static boolean matchingQualifier(final Cell left, final Cell right) {
+    int lqlength = left.getQualifierLength();
+    int rqlength = right.getQualifierLength();
+    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
+          ((ByteBufferCell) left).getQualifierPosition(), lqlength,
+          ((ByteBufferCell) right).getQualifierByteBuffer(),
+          ((ByteBufferCell) right).getQualifierPosition(), rqlength);
     }
-
-    @Override
-    public void write(ByteBuffer buf, int offset) {
-      offset = KeyValueUtil.appendTo(this.cell, buf, offset, false);
-      int tagsLen = this.tags == null ? 0 : this.tags.length;
-      if (tagsLen > 0) {
-        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
-        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, this.tags, 0, tagsLen);
-      }
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
+          ((ByteBufferCell) left).getQualifierPosition(), lqlength,
+          right.getQualifierArray(), right.getQualifierOffset(), rqlength);
     }
-
-    @Override
-    public ExtendedCell deepClone() {
-      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
-      return new TagRewriteCell(clonedBaseCell, this.tags);
+    if (right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) right).getQualifierByteBuffer(),
+          ((ByteBufferCell) right).getQualifierPosition(), rqlength,
+          left.getQualifierArray(), left.getQualifierOffset(), lqlength);
     }
+    return Bytes.equals(left.getQualifierArray(), left.getQualifierOffset(),
+        lqlength, right.getQualifierArray(), right.getQualifierOffset(),
+        rqlength);
   }
 
-  @InterfaceAudience.Private
-  private static class TagRewriteByteBufferCell extends ByteBufferCell implements ExtendedCell {
-
-    protected ByteBufferCell cell;
-    protected byte[] tags;
-    private static final long HEAP_SIZE_OVERHEAD = ClassSize.OBJECT + 2 * ClassSize.REFERENCE;
-
-    /**
-     * @param cell The original ByteBufferCell which it rewrites
-     * @param tags the tags bytes. The array suppose to contain the tags bytes alone.
-     */
-    public TagRewriteByteBufferCell(ByteBufferCell cell, byte[] tags) {
-      assert cell instanceof ExtendedCell;
-      assert tags != null;
-      this.cell = cell;
-      this.tags = tags;
-      // tag offset will be treated as 0 and length this.tags.length
-      if (this.cell instanceof TagRewriteByteBufferCell) {
-        // Cleaning the ref so that the byte[] can be GCed
-        ((TagRewriteByteBufferCell) this.cell).tags = null;
-      }
+  /**
+   * Finds if the qualifier part of the cell and the KV serialized
+   * byte[] are equal
+   * @param left
+   * @param buf the serialized keyvalue format byte[]
+   * @return true if the qualifier matches, false otherwise
+   */
+  public static boolean matchingQualifier(final Cell left, final byte[] buf) {
+    if (buf == null) {
+      return left.getQualifierLength() == 0;
     }
+    return matchingQualifier(left, buf, 0, buf.length);
+  }
 
-    @Override
-    public byte[] getRowArray() {
-      return this.cell.getRowArray();
-    }
+  /**
+   * Finds if the qualifier part of the cell and the KV serialized
+   * byte[] are equal
+   * @param left
+   * @param buf the serialized keyvalue format byte[]
+   * @param offset the offset of the qualifier in the byte[]
+   * @param length the length of the qualifier in the byte[]
+   * @return true if the qualifier matches, false otherwise
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static boolean matchingQualifier(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    return PrivateCellUtil.matchingQualifier(left, buf, offset, length);
+  }
 
-    @Override
-    public int getRowOffset() {
-      return this.cell.getRowOffset();
-    }
+  public static boolean matchingColumn(final Cell left, final byte[] fam, final byte[] qual) {
+    if (!matchingFamily(left, fam))
+      return false;
+    return matchingQualifier(left, qual);
+  }
 
-    @Override
-    public short getRowLength() {
-      return this.cell.getRowLength();
-    }
+  /**
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static boolean matchingColumn(final Cell left, final byte[] fam, final int foffset,
+      final int flength, final byte[] qual, final int qoffset, final int qlength) {
+    return PrivateCellUtil.matchingColumn(left, fam, foffset, flength, qual, qoffset, qlength);
+  }
 
-    @Override
-    public byte[] getFamilyArray() {
-      return this.cell.getFamilyArray();
-    }
+  public static boolean matchingColumn(final Cell left, final Cell right) {
+    if (!matchingFamily(left, right))
+      return false;
+    return matchingQualifier(left, right);
+  }
 
-    @Override
-    public int getFamilyOffset() {
-      return this.cell.getFamilyOffset();
-    }
+  public static boolean matchingValue(final Cell left, final Cell right) {
+    return matchingValue(left, right, left.getValueLength(), right.getValueLength());
+  }
 
-    @Override
-    public byte getFamilyLength() {
-      return this.cell.getFamilyLength();
+  public static boolean matchingValue(final Cell left, final Cell right, int lvlength,
+      int rvlength) {
+    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
+        ((ByteBufferCell) left).getValuePosition(), lvlength,
+        ((ByteBufferCell) right).getValueByteBuffer(),
+        ((ByteBufferCell) right).getValuePosition(), rvlength);
     }
-
-    @Override
-    public byte[] getQualifierArray() {
-      return this.cell.getQualifierArray();
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
+        ((ByteBufferCell) left).getValuePosition(), lvlength, right.getValueArray(),
+        right.getValueOffset(), rvlength);
     }
-
-    @Override
-    public int getQualifierOffset() {
-      return this.cell.getQualifierOffset();
+    if (right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) right).getValueByteBuffer(),
+        ((ByteBufferCell) right).getValuePosition(), rvlength, left.getValueArray(),
+        left.getValueOffset(), lvlength);
     }
+    return Bytes.equals(left.getValueArray(), left.getValueOffset(), lvlength,
+      right.getValueArray(), right.getValueOffset(), rvlength);
+  }
 
-    @Override
-    public int getQualifierLength() {
-      return this.cell.getQualifierLength();
+  public static boolean matchingValue(final Cell left, final byte[] buf) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getValueByteBuffer(),
+          ((ByteBufferCell) left).getValuePosition(), left.getValueLength(), buf, 0,
+          buf.length) == 0;
     }
+    return Bytes.equals(left.getValueArray(), left.getValueOffset(), left.getValueLength(), buf, 0,
+        buf.length);
+  }
 
-    @Override
-    public long getTimestamp() {
-      return this.cell.getTimestamp();
-    }
+  /**
+   * @return True if a delete type, a {@link KeyValue.Type#Delete} or a
+   *         {KeyValue.Type#DeleteFamily} or a
+   *         {@link KeyValue.Type#DeleteColumn} KeyValue type.
+   */
+  public static boolean isDelete(final Cell cell) {
+    return PrivateCellUtil.isDelete(cell.getTypeByte());
+  }
 
-    @Override
-    public byte getTypeByte() {
-      return this.cell.getTypeByte();
-    }
+  /**
+   * @return True if a delete type, a {@link KeyValue.Type#Delete} or a
+   *         {KeyValue.Type#DeleteFamily} or a
+   *         {@link KeyValue.Type#DeleteColumn} KeyValue type.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static boolean isDelete(final byte type) {
+    return Type.Delete.getCode() <= type
+        && type <= Type.DeleteFamily.getCode();
+  }
 
-    @Override
-    public long getSequenceId() {
-      return this.cell.getSequenceId();
-    }
+  /**
+   * @return True if this cell is a {@link KeyValue.Type#Delete} type.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static boolean isDeleteType(Cell cell) {
+    return cell.getTypeByte() == Type.Delete.getCode();
+  }
 
-    @Override
-    public byte[] getValueArray() {
-      return this.cell.getValueArray();
-    }
+  /**
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. 
+   */
+  @Deprecated
+  public static boolean isDeleteFamily(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteFamily.getCode();
+  }
 
-    @Override
-    public int getValueOffset() {
-      return this.cell.getValueOffset();
-    }
+  /**
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. 
+   */
+  @Deprecated
+  public static boolean isDeleteFamilyVersion(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteFamilyVersion.getCode();
+  }
 
-    @Override
-    public int getValueLength() {
-      return this.cell.getValueLength();
-    }
+  /**
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. 
+   */
+  @Deprecated
+  public static boolean isDeleteColumns(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteColumn.getCode();
+  }
 
-    @Override
-    public byte[] getTagsArray() {
-      return this.tags;
-    }
+  /**
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. 
+   */
+  @Deprecated
+  public static boolean isDeleteColumnVersion(final Cell cell) {
+    return cell.getTypeByte() == Type.Delete.getCode();
+  }
 
-    @Override
-    public int getTagsOffset() {
-      return 0;
-    }
+  /**
+   *
+   * @return True if this cell is a delete family or column type.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static boolean isDeleteColumnOrFamily(Cell cell) {
+    int t = cell.getTypeByte();
+    return t == Type.DeleteColumn.getCode() || t == Type.DeleteFamily.getCode();
+  }
 
-    @Override
-    public int getTagsLength() {
-      if (null == this.tags) {
-        // Nulled out tags array optimization in constructor
-        return 0;
-      }
-      return this.tags.length;
-    }
+  /**
+   * Estimate based on keyvalue's serialization format in the RPC layer. Note that there is an extra
+   * SIZEOF_INT added to the size here that indicates the actual length of the cell for cases where
+   * cell's are serialized in a contiguous format (For eg in RPCs).
+   * @param cell
+   * @return Estimate of the <code>cell</code> size in bytes plus an extra SIZEOF_INT indicating the
+   *         actual cell length.
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static int estimatedSerializedSizeOf(final Cell cell) {
+    return PrivateCellUtil.estimatedSerializedSizeOf(cell);
+  }
 
-    @Override
-    public void setSequenceId(long seqId) throws IOException {
-      CellUtil.setSequenceId(this.cell, seqId);
-    }
+  /**
+   * Calculates the serialized key size. We always serialize in the KeyValue's serialization
+   * format.
+   * @param cell the cell for which the key size has to be calculated.
+   * @return the key size
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static int estimatedSerializedSizeOfKey(final Cell cell) {
+    return PrivateCellUtil.estimatedSerializedSizeOfKey(cell);
+  }
 
-    @Override
-    public void setTimestamp(long ts) throws IOException {
-      CellUtil.setTimestamp(this.cell, ts);
-    }
+  /**
+   * This is an estimate of the heap space occupied by a cell. When the cell is of type
+   * {@link HeapSize} we call {@link HeapSize#heapSize()} so cell can give a correct value. In other
+   * cases we just consider the bytes occupied by the cell components ie. row, CF, qualifier,
+   * timestamp, type, value and tags.
+   * @param cell
+   * @return estimate of the heap space
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static long estimatedHeapSizeOf(final Cell cell) {
+    return PrivateCellUtil.estimatedHeapSizeOf(cell);
+  }
 
-    @Override
-    public void setTimestamp(byte[] ts, int tsOffset) throws IOException {
-      CellUtil.setTimestamp(this.cell, ts, tsOffset);
-    }
+  /********************* tags *************************************/
+  /**
+   * Util method to iterate through the tags
+   *
+   * @param tags
+   * @param offset
+   * @param length
+   * @return iterator for the tags
+   * @deprecated As of 2.0.0 and will be removed in 3.0.0
+   *             Instead use {@link #tagsIterator(Cell)}
+   */
+  @Deprecated
+  public static Iterator<Tag> tagsIterator(final byte[] tags, final int offset, final int length) {
+    return new Iterator<Tag>() {
+      private int pos = offset;
+      private int endOffset = offset + length - 1;
 
-    @Override
-    public long heapSize() {
-      long sum = HEAP_SIZE_OVERHEAD + CellUtil.estimatedHeapSizeOf(cell);
-      // this.tags is on heap byte[]
-      if (this.tags != null) {
-        sum += ClassSize.sizeOf(this.tags);
+      @Override
+      public boolean hasNext() {
+        return this.pos < endOffset;
       }
-      return sum;
-    }
 
-    @Override
-    public int write(OutputStream out, boolean withTags) throws IOException {
-      int len = ((ExtendedCell) this.cell).write(out, false);
-      if (withTags && this.tags != null) {
-        // Write the tagsLength 2 bytes
-        out.write((byte) (0xff & (this.tags.length >> 8)));
-        out.write((byte) (0xff & this.tags.length));
-        out.write(this.tags);
-        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
+      @Override
+      public Tag next() {
+        if (hasNext()) {
+          int curTagLen = Bytes.readAsInt(tags, this.pos, Tag.TAG_LENGTH_SIZE);
+          Tag tag = new ArrayBackedTag(tags, pos, curTagLen + TAG_LENGTH_SIZE);
+          this.pos += Bytes.SIZEOF_SHORT + curTagLen;
+          return tag;
+        }
+        return null;
       }
-      return len;
-    }
 
-    @Override
-    public int getSerializedSize(boolean withTags) {
-      int len = ((ExtendedCell) this.cell).getSerializedSize(false);
-      if (withTags && this.tags != null) {
-        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
-      }
-      return len;
-    }
-
-    @Override
-    public void write(ByteBuffer buf, int offset) {
-      offset = KeyValueUtil.appendTo(this.cell, buf, offset, false);
-      int tagsLen = this.tags == null ? 0 : this.tags.length;
-      if (tagsLen > 0) {
-        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
-        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, this.tags, 0, tagsLen);
-      }
-    }
-
-    @Override
-    public ExtendedCell deepClone() {
-      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
-      if (clonedBaseCell instanceof ByteBufferCell) {
-        return new TagRewriteByteBufferCell((ByteBufferCell) clonedBaseCell, this.tags);
+      @Override
+      public void remove() {
+        throw new UnsupportedOperationException();
       }
-      return new TagRewriteCell(clonedBaseCell, this.tags);
-    }
-
-    @Override
-    public ByteBuffer getRowByteBuffer() {
-      return this.cell.getRowByteBuffer();
-    }
-
-    @Override
-    public int getRowPosition() {
-      return this.cell.getRowPosition();
-    }
-
-    @Override
-    public ByteBuffer getFamilyByteBuffer() {
-      return this.cell.getFamilyByteBuffer();
-    }
-
-    @Override
-    public int getFamilyPosition() {
-      return this.cell.getFamilyPosition();
-    }
-
-    @Override
-    public ByteBuffer getQualifierByteBuffer() {
-      return this.cell.getQualifierByteBuffer();
-    }
-
-    @Override
-    public int getQualifierPosition() {
-      return this.cell.getQualifierPosition();
-    }
-
-    @Override
-    public ByteBuffer getValueByteBuffer() {
-      return this.cell.getValueByteBuffer();
-    }
-
-    @Override
-    public int getValuePosition() {
-      return this.cell.getValuePosition();
-    }
-
-    @Override
-    public ByteBuffer getTagsByteBuffer() {
-      return this.tags == null ? HConstants.EMPTY_BYTE_BUFFER : ByteBuffer.wrap(this.tags);
-    }
-
-    @Override
-    public int getTagsPosition() {
-      return 0;
-    }
+    };
   }
 
-  @InterfaceAudience.Private
-  private static class ValueAndTagRewriteCell extends TagRewriteCell {
-
-    protected byte[] value;
-
-    public ValueAndTagRewriteCell(Cell cell, byte[] value, byte[] tags) {
-      super(cell, tags);
-      this.value = value;
-    }
-
-    @Override
-    public byte[] getValueArray() {
-      return this.value;
-    }
-
-    @Override
-    public int getValueOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getValueLength() {
-      return this.value == null ? 0 : this.value.length;
-    }
-
-    @Override
-    public long heapSize() {
-      long sum = ClassSize.REFERENCE + super.heapSize();
-      if (this.value != null) {
-        sum += ClassSize.sizeOf(this.value);
-      }
-      return sum;
-    }
-
-    @Override
-    public int write(OutputStream out, boolean withTags) throws IOException {
-      return write(out, withTags, this.cell, this.value, this.tags);
-    }
-
-    // Made into a static method so as to reuse the logic within ValueAndTagRewriteByteBufferCell
-    static int write(OutputStream out, boolean withTags, Cell cell, byte[] value, byte[] tags)
-        throws IOException {
-      int valLen = value == null ? 0 : value.length;
-      ByteBufferUtils.putInt(out, KeyValueUtil.keyLength(cell));// Key length
-      ByteBufferUtils.putInt(out, valLen);// Value length
-      int len = 2 * Bytes.SIZEOF_INT;
-      len += CellUtil.writeFlatKey(cell, out);// Key
-      if (valLen > 0) out.write(value);// Value
-      len += valLen;
-      if (withTags && tags != null) {
-        // Write the tagsLength 2 bytes
-        out.write((byte) (0xff & (tags.length >> 8)));
-        out.write((byte) (0xff & tags.length));
-        out.write(tags);
-        len += KeyValue.TAGS_LENGTH_SIZE + tags.length;
-      }
-      return len;
-    }
-
-    @Override
-    public int getSerializedSize(boolean withTags) {
-      return super.getSerializedSize(withTags) - this.cell.getValueLength() + this.value.length;
-    }
-
-    @Override
-    public void write(ByteBuffer buf, int offset) {
-      write(buf, offset, this.cell, this.value, this.tags);
-    }
-
-    // Made into a static method so as to reuse the logic within ValueAndTagRewriteByteBufferCell
-    static void write(ByteBuffer buf, int offset, Cell cell, byte[] value, byte[] tags) {
-      offset = ByteBufferUtils.putInt(buf, offset, KeyValueUtil.keyLength(cell));// Key length
-      offset = ByteBufferUtils.putInt(buf, offset, value.length);// Value length
-      offset = KeyValueUtil.appendKeyTo(cell, buf, offset);
-      ByteBufferUtils.copyFromArrayToBuffer(buf, offset, value, 0, value.length);
-      offset += value.length;
-      int tagsLen = tags == null ? 0 : tags.length;
-      if (tagsLen > 0) {
-        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
-        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, tags, 0, tagsLen);
-      }
-    }
-
-    @Override
-    public ExtendedCell deepClone() {
-      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
-      return new ValueAndTagRewriteCell(clonedBaseCell, this.value, this.tags);
-    }
+  /**
+   * @param cell The Cell
+   * @return Tags in the given Cell as a List
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static List<Tag> getTags(Cell cell) {
+    return PrivateCellUtil.getTags(cell);
   }
 
-  @InterfaceAudience.Private
-  private static class ValueAndTagRewriteByteBufferCell extends TagRewriteByteBufferCell {
-
-    protected byte[] value;
-
-    public ValueAndTagRewriteByteBufferCell(ByteBufferCell cell, byte[] value, byte[] tags) {
-      super(cell, tags);
-      this.value = value;
-    }
-
-    @Override
-    public byte[] getValueArray() {
-      return this.value;
-    }
-
-    @Override
-    public int getValueOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getValueLength() {
-      return this.value == null ? 0 : this.value.length;
-    }
-
-    @Override
-    public ByteBuffer getValueByteBuffer() {
-      return ByteBuffer.wrap(this.value);
-    }
-
-    @Override
-    public int getValuePosition() {
-      return 0;
-    }
-
-    @Override
-    public long heapSize() {
-      long sum = ClassSize.REFERENCE + super.heapSize();
-      if (this.value != null) {
-        sum += ClassSize.sizeOf(this.value);
-      }
-      return sum;
-    }
-
-    @Override
-    public int write(OutputStream out, boolean withTags) throws IOException {
-      return ValueAndTagRewriteCell.write(out, withTags, this.cell, this.value, this.tags);
-    }
-
-    @Override
-    public int getSerializedSize(boolean withTags) {
-      return super.getSerializedSize(withTags) - this.cell.getValueLength() + this.value.length;
-    }
-
-    @Override
-    public void write(ByteBuffer buf, int offset) {
-      ValueAndTagRewriteCell.write(buf, offset, this.cell, this.value, this.tags);
-    }
-
-    @Override
-    public ExtendedCell deepClone() {
-      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
-      if (clonedBaseCell instanceof ByteBufferCell) {
-        return new ValueAndTagRewriteByteBufferCell((ByteBufferCell) clonedBaseCell, this.value,
-            this.tags);
-      }
-      return new ValueAndTagRewriteCell(clonedBaseCell, this.value, this.tags);
-    }
+  /**
+   * Retrieve Cell's first tag, matching the passed in type
+   *
+   * @param cell The Cell
+   * @param type Type of the Tag to retrieve
+   * @return null if there is no tag of the passed in tag type
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static Tag getTag(Cell cell, byte type){
+    return PrivateCellUtil.getTag(cell, type);
   }
 
   /**
-   * @param cellScannerables
-   * @return CellScanner interface over <code>cellIterables</code>
+   * Returns true if the first range start1...end1 overlaps with the second range
+   * start2...end2, assuming the byte arrays represent row keys
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public static CellScanner createCellScanner(
-      final List<? extends CellScannable> cellScannerables) {
-    return new CellScanner() {
-      private final Iterator<? extends CellScannable> iterator = cellScannerables.iterator();
-      private CellScanner cellScanner = null;
-
-      @Override
-      public Cell current() {
-        return this.cellScanner != null? this.cellScanner.current(): null;
-      }
-
-      @Override
-      public boolean advance() throws IOException {
-        while (true) {
-          if (this.cellScanner == null) {
-            if (!this.iterator.hasNext()) return false;
-            this.cellScanner = this.iterator.next().cellScanner();
-          }
-          if (this.cellScanner.advance()) return true;
-          this.cellScanner = null;
-        }
-      }
-    };
+  @Deprecated
+  public static boolean overlappingKeys(final byte[] start1, final byte[] end1,
+      final byte[] start2, final byte[] end2) {
+    return PrivateCellUtil.overlappingKeys(start1, end1, start2, end2);
   }
 
   /**
-   * @param cellIterable
-   * @return CellScanner interface over <code>cellIterable</code>
+   * Sets the given seqId to the cell.
+   * Marked as audience Private as of 1.2.0.
+   * Setting a Cell sequenceid is an internal implementation detail not for general public use.
+   * @param cell
+   * @param seqId
+   * @throws IOException when the passed cell is not of type {@link SettableSequenceId}
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public static CellScanner createCellScanner(final Iterable<Cell> cellIterable) {
-    if (cellIterable == null) return null;
-    return createCellScanner(cellIterable.iterator());
+  @Deprecated
+  public static void setSequenceId(Cell cell, long seqId) throws IOException {
+    PrivateCellUtil.setSequenceId(cell, seqId);
   }
 
   /**
-   * @param cells
-   * @return CellScanner interface over <code>cellIterable</code> or null if <code>cells</code> is
-   * null
+   * Sets the given timestamp to the cell.
+   * @param cell
+   * @param ts
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public static CellScanner createCellScanner(final Iterator<Cell> cells) {
-    if (cells == null) return null;
-    return new CellScanner() {
-      private final Iterator<Cell> iterator = cells;
-      private Cell current = null;
-
-      @Override
-      public Cell current() {
-        return this.current;
-      }
-
-      @Override
-      public boolean advance() {
-        boolean hasNext = this.iterator.hasNext();
-        this.current = hasNext? this.iterator.next(): null;
-        return hasNext;
-      }
-    };
+  @Deprecated
+  public static void setTimestamp(Cell cell, long ts) throws IOException {
+    PrivateCellUtil.setTimestamp(cell, ts);
   }
 
   /**
-   * @param cellArray
-   * @return CellScanner interface over <code>cellArray</code>
+   * Sets the given timestamp to the cell.
+   * @param cell
+   * @param ts buffer containing the timestamp value
+   * @param tsOffset offset to the new timestamp
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public static CellScanner createCellScanner(final Cell[] cellArray) {
-    return new CellScanner() {
-      private final Cell [] cells = cellArray;
-      private int index = -1;
-
-      @Override
-      public Cell current() {
-        if (cells == null) return null;
-        return (index < 0)? null: this.cells[index];
-      }
-
-      @Override
-      public boolean advance() {
-        if (cells == null) return false;
-        return ++index < this.cells.length;
-      }
-    };
+  @Deprecated
+  public static void setTimestamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
+    PrivateCellUtil.setTimestamp(cell, ts, tsOffset);
   }
 
   /**
-   * Flatten the map of cells out under the CellScanner
-   * @param map Map of Cell Lists; for example, the map of families to Cells that is used
-   * inside Put, etc., keeping Cells organized by family.
-   * @return CellScanner interface over <code>cellIterable</code>
+   * Sets the given timestamp to the cell iff current timestamp is
+   * {@link HConstants#LATEST_TIMESTAMP}.
+   * @param cell
+   * @param ts
+   * @return True if cell timestamp is modified.
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public static CellScanner createCellScanner(final NavigableMap<byte [], List<Cell>> map) {
-    return new CellScanner() {
-      private final Iterator<Entry<byte[], List<Cell>>> entries = map.entrySet().iterator();
-      private Iterator<Cell> currentIterator = null;
-      private Cell currentCell;
-
-      @Override
-      public Cell current() {
-        return this.currentCell;
-      }
-
-      @Override
-      public boolean advance() {
-        while(true) {
-          if (this.currentIterator == null) {
-            if (!this.entries.hasNext()) return false;
-            this.currentIterator = this.entries.next().getValue().iterator();
-          }
-          if (this.currentIterator.hasNext()) {
-            this.currentCell = this.currentIterator.next();
-            return true;
-          }
-          this.currentCell = null;
-          this.currentIterator = null;
-        }
-      }
-    };
+  @Deprecated
+  public static boolean updateLatestStamp(Cell cell, long ts) throws IOException {
+    return PrivateCellUtil.updateLatestStamp(cell, ts);
   }
 
   /**
-   * @param left
-   * @param right
-   * @return True if the rows in <code>left</code> and <code>right</code> Cells match
+   * Sets the given timestamp to the cell iff current timestamp is
+   * {@link HConstants#LATEST_TIMESTAMP}.
+   * @param cell
+   * @param ts buffer containing the timestamp value
+   * @param tsOffset offset to the new timestamp
+   * @return True if cell timestamp is modified.
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
-   *             Instead use {@link #matchingRows(Cell, Cell)}
    */
   @Deprecated
-  public static boolean matchingRow(final Cell left, final Cell right) {
-    return matchingRows(left, right);
+  public static boolean updateLatestStamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
+    return PrivateCellUtil.updateLatestStamp(cell, ts, tsOffset);
   }
 
-  public static boolean matchingRow(final Cell left, final byte[] buf) {
-    if (buf == null) {
-      return left.getRowLength() == 0;
-    }
-    return matchingRow(left, buf, 0, buf.length);
-  }
-
-  public static boolean matchingRow(final Cell left, final byte[] buf, final int offset,
-      final int length) {
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
-          ((ByteBufferCell) left).getRowPosition(), left.getRowLength(), buf, offset,
-          length);
-    }
-    return Bytes.equals(left.getRowArray(), left.getRowOffset(), left.getRowLength(), buf, offset,
-        length);
-  }
-
-  public static boolean matchingFamily(final Cell left, final Cell right) {
-    byte lfamlength = left.getFamilyLength();
-    byte rfamlength = right.getFamilyLength();
-    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
-          ((ByteBufferCell) left).getFamilyPosition(), lfamlength,
-          ((ByteBufferCell) right).getFamilyByteBuffer(),
-          ((ByteBufferCell) right).getFamilyPosition(), rfamlength);
-    }
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
-          ((ByteBufferCell) left).getFamilyPosition(), lfamlength,
-          right.getFamilyArray(), right.getFamilyOffset(), rfamlength);
-    }
-    if (right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) right).getFamilyByteBuffer(),
-          ((ByteBufferCell) right).getFamilyPosition(), rfamlength,
-          left.getFamilyArray(), left.getFamilyOffset(), lfamlength);
-    }
-    return Bytes.equals(left.getFamilyArray(), left.getFamilyOffset(), lfamlength,
-        right.getFamilyArray(), right.getFamilyOffset(), rfamlength);
-  }
-
-  public static boolean matchingFamily(final Cell left, final byte[] buf) {
-    if (buf == null) {
-      return left.getFamilyLength() == 0;
-    }
-    return matchingFamily(left, buf, 0, buf.length);
-  }
-
-  public static boolean matchingFamily(final Cell left, final byte[] buf, final int offset,
-      final int length) {
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
-          ((ByteBufferCell) left).getFamilyPosition(), left.getFamilyLength(), buf,
-          offset, length);
-    }
-    return Bytes.equals(left.getFamilyArray(), left.getFamilyOffset(), left.getFamilyLength(), buf,
-        offset, length);
-  }
-
-  public static boolean matchingQualifier(final Cell left, final Cell right) {
-    int lqlength = left.getQualifierLength();
-    int rqlength = right.getQualifierLength();
-    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
-          ((ByteBufferCell) left).getQualifierPosition(), lqlength,
-          ((ByteBufferCell) right).getQualifierByteBuffer(),
-          ((ByteBufferCell) right).getQualifierPosition(), rqlength);
-    }
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
-          ((ByteBufferCell) left).getQualifierPosition(), lqlength,
-          right.getQualifierArray(), right.getQualifierOffset(), rqlength);
-    }
-    if (right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) right).getQualifierByteBuffer(),
-          ((ByteBufferCell) right).getQualifierPosition(), rqlength,
-          left.getQualifierArray(), left.getQualifierOffset(), lqlength);
-    }
-    return Bytes.equals(left.getQualifierArray(), left.getQualifierOffset(),
-        lqlength, right.getQualifierArray(), right.getQualifierOffset(),
-        rqlength);
-  }
-
-  /**
-   * Finds if the qualifier part of the cell and the KV serialized
-   * byte[] are equal
-   * @param left
-   * @param buf the serialized keyvalue format byte[]
-   * @return true if the qualifier matches, false otherwise
-   */
-  public static boolean matchingQualifier(final Cell left, final byte[] buf) {
-    if (buf == null) {
-      return left.getQualifierLength() == 0;
-    }
-    return matchingQualifier(left, buf, 0, buf.length);
-  }
-
-  /**
-   * Finds if the qualifier part of the cell and the KV serialized
-   * byte[] are equal
-   * @param left
-   * @param buf the serialized keyvalue format byte[]
-   * @param offset the offset of the qualifier in the byte[]
-   * @param length the length of the qualifier in the byte[]
-   * @return true if the qualifier matches, false otherwise
-   */
-  public static boolean matchingQualifier(final Cell left, final byte[] buf, final int offset,
-      final int length) {
-    if (buf == null) {
-      return left.getQualifierLength() == 0;
-    }
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
-          ((ByteBufferCell) left).getQualifierPosition(), left.getQualifierLength(),
-          buf, offset, length);
-    }
-    return Bytes.equals(left.getQualifierArray(), left.getQualifierOffset(),
-        left.getQualifierLength(), buf, offset, length);
-  }
-
-  public static boolean matchingColumn(final Cell left, final byte[] fam, final byte[] qual) {
-    if (!matchingFamily(left, fam))
-      return false;
-    return matchingQualifier(left, qual);
-  }
-
-  public static boolean matchingColumn(final Cell left, final byte[] fam, final int foffset,
-      final int flength, final byte[] qual, final int qoffset, final int qlength) {
-    if (!matchingFamily(left, fam, foffset, flength))
-      return false;
-    return matchingQualifier(left, qual, qoffset, qlength);
-  }
-
-  public static boolean matchingColumn(final Cell left, final Cell right) {
-    if (!matchingFamily(left, right))
-      return false;
-    return matchingQualifier(left, right);
-  }
-
-  public static boolean matchingValue(final Cell left, final Cell right) {
-    return matchingValue(left, right, left.getValueLength(), right.getValueLength());
-  }
-
-  public static boolean matchingValue(final Cell left, final Cell right, int lvlength,
-      int rvlength) {
-    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
-        ((ByteBufferCell) left).getValuePosition(), lvlength,
-        ((ByteBufferCell) right).getValueByteBuffer(),
-        ((ByteBufferCell) right).getValuePosition(), rvlength);
-    }
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
-        ((ByteBufferCell) left).getValuePosition(), lvlength, right.getValueArray(),
-        right.getValueOffset(), rvlength);
-    }
-    if (right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) right).getValueByteBuffer(),
-        ((ByteBufferCell) right).getValuePosition(), rvlength, left.getValueArray(),
-        left.getValueOffset(), lvlength);
-    }
-    return Bytes.equals(left.getValueArray(), left.getValueOffset(), lvlength,
-      right.getValueArray(), right.getValueOffset(), rvlength);
-  }
-
-  public static boolean matchingValue(final Cell left, final byte[] buf) {
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getValueByteBuffer(),
-          ((ByteBufferCell) left).getValuePosition(), left.getValueLength(), buf, 0,
-          buf.length) == 0;
-    }
-    return Bytes.equals(left.getValueArray(), left.getValueOffset(), left.getValueLength(), buf, 0,
-        buf.length);
-  }
-
-  /**
-   * @return True if a delete type, a {@link KeyValue.Type#Delete} or a
-   *         {KeyValue.Type#DeleteFamily} or a
-   *         {@link KeyValue.Type#DeleteColumn} KeyValue type.
-   */
-  public static boolean isDelete(final Cell cell) {
-    return isDelete(cell.getTypeByte());
-  }
-
-  /**
-   * @return True if a delete type, a {@link KeyValue.Type#Delete} or a
-   *         {KeyValue.Type#DeleteFamily} or a
-   *         {@link KeyValue.Type#DeleteColumn} KeyValue type.
-   */
-  public static boolean isDelete(final byte type) {
-    return Type.Delete.getCode() <= type
-        && type <= Type.DeleteFamily.getCode();
-  }
-
-  /**
-   * @return True if this cell is a {@link KeyValue.Type#Delete} type.
-   */
-  public static boolean isDeleteType(Cell cell) {
-    return cell.getTypeByte() == Type.Delete.getCode();
-  }
-
-  public static boolean isDeleteFamily(final Cell cell) {
-    return cell.getTypeByte() == Type.DeleteFamily.getCode();
-  }
-
-  public static boolean isDeleteFamilyVersion(final Cell cell) {
-    return cell.getTypeByte() == Type.DeleteFamilyVersion.getCode();
-  }
-
-  public static boolean isDeleteColumns(final Cell cell) {
-    return cell.getTypeByte() == Type.DeleteColumn.getCode();
-  }
-
-  public static boolean isDeleteColumnVersion(final Cell cell) {
-    return cell.getTypeByte() == Type.Delete.getCode();
-  }
-
-  /**
-   *
-   * @return True if this cell is a delete family or column type.
-   */
-  public static boolean isDeleteColumnOrFamily(Cell cell) {
-    int t = cell.getTypeByte();
-    return t == Type.DeleteColumn.getCode() || t == Type.DeleteFamily.getCode();
-  }
-
-  /**
-   * Estimate based on keyvalue's serialization format in the RPC layer. Note that there is an extra
-   * SIZEOF_INT added to the size here that indicates the actual length of the cell for cases where
-   * cell's are serialized in a contiguous format (For eg in RPCs).
-   * @param cell
-   * @return Estimate of the <code>cell</code> size in bytes plus an extra SIZEOF_INT indicating the
-   *         actual cell length.
-   */
-  public static int estimatedSerializedSizeOf(final Cell cell) {
-    if (cell instanceof ExtendedCell) {
-      return ((ExtendedCell) cell).getSerializedSize(true) + Bytes.SIZEOF_INT;
-    }
-
-    return getSumOfCellElementLengths(cell) +
-      // Use the KeyValue's infrastructure size presuming that another implementation would have
-      // same basic cost.
-      KeyValue.ROW_LENGTH_SIZE + KeyValue.FAMILY_LENGTH_SIZE +
-      // Serialization is probably preceded by a length (it is in the KeyValueCodec at least).
-      Bytes.SIZEOF_INT;
-  }
-
-  /**
-   * @param cell
-   * @return Sum of the lengths of all the elements in a Cell; does not count in any infrastructure
-   */
-  private static int getSumOfCellElementLengths(final Cell cell) {
-    return getSumOfCellKeyElementLengths(cell) + cell.getValueLength() + cell.getTagsLength();
-  }
-
-  /**
-   * @param cell
-   * @return Sum of all elements that make up a key; does not include infrastructure, tags or
-   * values.
-   */
-  private static int getSumOfCellKeyElementLengths(final Cell cell) {
-    return cell.getRowLength() + cell.getFamilyLength() +
-    cell.getQualifierLength() +
-    KeyValue.TIMESTAMP_TYPE_SIZE;
-  }
-
-  /**
-   * Calculates the serialized key size. We always serialize in the KeyValue's serialization
-   * format.
-   * @param cell the cell for which the key size has to be calculated.
-   * @return the key size
-   */
-  public static int estimatedSerializedSizeOfKey(final Cell cell) {
-    if (cell instanceof KeyValue) return ((KeyValue)cell).getKeyLength();
-    return cell.getRowLength() + cell.getFamilyLength() +
-        cell.getQualifierLength() +
-        KeyValue.KEY_INFRASTRUCTURE_SIZE;
-  }
-
-  /**
-   * This is an estimate of the heap space occupied by a cell. When the cell is of type
-   * {@link HeapSize} we call {@link HeapSize#heapSize()} so cell can give a correct value. In other
-   * cases we just consider the bytes occupied by the cell components ie. row, CF, qualifier,
-   * timestamp, type, value and tags.
-   * @param cell
-   * @return estimate of the heap space
-   */
-  public static long estimatedHeapSizeOf(final Cell cell) {
-    if (cell instanceof HeapSize) {
-      return ((HeapSize) cell).heapSize();
-    }
-    // TODO: Add sizing of references that hold the row, family, etc., arrays.
-    return estimatedSerializedSizeOf(cell);
-  }
-
-  /********************* tags *************************************/
-  /**
-   * Util method to iterate through the tags
-   *
-   * @param tags
-   * @param offset
-   * @param length
-   * @return iterator for the tags
-   * @deprecated As of 2.0.0 and will be removed in 3.0.0
-   *             Instead use {@link #tagsIterator(Cell)}
-   */
-  @Deprecated
-  public static Iterator<Tag> tagsIterator(final byte[] tags, final int offset, final int length) {
-    return new Iterator<Tag>() {
-      private int pos = offset;
-      private int endOffset = offset + length - 1;
-
-      @Override
-      public boolean hasNext() {
-        return this.pos < endOffset;
-      }
-
-      @Override
-      public Tag next() {
-        if (hasNext()) {
-          int curTagLen = Bytes.readAsInt(tags, this.pos, Tag.TAG_LENGTH_SIZE);
-          Tag tag = new ArrayBackedTag(tags, pos, curTagLen + TAG_LENGTH_SIZE);
-          this.pos += Bytes.SIZEOF_SHORT + curTagLen;
-          return tag;
-        }
-        return null;
-      }
-
-      @Override
-      public void remove() {
-        throw new UnsupportedOperationException();
-      }
-    };
-  }
-
-  private static Iterator<Tag> tagsIterator(final ByteBuffer tags, final int offset,
-      final int length) {
-    return new Iterator<Tag>() {
-      private int pos = offset;
-      private int endOffset = offset + length - 1;
-
-      @Override
-      public boolean hasNext() {
-        return this.pos < endOffset;
-      }
-
-      @Override
-      public Tag next() {
-        if (hasNext()) {
-          int curTagLen = ByteBufferUtils.readAsInt(tags, this.pos, Tag.TAG_LENGTH_SIZE);
-          Tag tag = new ByteBufferTag(tags, pos, curTagLen + Tag.TAG_LENGTH_SIZE);
-          this.pos += Bytes.SIZEOF_SHORT + curTagLen;
-          return tag;
-        }
-        return null;
-      }
-
-      @Override
-      public void remove() {
-        throw new UnsupportedOperationException();
-      }
-    };
-  }
-
-  /**
-   * Util method to iterate through the tags in the given cell.
-   *
-   * @param cell The Cell over which tags iterator is needed.
-   * @return iterator for the tags
-   */
-  public static Iterator<Tag> tagsIterator(final Cell cell) {
-    final int tagsLength = cell.getTagsLength();
-    // Save an object allocation where we can
-    if (tagsLength == 0) {
-      return TagUtil.EMPTY_TAGS_ITR;
-    }
-    if (cell instanceof ByteBufferCell) {
-      return tagsIterator(((ByteBufferCell) cell).getTagsByteBuffer(),
-          ((ByteBufferCell) cell).getTagsPosition(), tagsLength);
-    }
-    return tagsIterator(cell.getTagsArray(), cell.getTagsOffset(), tagsLength);
-  }
-
-  /**
-   * @param cell The Cell
-   * @return Tags in the given Cell as a List
-   */
-  public static List<Tag> getTags(Cell cell) {
-    List<Tag> tags = new ArrayList<>();
-    Iterator<Tag> tagsItr = tagsIterator(cell);
-    while (tagsItr.hasNext()) {
-      tags.add(tagsItr.next());
-    }
-    return tags;
-  }
-
-  /**
-   * Retrieve Cell's first tag, matching the passed in type
-   *
-   * @param cell The Cell
-   * @param type Type of the Tag to retrieve
-   * @return null if there is no tag of the passed in tag type
-   */
-  public static Tag getTag(Cell cell, byte type){
-    boolean bufferBacked = cell instanceof ByteBufferCell;
-    int length = cell.getTagsLength();
-    int offset = bufferBacked? ((ByteBufferCell)cell).getTagsPosition():cell.getTagsOffset();
-    int pos = offset;
-    while (pos < offset + length) {
-      int tagLen;
-      if (bufferBacked) {
-        ByteBuffer tagsBuffer = ((ByteBufferCell)cell).getTagsByteBuffer();
-        tagLen = ByteBufferUtils.readAsInt(tagsBuffer, pos, TAG_LENGTH_SIZE);
-        if (ByteBufferUtils.toByte(tagsBuffer, pos + TAG_LENGTH_SIZE) == type) {
-          return new ByteBufferTag(tagsBuffer, pos, tagLen + TAG_LENGTH_SIZE);
-        }
-      } else {
-        tagLen = Bytes.readAsInt(cell.getTagsArray(), pos, TAG_LENGTH_SIZE);
-        if (cell.getTagsArray()[pos + TAG_LENGTH_SIZE] == type) {
-          return new ArrayBackedTag(cell.getTagsArray(), pos, tagLen + TAG_LENGTH_SIZE);
-        }
-      }
-      pos += TAG_LENGTH_SIZE + tagLen;
-    }
-    return null;
-  }
-
-  /**
-   * Returns true if the first range start1...end1 overlaps with the second range
-   * start2...end2, assuming the byte arrays represent row keys
-   */
-  public static boolean overlappingKeys(final byte[] start1, final byte[] end1,
-      final byte[] start2, final byte[] end2) {
-    return (end2.length == 0 || start1.length == 0 || Bytes.compareTo(start1,
-        end2) < 0)
-        && (end1.length == 0 || start2.length == 0 || Bytes.compareTo(start2,
-            end1) < 0);
-  }
-
-  /**
-   * Sets the given seqId to the cell.
-   * Marked as audience Private as of 1.2.0.
-   * Setting a Cell sequenceid is an internal implementation detail not for general public use.
-   * @param cell
-   * @param seqId
-   * @throws IOException when the passed cell is not of type {@link SettableSequenceId}
-   */
-  @InterfaceAudience.Private
-  public static void setSequenceId(Cell cell, long seqId) throws IOException {
-    if (cell instanceof SettableSequenceId) {
-      ((SettableSequenceId) cell).setSequenceId(seqId);
-    } else {
-      throw new IOException(new UnsupportedOperationException("Cell is not of type "
-          + SettableSequenceId.class.getName()));
-    }
-  }
-
-  /**
-   * Sets the given timestamp to the cell.
-   * @param cell
-   * @param ts
-   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
-   */
-  public static void setTimestamp(Cell cell, long ts) throws IOException {
-    if (cell instanceof SettableTimestamp) {
-      ((SettableTimestamp) cell).setTimestamp(ts);
-    } else {
-      throw new IOException(new UnsupportedOperationException("Cell is not of type "
-          + SettableTimestamp.class.getName()));
-    }
-  }
-
-  /**
-   * Sets the given timestamp to the cell.
-   * @param cell
-   * @param ts buffer containing the timestamp value
-   * @param tsOffset offset to the new timestamp
-   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
-   */
-  public static void setTimestamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
-    if (cell instanceof SettableTimestamp) {
-      ((SettableTimestamp) cell).setTimestamp(ts, tsOffset);
-    } else {
-      throw new IOException(new UnsupportedOperationException("Cell is not of type "
-          + SettableTimestamp.class.getName()));
-    }
-  }
-
-  /**
-   * Sets the given timestamp to the cell iff current timestamp is
-   * {@link HConstants#LATEST_TIMESTAMP}.
-   * @param cell
-   * @param ts
-   * @return True if cell timestamp is modified.
-   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
-   */
-  public static boolean updateLatestStamp(Cell cell, long ts) throws IOException {
-    if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP) {
-      setTimestamp(cell, ts);
-      return true;
-    }
-    return false;
-  }
-
-  /**
-   * Sets the given timestamp to the cell iff current timestamp is
-   * {@link HConstants#LATEST_TIMESTAMP}.
-   * @param cell
-   * @param ts buffer containing the timestamp value
-   * @param tsOffset offset to the new timestamp
-   * @return True if cell timestamp is modified.
-   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
-   */
-  public static boolean updateLatestStamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
-    if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP) {
-      setTimestamp(cell, ts, tsOffset);
-      return true;
-    }
-    return false;
-  }
-
-  /**
-   * Writes the Cell's key part as it would have serialized in a KeyValue. The format is &lt;2 bytes
-   * rk len&gt;&lt;rk&gt;&lt;1 byte cf len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes
-   * timestamp&gt;&lt;1 byte type&gt;
-   * @param cell
-   * @param out
-   * @throws IOException
-   */
-  public static void writeFlatKey(Cell cell, DataOutput out) throws IOException {
-    short rowLen = cell.getRowLength();
-    byte fLen = cell.getFamilyLength();
-    int qLen = cell.getQualifierLength();
-    // Using just one if/else loop instead of every time checking before writing every
-    // component of cell
-    if (cell instanceof ByteBufferCell) {
-      out.writeShort(rowLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), rowLen);
-      out.writeByte(fLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
-        ((ByteBufferCell) cell).getFamilyPosition(), fLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition(), qLen);
-    } else {
-      out.writeShort(rowLen);
-      out.write(cell.getRowArray(), cell.getRowOffset(), rowLen);
-      out.writeByte(fLen);
-      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), fLen);
-      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qLen);
-    }
-    out.writeLong(cell.getTimestamp());
-    out.writeByte(cell.getTypeByte());
-  }
-
-  /**
-   * Deep clones the given cell if the cell supports deep cloning
-   * @param cell the cell to be cloned
-   * @return the cloned cell
-   * @throws CloneNotSupportedException
-   */
-  public static Cell deepClone(Cell cell) throws CloneNotSupportedException {
-    if (cell instanceof ExtendedCell) {
-      return ((ExtendedCell) cell).deepClone();
-    }
-    throw new CloneNotSupportedException();
-  }
-
-  /**
-   * Writes the cell to the given OutputStream
-   * @param cell the cell to be written
-   * @param out the outputstream
-   * @param withTags if tags are to be written or not
-   * @return the total bytes written
-   * @throws IOException
-   */
-  public static int writeCell(Cell cell, OutputStream out, boolean withTags) throws IOException {
-    if (cell instanceof ExtendedCell) {
-      return ((ExtendedCell) cell).write(out, withTags);
-    } else {
-      ByteBufferUtils.putInt(out, CellUtil.estimatedSerializedSizeOfKey(cell));
-      ByteBufferUtils.putInt(out, cell.getValueLength());
-      CellUtil.writeFlatKey(cell, out);
-      CellUtil.writeValue(out, cell, cell.getValueLength());
-      int tagsLength = cell.getTagsLength();
-      if (withTags) {
-        byte[] len = new byte[Bytes.SIZEOF_SHORT];
-        Bytes.putAsShort(len, 0, tagsLength);
-        out.write(len);
-        if (tagsLength > 0) {
-          CellUtil.writeTags(out, cell, tagsLength);
-        }
-      }
-      int lenWritten = (2 * Bytes.SIZEOF_INT) + CellUtil.estimatedSerializedSizeOfKey(cell)
-          + cell.getValueLength();
-      if (withTags) {
-        lenWritten += Bytes.SIZEOF_SHORT + tagsLength;
-      }
-      return lenWritten;
-    }
-  }
-
-  /**
-   * Writes a cell to the buffer at the given offset
-   * @param cell the cell to be written
-   * @param buf the buffer to which the cell has to be wrriten
-   * @param offset the offset at which the cell should be written
-   */
-  public static void writeCellToBuffer(Cell cell, ByteBuffer buf, int offset) {
-    if (cell instanceof ExtendedCell) {
-      ((ExtendedCell) cell).write(buf, offset);
-    } else {
-      // Using the KVUtil
-      byte[] bytes = KeyValueUtil.copyToNewByteArray(cell);
-      ByteBufferUtils.copyFromArrayToBuffer(buf, offset, bytes, 0, bytes.length);
-    }
-  }
-
-  public static int writeFlatKey(Cell cell, OutputStream out) throws IOException {
-    short rowLen = cell.getRowLength();
-    byte fLen = cell.getFamilyLength();
-    int qLen = cell.getQualifierLength();
-    // Using just one if/else loop instead of every time checking before writing every
-    // component of cell
-    if (cell instanceof ByteBufferCell) {
-      StreamUtils.writeShort(out, rowLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), rowLen);
-      out.write(fLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
-        ((ByteBufferCell) cell).getFamilyPosition(), fLen);
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition(), qLen);
-    } else {
-      StreamUtils.writeShort(out, rowLen);
-      out.write(cell.getRowArray(), cell.getRowOffset(), rowLen);
-      out.write(fLen);
-      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), fLen);
-      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qLen);
-    }
-    StreamUtils.writeLong(out, cell.getTimestamp());
-    out.write(cell.getTypeByte());
-    return Bytes.SIZEOF_SHORT + rowLen + Bytes.SIZEOF_BYTE + fLen + qLen + Bytes.SIZEOF_LONG
-        + Bytes.SIZEOF_BYTE;
-  }
-
-  /**
-   * Writes the row from the given cell to the output stream
-   * @param out The outputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param rlength the row length
-   * @throws IOException
-   */
-  public static void writeRow(OutputStream out, Cell cell, short rlength) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), rlength);
-    } else {
-      out.write(cell.getRowArray(), cell.getRowOffset(), rlength);
-    }
-  }
-
-  /**
-   * Writes the row from the given cell to the output stream excluding the common prefix
-   * @param out The dataoutputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param rlength the row length
-   * @throws IOException
-   */
-  public static void writeRowSkippingBytes(DataOutputStream out, Cell cell, short rlength,
-      int commonPrefix) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream((DataOutput)out, ((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition() + commonPrefix, rlength - commonPrefix);
-    } else {
-      out.write(cell.getRowArray(), cell.getRowOffset() + commonPrefix, rlength - commonPrefix);
-    }
-  }
-
-  /**
-   * Writes the family from the given cell to the output stream
-   * @param out The outputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param flength the family length
-   * @throws IOException
-   */
-  public static void writeFamily(OutputStream out, Cell cell, byte flength) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
-        ((ByteBufferCell) cell).getFamilyPosition(), flength);
-    } else {
-      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), flength);
-    }
-  }
-
-  /**
-   * Writes the qualifier from the given cell to the output stream
-   * @param out The outputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param qlength the qualifier length
-   * @throws IOException
-   */
-  public static void writeQualifier(OutputStream out, Cell cell, int qlength)
-      throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition(), qlength);
-    } else {
-      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qlength);
-    }
-  }
-
-  /**
-   * Writes the qualifier from the given cell to the output stream excluding the common prefix
-   * @param out The dataoutputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param qlength the qualifier length
-   * @throws IOException
-   */
-  public static void writeQualifierSkippingBytes(DataOutputStream out, Cell cell,
-      int qlength, int commonPrefix) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream((DataOutput)out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition() + commonPrefix, qlength - commonPrefix);
-    } else {
-      out.write(cell.getQualifierArray(), cell.getQualifierOffset() + commonPrefix,
-        qlength - commonPrefix);
-    }
-  }
-
-  /**
-   * Writes the value from the given cell to the output stream
-   * @param out The outputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param vlength the value length
-   * @throws IOException
-   */
-  public static void writeValue(OutputStream out, Cell cell, int vlength) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getValueByteBuffer(),
-        ((ByteBufferCell) cell).getValuePosition(), vlength);
-    } else {
-      out.write(cell.getValueArray(), cell.getValueOffset(), vlength);
-    }
-  }
-
-  /**
-   * Writes the tag from the given cell to the output stream
-   * @param out The outputstream to which the data has to be written
-   * @param cell The cell whose contents has to be written
-   * @param tagsLength the tag length
-   * @throws IOException
-   */
-  public static void writeTags(OutputStream out, Cell cell, int tagsLength) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getTagsByteBuffer(),
-        ((ByteBufferCell) cell).getTagsPosition(), tagsLength);
-    } else {
-      out.write(cell.getTagsArray(), cell.getTagsOffset(), tagsLength);
-    }
-  }
-
-  /**
-   * @param cell
-   * @return The Key portion of the passed <code>cell</code> as a String.
-   */
-  public static String getCellKeyAsString(Cell cell) {
-    StringBuilder sb = new StringBuilder(Bytes.toStringBinary(
-      cell.getRowArray(), cell.getRowOffset(), cell.getRowLength()));
-    sb.append('/');
-    sb.append(cell.getFamilyLength() == 0? "":
-      Bytes.toStringBinary(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength()));
-    // KeyValue only added ':' if family is non-null.  Do same.
-    if (cell.getFamilyLength() > 0) sb.append(':');
-    sb.append(cell.getQualifierLength() == 0? "":
-      Bytes.toStringBinary(cell.getQualifierArray(), cell.getQualifierOffset(),
-        cell.getQualifierLength()));
-    sb.append('/');
-    sb.append(KeyValue.humanReadableTimestamp(cell.getTimestamp()));
-    sb.append('/');
-    sb.append(Type.codeToType(cell.getTypeByte()));
-    if (!(cell instanceof KeyValue.KeyOnlyKeyValue)) {
-      sb.append("/vlen=");
-      sb.append(cell.getValueLength());
-    }
-    sb.append("/seqid=");
-    sb.append(cell.getSequenceId());
-    return sb.toString();
-  }
-
-  /**
-   * This method exists just to encapsulate how we serialize keys.  To be replaced by a factory
-   * that we query to figure what the Cell implementation is and then, what serialization engine
-   * to use and further, how to serialize the key for inclusion in hfile index. TODO.
-   * @param cell
-   * @return The key portion of the Cell serialized in the old-school KeyValue way or null if
-   * passed a null <code>cell</code>
-   */
-  public static byte [] getCellKeySerializedAsKeyValueKey(final Cell cell) {
-    if (cell == null) return null;
-    byte [] b = new byte[KeyValueUtil.keyLength(cell)];
-    KeyValueUtil.appendKeyTo(cell, b, 0);
-    return b;
-  }
-
-  /**
-   * Write rowkey excluding the common part.
-   * @param cell
-   * @param rLen
-   * @param commonPrefix
-   * @param out
-   * @throws IOException
-   */
-  public static void writeRowKeyExcludingCommon(Cell cell, short rLen, int commonPrefix,
-      DataOutputStream out) throws IOException {
-    if (commonPrefix == 0) {
-      out.writeShort(rLen);
-    } else if (commonPrefix == 1) {
-      out.writeByte((byte) rLen);
-      commonPrefix--;
-    } else {
-      commonPrefix -= KeyValue.ROW_LENGTH_SIZE;
-    }
-    if (rLen > commonPrefix) {
-      writeRowSkippingBytes(out, cell, rLen, commonPrefix);
-    }
-  }
-
-  /**
-   * Find length of common prefix in keys of the cells, considering key as byte[] if serialized in
-   * {@link KeyValue}. The key format is &lt;2 bytes rk len&gt;&lt;rk&gt;&lt;1 byte cf
-   * len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes timestamp&gt;&lt;1 byte type&gt;
-   * @param c1
-   *          the cell
-   * @param c2
-   *          the cell
-   * @param bypassFamilyCheck
-   *          when true assume the family bytes same in both cells. Pass it as true when dealing
-   *          with Cells in same CF so as to avoid some checks
-   * @param withTsType
-   *          when true check timestamp and type bytes also.
-   * @return length of common prefix
-   */
-  public static int findCommonPrefixInFlatKey(Cell c1, Cell c2, boolean bypassFamilyCheck,
-      boolean withTsType) {
-    // Compare the 2 bytes in RK length part
-    short rLen1 = c1.getRowLength();
-    short rLen2 = c2.getRowLength();
-    int commonPrefix = KeyValue.ROW_LENGTH_SIZE;
-    if (rLen1 != rLen2) {
-      // early out when the RK length itself is not matching
-      return ByteBufferUtils.findCommonPrefix(Bytes.toBytes(rLen1), 0, KeyValue.ROW_LENGTH_SIZE,
-          Bytes.toBytes(rLen2), 0, KeyValue.ROW_LENGTH_SIZE);
-    }
-    // Compare the RKs
-    int rkCommonPrefix = 0;
-    if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
-      rkCommonPrefix = ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getRowByteBuffer(),
-        ((ByteBufferCell) c1).getRowPosition(), rLen1, ((ByteBufferCell) c2).getRowByteBuffer(),
-        ((ByteBufferCell) c2).getRowPosition(), rLen2);
-    } else {
-      // There cannot be a case where one cell is BBCell and other is KeyValue. This flow comes either
-      // in flush or compactions. In flushes both cells are KV and in case of compaction it will be either
-      // KV or BBCell
-      rkCommonPrefix = ByteBufferUtils.findCommonPrefix(c1.getRowArray(), c1.getRowOffset(),
-        rLen1, c2.getRowArray(), c2.getRowOffset(), rLen2);
-    }
-    commonPrefix += rkCommonPrefix;
-    if (rkCommonPrefix != rLen1) {
-      // Early out when RK is not fully matching.
-      return commonPrefix;
-    }
-    // Compare 1 byte CF length part
-    byte fLen1 = c1.getFamilyLength();
-    if (bypassFamilyCheck) {
-      // This flag will be true when caller is sure that the family will be same for both the cells
-      // Just make commonPrefix to increment by the family part
-      commonPrefix += KeyValue.FAMILY_LENGTH_SIZE + fLen1;
-    } else {
-      byte fLen2 = c2.getFamilyLength();
-      if (fLen1 != fLen2) {
-        // early out when the CF length itself is not matching
-        return commonPrefix;
-      }
-      // CF lengths are same so there is one more byte common in key part
-      commonPrefix += KeyValue.FAMILY_LENGTH_SIZE;
-      // Compare the CF names
-      int fCommonPrefix;
-      if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
-        fCommonPrefix =
-            ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getFamilyByteBuffer(),
-              ((ByteBufferCell) c1).getFamilyPosition(), fLen1,
-              ((ByteBufferCell) c2).getFamilyByteBuffer(),
-              ((ByteBufferCell) c2).getFamilyPosition(), fLen2);
-      } else {
-        fCommonPrefix = ByteBufferUtils.findCommonPrefix(c1.getFamilyArray(), c1.getFamilyOffset(),
-          fLen1, c2.getFamilyArray(), c2.getFamilyOffset(), fLen2);
-      }
-      commonPrefix += fCommonPrefix;
-      if (fCommonPrefix != fLen1) {
-        return commonPrefix;
-      }
-    }
-    // Compare the Qualifiers
-    int qLen1 = c1.getQualifierLength();
-    int qLen2 = c2.getQualifierLength();
-    int qCommon;
-    if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
-      qCommon = ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getQualifierByteBuffer(),
-        ((ByteBufferCell) c1).getQualifierPosition(), qLen1,
-        ((ByteBufferCell) c2).getQualifierByteBuffer(),
-        ((ByteBufferCell) c2).getQualifierPosition(), qLen2);
-    } else {
-      qCommon = ByteBufferUtils.findCommonPrefix(c1.getQualifierArray(), c1.getQualifierOffset(),
-        qLen1, c2.getQualifierArray(), c2.getQualifierOffset(), qLen2);
-    }
-    commonPrefix += qCommon;
-    if (!withTsType || Math.max(qLen1, qLen2) != qCommon) {
-      return commonPrefix;
-    }
-    // Compare the timestamp parts
-    int tsCommonPrefix = ByteBufferUtils.findCommonPrefix(Bytes.toBytes(c1.getTimestamp()), 0,
-        KeyValue.TIMESTAMP_SIZE, Bytes.toBytes(c2.getTimestamp()), 0, KeyValue.TIMESTAMP_SIZE);
-    commonPrefix += tsCommonPrefix;
-    if (tsCommonPrefix != KeyValue.TIMESTAMP_SIZE) {
-      return commonPrefix;
-    }
-    // Compare the type
-    if (c1.getTypeByte() == c2.getTypeByte()) {
-      commonPrefix += KeyValue.TYPE_SIZE;
-    }
-    return commonPrefix;
-  }
-
-  /** Returns a string representation of the cell */
-  public static String toString(Cell cell, boolean verbose) {
-    if (cell == null) {
-      return "";
-    }
-    StringBuilder builder = new StringBuilder();
-    String keyStr = getCellKeyAsString(cell);
-
-    String tag = null;
-    String value = null;
-    if (verbose) {
-      // TODO: pretty print tags as well
-      if (cell.getTagsLength() > 0) {
-        tag = Bytes.toStringBinary(cell.getTagsArray(), cell.getTagsOffset(), cell.getTagsLength());
-      }
-      if (!(cell instanceof KeyValue.KeyOnlyKeyValue)) {
-        value = Bytes.toStringBinary(cell.getValueArray(), cell.getValueOffset(),
-            cell.getValueLength());
-      }
-    }
-
-    builder
-      .append(keyStr);
-    if (tag != null && !tag.isEmpty()) {
-      builder.append("/").append(tag);
-    }
-    if (value != null) {
-      builder.append("/").append(value);
-    }
-
-    return builder.toString();
-  }
-
-  /***************** special cases ****************************/
-
-  /**
-   * special case for Cell.equals
-   */
-  public static boolean equalsIgnoreMvccVersion(Cell a, Cell b) {
-    // row
-    boolean res = matchingRow(a, b);
-    if (!res)
-      return res;
-
-    // family
-    res = matchingColumn(a, b);
-    if (!res)
-      return res;
-
-    // timestamp: later sorts first
-    if (!matchingTimestamp(a, b))
-      return false;
-
-    // type
-    int c = (0xff & b.getTypeByte()) - (0xff & a.getTypeByte());
-    if (c != 0)
-      return false;
-    else return true;
-  }
-
-  /**************** equals ****************************/
-
-  public static boolean equals(Cell a, Cell b) {
-    return matchingRow(a, b) && matchingFamily(a, b) && matchingQualifier(a, b)
-        && matchingTimestamp(a, b) && matchingType(a, b);
-  }
-
-  public static boolean matchingTimestamp(Cell a, Cell b) {
-    return CellComparatorImpl.COMPARATOR.compareTimestamps(a.getTimestamp(), b.getTimestamp()) == 0;
-  }
-
-  public static boolean matchingType(Cell a, Cell b) {
-    return a.getTypeByte() == b.getTypeByte();
-  }
-
-  /**
-   * Compares the row of two keyvalues for equality
-   *
-   * @param left
-   * @param right
-   * @return True if rows match.
-   */
-  public static boolean matchingRows(final Cell left, final Cell right) {
-    short lrowlength = left.getRowLength();
-    short rrowlength = right.getRowLength();
-    if (lrowlength != rrowlength) return false;
-    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
-          ((ByteBufferCell) left).getRowPosition(), lrowlength,
-          ((ByteBufferCell) right).getRowByteBuffer(),
-          ((ByteBufferCell) right).getRowPosition(), rrowlength);
-    }
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
-          ((ByteBufferCell) left).getRowPosition(), lrowlength, right.getRowArray(),
-          right.getRowOffset(), rrowlength);
-    }
-    if (right instanceof ByteBufferCell) {
-      return ByteBufferUtils.equals(((ByteBufferCell) right).getRowByteBuffer(),
-          ((ByteBufferCell) right).getRowPosition(), rrowlength, left.getRowArray(),
-          left.getRowOffset(), lrowlength);
-    }
-    return Bytes.equals(left.getRowArray(), left.getRowOffset(), lrowlength,
-        right.getRowArray(), right.getRowOffset(), rrowlength);
-  }
-
-  /**
-   * Compares the row and column of two keyvalues for equality
-   *
-   * @param left
-   * @param right
-   * @return True if same row and column.
-   */
-  public static boolean matchingRowColumn(final Cell left, final Cell right) {
-    if ((left.getRowLength() + left.getFamilyLength() + left.getQualifierLength()) != (right
-        .getRowLength() + right.getFamilyLength() + right.getQualifierLength())) {
-      return false;
-    }
-
-    if (!matchingRows(left, right)) {
-      return false;
-    }
-    return matchingColumn(left, right);
-  }
-
-  /**
-   * Converts the rowkey bytes of the given cell into an int value
-   *
-   * @param cell
-   * @return rowkey as int
-   */
-  public static int getRowAsInt(Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return ByteBufferUtils.toInt(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition());
-    }
-    return Bytes.toInt(cell.getRowArray(), cell.getRowOffset());
-  }
-
-  /**
-   * Converts the value bytes of the given cell into a long value
-   *
-   * @param cell
-   * @return value as long
-   */
-  public static long getValueAsLong(Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return ByteBufferUtils.toLong(((ByteBufferCell) cell).getValueByteBuffer(),
-          ((ByteBufferCell) cell).getValuePosition());
-    }
-    return Bytes.toLong(cell.getValueArray(), cell.getValueOffset());
-  }
-
-  /**
-   * Converts the value bytes of the given cell into a int value
-   *
-   * @param cell
-   * @return value as int
-   */
-  public static int getValueAsInt(Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return ByteBufferUtils.toInt(((ByteBufferCell) cell).getValueByteBuffer(),
-          ((ByteBufferCell) cell).getValuePosition());
-    }
-    return Bytes.toInt(cell.getValueArray(), cell.getValueOffset());
-  }
-
-  /**
-   * Converts the value bytes of the given cell into a double value
-   *
-   * @param cell
-   * @return value as double
-   */
-  public static double getValueAsDouble(Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return ByteBufferUtils.toDouble(((ByteBufferCell) cell).getValueByteBuffer(),
-          ((ByteBufferCell) cell).getValuePosition());
-    }
-    return Bytes.toDouble(cell.getValueArray(), cell.getValueOffset());
-  }
-
-  /**
-   * Converts the value bytes of the given cell into a BigDecimal
-   *
-   * @param cell
-   * @return value as BigDecimal
-   */
-  public static BigDecimal getValueAsBigDecimal(Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return ByteBufferUtils.toBigDecimal(((ByteBufferCell) cell).getValueByteBuffer(),
-          ((ByteBufferCell) cell).getValuePosition(), cell.getValueLength());
-    }
-    return Bytes.toBigDecimal(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
-  }
-
-  /**
-   * Create a Cell that is smaller than all other possible Cells for the given Cell's row.
-   *
-   * @param cell
-   * @return First possible Cell on passed Cell's row.
-   */
-  public static Cell createFirstOnRow(final Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return new FirstOnRowByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength());
-    }
-    return new FirstOnRowCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
-  }
-
-  public static Cell createFirstOnRow(final byte [] row, int roffset, short rlength) {
-    return new FirstOnRowCell(row, roffset, rlength);
-  }
-
-  public static Cell createFirstOnRow(final byte[] row, final byte[] family, final byte[] col) {
-    return createFirstOnRow(row, 0, (short)row.length,
-        family, 0, (byte)family.length,
-        col, 0, col.length);
-  }
-
-  public static Cell createFirstOnRow(final byte[] row, int roffset, short rlength,
-                                      final byte[] family, int foffset, byte flength,
-                                      final byte[] col, int coffset, int clength) {
-    return new FirstOnRowColCell(row, roffset, rlength,
-        family, foffset, flength,
-        col, coffset, clength);
-  }
-
-  public static Cell createFirstOnRow(final byte[] row) {
-    return createFirstOnRow(row, 0, (short)row.length);
-  }
-
-  /**
-   * @return Cell that is smaller than all other possible Cells for the given Cell's row and passed
-   *         family.
-   */
-  public static Cell createFirstOnRowFamily(Cell cell, byte[] fArray, int foff, int flen) {
-    if (cell instanceof ByteBufferCell) {
-      return new FirstOnRowColByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(), ByteBuffer.wrap(fArray),
-          foff, (byte) flen, HConstants.EMPTY_BYTE_BUFFER, 0, 0);
-    }
-    return new FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(),
-        fArray, foff, (byte) flen, HConstants.EMPTY_BYTE_ARRAY, 0, 0);
-  }
-
-  /**
-   * Create a Cell that is smaller than all other possible Cells for the given Cell's row.
-   * The family length is considered to be 0
-   * @param cell
-   * @return First possible Cell on passed Cell's row.
-   */
-  public static Cell createFirstOnRowCol(final Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return new FirstOnRowColByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
-          HConstants.EMPTY_BYTE_BUFFER, 0, (byte) 0,
-          ((ByteBufferCell) cell).getQualifierByteBuffer(),
-          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
-    }
-    return new FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(),
-        cell.getRowLength(), HConstants.EMPTY_BYTE_ARRAY, 0, (byte)0, cell.getQualifierArray(),
-        cell.getQualifierOffset(), cell.getQualifierLength());
-  }
-  /**
-   * Create a Cell that is smaller than all other possible Cells for the given Cell row's next row.
-   * Makes the next row's rowkey by appending single byte 0x00 to the end of current row key.
-   */
-  public static Cell createFirstOnNextRow(final Cell cell) {
-    byte[] nextRow = new byte[cell.getRowLength() + 1];
-    copyRowTo(cell, nextRow, 0);
-    nextRow[nextRow.length - 1] = 0;// maybe not necessary
-    return new FirstOnRowCell(nextRow, 0, (short) nextRow.length);
-  }
-
-  /**
-   * Create a Cell that is smaller than all other possible Cells for the given Cell's rk:cf and
-   * passed qualifier.
-   *
-   * @param cell
-   * @param qArray
-   * @param qoffest
-   * @param qlength
-   * @return Last possible Cell on passed Cell's rk:cf and passed qualifier.
-   */
-  public static Cell createFirstOnRowCol(final Cell cell, byte[] qArray, int qoffest, int qlength) {
-    if(cell instanceof ByteBufferCell) {
-      return new FirstOnRowColByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
-          ((ByteBufferCell) cell).getFamilyByteBuffer(),
-          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
-          ByteBuffer.wrap(qArray), qoffest, qlength);
-    }
-    return new FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(),
-        cell.getRowLength(), cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
-        qArray, qoffest, qlength);
-  }
-
-  /**
-   * Creates the first cell with the row/family/qualifier of this cell and the given timestamp.
-   * Uses the "maximum" type that guarantees that the new cell is the lowest possible for this
-   * combination of row, family, qualifier, and timestamp. This cell's own timestamp is ignored.
-   *
-   * @param cell - cell
-   * @param ts
-   */
-  public static Cell createFirstOnRowColTS(Cell cell, long ts) {
-    if(cell instanceof ByteBufferCell) {
-      return new FirstOnRowColTSByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
-          ((ByteBufferCell) cell).getFamilyByteBuffer(),
-          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
-          ((ByteBufferCell) cell).getQualifierByteBuffer(),
-          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength(),
-          ts);
-    }
-    return new FirstOnRowColTSCell(cell.getRowArray(), cell.getRowOffset(),
-        cell.getRowLength(), cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
-        cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength(), ts);
-  }
-
-  /**
-   * Create a Cell that is larger than all other possible Cells for the given Cell's row.
-   *
-   * @param cell
-   * @return Last possible Cell on passed Cell's row.
-   */
-  public static Cell createLastOnRow(final Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return new LastOnRowByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength());
-    }
-    return new LastOnRowCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
-  }
-
-  public static Cell createLastOnRow(final byte[] row) {
-    return new LastOnRowCell(row, 0, (short)row.length);
-  }
-
-  /**
-   * Create a Cell that is larger than all other possible Cells for the given Cell's rk:cf:q. Used
-   * in creating "fake keys" for the multi-column Bloom filter optimization to skip the row/column
-   * we already know is not in the file.
-   *
-   * @param cell
-   * @return Last possible Cell on passed Cell's rk:cf:q.
-   */
-  public static Cell createLastOnRowCol(final Cell cell) {
-    if (cell instanceof ByteBufferCell) {
-      return new LastOnRowColByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
-          ((ByteBufferCell) cell).getFamilyByteBuffer(),
-          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
-          ((ByteBufferCell) cell).getQualifierByteBuffer(),
-          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
-    }
-    return new LastOnRowColCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(),
-        cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
-        cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());
-  }
-
-  /**
-   * Create a Delete Family Cell for the specified row and family that would
-   * be smaller than all other possible Delete Family KeyValues that have the
-   * same row and family.
-   * Used for seeking.
-   * @param row - row key (arbitrary byte array)
-   * @param fam - family name
-   * @return First Delete Family possible key on passed <code>row</code>.
-   */
-  public static Cell createFirstDeleteFamilyCellOnRow(final byte[] row, final byte[] fam) {
-    return new FirstOnRowDeleteFamilyCell(row, fam);
-  }
-
-  /**
-   * Compresses the tags to the given outputstream using the TagcompressionContext
-   * @param out the outputstream to which the compression should happen
-   * @param cell the cell which has tags
-   * @param tagCompressionContext the TagCompressionContext
-   * @throws IOException can throw IOException if the compression encounters issue
-   */
-  @InterfaceAudience.Private
-  public static void compressTags(OutputStream out, Cell cell,
-      TagCompressionContext tagCompressionContext) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      tagCompressionContext.compressTags(out, ((ByteBufferCell) cell).getTagsByteBuffer(),
-          ((ByteBufferCell) cell).getTagsPosition(), cell.getTagsLength());
-    } else {
-      tagCompressionContext.compressTags(out, cell.getTagsArray(), cell.getTagsOffset(),
-          cell.getTagsLength());
-    }
-  }
-
-  @InterfaceAudience.Private
-  public static void compressRow(OutputStream out, Cell cell, Dictionary dict) throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      Dictionary.write(out, ((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(), dict);
-    } else {
-      Dictionary.write(out, cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(), dict);
-    }
-  }
-
-  @InterfaceAudience.Private
-  public static void compressFamily(OutputStream out, Cell cell, Dictionary dict)
-      throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      Dictionary.write(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
-        ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(), dict);
-    } else {
-      Dictionary.write(out, cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
-        dict);
-    }
-  }
-
-  @InterfaceAudience.Private
-  public static void compressQualifier(OutputStream out, Cell cell, Dictionary dict)
-      throws IOException {
-    if (cell instanceof ByteBufferCell) {
-      Dictionary.write(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength(), dict);
-    } else {
-      Dictionary.write(out, cell.getQualifierArray(), cell.getQualifierOffset(),
-        cell.getQualifierLength(), dict);
-    }
-  }
-
-  /**
-   * Compares only the key portion of a cell. It does not include the sequence id/mvcc of the cell
-   * @param left
-   * @param right
-   * @return an int greater than 0 if left &gt; than right lesser than 0 if left &lt; than right
-   *         equal to 0 if left is equal to right
-   */
-  public static final int compareKeyIgnoresMvcc(CellComparator comparator, Cell left, Cell right) {
-    return ((CellComparatorImpl) comparator).compare(left, right, true);
-  }
-
-  /**
-   * Used to compare two cells based on the column hint provided. This is specifically
-   * used when we need to optimize the seeks based on the next indexed key. This is an
-   * advanced usage API specifically needed for some optimizations.
-   * @param nextIndexedCell the next indexed cell
-   * @param currentCell the cell to be compared
-   * @param foff the family offset of the currentCell
-   * @param flen the family length of the currentCell
-   * @param colHint the column hint provided - could be null
-   * @param coff the offset of the column hint if provided, if not offset of the currentCell's
-   * qualifier
-   * @param clen the length of the column hint if provided, if not length of the currentCell's
-   * qualifier
-   * @param ts the timestamp to be seeked
-   * @param type the type to be seeked
-   * @return an int based on the given column hint
-   * TODO : To be moved out of here because this is a special API used in scan
-   * optimization.
-   */
-  // compare a key against row/fam/qual/ts/type
-  @InterfaceAudience.Private
-  public static final int compareKeyBasedOnColHint(CellComparator comparator, Cell nextIndexedCell,
-      Cell currentCell, int foff, int flen, byte[] colHint, int coff, int clen, long ts,
-      byte type) {
-    int compare = comparator.compareRows(nextIndexedCell, currentCell);
-    if (compare != 0) {
-      return compare;
-    }
-    // If the column is not specified, the "minimum" key type appears the
-    // latest in the sorted order, regardless of the timestamp. This is used
-    // for specifying the last key/value in a given row, because there is no
-    // "lexicographically last column" (it would be infinitely long). The
-    // "maximum" key type does not need this behavior.
-    if (nextIndexedCell.getFamilyLength() + nextIndexedCell.getQualifierLength() == 0
-        && nextIndexedCell.getTypeByte() == Type.Minimum.getCode()) {
-      // left is "bigger", i.e. it appears later in the sorted order
-      return 1;
-    }
-    if (flen + clen == 0 && type == Type.Minimum.getCode()) {
-      return -1;
-    }
-
-    compare = comparator.compareFamilies(nextIndexedCell, currentCell);
-    if (compare != 0) {
-      return compare;
-    }
-    if (colHint == null) {
-      compare = comparator.compareQualifiers(nextIndexedCell, currentCell);
-    } else {
-      compare = compareQualifiers(nextIndexedCell, colHint, coff, clen);
-    }
-    if (compare != 0) {
-      return compare;
-    }
-    // Next compare timestamps.
-    compare = comparator.compareTimestamps(nextIndexedCell.getTimestamp(), ts);
-    if (compare != 0) {
-      return compare;
-    }
-
-    // Compare types. Let the delete types sort ahead of puts; i.e. types
-    // of higher numbers sort before those of lesser numbers. Maximum (255)
-    // appears ahead of everything, and minimum (0) appears after
-    // everything.
-    return (0xff & type) - (0xff & nextIndexedCell.getTypeByte());
-  }
-
-  /**
-   * Compares the cell's qualifier with the given byte[]
-   * @param left the cell for which the qualifier has to be compared
-   * @param right the byte[] having the qualifier
-   * @param rOffset the offset of the qualifier
-   * @param rLength the length of the qualifier
-   * @return greater than 0 if left cell's qualifier is bigger than byte[], lesser than 0 if left
-   *         cell's qualifier is lesser than byte[] and 0 otherwise
-   */
-  public final static int compareQualifiers(Cell left, byte[] right, int rOffset, int rLength) {
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getQualifierByteBuffer(),
-          ((ByteBufferCell) left).getQualifierPosition(), left.getQualifierLength(),
-          right, rOffset, rLength);
-    }
-    return Bytes.compareTo(left.getQualifierArray(), left.getQualifierOffset(),
-        left.getQualifierLength(), right, rOffset, rLength);
-  }
-
-  /**
-   * Compare cell's row against given comparator
-   * @param cell
-   * @param comparator
-   * @return result comparing cell's row
-   */
-  @InterfaceAudience.Private
-  public static int compareRow(Cell cell, ByteArrayComparable comparator) {
-    if (cell instanceof ByteBufferCell) {
-      return comparator.compareTo(((ByteBufferCell) cell).getRowByteBuffer(),
-        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength());
-    }
-    return comparator.compareTo(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
-  }
-
-  /**
-   * Compare cell's column family against given comparator
-   * @param cell
-   * @param comparator
-   * @return result comparing cell's column family
-   */
-  @InterfaceAudience.Private
-  public static int compareFamily(Cell cell, ByteArrayComparable comparator) {
-    if (cell instanceof ByteBufferCell) {
-      return comparator.compareTo(((ByteBufferCell) cell).getFamilyByteBuffer(),
-        ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength());
-    }
-    return comparator.compareTo(cell.getFamilyArray(), cell.getFamilyOffset(),
-      cell.getFamilyLength());
-  }
-
-  /**
-   * Compare cell's qualifier against given comparator
-   * @param cell
-   * @param comparator
-   * @return result comparing cell's qualifier
-   */
-  @InterfaceAudience.Private
-  public static int compareQualifier(Cell cell, ByteArrayComparable comparator) {
-    if (cell instanceof ByteBufferCell) {
-      return comparator.compareTo(((ByteBufferCell) cell).getQualifierByteBuffer(),
-        ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
-    }
-    return comparator.compareTo(cell.getQualifierArray(), cell.getQualifierOffset(),
-      cell.getQualifierLength());
-  }
-
-  /**
-   * Compare cell's value against given comparator
-   * @param cell
-   * @param comparator
-   * @return result comparing cell's value
-   */
-  @InterfaceAudience.Private
-  public static int compareValue(Cell cell, ByteArrayComparable comparator) {
-    if (cell instanceof ByteBufferCell) {
-      return comparator.compareTo(((ByteBufferCell) cell).getValueByteBuffer(),
-        ((ByteBufferCell) cell).getValuePosition(), cell.getValueLength());
-    }
-    return comparator.compareTo(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
-  }
-
-  /**
-   * Used when a cell needs to be compared with a key byte[] such as cases of
-   * finding the index from the index block, bloom keys from the bloom blocks
-   * This byte[] is expected to be serialized in the KeyValue serialization format
-   * If the KeyValue (Cell's) serialization format changes this method cannot be used.
-   * @param comparator the cell comparator
-   * @param left the cell to be compared
-   * @param key the serialized key part of a KeyValue
-   * @param offset the offset in the key byte[]
-   * @param length the length of the key byte[]
-   * @return an int greater than 0 if left is greater than right
-   *                lesser than 0 if left is lesser than right
-   *                equal to 0 if left is equal to right
-   */
-  @VisibleForTesting
-  public static final int compare(CellComparator comparator, Cell left, byte[] key, int offset,
-      int length) {
-    // row
-    short rrowlength = Bytes.toShort(key, offset);
-    int c = comparator.compareRows(left, key, offset + Bytes.SIZEOF_SHORT, rrowlength);
-    if (c != 0) return c;
-
-    // Compare the rest of the two KVs without making any assumptions about
-    // the common prefix. This function will not compare rows anyway, so we
-    // don't need to tell it that the common prefix includes the row.
-    return compareWithoutRow(comparator, left, key, offset, length, rrowlength);
-  }
-
-  /**
-   * Compare columnFamily, qualifier, timestamp, and key type (everything
-   * except the row). This method is used both in the normal comparator and
-   * the "same-prefix" comparator. Note that we are assuming that row portions
-   * of both KVs have already been parsed and found identical, and we don't
-   * validate that assumption here.
-   * @param commonPrefix
-   *          the length of the common prefix of the two key-values being
-   *          compared, including row length and row
-   */
-  private static final int compareWithoutRow(CellComparator comparator, Cell left,
-      byte[] right, int roffset, int rlength, short rowlength) {
-    /***
-     * KeyValue Format and commonLength:
-     * |_keyLen_|_valLen_|_rowLen_|_rowKey_|_famiLen_|_fami_|_Quali_|....
-     * ------------------|-------commonLength--------|--------------
-     */
-    int commonLength = KeyValue.ROW_LENGTH_SIZE + KeyValue.FAMILY_LENGTH_SIZE + rowlength;
-
-    // commonLength + TIMESTAMP_TYPE_SIZE
-    int commonLengthWithTSAndType = KeyValue.TIMESTAMP_TYPE_SIZE + commonLength;
-    // ColumnFamily + Qualifier length.
-    int lcolumnlength = left.getFamilyLength() + left.getQualifierLength();
-    int rcolumnlength = rlength - commonLengthWithTSAndType;
-
-    byte ltype = left.getTypeByte();
-    byte rtype = right[roffset + (rlength - 1)];
-
-    // If the column is not specified, the "minimum" key type appears the
-    // latest in the sorted order, regardless of the timestamp. This is used
-    // for specifying the last key/value in a given row, because there is no
-    // "lexicographically last column" (it would be infinitely long). The
-    // "maximum" key type does not need this behavior.
-    if (lcolumnlength == 0 && ltype == Type.Minimum.getCode()) {
-      // left is "bigger", i.e. it appears later in the sorted order
-      return 1;
-    }
-    if (rcolumnlength == 0 && rtype == Type.Minimum.getCode()) {
-      return -1;
-    }
-
-    int rfamilyoffset = commonLength + roffset;
-
-    // Column family length.
-    int lfamilylength = left.getFamilyLength();
-    int rfamilylength = right[rfamilyoffset - 1];
-    // If left family size is not equal to right family size, we need not
-    // compare the qualifiers.
-    boolean sameFamilySize = (lfamilylength == rfamilylength);
-    if (!sameFamilySize) {
-      // comparing column family is enough.
-      return compareFamilies(left, right, rfamilyoffset, rfamilylength);
-    }
-    // Compare family & qualifier together.
-    // Families are same. Compare on qualifiers.
-    int comparison = compareColumns(left, right, rfamilyoffset, rfamilylength,
-      rfamilyoffset + rfamilylength, (rcolumnlength - rfamilylength));
-    if (comparison != 0) {
-      return comparison;
-    }
-
-    // //
-    // Next compare timestamps.
-    long rtimestamp = Bytes.toLong(right, roffset + (rlength - KeyValue.TIMESTAMP_TYPE_SIZE));
-    int compare = comparator.compareTimestamps(left.getTimestamp(), rtimestamp);
-    if (compare != 0) {
-      return compare;
-    }
-
-    // Compare types. Let the delete types sort ahead of puts; i.e. types
-    // of higher numbers sort before those of lesser numbers. Maximum (255)
-    // appears ahead of everything, and minimum (0) appears after
-    // everything.
-    return (0xff & rtype) - (0xff & ltype);
-  }
-
-  /**
-   * Compares the cell's family with the given byte[]
-   * @param left the cell for which the family has to be compared
-   * @param right the byte[] having the family
-   * @param roffset the offset of the family
-   * @param rlength the length of the family
-   * @return greater than 0 if left cell's family is bigger than byte[], lesser than 0 if left
-   *         cell's family is lesser than byte[] and 0 otherwise
-   */
-  public final static int compareFamilies(Cell left, byte[] right, int roffset, int rlength) {
-    if (left instanceof ByteBufferCell) {
-      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getFamilyByteBuffer(),
-        ((ByteBufferCell) left).getFamilyPosition(), left.getFamilyLength(), right, roffset,
-        rlength);
-    }
-    return Bytes.compareTo(left.getFamilyArray(), left.getFamilyOffset(), left.getFamilyLength(),
-      right, roffset, rlength);
-  }
 
   /**
-   * Compares the cell's column (family and qualifier) with the given byte[]
-   * @param left the cell for which the column has to be compared
-   * @param right the byte[] having the column
-   * @param rfoffset the offset of the family
-   * @param rflength the length of the family
-   * @param rqoffset the offset of the qualifier
-   * @param rqlength the length of the qualifier
-   * @return greater than 0 if left cell's column is bigger than byte[], lesser than 0 if left
-   *         cell's column is lesser than byte[] and 0 otherwise
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  public final static int compareColumns(Cell left, byte[] right, int rfoffset, int rflength,
-      int rqoffset, int rqlength) {
-    int diff = compareFamilies(left, right, rfoffset, rflength);
-    if (diff != 0) return diff;
-    return compareQualifiers(left, right, rqoffset, rqlength);
+  @Deprecated
+  public static int writeFlatKey(Cell cell, OutputStream out) throws IOException {
+    return PrivateCellUtil.writeFlatKey(cell, out);
   }
 
-  @InterfaceAudience.Private
   /**
-   * These cells are used in reseeks/seeks to improve the read performance.
-   * They are not real cells that are returned back to the clients
+   * Writes the row from the given cell to the output stream excluding the common prefix
+   * @param out The dataoutputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param rlength the row length
+   * @throws IOException
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  private static abstract class EmptyCell implements Cell, SettableSequenceId {
-
-    @Override
-    public void setSequenceId(long seqId) {
-      // Fake cells don't need seqId, so leaving it as a noop.
-    }
-    @Override
-    public byte[] getRowArray() {
-      return EMPTY_BYTE_ARRAY;
-    }
-
-    @Override
-    public int getRowOffset() {
-      return 0;
-    }
-
-    @Override
-    public short getRowLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getFamilyArray() {
-      return EMPTY_BYTE_ARRAY;
-    }
-
-    @Override
-    public int getFamilyOffset() {
-      return 0;
-    }
-
-    @Override
-    public byte getFamilyLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getQualifierArray() {
-      return EMPTY_BYTE_ARRAY;
-    }
-
-    @Override
-    public int getQualifierOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getQualifierLength() {
-      return 0;
-    }
-
-    @Override
-    public long getSequenceId() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getValueArray() {
-      return EMPTY_BYTE_ARRAY;
-    }
-
-    @Override
-    public int getValueOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getValueLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getTagsArray() {
-      return EMPTY_BYTE_ARRAY;
-    }
-
-    @Override
-    public int getTagsOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getTagsLength() {
-      return 0;
-    }
+  @Deprecated
+  public static void writeRowSkippingBytes(DataOutputStream out, Cell cell, short rlength,
+      int commonPrefix) throws IOException {
+    PrivateCellUtil.writeRowSkippingBytes(out, cell, rlength, commonPrefix);
   }
 
-  @InterfaceAudience.Private
   /**
-   * These cells are used in reseeks/seeks to improve the read performance.
-   * They are not real cells that are returned back to the clients
+   * Writes the qualifier from the given cell to the output stream excluding the common prefix
+   * @param out The dataoutputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param qlength the qualifier length
+   * @throws IOException
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
    */
-  private static abstract class EmptyByteBufferCell extends ByteBufferCell
-      implements SettableSequenceId {
-
-    @Override
-    public void setSequenceId(long seqId) {
-      // Fake cells don't need seqId, so leaving it as a noop.
-    }
-
-    @Override
-    public byte[] getRowArray() {
-      return CellUtil.cloneRow(this);
-    }
-
-    @Override
-    public int getRowOffset() {
-      return 0;
-    }
-
-    @Override
-    public short getRowLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getFamilyArray() {
-      return CellUtil.cloneFamily(this);
-    }
-
-    @Override
-    public int getFamilyOffset() {
-      return 0;
-    }
-
-    @Override
-    public byte getFamilyLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getQualifierArray() {
-      return CellUtil.cloneQualifier(this);
-    }
-
-    @Override
-    public int getQualifierOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getQualifierLength() {
-      return 0;
-    }
-
-    @Override
-    public long getSequenceId() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getValueArray() {
-      return CellUtil.cloneValue(this);
-    }
-
-    @Override
-    public int getValueOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getValueLength() {
-      return 0;
-    }
-
-    @Override
-    public byte[] getTagsArray() {
-      return CellUtil.cloneTags(this);
-    }
-
-    @Override
-    public int getTagsOffset() {
-      return 0;
-    }
-
-    @Override
-    public int getTagsLength() {
-      return 0;
-    }
-
-    @Override
-    public ByteBuffer getRowByteBuffer() {
-      return HConstants.EMPTY_BYTE_BUFFER;
-    }
-
-    @Override
-    public int getRowPosition() {
-      return 0;
-    }
-
-    @Override
-    public ByteBuffer getFamilyByteBuffer() {
-      return HConstants.EMPTY_BYTE_BUFFER;
-    }
-
-    @Override
-    public int getFamilyPosition() {
-      return 0;
-    }
-
-    @Override
-    public ByteBuffer getQualifierByteBuffer() {
-      return HConstants.EMPTY_BYTE_BUFFER;
-    }
-
-    @Override
-    public int getQualifierPosition() {
-      return 0;
-    }
-
-    @Override
-    public ByteBuffer getTagsByteBuffer() {
-      return HConstants.EMPTY_BYTE_BUFFER;
-    }
-
-    @Override
-    public int getTagsPosition() {
-      return 0;
-    }
-
-    @Override
-    public ByteBuffer getValueByteBuffer() {
-      return HConstants.EMPTY_BYTE_BUFFER;
-    }
-
-    @Override
-    public int getValuePosition() {
-      return 0;
-    }
-  }
-
-  @InterfaceAudience.Private
-  private static class FirstOnRowCell extends EmptyCell {
-    private final byte[] rowArray;
-    private final int roffset;
-    private final short rlength;
-
-    public FirstOnRowCell(final byte[] row, int roffset, short rlength) {
-      this.rowArray = row;
-      this.roffset = roffset;
-      this.rlength = rlength;
-    }
-
-    @Override
-    public byte[] getRowArray() {
-      return this.rowArray;
-    }
-
-    @Override
-    public int getRowOffset() {
-      return this.roffset;
-    }
-
-    @Override
-    public short getRowLength() {
-      return this.rlength;
-    }
-
-    @Override
-    public long getTimestamp() {
-      return HConstants.LATEST_TIMESTAMP;
-    }
-
-    @Override
-    public byte getTypeByte() {
-      return Type.Maximum.getCode();
-    }
-  }
-
-  @InterfaceAudience.Private
-  private static class FirstOnRowByteBufferCell extends EmptyByteBufferCell {
-    private final ByteBuffer rowBuff;
-    private final int roffset;
-    private final short rlength;
-
-    public FirstOnRowByteBufferCell(final ByteBuffer row, int roffset, short rlength) {
-      this.rowBuff = row;
-      this.roffset = roffset;
-      this.rlength = rlength;
-    }
-
-    @Override
-    public ByteBuffer getRowByteBuffer() {
-      return this.rowBuff;
-    }
-
-    @Override
-    public int getRowPosition() {
-      return this.roffset;
-    }
-
-    @Override
-    public short getRowLength() {
-      return this.rlength;
-    }
-
-    @Override
-    public long getTimestamp() {
-      return HConstants.LATEST_TIMESTAMP;
-    }
-
-    @Override
-    public byte getTypeByte() {
-      return Type.Maximum.getCode();
-    }
-  }
-
-  @InterfaceAudience.Private
-  private static class LastOnRowByteBufferCell extends EmptyByteBufferCell {
-    private final ByteBuffer rowBuff;
-    private final int roffset;
-    private final short rlength;
-
-    public LastOnRowByteBufferCell(final ByteBuffer row, int roffset, short rlength) {
-      this.rowBuff = row;
-      this.roffset = roffset;
-      this.rlength = rlength;
-    }
-
-    @Override
-    public ByteBuffer getRowByteBuffer() {
-      return this.rowBuff;
-    }
-
-    @Override
-    public int getRowPosition() {
-      return this.roffset;
-    }
-
-    @Override
-    public short getRowLength() {
-      return this.rlength;
-    }
-
-    @Override
-    public long getTimestamp() {
-      return HConstants.OLDEST_TIMESTAMP;
-    }
-
-    @Override
-    public byte getTypeByte() {
-      return Type.Minimum.getCode();
-    }
-  }
-
-  @InterfaceAudience.Private
-  private static class FirstOnRowColByteBufferCell extends FirstOnRowByteBufferCell {
-    private final ByteBuffer famBuff;
-    private final int famOffset;
-    private final byte famLength;
-    private final ByteBuffer colBuff;
-    private final int colOffset;
-    private final int colLength;
-
-    public FirstOnRowColByteBufferCell(final ByteBuffer row, int roffset, short rlength,
-        final ByteBuffer famBuff, final int famOffset, final byte famLength, final ByteBuffer col,
-        final int colOffset, final int colLength) {
-      super(row, roffset, rlength);
-      this.famBuff = famBuff;
-      this.famOffset = famOffset;
-      this.famLength = famLength;
-      this.colBuff = col;
-      this.colOffset = colOffset;
-      this.colLength = colLength;
-    }
-
-    @Override
-    public ByteBuffer getFamilyByteBuffer() {
-      return this.famBuff;
-    }
-
-    @Override
-    public int getFamilyPosition() {
-      return this.famOffset;
-    }
-
-    @Override
-    public byte getFamilyLength() {
-      return famLength;
-    }
-
-    @Override
-    public ByteBuffer getQualifierByteBuffer() {
-      return this.colBuff;
-    }
-
-    @Override
-    public int getQualifierPosition() {
-      return this.colOffset;
-    }
-
-    @Override
-    public int getQualifierLength() {
-      return this.colLength;
+  @Deprecated
+  public static void writeQualifierSkippingBytes(DataOutputStream out, Cell cell,
+      int qlength, int commonPrefix) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream((DataOutput)out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition() + commonPrefix, qlength - commonPrefix);
+    } else {
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset() + commonPrefix,
+        qlength - commonPrefix);
     }
   }
 
-  @InterfaceAudience.Private
-  private static class FirstOnRowColCell extends FirstOnRowCell {
-    private final byte[] fArray;
-    private final int foffset;
-    private final byte flength;
-    private final byte[] qArray;
-    private final int qoffset;
-    private final int qlength;
-
-    public FirstOnRowColCell(byte[] rArray, int roffset, short rlength, byte[] fArray,
-        int foffset, byte flength, byte[] qArray, int qoffset, int qlength) {
-      super(rArray, roffset, rlength);
-      this.fArray = fArray;
-      this.foffset = foffset;
-      this.flength = flength;
-      this.qArray = qArray;
-      this.qoffset = qoffset;
-      this.qlength = qlength;
-    }
-
-    @Override
-    public byte[] getFamilyArray() {
-      return this.fArray;
-    }
-
-    @Override
-    public int getFamilyOffset() {
-      return this.foffset;
-    }
-
-    @Override
-    public byte getFamilyLength() {
-      return this.flength;
-    }
-
-    @Override
-    public byte[] getQualifierArray() {
-      return this.qArray;
-    }
-
-    @Override
-    public int getQualifierOffset() {
-      return this.qoffset;
-    }
-
-    @Override
-    public int getQualifierLength() {
-      return this.qlength;
+  /**
+   * @param cell
+   * @return The Key portion of the passed <code>cell</code> as a String.
+   */
+  public static String getCellKeyAsString(Cell cell) {
+    StringBuilder sb = new StringBuilder(Bytes.toStringBinary(
+      cell.getRowArray(), cell.getRowOffset(), cell.getRowLength()));
+    sb.append('/');
+    sb.append(cell.getFamilyLength() == 0? "":
+      Bytes.toStringBinary(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength()));
+    // KeyValue only added ':' if family is non-null.  Do same.
+    if (cell.getFamilyLength() > 0) sb.append(':');
+    sb.append(cell.getQualifierLength() == 0? "":
+      Bytes.toStringBinary(cell.getQualifierArray(), cell.getQualifierOffset(),
+        cell.getQualifierLength()));
+    sb.append('/');
+    sb.append(KeyValue.humanReadableTimestamp(cell.getTimestamp()));
+    sb.append('/');
+    sb.append(Type.codeToType(cell.getTypeByte()));
+    if (!(cell instanceof KeyValue.KeyOnlyKeyValue)) {
+      sb.append("/vlen=");
+      sb.append(cell.getValueLength());
     }
+    sb.append("/seqid=");
+    sb.append(cell.getSequenceId());
+    return sb.toString();
   }
 
-  @InterfaceAudience.Private
-  private static class FirstOnRowColTSCell extends FirstOnRowColCell {
-
-    private long ts;
-
-    public FirstOnRowColTSCell(byte[] rArray, int roffset, short rlength, byte[] fArray,
-        int foffset, byte flength, byte[] qArray, int qoffset, int qlength, long ts) {
-      super(rArray, roffset, rlength, fArray, foffset, flength, qArray, qoffset, qlength);
-      this.ts = ts;
-    }
-
-    @Override
-    public long getTimestamp() {
-      return this.ts;
-    }
+  /**
+   * This method exists just to encapsulate how we serialize keys.  To be replaced by a factory
+   * that we query to figure what the Cell implementation is and then, what serialization engine
+   * to use and further, how to serialize the key for inclusion in hfile index. TODO.
+   * @param cell
+   * @return The key portion of the Cell serialized in the old-school KeyValue way or null if
+   * passed a null <code>cell</code>
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static byte [] getCellKeySerializedAsKeyValueKey(final Cell cell) {
+    return PrivateCellUtil.getCellKeySerializedAsKeyValueKey(cell);
   }
 
-  @InterfaceAudience.Private
-  private static class FirstOnRowColTSByteBufferCell extends FirstOnRowColByteBufferCell {
-
-    private long ts;
-
-    public FirstOnRowColTSByteBufferCell(ByteBuffer rBuffer, int roffset, short rlength,
-        ByteBuffer fBuffer, int foffset, byte flength, ByteBuffer qBuffer, int qoffset, int qlength,
-        long ts) {
-      super(rBuffer, roffset, rlength, fBuffer, foffset, flength, qBuffer, qoffset, qlength);
-      this.ts = ts;
-    }
-
-    @Override
-    public long getTimestamp() {
-      return this.ts;
-    }
+  /**
+   * Write rowkey excluding the common part.
+   * @param cell
+   * @param rLen
+   * @param commonPrefix
+   * @param out
+   * @throws IOException
+   * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.
+   */
+  @Deprecated
+  public static void writeRowKeyExcludingCommon(Cell cell, short rLen, int commonPrefix,
+      DataOutputStream out) throws IOException {
+    PrivateCellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
   }
 
-  @InterfaceAudience.Private
-  private static class LastOnRowCell extends EmptyCell {
-    private final byte[] rowArray;
-    private final int roffset;
-    private final short rlength;
-
-    public LastOnRowCell(byte[] row, int roffset, short rlength) {
-      this.rowArray = row;
-      this.roffset = roffset;
-      this.rlength = rlength;
-    }
-
-    @Override
-    public byte[] getRowArray() {
-      return this.rowArray;
-    }
-
-    @Override
-    public int getRowOffset() {
-      return this.roffset;
-    }
-
-    @Override
-    public short getRowLength() {
-      return this.rlength;
-    }
-
-    @Override
-    public long getTimestamp() {
-      return HConstants.OLDEST_TIMESTAMP;
-    }
-
-    @Override
-    public byte getTypeByte() {
-      return Type.Minimum.getCode();
-    }
+  /**
+   * Find length of common prefix in keys of the cells, considering key as byte[] if serialized in
+   * {@link KeyValue}. The key format is &lt;2 bytes rk len&gt;&lt;rk&gt;&lt;1 byte cf
+   * len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes timestamp&gt;&lt;1 byte type&gt;
+   * @param c1 the cell
+   * @param c2 the cell
+   * @param bypassFamilyCheck when true assume the family bytes same in both cells. Pass it as true
+   *          when dealing with Cells in same CF so as to avoid some checks
+   * @param withTsType when true check timestamp and type bytes also.
+   * @return length of common prefix
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static int findCommonPrefixInFlatKey(Cell c1, Cell c2, boolean bypassFamilyCheck,
+      boolean withTsType) {
+    return PrivateCellUtil.findCommonPrefixInFlatKey(c1, c2, bypassFamilyCheck, withTsType);
   }
 
-  @InterfaceAudience.Private
-  private static class LastOnRowColCell extends LastOnRowCell {
-    private final byte[] fArray;
-    private final int foffset;
-    private final byte flength;
-    private final byte[] qArray;
-    private final int qoffset;
-    private final int qlength;
-
-    public LastOnRowColCell(byte[] rArray, int roffset, short rlength, byte[] fArray,
-        int foffset, byte flength, byte[] qArray, int qoffset, int qlength) {
-      super(rArray, roffset, rlength);
-      this.fArray = fArray;
-      this.foffset = foffset;
-      this.flength = flength;
-      this.qArray = qArray;
-      this.qoffset = qoffset;
-      this.qlength = qlength;
+  /** Returns a string representation of the cell */
+  public static String toString(Cell cell, boolean verbose) {
+    if (cell == null) {
+      return "";
     }
+    StringBuilder builder = new StringBuilder();
+    String keyStr = getCellKeyAsString(cell);
 
-    @Override
-    public byte[] getFamilyArray() {
-      return this.fArray;
+    String tag = null;
+    String value = null;
+    if (verbose) {
+      // TODO: pretty print tags as well
+      if (cell.getTagsLength() > 0) {
+        tag = Bytes.toStringBinary(cell.getTagsArray(), cell.getTagsOffset(), cell.getTagsLength());
+      }
+      if (!(cell instanceof KeyValue.KeyOnlyKeyValue)) {
+        value = Bytes.toStringBinary(cell.getValueArray(), cell.getValueOffset(),
+          cell.getValueLength());
+      }
     }
 
-    @Override
-    public int getFamilyOffset() {
-      return this.foffset;
+    builder.append(keyStr);
+    if (tag != null && !tag.isEmpty()) {
+      builder.append("/").append(tag);
     }
-
-    @Override
-    public byte getFamilyLength() {
-      return this.flength;
+    if (value != null) {
+      builder.append("/").append(value);
     }
 
-    @Override
-    public byte[] getQualifierArray() {
-      return this.qArray;
-    }
+    return builder.toString();
+  }
 
-    @Override
-    public int getQualifierOffset() {
-      return this.qoffset;
-    }
+  /***************** special cases ****************************/
 
-    @Override
-    public int getQualifierLength() {
-      return this.qlength;
-    }
+  /**
+   * special case for Cell.equals
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static boolean equalsIgnoreMvccVersion(Cell a, Cell b) {
+    return PrivateCellUtil.equalsIgnoreMvccVersion(a, b);
   }
 
-  @InterfaceAudience.Private
-  private static class LastOnRowColByteBufferCell extends LastOnRowByteBufferCell {
-    private final ByteBuffer fBuffer;
-    private final int foffset;
-    private final byte flength;
-    private final ByteBuffer qBuffer;
-    private final int qoffset;
-    private final int qlength;
-
-    public LastOnRowColByteBufferCell(ByteBuffer rBuffer, int roffset, short rlength,
-        ByteBuffer fBuffer, int foffset, byte flength, ByteBuffer qBuffer, int qoffset,
-        int qlength) {
-      super(rBuffer, roffset, rlength);
-      this.fBuffer = fBuffer;
-      this.foffset = foffset;
-      this.flength = flength;
-      this.qBuffer = qBuffer;
-      this.qoffset = qoffset;
-      this.qlength = qlength;
-    }
+  /**************** equals ****************************/
 
-    @Override
-    public ByteBuffer getFamilyByteBuffer() {
-      return this.fBuffer;
-    }
+  public static boolean equals(Cell a, Cell b) {
+    return matchingRows(a, b) && matchingFamily(a, b) && matchingQualifier(a, b)
+        && matchingTimestamp(a, b) && PrivateCellUtil.matchingType(a, b);
+  }
 
-    @Override
-    public int getFamilyPosition() {
-      return this.foffset;
-    }
+  public static boolean matchingTimestamp(Cell a, Cell b) {
+    return CellComparatorImpl.COMPARATOR.compareTimestamps(a.getTimestamp(), b.getTimestamp()) == 0;
+  }
 
-    @Override
-    public byte getFamilyLength() {
-      return this.flength;
-    }
+  /**
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @Deprecated
+  public static boolean matchingType(Cell a, Cell b) {
+    return PrivateCellUtil.matchingType(a, b);
+  }
 
-    @Override
-    public ByteBuffer getQualifierByteBuffer() {
-      return this.qBuffer;
+  /**
+   * Compares the row of two keyvalues for equality
+   * @param left
+   * @param right
+   * @return True if rows match.
+   */
+  public static boolean matchingRows(final Cell left, final Cell right) {
+    short lrowlength = left.getRowLength();
+    short rrowlength = right.getRowLength();
+    if (lrowlength != rrowlength) return false;
+    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
+        ((ByteBufferCell) left).getRowPosition(), lrowlength,
+        ((ByteBufferCell) right).getRowByteBuffer(), ((ByteBufferCell) right).getRowPosition(),
+        rrowlength);
     }
-
-    @Override
-    public int getQualifierPosition() {
-      return this.qoffset;
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
+        ((ByteBufferCell) left).getRowPosition(), lrowlength, right.getRowArray(),
+        right.getRowOffset(), rrowlength);
     }
-
-    @Override
-    public int getQualifierLength() {
-      return this.qlength;
+    if (right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) right).getRowByteBuffer(),
+        ((ByteBufferCell) right).getRowPosition(), rrowlength, left.getRowArray(),
+        left.getRowOffset(), lrowlength);
     }
+    return Bytes.equals(left.getRowArray(), left.getRowOffset(), lrowlength, right.getRowArray(),
+      right.getRowOffset(), rrowlength);
   }
 
-  @InterfaceAudience.Private
-  private static class FirstOnRowDeleteFamilyCell extends EmptyCell {
-    private final byte[] row;
-    private final byte[] fam;
-
-    public FirstOnRowDeleteFamilyCell(byte[] row, byte[] fam) {
-      this.row = row;
-      this.fam = fam;
-    }
-
-    @Override
-    public byte[] getRowArray() {
-      return this.row;
-    }
-
-    @Override
-    public short getRowLength() {
-      return (short) this.row.length;
+  /**
+   * Compares the row and column of two keyvalues for equality
+   * @param left
+   * @param right
+   * @return True if same row and column.
+   */
+  public static boolean matchingRowColumn(final Cell left, final Cell right) {
+    if ((left.getRowLength() + left.getFamilyLength()
+        + left.getQualifierLength()) != (right.getRowLength() + right.getFamilyLength()
+            + right.getQualifierLength())) {
+      return false;
     }
 
-    @Override
-    public byte[] getFamilyArray() {
-      return this.fam;
+    if (!matchingRows(left, right)) {
+      return false;
     }
+    return matchingColumn(left, right);
+  }
 
-    @Override
-    public byte getFamilyLength() {
-      return (byte) this.fam.length;
+  /**
+   * Compares the cell's qualifier with the given byte[]
+   * @param left the cell for which the qualifier has to be compared
+   * @param right the byte[] having the qualifier
+   * @param rOffset the offset of the qualifier
+   * @param rLength the length of the qualifier
+   * @return greater than 0 if left cell's qualifier is bigger than byte[], lesser than 0 if left
+   *         cell's qualifier is lesser than byte[] and 0 otherwise
+   */
+  public final static int compareQualifiers(Cell left, byte[] right, int rOffset, int rLength) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getQualifierByteBuffer(),
+        ((ByteBufferCell) left).getQualifierPosition(), left.getQualifierLength(), right, rOffset,
+        rLength);
     }
+    return Bytes.compareTo(left.getQualifierArray(), left.getQualifierOffset(),
+      left.getQualifierLength(), right, rOffset, rLength);
+  }
 
-    @Override
-    public long getTimestamp() {
-      return HConstants.LATEST_TIMESTAMP;
-    }
+  /**
+   * Used when a cell needs to be compared with a key byte[] such as cases of finding the index from
+   * the index block, bloom keys from the bloom blocks This byte[] is expected to be serialized in
+   * the KeyValue serialization format If the KeyValue (Cell's) serialization format changes this
+   * method cannot be used.
+   * @param comparator the cell comparator
+   * @param left the cell to be compared
+   * @param key the serialized key part of a KeyValue
+   * @param offset the offset in the key byte[]
+   * @param length the length of the key byte[]
+   * @return an int greater than 0 if left is greater than right lesser than 0 if left is lesser
+   *         than right equal to 0 if left is equal to right
+   * @deprecated As of HBase-2.0. Will be removed in HBase-3.0
+   */
+  @VisibleForTesting
+  @Deprecated
+  public static final int compare(CellComparator comparator, Cell left, byte[] key, int offset,
+      int length) {
+    // row
+    short rrowlength = Bytes.toShort(key, offset);
+    int c = comparator.compareRows(left, key, offset + Bytes.SIZEOF_SHORT, rrowlength);
+    if (c != 0) return c;
 
-    @Override
-    public byte getTypeByte() {
-      return Type.DeleteFamily.getCode();
-    }
+    // Compare the rest of the two KVs without making any assumptions about
+    // the common prefix. This function will not compare rows anyway, so we
+    // don't need to tell it that the common prefix includes the row.
+    return PrivateCellUtil.compareWithoutRow(comparator, left, key, offset, length, rrowlength);
   }
 
   /**
-   * @return An new cell is located following input cell. If both of type and timestamp are
-   *         minimum, the input cell will be returned directly.
+   * Compares the cell's family with the given byte[]
+   * @param left the cell for which the family has to be compared
+   * @param right the byte[] having the family
+   * @param roffset the offset of the family
+   * @param rlength the length of the family
+   * @return greater than 0 if left cell's family is bigger than byte[], lesser than 0 if left
+   *         cell's family is lesser than byte[] and 0 otherwise
    */
-  @InterfaceAudience.Private
-  public static Cell createNextOnRowCol(Cell cell) {
-    long ts = cell.getTimestamp();
-    byte type = cell.getTypeByte();
-    if (type != Type.Minimum.getCode()) {
-      type = KeyValue.Type.values()[KeyValue.Type.codeToType(type).ordinal() - 1].getCode();
-    } else if (ts != HConstants.OLDEST_TIMESTAMP) {
-      ts = ts - 1;
-      type = Type.Maximum.getCode();
-    } else {
-      return cell;
+  public final static int compareFamilies(Cell left, byte[] right, int roffset, int rlength) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.compareTo(((ByteBufferCell) left).getFamilyByteBuffer(),
+        ((ByteBufferCell) left).getFamilyPosition(), left.getFamilyLength(), right, roffset,
+        rlength);
     }
-    return createNextOnRowCol(cell, ts, type);
+    return Bytes.compareTo(left.getFamilyArray(), left.getFamilyOffset(), left.getFamilyLength(),
+      right, roffset, rlength);
   }
 
-  private static Cell createNextOnRowCol(Cell cell, long ts, byte type) {
-    if (cell instanceof ByteBufferCell) {
-      return new LastOnRowColByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
-              ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
-              ((ByteBufferCell) cell).getFamilyByteBuffer(),
-              ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
-              ((ByteBufferCell) cell).getQualifierByteBuffer(),
-              ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength()) {
-        @Override
-        public long getTimestamp() {
-          return ts;
-        }
-
-        @Override
-        public byte getTypeByte() {
-          return type;
-        }
-      };
-    }
-    return new LastOnRowColCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(),
-            cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
-            cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength()) {
-      @Override
-      public long getTimestamp() {
-        return ts;
-      }
-
-      @Override
-      public byte getTypeByte() {
-        return type;
-      }
-    };
+  /**
+   * Compares the cell's column (family and qualifier) with the given byte[]
+   * @param left the cell for which the column has to be compared
+   * @param right the byte[] having the column
+   * @param rfoffset the offset of the family
+   * @param rflength the length of the family
+   * @param rqoffset the offset of the qualifier
+   * @param rqlength the length of the qualifier
+   * @return greater than 0 if left cell's column is bigger than byte[], lesser than 0 if left
+   *         cell's column is lesser than byte[] and 0 otherwise
+   */
+  public final static int compareColumns(Cell left, byte[] right, int rfoffset, int rflength,
+      int rqoffset, int rqlength) {
+    int diff = compareFamilies(left, right, rfoffset, rflength);
+    if (diff != 0) return diff;
+    return compareQualifiers(left, right, rqoffset, rqlength);
   }
 }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/IndividualBytesFieldCell.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/IndividualBytesFieldCell.java
index 14e35df..a15843c 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/IndividualBytesFieldCell.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/IndividualBytesFieldCell.java
@@ -24,7 +24,6 @@ import java.io.IOException;
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 
-import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.util.ArrayUtils;
 import org.apache.hadoop.hbase.util.ByteBufferUtils;
 import org.apache.hadoop.hbase.util.Bytes;
@@ -144,7 +143,7 @@ public class IndividualBytesFieldCell implements ExtendedCell {
     ByteBufferUtils.putInt(out, getValueLength());
 
     // Key
-    CellUtil.writeFlatKey(this, out);
+    PrivateCellUtil.writeFlatKey(this, out);
 
     // Value
     out.write(getValueArray());
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
index 6154045..42ac97d 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
@@ -1617,7 +1617,7 @@ public class KeyValue implements ExtendedCell {
      */
     @Override
     public int compare(final Cell left, final Cell right) {
-      return CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.META_COMPARATOR, left, right);
+      return PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.META_COMPARATOR, left, right);
     }
 
     @Override
@@ -1839,7 +1839,7 @@ public class KeyValue implements ExtendedCell {
     }
 
     public int compareOnlyKeyPortion(Cell left, Cell right) {
-      return CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, right);
+      return PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, right);
     }
 
     /**
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueTestUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueTestUtil.java
index c8bed3e..7467d67 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueTestUtil.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueTestUtil.java
@@ -85,7 +85,7 @@ public class KeyValueTestUtil {
     for (Cell kv1 : kvCollection1) {
       boolean found = false;
       for (Cell kv2 : kvCollection2) {
-        if (CellUtil.equalsIgnoreMvccVersion(kv1, kv2)) found = true;
+        if (PrivateCellUtil.equalsIgnoreMvccVersion(kv1, kv2)) found = true;
       }
       if (!found) return false;
     }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueUtil.java
index f1f03eb..6fd37c0 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueUtil.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValueUtil.java
@@ -163,7 +163,7 @@ public class KeyValueUtil {
     pos = CellUtil.copyValueTo(cell, output, pos);
     if (withTags && (cell.getTagsLength() > 0)) {
       pos = Bytes.putAsShort(output, pos, cell.getTagsLength());
-      pos = CellUtil.copyTagTo(cell, output, pos);
+      pos = PrivateCellUtil.copyTagsTo(cell, output, pos);
     }
     return pos;
   }
@@ -179,7 +179,7 @@ public class KeyValueUtil {
     int tagsLength = cell.getTagsLength();
     if (withTags && (tagsLength > 0)) {
       offset = ByteBufferUtils.putAsShort(buf, offset, tagsLength);// Tags length
-      offset = CellUtil.copyTagTo(cell, buf, offset);// Tags bytes
+      offset = PrivateCellUtil.copyTagsTo(cell, buf, offset);// Tags bytes
     }
     return offset;
   }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/PrivateCellUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/PrivateCellUtil.java
new file mode 100644
index 0000000..544f885
--- /dev/null
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/PrivateCellUtil.java
@@ -0,0 +1,2776 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase;
+
+import static org.apache.hadoop.hbase.HConstants.EMPTY_BYTE_ARRAY;
+import static org.apache.hadoop.hbase.Tag.TAG_LENGTH_SIZE;
+
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.hadoop.hbase.KeyValue.Type;
+import org.apache.hadoop.hbase.filter.ByteArrayComparable;
+import org.apache.hadoop.hbase.io.HeapSize;
+import org.apache.hadoop.hbase.io.TagCompressionContext;
+import org.apache.hadoop.hbase.io.util.Dictionary;
+import org.apache.hadoop.hbase.io.util.StreamUtils;
+import org.apache.hadoop.hbase.util.ByteBufferUtils;
+import org.apache.hadoop.hbase.util.ByteRange;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.ClassSize;
+import org.apache.yetus.audience.InterfaceAudience;
+
+import com.google.common.annotations.VisibleForTesting;
+
+/**
+ * Utility methods helpful slinging {@link Cell} instances. It has more powerful and
+ * rich set of APIs than those in {@link CellUtil} for internal usage.
+ */
+@InterfaceAudience.Private
+// TODO : Make Tag IA.LimitedPrivate and move some of the Util methods to CP exposed Util class
+public class PrivateCellUtil {
+
+  /**
+   * Private constructor to keep this class from being instantiated.
+   */
+  private PrivateCellUtil() {
+
+  }
+
+  /******************* ByteRange *******************************/
+
+  public static ByteRange fillRowRange(Cell cell, ByteRange range) {
+    return range.set(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
+  }
+
+  public static ByteRange fillFamilyRange(Cell cell, ByteRange range) {
+    return range.set(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());
+  }
+
+  public static ByteRange fillQualifierRange(Cell cell, ByteRange range) {
+    return range.set(cell.getQualifierArray(), cell.getQualifierOffset(),
+      cell.getQualifierLength());
+  }
+
+  public static ByteRange fillValueRange(Cell cell, ByteRange range) {
+    return range.set(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
+  }
+
+  public static ByteRange fillTagRange(Cell cell, ByteRange range) {
+    return range.set(cell.getTagsArray(), cell.getTagsOffset(), cell.getTagsLength());
+  }
+
+  /**
+   * Returns tag value in a new byte array. If server-side, use {@link Tag#getValueArray()} with
+   * appropriate {@link Tag#getValueOffset()} and {@link Tag#getValueLength()} instead to save on
+   * allocations.
+   * @param cell
+   * @return tag value in a new byte array.
+   */
+  public static byte[] getTagsArray(Cell cell) {
+    byte[] output = new byte[cell.getTagsLength()];
+    copyTagsTo(cell, output, 0);
+    return output;
+  }
+
+  public static byte[] cloneTags(Cell cell) {
+    byte[] output = new byte[cell.getTagsLength()];
+    copyTagsTo(cell, output, 0);
+    return output;
+  }
+
+  /**
+   * Copies the tags info into the tag portion of the cell
+   * @param cell
+   * @param destination
+   * @param destinationOffset
+   * @return position after tags
+   */
+  public static int copyTagsTo(Cell cell, byte[] destination, int destinationOffset) {
+    int tlen = cell.getTagsLength();
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyFromBufferToArray(destination,
+        ((ByteBufferCell) cell).getTagsByteBuffer(), ((ByteBufferCell) cell).getTagsPosition(),
+        destinationOffset, tlen);
+    } else {
+      System.arraycopy(cell.getTagsArray(), cell.getTagsOffset(), destination, destinationOffset,
+        tlen);
+    }
+    return destinationOffset + tlen;
+  }
+
+  /**
+   * Copies the tags info into the tag portion of the cell
+   * @param cell
+   * @param destination
+   * @param destinationOffset
+   * @return the position after tags
+   */
+  public static int copyTagsTo(Cell cell, ByteBuffer destination, int destinationOffset) {
+    int tlen = cell.getTagsLength();
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyFromBufferToBuffer(((ByteBufferCell) cell).getTagsByteBuffer(),
+        destination, ((ByteBufferCell) cell).getTagsPosition(), destinationOffset, tlen);
+    } else {
+      ByteBufferUtils.copyFromArrayToBuffer(destination, destinationOffset, cell.getTagsArray(),
+        cell.getTagsOffset(), tlen);
+    }
+    return destinationOffset + tlen;
+  }
+
+  /********************* misc *************************************/
+
+  public static byte getRowByte(Cell cell, int index) {
+    if (cell instanceof ByteBufferCell) {
+      return ((ByteBufferCell) cell).getRowByteBuffer()
+          .get(((ByteBufferCell) cell).getRowPosition() + index);
+    }
+    return cell.getRowArray()[cell.getRowOffset() + index];
+  }
+
+  public static byte getQualifierByte(Cell cell, int index) {
+    if (cell instanceof ByteBufferCell) {
+      return ((ByteBufferCell) cell).getQualifierByteBuffer()
+          .get(((ByteBufferCell) cell).getQualifierPosition() + index);
+    }
+    return cell.getQualifierArray()[cell.getQualifierOffset() + index];
+  }
+
+  public static ByteBuffer getValueBufferShallowCopy(Cell cell) {
+    ByteBuffer buffer =
+        ByteBuffer.wrap(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
+    return buffer;
+  }
+
+  /**
+   * @return A new cell which is having the extra tags also added to it.
+   */
+  public static Cell createCell(Cell cell, List<Tag> tags) {
+    return createCell(cell, TagUtil.fromList(tags));
+  }
+
+  /**
+   * @return A new cell which is having the extra tags also added to it.
+   */
+  public static Cell createCell(Cell cell, byte[] tags) {
+    if (cell instanceof ByteBufferCell) {
+      return new TagRewriteByteBufferCell((ByteBufferCell) cell, tags);
+    }
+    return new TagRewriteCell(cell, tags);
+  }
+
+  public static Cell createCell(Cell cell, byte[] value, byte[] tags) {
+    if (cell instanceof ByteBufferCell) {
+      return new ValueAndTagRewriteByteBufferCell((ByteBufferCell) cell, value, tags);
+    }
+    return new ValueAndTagRewriteCell(cell, value, tags);
+  }
+
+  /**
+   * This can be used when a Cell has to change with addition/removal of one or more tags. This is
+   * an efficient way to do so in which only the tags bytes part need to recreated and copied. All
+   * other parts, refer to the original Cell.
+   */
+  static class TagRewriteCell implements ExtendedCell {
+    protected Cell cell;
+    protected byte[] tags;
+    private static final long HEAP_SIZE_OVERHEAD = ClassSize.OBJECT + 2 * ClassSize.REFERENCE;
+
+    /**
+     * @param cell The original Cell which it rewrites
+     * @param tags the tags bytes. The array suppose to contain the tags bytes alone.
+     */
+    public TagRewriteCell(Cell cell, byte[] tags) {
+      assert cell instanceof ExtendedCell;
+      assert tags != null;
+      this.cell = cell;
+      this.tags = tags;
+      // tag offset will be treated as 0 and length this.tags.length
+      if (this.cell instanceof TagRewriteCell) {
+        // Cleaning the ref so that the byte[] can be GCed
+        ((TagRewriteCell) this.cell).tags = null;
+      }
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return cell.getRowArray();
+    }
+
+    @Override
+    public int getRowOffset() {
+      return cell.getRowOffset();
+    }
+
+    @Override
+    public short getRowLength() {
+      return cell.getRowLength();
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return cell.getFamilyArray();
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return cell.getFamilyOffset();
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return cell.getFamilyLength();
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return cell.getQualifierArray();
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return cell.getQualifierOffset();
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return cell.getQualifierLength();
+    }
+
+    @Override
+    public long getTimestamp() {
+      return cell.getTimestamp();
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return cell.getTypeByte();
+    }
+
+    @Override
+    public long getSequenceId() {
+      return cell.getSequenceId();
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return cell.getValueArray();
+    }
+
+    @Override
+    public int getValueOffset() {
+      return cell.getValueOffset();
+    }
+
+    @Override
+    public int getValueLength() {
+      return cell.getValueLength();
+    }
+
+    @Override
+    public byte[] getTagsArray() {
+      return this.tags;
+    }
+
+    @Override
+    public int getTagsOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getTagsLength() {
+      if (null == this.tags) {
+        // Nulled out tags array optimization in constructor
+        return 0;
+      }
+      return this.tags.length;
+    }
+
+    @Override
+    public long heapSize() {
+      long sum = HEAP_SIZE_OVERHEAD + estimatedHeapSizeOf(cell);
+      if (this.tags != null) {
+        sum += ClassSize.sizeOf(this.tags);
+      }
+      return sum;
+    }
+
+    @Override
+    public void setTimestamp(long ts) throws IOException {
+      // The incoming cell is supposed to be SettableTimestamp type.
+      PrivateCellUtil.setTimestamp(cell, ts);
+    }
+
+    @Override
+    public void setTimestamp(byte[] ts, int tsOffset) throws IOException {
+      // The incoming cell is supposed to be SettableTimestamp type.
+      PrivateCellUtil.setTimestamp(cell, ts, tsOffset);
+    }
+
+    @Override
+    public void setSequenceId(long seqId) throws IOException {
+      // The incoming cell is supposed to be SettableSequenceId type.
+      PrivateCellUtil.setSequenceId(cell, seqId);
+    }
+
+    @Override
+    public int write(OutputStream out, boolean withTags) throws IOException {
+      int len = ((ExtendedCell) this.cell).write(out, false);
+      if (withTags && this.tags != null) {
+        // Write the tagsLength 2 bytes
+        out.write((byte) (0xff & (this.tags.length >> 8)));
+        out.write((byte) (0xff & this.tags.length));
+        out.write(this.tags);
+        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
+      }
+      return len;
+    }
+
+    @Override
+    public int getSerializedSize(boolean withTags) {
+      int len = ((ExtendedCell) this.cell).getSerializedSize(false);
+      if (withTags && this.tags != null) {
+        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
+      }
+      return len;
+    }
+
+    @Override
+    public void write(ByteBuffer buf, int offset) {
+      offset = KeyValueUtil.appendTo(this.cell, buf, offset, false);
+      int tagsLen = this.tags == null ? 0 : this.tags.length;
+      if (tagsLen > 0) {
+        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
+        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, this.tags, 0, tagsLen);
+      }
+    }
+
+    @Override
+    public ExtendedCell deepClone() {
+      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
+      return new TagRewriteCell(clonedBaseCell, this.tags);
+    }
+  }
+
+  static class TagRewriteByteBufferCell extends ByteBufferCell implements ExtendedCell {
+
+    protected ByteBufferCell cell;
+    protected byte[] tags;
+    private static final long HEAP_SIZE_OVERHEAD = ClassSize.OBJECT + 2 * ClassSize.REFERENCE;
+
+    /**
+     * @param cell The original ByteBufferCell which it rewrites
+     * @param tags the tags bytes. The array suppose to contain the tags bytes alone.
+     */
+    public TagRewriteByteBufferCell(ByteBufferCell cell, byte[] tags) {
+      assert cell instanceof ExtendedCell;
+      assert tags != null;
+      this.cell = cell;
+      this.tags = tags;
+      // tag offset will be treated as 0 and length this.tags.length
+      if (this.cell instanceof TagRewriteByteBufferCell) {
+        // Cleaning the ref so that the byte[] can be GCed
+        ((TagRewriteByteBufferCell) this.cell).tags = null;
+      }
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return this.cell.getRowArray();
+    }
+
+    @Override
+    public int getRowOffset() {
+      return this.cell.getRowOffset();
+    }
+
+    @Override
+    public short getRowLength() {
+      return this.cell.getRowLength();
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return this.cell.getFamilyArray();
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return this.cell.getFamilyOffset();
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return this.cell.getFamilyLength();
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return this.cell.getQualifierArray();
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return this.cell.getQualifierOffset();
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return this.cell.getQualifierLength();
+    }
+
+    @Override
+    public long getTimestamp() {
+      return this.cell.getTimestamp();
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return this.cell.getTypeByte();
+    }
+
+    @Override
+    public long getSequenceId() {
+      return this.cell.getSequenceId();
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return this.cell.getValueArray();
+    }
+
+    @Override
+    public int getValueOffset() {
+      return this.cell.getValueOffset();
+    }
+
+    @Override
+    public int getValueLength() {
+      return this.cell.getValueLength();
+    }
+
+    @Override
+    public byte[] getTagsArray() {
+      return this.tags;
+    }
+
+    @Override
+    public int getTagsOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getTagsLength() {
+      if (null == this.tags) {
+        // Nulled out tags array optimization in constructor
+        return 0;
+      }
+      return this.tags.length;
+    }
+
+    @Override
+    public void setSequenceId(long seqId) throws IOException {
+      PrivateCellUtil.setSequenceId(this.cell, seqId);
+    }
+
+    @Override
+    public void setTimestamp(long ts) throws IOException {
+      PrivateCellUtil.setTimestamp(this.cell, ts);
+    }
+
+    @Override
+    public void setTimestamp(byte[] ts, int tsOffset) throws IOException {
+      PrivateCellUtil.setTimestamp(this.cell, ts, tsOffset);
+    }
+
+    @Override
+    public long heapSize() {
+      long sum = HEAP_SIZE_OVERHEAD + estimatedHeapSizeOf(cell);
+      // this.tags is on heap byte[]
+      if (this.tags != null) {
+        sum += ClassSize.sizeOf(this.tags);
+      }
+      return sum;
+    }
+
+    @Override
+    public int write(OutputStream out, boolean withTags) throws IOException {
+      int len = ((ExtendedCell) this.cell).write(out, false);
+      if (withTags && this.tags != null) {
+        // Write the tagsLength 2 bytes
+        out.write((byte) (0xff & (this.tags.length >> 8)));
+        out.write((byte) (0xff & this.tags.length));
+        out.write(this.tags);
+        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
+      }
+      return len;
+    }
+
+    @Override
+    public int getSerializedSize(boolean withTags) {
+      int len = ((ExtendedCell) this.cell).getSerializedSize(false);
+      if (withTags && this.tags != null) {
+        len += KeyValue.TAGS_LENGTH_SIZE + this.tags.length;
+      }
+      return len;
+    }
+
+    @Override
+    public void write(ByteBuffer buf, int offset) {
+      offset = KeyValueUtil.appendTo(this.cell, buf, offset, false);
+      int tagsLen = this.tags == null ? 0 : this.tags.length;
+      if (tagsLen > 0) {
+        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
+        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, this.tags, 0, tagsLen);
+      }
+    }
+
+    @Override
+    public ExtendedCell deepClone() {
+      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
+      if (clonedBaseCell instanceof ByteBufferCell) {
+        return new TagRewriteByteBufferCell((ByteBufferCell) clonedBaseCell, this.tags);
+      }
+      return new TagRewriteCell(clonedBaseCell, this.tags);
+    }
+
+    @Override
+    public ByteBuffer getRowByteBuffer() {
+      return this.cell.getRowByteBuffer();
+    }
+
+    @Override
+    public int getRowPosition() {
+      return this.cell.getRowPosition();
+    }
+
+    @Override
+    public ByteBuffer getFamilyByteBuffer() {
+      return this.cell.getFamilyByteBuffer();
+    }
+
+    @Override
+    public int getFamilyPosition() {
+      return this.cell.getFamilyPosition();
+    }
+
+    @Override
+    public ByteBuffer getQualifierByteBuffer() {
+      return this.cell.getQualifierByteBuffer();
+    }
+
+    @Override
+    public int getQualifierPosition() {
+      return this.cell.getQualifierPosition();
+    }
+
+    @Override
+    public ByteBuffer getValueByteBuffer() {
+      return this.cell.getValueByteBuffer();
+    }
+
+    @Override
+    public int getValuePosition() {
+      return this.cell.getValuePosition();
+    }
+
+    @Override
+    public ByteBuffer getTagsByteBuffer() {
+      return this.tags == null ? HConstants.EMPTY_BYTE_BUFFER : ByteBuffer.wrap(this.tags);
+    }
+
+    @Override
+    public int getTagsPosition() {
+      return 0;
+    }
+  }
+
+  static class ValueAndTagRewriteCell extends TagRewriteCell {
+
+    protected byte[] value;
+
+    public ValueAndTagRewriteCell(Cell cell, byte[] value, byte[] tags) {
+      super(cell, tags);
+      this.value = value;
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return this.value;
+    }
+
+    @Override
+    public int getValueOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getValueLength() {
+      return this.value == null ? 0 : this.value.length;
+    }
+
+    @Override
+    public long heapSize() {
+      long sum = ClassSize.REFERENCE + super.heapSize();
+      if (this.value != null) {
+        sum += ClassSize.sizeOf(this.value);
+      }
+      return sum;
+    }
+
+    @Override
+    public int write(OutputStream out, boolean withTags) throws IOException {
+      return write(out, withTags, this.cell, this.value, this.tags);
+    }
+
+    // Made into a static method so as to reuse the logic within ValueAndTagRewriteByteBufferCell
+    static int write(OutputStream out, boolean withTags, Cell cell, byte[] value, byte[] tags)
+        throws IOException {
+      int valLen = value == null ? 0 : value.length;
+      ByteBufferUtils.putInt(out, KeyValueUtil.keyLength(cell));// Key length
+      ByteBufferUtils.putInt(out, valLen);// Value length
+      int len = 2 * Bytes.SIZEOF_INT;
+      len += writeFlatKey(cell, out);// Key
+      if (valLen > 0) out.write(value);// Value
+      len += valLen;
+      if (withTags && tags != null) {
+        // Write the tagsLength 2 bytes
+        out.write((byte) (0xff & (tags.length >> 8)));
+        out.write((byte) (0xff & tags.length));
+        out.write(tags);
+        len += KeyValue.TAGS_LENGTH_SIZE + tags.length;
+      }
+      return len;
+    }
+
+    @Override
+    public int getSerializedSize(boolean withTags) {
+      return super.getSerializedSize(withTags) - this.cell.getValueLength() + this.value.length;
+    }
+
+    @Override
+    public void write(ByteBuffer buf, int offset) {
+      write(buf, offset, this.cell, this.value, this.tags);
+    }
+
+    // Made into a static method so as to reuse the logic within ValueAndTagRewriteByteBufferCell
+    static void write(ByteBuffer buf, int offset, Cell cell, byte[] value, byte[] tags) {
+      offset = ByteBufferUtils.putInt(buf, offset, KeyValueUtil.keyLength(cell));// Key length
+      offset = ByteBufferUtils.putInt(buf, offset, value.length);// Value length
+      offset = KeyValueUtil.appendKeyTo(cell, buf, offset);
+      ByteBufferUtils.copyFromArrayToBuffer(buf, offset, value, 0, value.length);
+      offset += value.length;
+      int tagsLen = tags == null ? 0 : tags.length;
+      if (tagsLen > 0) {
+        offset = ByteBufferUtils.putAsShort(buf, offset, tagsLen);
+        ByteBufferUtils.copyFromArrayToBuffer(buf, offset, tags, 0, tagsLen);
+      }
+    }
+
+    @Override
+    public ExtendedCell deepClone() {
+      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
+      return new ValueAndTagRewriteCell(clonedBaseCell, this.value, this.tags);
+    }
+  }
+
+  static class ValueAndTagRewriteByteBufferCell extends TagRewriteByteBufferCell {
+
+    protected byte[] value;
+
+    public ValueAndTagRewriteByteBufferCell(ByteBufferCell cell, byte[] value, byte[] tags) {
+      super(cell, tags);
+      this.value = value;
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return this.value;
+    }
+
+    @Override
+    public int getValueOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getValueLength() {
+      return this.value == null ? 0 : this.value.length;
+    }
+
+    @Override
+    public ByteBuffer getValueByteBuffer() {
+      return ByteBuffer.wrap(this.value);
+    }
+
+    @Override
+    public int getValuePosition() {
+      return 0;
+    }
+
+    @Override
+    public long heapSize() {
+      long sum = ClassSize.REFERENCE + super.heapSize();
+      if (this.value != null) {
+        sum += ClassSize.sizeOf(this.value);
+      }
+      return sum;
+    }
+
+    @Override
+    public int write(OutputStream out, boolean withTags) throws IOException {
+      return ValueAndTagRewriteCell.write(out, withTags, this.cell, this.value, this.tags);
+    }
+
+    @Override
+    public int getSerializedSize(boolean withTags) {
+      return super.getSerializedSize(withTags) - this.cell.getValueLength() + this.value.length;
+    }
+
+    @Override
+    public void write(ByteBuffer buf, int offset) {
+      ValueAndTagRewriteCell.write(buf, offset, this.cell, this.value, this.tags);
+    }
+
+    @Override
+    public ExtendedCell deepClone() {
+      Cell clonedBaseCell = ((ExtendedCell) this.cell).deepClone();
+      if (clonedBaseCell instanceof ByteBufferCell) {
+        return new ValueAndTagRewriteByteBufferCell((ByteBufferCell) clonedBaseCell, this.value,
+            this.tags);
+      }
+      return new ValueAndTagRewriteCell(clonedBaseCell, this.value, this.tags);
+    }
+  }
+
+  public static boolean matchingRows(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getRowByteBuffer(),
+        ((ByteBufferCell) left).getRowPosition(), left.getRowLength(), buf, offset, length);
+    }
+    return Bytes.equals(left.getRowArray(), left.getRowOffset(), left.getRowLength(), buf, offset,
+      length);
+  }
+
+  public static boolean matchingFamily(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getFamilyByteBuffer(),
+        ((ByteBufferCell) left).getFamilyPosition(), left.getFamilyLength(), buf, offset, length);
+    }
+    return Bytes.equals(left.getFamilyArray(), left.getFamilyOffset(), left.getFamilyLength(), buf,
+      offset, length);
+  }
+
+  /**
+   * Finds if the qualifier part of the cell and the KV serialized byte[] are equal
+   * @param left
+   * @param buf the serialized keyvalue format byte[]
+   * @param offset the offset of the qualifier in the byte[]
+   * @param length the length of the qualifier in the byte[]
+   * @return true if the qualifier matches, false otherwise
+   */
+  public static boolean matchingQualifier(final Cell left, final byte[] buf, final int offset,
+      final int length) {
+    if (buf == null) {
+      return left.getQualifierLength() == 0;
+    }
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getQualifierByteBuffer(),
+        ((ByteBufferCell) left).getQualifierPosition(), left.getQualifierLength(), buf, offset,
+        length);
+    }
+    return Bytes.equals(left.getQualifierArray(), left.getQualifierOffset(),
+      left.getQualifierLength(), buf, offset, length);
+  }
+
+  public static boolean matchingColumn(final Cell left, final byte[] fam, final int foffset,
+      final int flength, final byte[] qual, final int qoffset, final int qlength) {
+    if (!matchingFamily(left, fam, foffset, flength)) return false;
+    return matchingQualifier(left, qual, qoffset, qlength);
+  }
+
+  public static boolean matchingValue(final Cell left, final Cell right, int lvlength,
+      int rvlength) {
+    if (left instanceof ByteBufferCell && right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
+        ((ByteBufferCell) left).getValuePosition(), lvlength,
+        ((ByteBufferCell) right).getValueByteBuffer(), ((ByteBufferCell) right).getValuePosition(),
+        rvlength);
+    }
+    if (left instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) left).getValueByteBuffer(),
+        ((ByteBufferCell) left).getValuePosition(), lvlength, right.getValueArray(),
+        right.getValueOffset(), rvlength);
+    }
+    if (right instanceof ByteBufferCell) {
+      return ByteBufferUtils.equals(((ByteBufferCell) right).getValueByteBuffer(),
+        ((ByteBufferCell) right).getValuePosition(), rvlength, left.getValueArray(),
+        left.getValueOffset(), lvlength);
+    }
+    return Bytes.equals(left.getValueArray(), left.getValueOffset(), lvlength,
+      right.getValueArray(), right.getValueOffset(), rvlength);
+  }
+
+  public static boolean matchingType(Cell a, Cell b) {
+    return a.getTypeByte() == b.getTypeByte();
+  }
+
+  /**
+   * @return True if a delete type, a {@link KeyValue.Type#Delete} or a {KeyValue.Type#DeleteFamily}
+   *         or a {@link KeyValue.Type#DeleteColumn} KeyValue type.
+   */
+  public static boolean isDelete(final byte type) {
+    return Type.Delete.getCode() <= type && type <= Type.DeleteFamily.getCode();
+  }
+
+  /**
+   * @return True if this cell is a {@link KeyValue.Type#Delete} type.
+   */
+  public static boolean isDeleteType(Cell cell) {
+    return cell.getTypeByte() == Type.Delete.getCode();
+  }
+
+  public static boolean isDeleteFamily(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteFamily.getCode();
+  }
+
+  public static boolean isDeleteFamilyVersion(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteFamilyVersion.getCode();
+  }
+
+  public static boolean isDeleteColumns(final Cell cell) {
+    return cell.getTypeByte() == Type.DeleteColumn.getCode();
+  }
+
+  public static boolean isDeleteColumnVersion(final Cell cell) {
+    return cell.getTypeByte() == Type.Delete.getCode();
+  }
+
+  /**
+   * @return True if this cell is a delete family or column type.
+   */
+  public static boolean isDeleteColumnOrFamily(Cell cell) {
+    int t = cell.getTypeByte();
+    return t == Type.DeleteColumn.getCode() || t == Type.DeleteFamily.getCode();
+  }
+
+  private static Iterator<Tag> tagsIterator(final ByteBuffer tags, final int offset,
+      final int length) {
+    return new Iterator<Tag>() {
+      private int pos = offset;
+      private int endOffset = offset + length - 1;
+
+      @Override
+      public boolean hasNext() {
+        return this.pos < endOffset;
+      }
+
+      @Override
+      public Tag next() {
+        if (hasNext()) {
+          int curTagLen = ByteBufferUtils.readAsInt(tags, this.pos, Tag.TAG_LENGTH_SIZE);
+          Tag tag = new ByteBufferTag(tags, pos, curTagLen + Tag.TAG_LENGTH_SIZE);
+          this.pos += Bytes.SIZEOF_SHORT + curTagLen;
+          return tag;
+        }
+        return null;
+      }
+
+      @Override
+      public void remove() {
+        throw new UnsupportedOperationException();
+      }
+    };
+  }
+
+  /**
+   * Util method to iterate through the tags in the given cell.
+   * @param cell The Cell over which tags iterator is needed.
+   * @return iterator for the tags
+   */
+  public static Iterator<Tag> tagsIterator(final Cell cell) {
+    final int tagsLength = cell.getTagsLength();
+    // Save an object allocation where we can
+    if (tagsLength == 0) {
+      return TagUtil.EMPTY_TAGS_ITR;
+    }
+    if (cell instanceof ByteBufferCell) {
+      return tagsIterator(((ByteBufferCell) cell).getTagsByteBuffer(),
+        ((ByteBufferCell) cell).getTagsPosition(), tagsLength);
+    }
+    return tagsIterator(cell.getTagsArray(), cell.getTagsOffset(), cell.getTagsLength());
+  }
+
+  private static Iterator<Tag> tagsIterator(final byte[] tags, final int offset, final int length) {
+    return new Iterator<Tag>() {
+      private int pos = offset;
+      private int endOffset = offset + length - 1;
+
+      @Override
+      public boolean hasNext() {
+        return this.pos < endOffset;
+      }
+
+      @Override
+      public Tag next() {
+        if (hasNext()) {
+          int curTagLen = Bytes.readAsInt(tags, this.pos, Tag.TAG_LENGTH_SIZE);
+          Tag tag = new ArrayBackedTag(tags, pos, curTagLen + TAG_LENGTH_SIZE);
+          this.pos += Bytes.SIZEOF_SHORT + curTagLen;
+          return tag;
+        }
+        return null;
+      }
+
+      @Override
+      public void remove() {
+        throw new UnsupportedOperationException();
+      }
+    };
+  }
+
+  /**
+   * @param cell The Cell
+   * @return Tags in the given Cell as a List
+   */
+  public static List<Tag> getTags(Cell cell) {
+    List<Tag> tags = new ArrayList<>();
+    Iterator<Tag> tagsItr = tagsIterator(cell);
+    while (tagsItr.hasNext()) {
+      tags.add(tagsItr.next());
+    }
+    return tags;
+  }
+
+  /**
+   * Retrieve Cell's first tag, matching the passed in type
+   * @param cell The Cell
+   * @param type Type of the Tag to retrieve
+   * @return null if there is no tag of the passed in tag type
+   */
+  public static Tag getTag(Cell cell, byte type) {
+    boolean bufferBacked = cell instanceof ByteBufferCell;
+    int length = cell.getTagsLength();
+    int offset = bufferBacked ? ((ByteBufferCell) cell).getTagsPosition() : cell.getTagsOffset();
+    int pos = offset;
+    while (pos < offset + length) {
+      int tagLen;
+      if (bufferBacked) {
+        ByteBuffer tagsBuffer = ((ByteBufferCell) cell).getTagsByteBuffer();
+        tagLen = ByteBufferUtils.readAsInt(tagsBuffer, pos, TAG_LENGTH_SIZE);
+        if (ByteBufferUtils.toByte(tagsBuffer, pos + TAG_LENGTH_SIZE) == type) {
+          return new ByteBufferTag(tagsBuffer, pos, tagLen + TAG_LENGTH_SIZE);
+        }
+      } else {
+        tagLen = Bytes.readAsInt(cell.getTagsArray(), pos, TAG_LENGTH_SIZE);
+        if (cell.getTagsArray()[pos + TAG_LENGTH_SIZE] == type) {
+          return new ArrayBackedTag(cell.getTagsArray(), pos, tagLen + TAG_LENGTH_SIZE);
+        }
+      }
+      pos += TAG_LENGTH_SIZE + tagLen;
+    }
+    return null;
+  }
+
+  /**
+   * Returns true if the first range start1...end1 overlaps with the second range start2...end2,
+   * assuming the byte arrays represent row keys
+   */
+  public static boolean overlappingKeys(final byte[] start1, final byte[] end1, final byte[] start2,
+      final byte[] end2) {
+    return (end2.length == 0 || start1.length == 0 || Bytes.compareTo(start1, end2) < 0)
+        && (end1.length == 0 || start2.length == 0 || Bytes.compareTo(start2, end1) < 0);
+  }
+
+  /**
+   * Write rowkey excluding the common part.
+   * @param cell
+   * @param rLen
+   * @param commonPrefix
+   * @param out
+   * @throws IOException
+   */
+  public static void writeRowKeyExcludingCommon(Cell cell, short rLen, int commonPrefix,
+      DataOutputStream out) throws IOException {
+    if (commonPrefix == 0) {
+      out.writeShort(rLen);
+    } else if (commonPrefix == 1) {
+      out.writeByte((byte) rLen);
+      commonPrefix--;
+    } else {
+      commonPrefix -= KeyValue.ROW_LENGTH_SIZE;
+    }
+    if (rLen > commonPrefix) {
+      writeRowSkippingBytes(out, cell, rLen, commonPrefix);
+    }
+  }
+
+  /**
+   * Writes the row from the given cell to the output stream excluding the common prefix
+   * @param out The dataoutputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param rlength the row length
+   * @throws IOException
+   */
+  public static void writeRowSkippingBytes(DataOutputStream out, Cell cell, short rlength,
+      int commonPrefix) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream((DataOutput) out,
+        ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition() + commonPrefix, rlength - commonPrefix);
+    } else {
+      out.write(cell.getRowArray(), cell.getRowOffset() + commonPrefix, rlength - commonPrefix);
+    }
+  }
+
+  /**
+   * Find length of common prefix in keys of the cells, considering key as byte[] if serialized in
+   * {@link KeyValue}. The key format is &lt;2 bytes rk len&gt;&lt;rk&gt;&lt;1 byte cf
+   * len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes timestamp&gt;&lt;1 byte type&gt;
+   * @param c1 the cell
+   * @param c2 the cell
+   * @param bypassFamilyCheck when true assume the family bytes same in both cells. Pass it as true
+   *          when dealing with Cells in same CF so as to avoid some checks
+   * @param withTsType when true check timestamp and type bytes also.
+   * @return length of common prefix
+   */
+  public static int findCommonPrefixInFlatKey(Cell c1, Cell c2, boolean bypassFamilyCheck,
+      boolean withTsType) {
+    // Compare the 2 bytes in RK length part
+    short rLen1 = c1.getRowLength();
+    short rLen2 = c2.getRowLength();
+    int commonPrefix = KeyValue.ROW_LENGTH_SIZE;
+    if (rLen1 != rLen2) {
+      // early out when the RK length itself is not matching
+      return ByteBufferUtils.findCommonPrefix(Bytes.toBytes(rLen1), 0, KeyValue.ROW_LENGTH_SIZE,
+        Bytes.toBytes(rLen2), 0, KeyValue.ROW_LENGTH_SIZE);
+    }
+    // Compare the RKs
+    int rkCommonPrefix = 0;
+    if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
+      rkCommonPrefix = ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getRowByteBuffer(),
+        ((ByteBufferCell) c1).getRowPosition(), rLen1, ((ByteBufferCell) c2).getRowByteBuffer(),
+        ((ByteBufferCell) c2).getRowPosition(), rLen2);
+    } else {
+      // There cannot be a case where one cell is BBCell and other is KeyValue. This flow comes
+      // either
+      // in flush or compactions. In flushes both cells are KV and in case of compaction it will be
+      // either
+      // KV or BBCell
+      rkCommonPrefix = ByteBufferUtils.findCommonPrefix(c1.getRowArray(), c1.getRowOffset(), rLen1,
+        c2.getRowArray(), c2.getRowOffset(), rLen2);
+    }
+    commonPrefix += rkCommonPrefix;
+    if (rkCommonPrefix != rLen1) {
+      // Early out when RK is not fully matching.
+      return commonPrefix;
+    }
+    // Compare 1 byte CF length part
+    byte fLen1 = c1.getFamilyLength();
+    if (bypassFamilyCheck) {
+      // This flag will be true when caller is sure that the family will be same for both the cells
+      // Just make commonPrefix to increment by the family part
+      commonPrefix += KeyValue.FAMILY_LENGTH_SIZE + fLen1;
+    } else {
+      byte fLen2 = c2.getFamilyLength();
+      if (fLen1 != fLen2) {
+        // early out when the CF length itself is not matching
+        return commonPrefix;
+      }
+      // CF lengths are same so there is one more byte common in key part
+      commonPrefix += KeyValue.FAMILY_LENGTH_SIZE;
+      // Compare the CF names
+      int fCommonPrefix;
+      if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
+        fCommonPrefix = ByteBufferUtils.findCommonPrefix(
+          ((ByteBufferCell) c1).getFamilyByteBuffer(), ((ByteBufferCell) c1).getFamilyPosition(),
+          fLen1, ((ByteBufferCell) c2).getFamilyByteBuffer(),
+          ((ByteBufferCell) c2).getFamilyPosition(), fLen2);
+      } else {
+        fCommonPrefix = ByteBufferUtils.findCommonPrefix(c1.getFamilyArray(), c1.getFamilyOffset(),
+          fLen1, c2.getFamilyArray(), c2.getFamilyOffset(), fLen2);
+      }
+      commonPrefix += fCommonPrefix;
+      if (fCommonPrefix != fLen1) {
+        return commonPrefix;
+      }
+    }
+    // Compare the Qualifiers
+    int qLen1 = c1.getQualifierLength();
+    int qLen2 = c2.getQualifierLength();
+    int qCommon;
+    if (c1 instanceof ByteBufferCell && c2 instanceof ByteBufferCell) {
+      qCommon = ByteBufferUtils.findCommonPrefix(((ByteBufferCell) c1).getQualifierByteBuffer(),
+        ((ByteBufferCell) c1).getQualifierPosition(), qLen1,
+        ((ByteBufferCell) c2).getQualifierByteBuffer(),
+        ((ByteBufferCell) c2).getQualifierPosition(), qLen2);
+    } else {
+      qCommon = ByteBufferUtils.findCommonPrefix(c1.getQualifierArray(), c1.getQualifierOffset(),
+        qLen1, c2.getQualifierArray(), c2.getQualifierOffset(), qLen2);
+    }
+    commonPrefix += qCommon;
+    if (!withTsType || Math.max(qLen1, qLen2) != qCommon) {
+      return commonPrefix;
+    }
+    // Compare the timestamp parts
+    int tsCommonPrefix = ByteBufferUtils.findCommonPrefix(Bytes.toBytes(c1.getTimestamp()), 0,
+      KeyValue.TIMESTAMP_SIZE, Bytes.toBytes(c2.getTimestamp()), 0, KeyValue.TIMESTAMP_SIZE);
+    commonPrefix += tsCommonPrefix;
+    if (tsCommonPrefix != KeyValue.TIMESTAMP_SIZE) {
+      return commonPrefix;
+    }
+    // Compare the type
+    if (c1.getTypeByte() == c2.getTypeByte()) {
+      commonPrefix += KeyValue.TYPE_SIZE;
+    }
+    return commonPrefix;
+  }
+
+  /**
+   * Used to compare two cells based on the column hint provided. This is specifically used when we
+   * need to optimize the seeks based on the next indexed key. This is an advanced usage API
+   * specifically needed for some optimizations.
+   * @param nextIndexedCell the next indexed cell
+   * @param currentCell the cell to be compared
+   * @param foff the family offset of the currentCell
+   * @param flen the family length of the currentCell
+   * @param colHint the column hint provided - could be null
+   * @param coff the offset of the column hint if provided, if not offset of the currentCell's
+   *          qualifier
+   * @param clen the length of the column hint if provided, if not length of the currentCell's
+   *          qualifier
+   * @param ts the timestamp to be seeked
+   * @param type the type to be seeked
+   * @return an int based on the given column hint TODO : To be moved out of here because this is a
+   *         special API used in scan optimization.
+   */
+  // compare a key against row/fam/qual/ts/type
+  public static final int compareKeyBasedOnColHint(CellComparator comparator, Cell nextIndexedCell,
+      Cell currentCell, int foff, int flen, byte[] colHint, int coff, int clen, long ts,
+      byte type) {
+    int compare = comparator.compareRows(nextIndexedCell, currentCell);
+    if (compare != 0) {
+      return compare;
+    }
+    // If the column is not specified, the "minimum" key type appears the
+    // latest in the sorted order, regardless of the timestamp. This is used
+    // for specifying the last key/value in a given row, because there is no
+    // "lexicographically last column" (it would be infinitely long). The
+    // "maximum" key type does not need this behavior.
+    if (nextIndexedCell.getFamilyLength() + nextIndexedCell.getQualifierLength() == 0
+        && nextIndexedCell.getTypeByte() == Type.Minimum.getCode()) {
+      // left is "bigger", i.e. it appears later in the sorted order
+      return 1;
+    }
+    if (flen + clen == 0 && type == Type.Minimum.getCode()) {
+      return -1;
+    }
+
+    compare = comparator.compareFamilies(nextIndexedCell, currentCell);
+    if (compare != 0) {
+      return compare;
+    }
+    if (colHint == null) {
+      compare = comparator.compareQualifiers(nextIndexedCell, currentCell);
+    } else {
+      compare = CellUtil.compareQualifiers(nextIndexedCell, colHint, coff, clen);
+    }
+    if (compare != 0) {
+      return compare;
+    }
+    // Next compare timestamps.
+    compare = comparator.compareTimestamps(nextIndexedCell.getTimestamp(), ts);
+    if (compare != 0) {
+      return compare;
+    }
+
+    // Compare types. Let the delete types sort ahead of puts; i.e. types
+    // of higher numbers sort before those of lesser numbers. Maximum (255)
+    // appears ahead of everything, and minimum (0) appears after
+    // everything.
+    return (0xff & type) - (0xff & nextIndexedCell.getTypeByte());
+  }
+
+  /**
+   * Compares only the key portion of a cell. It does not include the sequence id/mvcc of the cell
+   * @param left
+   * @param right
+   * @return an int greater than 0 if left &gt; than right lesser than 0 if left &lt; than right
+   *         equal to 0 if left is equal to right
+   */
+  public static final int compareKeyIgnoresMvcc(CellComparator comparator, Cell left, Cell right) {
+    return ((CellComparatorImpl) comparator).compare(left, right, true);
+  }
+
+  /**
+   * Compare cell's row against given comparator
+   * @param cell
+   * @param comparator
+   * @return result comparing cell's row
+   */
+  public static int compareRow(Cell cell, ByteArrayComparable comparator) {
+    if (cell instanceof ByteBufferCell) {
+      return comparator.compareTo(((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength());
+    }
+    return comparator.compareTo(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
+  }
+
+  /**
+   * Compare cell's column family against given comparator
+   * @param cell
+   * @param comparator
+   * @return result comparing cell's column family
+   */
+  public static int compareFamily(Cell cell, ByteArrayComparable comparator) {
+    if (cell instanceof ByteBufferCell) {
+      return comparator.compareTo(((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength());
+    }
+    return comparator.compareTo(cell.getFamilyArray(), cell.getFamilyOffset(),
+      cell.getFamilyLength());
+  }
+
+  /**
+   * Compare cell's qualifier against given comparator
+   * @param cell
+   * @param comparator
+   * @return result comparing cell's qualifier
+   */
+  public static int compareQualifier(Cell cell, ByteArrayComparable comparator) {
+    if (cell instanceof ByteBufferCell) {
+      return comparator.compareTo(((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
+    }
+    return comparator.compareTo(cell.getQualifierArray(), cell.getQualifierOffset(),
+      cell.getQualifierLength());
+  }
+
+  /**
+   * Compare cell's value against given comparator
+   * @param cell
+   * @param comparator
+   * @return result comparing cell's value
+   */
+  public static int compareValue(Cell cell, ByteArrayComparable comparator) {
+    if (cell instanceof ByteBufferCell) {
+      return comparator.compareTo(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition(), cell.getValueLength());
+    }
+    return comparator.compareTo(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
+  }
+
+  /**
+   * These cells are used in reseeks/seeks to improve the read performance. They are not real cells
+   * that are returned back to the clients
+   */
+  private static abstract class EmptyCell implements Cell, SettableSequenceId {
+
+    @Override
+    public void setSequenceId(long seqId) {
+      // Fake cells don't need seqId, so leaving it as a noop.
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return EMPTY_BYTE_ARRAY;
+    }
+
+    @Override
+    public int getRowOffset() {
+      return 0;
+    }
+
+    @Override
+    public short getRowLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return EMPTY_BYTE_ARRAY;
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return 0;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return EMPTY_BYTE_ARRAY;
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return 0;
+    }
+
+    @Override
+    public long getSequenceId() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return EMPTY_BYTE_ARRAY;
+    }
+
+    @Override
+    public int getValueOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getValueLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getTagsArray() {
+      return EMPTY_BYTE_ARRAY;
+    }
+
+    @Override
+    public int getTagsOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getTagsLength() {
+      return 0;
+    }
+  }
+
+  /**
+   * These cells are used in reseeks/seeks to improve the read performance. They are not real cells
+   * that are returned back to the clients
+   */
+  private static abstract class EmptyByteBufferCell extends ByteBufferCell
+      implements SettableSequenceId {
+
+    @Override
+    public void setSequenceId(long seqId) {
+      // Fake cells don't need seqId, so leaving it as a noop.
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return CellUtil.cloneRow(this);
+    }
+
+    @Override
+    public int getRowOffset() {
+      return 0;
+    }
+
+    @Override
+    public short getRowLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return CellUtil.cloneFamily(this);
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return 0;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return CellUtil.cloneQualifier(this);
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return 0;
+    }
+
+    @Override
+    public long getSequenceId() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getValueArray() {
+      return CellUtil.cloneValue(this);
+    }
+
+    @Override
+    public int getValueOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getValueLength() {
+      return 0;
+    }
+
+    @Override
+    public byte[] getTagsArray() {
+      return CellUtil.cloneTags(this);
+    }
+
+    @Override
+    public int getTagsOffset() {
+      return 0;
+    }
+
+    @Override
+    public int getTagsLength() {
+      return 0;
+    }
+
+    @Override
+    public ByteBuffer getRowByteBuffer() {
+      return HConstants.EMPTY_BYTE_BUFFER;
+    }
+
+    @Override
+    public int getRowPosition() {
+      return 0;
+    }
+
+    @Override
+    public ByteBuffer getFamilyByteBuffer() {
+      return HConstants.EMPTY_BYTE_BUFFER;
+    }
+
+    @Override
+    public int getFamilyPosition() {
+      return 0;
+    }
+
+    @Override
+    public ByteBuffer getQualifierByteBuffer() {
+      return HConstants.EMPTY_BYTE_BUFFER;
+    }
+
+    @Override
+    public int getQualifierPosition() {
+      return 0;
+    }
+
+    @Override
+    public ByteBuffer getTagsByteBuffer() {
+      return HConstants.EMPTY_BYTE_BUFFER;
+    }
+
+    @Override
+    public int getTagsPosition() {
+      return 0;
+    }
+
+    @Override
+    public ByteBuffer getValueByteBuffer() {
+      return HConstants.EMPTY_BYTE_BUFFER;
+    }
+
+    @Override
+    public int getValuePosition() {
+      return 0;
+    }
+  }
+
+  private static class FirstOnRowCell extends EmptyCell {
+    private final byte[] rowArray;
+    private final int roffset;
+    private final short rlength;
+
+    public FirstOnRowCell(final byte[] row, int roffset, short rlength) {
+      this.rowArray = row;
+      this.roffset = roffset;
+      this.rlength = rlength;
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return this.rowArray;
+    }
+
+    @Override
+    public int getRowOffset() {
+      return this.roffset;
+    }
+
+    @Override
+    public short getRowLength() {
+      return this.rlength;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return HConstants.LATEST_TIMESTAMP;
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return Type.Maximum.getCode();
+    }
+  }
+
+  private static class FirstOnRowByteBufferCell extends EmptyByteBufferCell {
+    private final ByteBuffer rowBuff;
+    private final int roffset;
+    private final short rlength;
+
+    public FirstOnRowByteBufferCell(final ByteBuffer row, int roffset, short rlength) {
+      this.rowBuff = row;
+      this.roffset = roffset;
+      this.rlength = rlength;
+    }
+
+    @Override
+    public ByteBuffer getRowByteBuffer() {
+      return this.rowBuff;
+    }
+
+    @Override
+    public int getRowPosition() {
+      return this.roffset;
+    }
+
+    @Override
+    public short getRowLength() {
+      return this.rlength;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return HConstants.LATEST_TIMESTAMP;
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return Type.Maximum.getCode();
+    }
+  }
+
+  private static class LastOnRowByteBufferCell extends EmptyByteBufferCell {
+    private final ByteBuffer rowBuff;
+    private final int roffset;
+    private final short rlength;
+
+    public LastOnRowByteBufferCell(final ByteBuffer row, int roffset, short rlength) {
+      this.rowBuff = row;
+      this.roffset = roffset;
+      this.rlength = rlength;
+    }
+
+    @Override
+    public ByteBuffer getRowByteBuffer() {
+      return this.rowBuff;
+    }
+
+    @Override
+    public int getRowPosition() {
+      return this.roffset;
+    }
+
+    @Override
+    public short getRowLength() {
+      return this.rlength;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return HConstants.OLDEST_TIMESTAMP;
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return Type.Minimum.getCode();
+    }
+  }
+
+  private static class FirstOnRowColByteBufferCell extends FirstOnRowByteBufferCell {
+    private final ByteBuffer famBuff;
+    private final int famOffset;
+    private final byte famLength;
+    private final ByteBuffer colBuff;
+    private final int colOffset;
+    private final int colLength;
+
+    public FirstOnRowColByteBufferCell(final ByteBuffer row, int roffset, short rlength,
+        final ByteBuffer famBuff, final int famOffset, final byte famLength, final ByteBuffer col,
+        final int colOffset, final int colLength) {
+      super(row, roffset, rlength);
+      this.famBuff = famBuff;
+      this.famOffset = famOffset;
+      this.famLength = famLength;
+      this.colBuff = col;
+      this.colOffset = colOffset;
+      this.colLength = colLength;
+    }
+
+    @Override
+    public ByteBuffer getFamilyByteBuffer() {
+      return this.famBuff;
+    }
+
+    @Override
+    public int getFamilyPosition() {
+      return this.famOffset;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return famLength;
+    }
+
+    @Override
+    public ByteBuffer getQualifierByteBuffer() {
+      return this.colBuff;
+    }
+
+    @Override
+    public int getQualifierPosition() {
+      return this.colOffset;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return this.colLength;
+    }
+  }
+
+  private static class FirstOnRowColCell extends FirstOnRowCell {
+    private final byte[] fArray;
+    private final int foffset;
+    private final byte flength;
+    private final byte[] qArray;
+    private final int qoffset;
+    private final int qlength;
+
+    public FirstOnRowColCell(byte[] rArray, int roffset, short rlength, byte[] fArray, int foffset,
+        byte flength, byte[] qArray, int qoffset, int qlength) {
+      super(rArray, roffset, rlength);
+      this.fArray = fArray;
+      this.foffset = foffset;
+      this.flength = flength;
+      this.qArray = qArray;
+      this.qoffset = qoffset;
+      this.qlength = qlength;
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return this.fArray;
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return this.foffset;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return this.flength;
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return this.qArray;
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return this.qoffset;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return this.qlength;
+    }
+  }
+
+  private static class FirstOnRowColTSCell extends FirstOnRowColCell {
+
+    private long ts;
+
+    public FirstOnRowColTSCell(byte[] rArray, int roffset, short rlength, byte[] fArray,
+        int foffset, byte flength, byte[] qArray, int qoffset, int qlength, long ts) {
+      super(rArray, roffset, rlength, fArray, foffset, flength, qArray, qoffset, qlength);
+      this.ts = ts;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return this.ts;
+    }
+  }
+
+  private static class FirstOnRowColTSByteBufferCell extends FirstOnRowColByteBufferCell {
+
+    private long ts;
+
+    public FirstOnRowColTSByteBufferCell(ByteBuffer rBuffer, int roffset, short rlength,
+        ByteBuffer fBuffer, int foffset, byte flength, ByteBuffer qBuffer, int qoffset, int qlength,
+        long ts) {
+      super(rBuffer, roffset, rlength, fBuffer, foffset, flength, qBuffer, qoffset, qlength);
+      this.ts = ts;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return this.ts;
+    }
+  }
+
+  private static class LastOnRowCell extends EmptyCell {
+    private final byte[] rowArray;
+    private final int roffset;
+    private final short rlength;
+
+    public LastOnRowCell(byte[] row, int roffset, short rlength) {
+      this.rowArray = row;
+      this.roffset = roffset;
+      this.rlength = rlength;
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return this.rowArray;
+    }
+
+    @Override
+    public int getRowOffset() {
+      return this.roffset;
+    }
+
+    @Override
+    public short getRowLength() {
+      return this.rlength;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return HConstants.OLDEST_TIMESTAMP;
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return Type.Minimum.getCode();
+    }
+  }
+
+  private static class LastOnRowColCell extends LastOnRowCell {
+    private final byte[] fArray;
+    private final int foffset;
+    private final byte flength;
+    private final byte[] qArray;
+    private final int qoffset;
+    private final int qlength;
+
+    public LastOnRowColCell(byte[] rArray, int roffset, short rlength, byte[] fArray, int foffset,
+        byte flength, byte[] qArray, int qoffset, int qlength) {
+      super(rArray, roffset, rlength);
+      this.fArray = fArray;
+      this.foffset = foffset;
+      this.flength = flength;
+      this.qArray = qArray;
+      this.qoffset = qoffset;
+      this.qlength = qlength;
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return this.fArray;
+    }
+
+    @Override
+    public int getFamilyOffset() {
+      return this.foffset;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return this.flength;
+    }
+
+    @Override
+    public byte[] getQualifierArray() {
+      return this.qArray;
+    }
+
+    @Override
+    public int getQualifierOffset() {
+      return this.qoffset;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return this.qlength;
+    }
+  }
+
+  private static class LastOnRowColByteBufferCell extends LastOnRowByteBufferCell {
+    private final ByteBuffer fBuffer;
+    private final int foffset;
+    private final byte flength;
+    private final ByteBuffer qBuffer;
+    private final int qoffset;
+    private final int qlength;
+
+    public LastOnRowColByteBufferCell(ByteBuffer rBuffer, int roffset, short rlength,
+        ByteBuffer fBuffer, int foffset, byte flength, ByteBuffer qBuffer, int qoffset,
+        int qlength) {
+      super(rBuffer, roffset, rlength);
+      this.fBuffer = fBuffer;
+      this.foffset = foffset;
+      this.flength = flength;
+      this.qBuffer = qBuffer;
+      this.qoffset = qoffset;
+      this.qlength = qlength;
+    }
+
+    @Override
+    public ByteBuffer getFamilyByteBuffer() {
+      return this.fBuffer;
+    }
+
+    @Override
+    public int getFamilyPosition() {
+      return this.foffset;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return this.flength;
+    }
+
+    @Override
+    public ByteBuffer getQualifierByteBuffer() {
+      return this.qBuffer;
+    }
+
+    @Override
+    public int getQualifierPosition() {
+      return this.qoffset;
+    }
+
+    @Override
+    public int getQualifierLength() {
+      return this.qlength;
+    }
+  }
+
+  private static class FirstOnRowDeleteFamilyCell extends EmptyCell {
+    private final byte[] row;
+    private final byte[] fam;
+
+    public FirstOnRowDeleteFamilyCell(byte[] row, byte[] fam) {
+      this.row = row;
+      this.fam = fam;
+    }
+
+    @Override
+    public byte[] getRowArray() {
+      return this.row;
+    }
+
+    @Override
+    public short getRowLength() {
+      return (short) this.row.length;
+    }
+
+    @Override
+    public byte[] getFamilyArray() {
+      return this.fam;
+    }
+
+    @Override
+    public byte getFamilyLength() {
+      return (byte) this.fam.length;
+    }
+
+    @Override
+    public long getTimestamp() {
+      return HConstants.LATEST_TIMESTAMP;
+    }
+
+    @Override
+    public byte getTypeByte() {
+      return Type.DeleteFamily.getCode();
+    }
+  }
+
+  /**
+   * Writes the Cell's key part as it would have serialized in a KeyValue. The format is &lt;2 bytes
+   * rk len&gt;&lt;rk&gt;&lt;1 byte cf len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes
+   * timestamp&gt;&lt;1 byte type&gt;
+   * @param cell
+   * @param out
+   * @throws IOException
+   */
+  public static void writeFlatKey(Cell cell, DataOutput out) throws IOException {
+    short rowLen = cell.getRowLength();
+    byte fLen = cell.getFamilyLength();
+    int qLen = cell.getQualifierLength();
+    // Using just one if/else loop instead of every time checking before writing every
+    // component of cell
+    if (cell instanceof ByteBufferCell) {
+      out.writeShort(rowLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), rowLen);
+      out.writeByte(fLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), fLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), qLen);
+    } else {
+      out.writeShort(rowLen);
+      out.write(cell.getRowArray(), cell.getRowOffset(), rowLen);
+      out.writeByte(fLen);
+      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), fLen);
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qLen);
+    }
+    out.writeLong(cell.getTimestamp());
+    out.writeByte(cell.getTypeByte());
+  }
+
+  /**
+   * Deep clones the given cell if the cell supports deep cloning
+   * @param cell the cell to be cloned
+   * @return the cloned cell
+   * @throws CloneNotSupportedException
+   */
+  public static Cell deepClone(Cell cell) throws CloneNotSupportedException {
+    if (cell instanceof ExtendedCell) {
+      return ((ExtendedCell) cell).deepClone();
+    }
+    throw new CloneNotSupportedException();
+  }
+
+  /**
+   * Writes the cell to the given OutputStream
+   * @param cell the cell to be written
+   * @param out the outputstream
+   * @param withTags if tags are to be written or not
+   * @return the total bytes written
+   * @throws IOException
+   */
+  public static int writeCell(Cell cell, OutputStream out, boolean withTags) throws IOException {
+    if (cell instanceof ExtendedCell) {
+      return ((ExtendedCell) cell).write(out, withTags);
+    } else {
+      ByteBufferUtils.putInt(out, estimatedSerializedSizeOfKey(cell));
+      ByteBufferUtils.putInt(out, cell.getValueLength());
+      writeFlatKey(cell, out);
+      writeValue(out, cell, cell.getValueLength());
+      int tagsLength = cell.getTagsLength();
+      if (withTags) {
+        byte[] len = new byte[Bytes.SIZEOF_SHORT];
+        Bytes.putAsShort(len, 0, tagsLength);
+        out.write(len);
+        if (tagsLength > 0) {
+          writeTags(out, cell, tagsLength);
+        }
+      }
+      int lenWritten = (2 * Bytes.SIZEOF_INT) + estimatedSerializedSizeOfKey(cell)
+          + cell.getValueLength();
+      if (withTags) {
+        lenWritten += Bytes.SIZEOF_SHORT + tagsLength;
+      }
+      return lenWritten;
+    }
+  }
+
+  /**
+   * Writes a cell to the buffer at the given offset
+   * @param cell the cell to be written
+   * @param buf the buffer to which the cell has to be wrriten
+   * @param offset the offset at which the cell should be written
+   */
+  public static void writeCellToBuffer(Cell cell, ByteBuffer buf, int offset) {
+    if (cell instanceof ExtendedCell) {
+      ((ExtendedCell) cell).write(buf, offset);
+    } else {
+      // Using the KVUtil
+      byte[] bytes = KeyValueUtil.copyToNewByteArray(cell);
+      ByteBufferUtils.copyFromArrayToBuffer(buf, offset, bytes, 0, bytes.length);
+    }
+  }
+
+  public static int writeFlatKey(Cell cell, OutputStream out) throws IOException {
+    short rowLen = cell.getRowLength();
+    byte fLen = cell.getFamilyLength();
+    int qLen = cell.getQualifierLength();
+    // Using just one if/else loop instead of every time checking before writing every
+    // component of cell
+    if (cell instanceof ByteBufferCell) {
+      StreamUtils.writeShort(out, rowLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), rowLen);
+      out.write(fLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), fLen);
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), qLen);
+    } else {
+      StreamUtils.writeShort(out, rowLen);
+      out.write(cell.getRowArray(), cell.getRowOffset(), rowLen);
+      out.write(fLen);
+      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), fLen);
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qLen);
+    }
+    StreamUtils.writeLong(out, cell.getTimestamp());
+    out.write(cell.getTypeByte());
+    return Bytes.SIZEOF_SHORT + rowLen + Bytes.SIZEOF_BYTE + fLen + qLen + Bytes.SIZEOF_LONG
+        + Bytes.SIZEOF_BYTE;
+  }
+
+  /**
+   * Sets the given seqId to the cell. Marked as audience Private as of 1.2.0. Setting a Cell
+   * sequenceid is an internal implementation detail not for general public use.
+   * @param cell
+   * @param seqId
+   * @throws IOException when the passed cell is not of type {@link SettableSequenceId}
+   */
+  public static void setSequenceId(Cell cell, long seqId) throws IOException {
+    if (cell instanceof SettableSequenceId) {
+      ((SettableSequenceId) cell).setSequenceId(seqId);
+    } else {
+      throw new IOException(new UnsupportedOperationException(
+          "Cell is not of type " + SettableSequenceId.class.getName()));
+    }
+  }
+
+  /**
+   * Sets the given timestamp to the cell.
+   * @param cell
+   * @param ts
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   */
+  public static void setTimestamp(Cell cell, long ts) throws IOException {
+    if (cell instanceof SettableTimestamp) {
+      ((SettableTimestamp) cell).setTimestamp(ts);
+    } else {
+      throw new IOException(new UnsupportedOperationException(
+          "Cell is not of type " + SettableTimestamp.class.getName()));
+    }
+  }
+
+  /**
+   * Sets the given timestamp to the cell.
+   * @param cell
+   * @param ts buffer containing the timestamp value
+   * @param tsOffset offset to the new timestamp
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   */
+  public static void setTimestamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
+    if (cell instanceof SettableTimestamp) {
+      ((SettableTimestamp) cell).setTimestamp(ts, tsOffset);
+    } else {
+      throw new IOException(new UnsupportedOperationException(
+          "Cell is not of type " + SettableTimestamp.class.getName()));
+    }
+  }
+
+  /**
+   * Sets the given timestamp to the cell iff current timestamp is
+   * {@link HConstants#LATEST_TIMESTAMP}.
+   * @param cell
+   * @param ts
+   * @return True if cell timestamp is modified.
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   */
+  public static boolean updateLatestStamp(Cell cell, long ts) throws IOException {
+    if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP) {
+      setTimestamp(cell, ts);
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Sets the given timestamp to the cell iff current timestamp is
+   * {@link HConstants#LATEST_TIMESTAMP}.
+   * @param cell
+   * @param ts buffer containing the timestamp value
+   * @param tsOffset offset to the new timestamp
+   * @return True if cell timestamp is modified.
+   * @throws IOException when the passed cell is not of type {@link SettableTimestamp}
+   */
+  public static boolean updateLatestStamp(Cell cell, byte[] ts, int tsOffset) throws IOException {
+    if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP) {
+      setTimestamp(cell, ts, tsOffset);
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Writes the row from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param rlength the row length
+   * @throws IOException
+   */
+  public static void writeRow(OutputStream out, Cell cell, short rlength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), rlength);
+    } else {
+      out.write(cell.getRowArray(), cell.getRowOffset(), rlength);
+    }
+  }
+
+  /**
+   * Writes the family from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param flength the family length
+   * @throws IOException
+   */
+  public static void writeFamily(OutputStream out, Cell cell, byte flength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), flength);
+    } else {
+      out.write(cell.getFamilyArray(), cell.getFamilyOffset(), flength);
+    }
+  }
+
+  /**
+   * Writes the qualifier from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param qlength the qualifier length
+   * @throws IOException
+   */
+  public static void writeQualifier(OutputStream out, Cell cell, int qlength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), qlength);
+    } else {
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset(), qlength);
+    }
+  }
+
+  /**
+   * Writes the qualifier from the given cell to the output stream excluding the common prefix
+   * @param out The dataoutputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param qlength the qualifier length
+   * @throws IOException
+   */
+  public static void writeQualifierSkippingBytes(DataOutputStream out, Cell cell, int qlength,
+      int commonPrefix) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream((DataOutput) out,
+        ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition() + commonPrefix, qlength - commonPrefix);
+    } else {
+      out.write(cell.getQualifierArray(), cell.getQualifierOffset() + commonPrefix,
+        qlength - commonPrefix);
+    }
+  }
+
+  /**
+   * Writes the value from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param vlength the value length
+   * @throws IOException
+   */
+  public static void writeValue(OutputStream out, Cell cell, int vlength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition(), vlength);
+    } else {
+      out.write(cell.getValueArray(), cell.getValueOffset(), vlength);
+    }
+  }
+
+  /**
+   * Writes the tag from the given cell to the output stream
+   * @param out The outputstream to which the data has to be written
+   * @param cell The cell whose contents has to be written
+   * @param tagsLength the tag length
+   * @throws IOException
+   */
+  public static void writeTags(OutputStream out, Cell cell, int tagsLength) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      ByteBufferUtils.copyBufferToStream(out, ((ByteBufferCell) cell).getTagsByteBuffer(),
+        ((ByteBufferCell) cell).getTagsPosition(), tagsLength);
+    } else {
+      out.write(cell.getTagsArray(), cell.getTagsOffset(), tagsLength);
+    }
+  }
+
+  /**
+   * special case for Cell.equals
+   */
+  public static boolean equalsIgnoreMvccVersion(Cell a, Cell b) {
+    // row
+    boolean res = CellUtil.matchingRows(a, b);
+    if (!res) return res;
+
+    // family
+    res = CellUtil.matchingColumn(a, b);
+    if (!res) return res;
+
+    // timestamp: later sorts first
+    if (!CellUtil.matchingTimestamp(a, b)) return false;
+
+    // type
+    int c = (0xff & b.getTypeByte()) - (0xff & a.getTypeByte());
+    if (c != 0) return false;
+    else return true;
+  }
+
+  /**
+   * Converts the rowkey bytes of the given cell into an int value
+   * @param cell
+   * @return rowkey as int
+   */
+  public static int getRowAsInt(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toInt(((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition());
+    }
+    return Bytes.toInt(cell.getRowArray(), cell.getRowOffset());
+  }
+
+  /**
+   * Converts the value bytes of the given cell into a long value
+   * @param cell
+   * @return value as long
+   */
+  public static long getValueAsLong(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toLong(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition());
+    }
+    return Bytes.toLong(cell.getValueArray(), cell.getValueOffset());
+  }
+
+  /**
+   * Converts the value bytes of the given cell into a int value
+   * @param cell
+   * @return value as int
+   */
+  public static int getValueAsInt(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toInt(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition());
+    }
+    return Bytes.toInt(cell.getValueArray(), cell.getValueOffset());
+  }
+
+  /**
+   * Converts the value bytes of the given cell into a double value
+   * @param cell
+   * @return value as double
+   */
+  public static double getValueAsDouble(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toDouble(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition());
+    }
+    return Bytes.toDouble(cell.getValueArray(), cell.getValueOffset());
+  }
+
+  /**
+   * Converts the value bytes of the given cell into a BigDecimal
+   * @param cell
+   * @return value as BigDecimal
+   */
+  public static BigDecimal getValueAsBigDecimal(Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return ByteBufferUtils.toBigDecimal(((ByteBufferCell) cell).getValueByteBuffer(),
+        ((ByteBufferCell) cell).getValuePosition(), cell.getValueLength());
+    }
+    return Bytes.toBigDecimal(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());
+  }
+
+  /**
+   * Compresses the tags to the given outputstream using the TagcompressionContext
+   * @param out the outputstream to which the compression should happen
+   * @param cell the cell which has tags
+   * @param tagCompressionContext the TagCompressionContext
+   * @throws IOException can throw IOException if the compression encounters issue
+   */
+  public static void compressTags(OutputStream out, Cell cell,
+      TagCompressionContext tagCompressionContext) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      tagCompressionContext.compressTags(out, ((ByteBufferCell) cell).getTagsByteBuffer(),
+        ((ByteBufferCell) cell).getTagsPosition(), cell.getTagsLength());
+    } else {
+      tagCompressionContext.compressTags(out, cell.getTagsArray(), cell.getTagsOffset(),
+        cell.getTagsLength());
+    }
+  }
+
+  public static void compressRow(OutputStream out, Cell cell, Dictionary dict) throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      Dictionary.write(out, ((ByteBufferCell) cell).getRowByteBuffer(),
+        ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(), dict);
+    } else {
+      Dictionary.write(out, cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(), dict);
+    }
+  }
+
+  public static void compressFamily(OutputStream out, Cell cell, Dictionary dict)
+      throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      Dictionary.write(out, ((ByteBufferCell) cell).getFamilyByteBuffer(),
+        ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(), dict);
+    } else {
+      Dictionary.write(out, cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
+        dict);
+    }
+  }
+
+  public static void compressQualifier(OutputStream out, Cell cell, Dictionary dict)
+      throws IOException {
+    if (cell instanceof ByteBufferCell) {
+      Dictionary.write(out, ((ByteBufferCell) cell).getQualifierByteBuffer(),
+        ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength(), dict);
+    } else {
+      Dictionary.write(out, cell.getQualifierArray(), cell.getQualifierOffset(),
+        cell.getQualifierLength(), dict);
+    }
+  }
+
+  /**
+   * Used when a cell needs to be compared with a key byte[] such as cases of finding the index from
+   * the index block, bloom keys from the bloom blocks This byte[] is expected to be serialized in
+   * the KeyValue serialization format If the KeyValue (Cell's) serialization format changes this
+   * method cannot be used.
+   * @param comparator the cell comparator
+   * @param left the cell to be compared
+   * @param key the serialized key part of a KeyValue
+   * @param offset the offset in the key byte[]
+   * @param length the length of the key byte[]
+   * @return an int greater than 0 if left is greater than right lesser than 0 if left is lesser
+   *         than right equal to 0 if left is equal to right
+   */
+  @VisibleForTesting
+  public static final int compare(CellComparator comparator, Cell left, byte[] key, int offset,
+      int length) {
+    // row
+    short rrowlength = Bytes.toShort(key, offset);
+    int c = comparator.compareRows(left, key, offset + Bytes.SIZEOF_SHORT, rrowlength);
+    if (c != 0) return c;
+
+    // Compare the rest of the two KVs without making any assumptions about
+    // the common prefix. This function will not compare rows anyway, so we
+    // don't need to tell it that the common prefix includes the row.
+    return compareWithoutRow(comparator, left, key, offset, length, rrowlength);
+  }
+
+  /**
+   * Compare columnFamily, qualifier, timestamp, and key type (everything except the row). This
+   * method is used both in the normal comparator and the "same-prefix" comparator. Note that we are
+   * assuming that row portions of both KVs have already been parsed and found identical, and we
+   * don't validate that assumption here.
+   * @param commonPrefix the length of the common prefix of the two key-values being compared,
+   *          including row length and row
+   */
+  static final int compareWithoutRow(CellComparator comparator, Cell left, byte[] right,
+      int roffset, int rlength, short rowlength) {
+    /***
+     * KeyValue Format and commonLength:
+     * |_keyLen_|_valLen_|_rowLen_|_rowKey_|_famiLen_|_fami_|_Quali_|....
+     * ------------------|-------commonLength--------|--------------
+     */
+    int commonLength = KeyValue.ROW_LENGTH_SIZE + KeyValue.FAMILY_LENGTH_SIZE + rowlength;
+
+    // commonLength + TIMESTAMP_TYPE_SIZE
+    int commonLengthWithTSAndType = KeyValue.TIMESTAMP_TYPE_SIZE + commonLength;
+    // ColumnFamily + Qualifier length.
+    int lcolumnlength = left.getFamilyLength() + left.getQualifierLength();
+    int rcolumnlength = rlength - commonLengthWithTSAndType;
+
+    byte ltype = left.getTypeByte();
+    byte rtype = right[roffset + (rlength - 1)];
+
+    // If the column is not specified, the "minimum" key type appears the
+    // latest in the sorted order, regardless of the timestamp. This is used
+    // for specifying the last key/value in a given row, because there is no
+    // "lexicographically last column" (it would be infinitely long). The
+    // "maximum" key type does not need this behavior.
+    if (lcolumnlength == 0 && ltype == Type.Minimum.getCode()) {
+      // left is "bigger", i.e. it appears later in the sorted order
+      return 1;
+    }
+    if (rcolumnlength == 0 && rtype == Type.Minimum.getCode()) {
+      return -1;
+    }
+
+    int rfamilyoffset = commonLength + roffset;
+
+    // Column family length.
+    int lfamilylength = left.getFamilyLength();
+    int rfamilylength = right[rfamilyoffset - 1];
+    // If left family size is not equal to right family size, we need not
+    // compare the qualifiers.
+    boolean sameFamilySize = (lfamilylength == rfamilylength);
+    if (!sameFamilySize) {
+      // comparing column family is enough.
+      return CellUtil.compareFamilies(left, right, rfamilyoffset, rfamilylength);
+    }
+    // Compare family & qualifier together.
+    // Families are same. Compare on qualifiers.
+    int comparison = CellUtil.compareColumns(left, right, rfamilyoffset, rfamilylength,
+      rfamilyoffset + rfamilylength, (rcolumnlength - rfamilylength));
+    if (comparison != 0) {
+      return comparison;
+    }
+
+    // //
+    // Next compare timestamps.
+    long rtimestamp = Bytes.toLong(right, roffset + (rlength - KeyValue.TIMESTAMP_TYPE_SIZE));
+    int compare = comparator.compareTimestamps(left.getTimestamp(), rtimestamp);
+    if (compare != 0) {
+      return compare;
+    }
+
+    // Compare types. Let the delete types sort ahead of puts; i.e. types
+    // of higher numbers sort before those of lesser numbers. Maximum (255)
+    // appears ahead of everything, and minimum (0) appears after
+    // everything.
+    return (0xff & rtype) - (0xff & ltype);
+  }
+
+  /**
+   * @return An new cell is located following input cell. If both of type and timestamp are minimum,
+   *         the input cell will be returned directly.
+   */
+  public static Cell createNextOnRowCol(Cell cell) {
+    long ts = cell.getTimestamp();
+    byte type = cell.getTypeByte();
+    if (type != Type.Minimum.getCode()) {
+      type = KeyValue.Type.values()[KeyValue.Type.codeToType(type).ordinal() - 1].getCode();
+    } else if (ts != HConstants.OLDEST_TIMESTAMP) {
+      ts = ts - 1;
+      type = Type.Maximum.getCode();
+    } else {
+      return cell;
+    }
+    return createNextOnRowCol(cell, ts, type);
+  }
+
+  static Cell createNextOnRowCol(Cell cell, long ts, byte type) {
+    if (cell instanceof ByteBufferCell) {
+      return new LastOnRowColByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength(), ((ByteBufferCell) cell).getFamilyByteBuffer(),
+          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
+          ((ByteBufferCell) cell).getQualifierByteBuffer(),
+          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength()) {
+        @Override
+        public long getTimestamp() {
+          return ts;
+        }
+
+        @Override
+        public byte getTypeByte() {
+          return type;
+        }
+      };
+    }
+    return new LastOnRowColCell(cell.getRowArray(), cell.getRowOffset(),
+        cell.getRowLength(), cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
+        cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength()) {
+      @Override
+      public long getTimestamp() {
+        return ts;
+      }
+
+      @Override
+      public byte getTypeByte() {
+        return type;
+      }
+    };
+  }
+
+  /**
+   * Estimate based on keyvalue's serialization format in the RPC layer. Note that there is an extra
+   * SIZEOF_INT added to the size here that indicates the actual length of the cell for cases where
+   * cell's are serialized in a contiguous format (For eg in RPCs).
+   * @param cell
+   * @return Estimate of the <code>cell</code> size in bytes plus an extra SIZEOF_INT indicating the
+   *         actual cell length.
+   */
+  public static int estimatedSerializedSizeOf(final Cell cell) {
+    if (cell instanceof ExtendedCell) {
+      return ((ExtendedCell) cell).getSerializedSize(true) + Bytes.SIZEOF_INT;
+    }
+
+    return getSumOfCellElementLengths(cell) +
+    // Use the KeyValue's infrastructure size presuming that another implementation would have
+    // same basic cost.
+        KeyValue.ROW_LENGTH_SIZE + KeyValue.FAMILY_LENGTH_SIZE +
+        // Serialization is probably preceded by a length (it is in the KeyValueCodec at least).
+        Bytes.SIZEOF_INT;
+  }
+
+  /**
+   * @param cell
+   * @return Sum of the lengths of all the elements in a Cell; does not count in any infrastructure
+   */
+  private static int getSumOfCellElementLengths(final Cell cell) {
+    return getSumOfCellKeyElementLengths(cell) + cell.getValueLength() + cell.getTagsLength();
+  }
+
+  /**
+   * @param cell
+   * @return Sum of all elements that make up a key; does not include infrastructure, tags or
+   *         values.
+   */
+  private static int getSumOfCellKeyElementLengths(final Cell cell) {
+    return cell.getRowLength() + cell.getFamilyLength() + cell.getQualifierLength()
+        + KeyValue.TIMESTAMP_TYPE_SIZE;
+  }
+
+  /**
+   * Calculates the serialized key size. We always serialize in the KeyValue's serialization format.
+   * @param cell the cell for which the key size has to be calculated.
+   * @return the key size
+   */
+  public static int estimatedSerializedSizeOfKey(final Cell cell) {
+    if (cell instanceof KeyValue) return ((KeyValue) cell).getKeyLength();
+    return cell.getRowLength() + cell.getFamilyLength() + cell.getQualifierLength()
+        + KeyValue.KEY_INFRASTRUCTURE_SIZE;
+  }
+
+  /**
+   * This is an estimate of the heap space occupied by a cell. When the cell is of type
+   * {@link HeapSize} we call {@link HeapSize#heapSize()} so cell can give a correct value. In other
+   * cases we just consider the bytes occupied by the cell components ie. row, CF, qualifier,
+   * timestamp, type, value and tags.
+   * @param cell
+   * @return estimate of the heap space
+   */
+  public static long estimatedHeapSizeOf(final Cell cell) {
+    if (cell instanceof HeapSize) {
+      return ((HeapSize) cell).heapSize();
+    }
+    // TODO: Add sizing of references that hold the row, family, etc., arrays.
+    return estimatedSerializedSizeOf(cell);
+  }
+
+  /**
+   * This method exists just to encapsulate how we serialize keys. To be replaced by a factory that
+   * we query to figure what the Cell implementation is and then, what serialization engine to use
+   * and further, how to serialize the key for inclusion in hfile index. TODO.
+   * @param cell
+   * @return The key portion of the Cell serialized in the old-school KeyValue way or null if passed
+   *         a null <code>cell</code>
+   */
+  public static byte[] getCellKeySerializedAsKeyValueKey(final Cell cell) {
+    if (cell == null) return null;
+    byte[] b = new byte[KeyValueUtil.keyLength(cell)];
+    KeyValueUtil.appendKeyTo(cell, b, 0);
+    return b;
+  }
+
+  /**
+   * Create a Cell that is smaller than all other possible Cells for the given Cell's row.
+   * @param cell
+   * @return First possible Cell on passed Cell's row.
+   */
+  public static Cell createFirstOnRow(final Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return new FirstOnRowByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength());
+    }
+    return new FirstOnRowCell(cell.getRowArray(), cell.getRowOffset(),
+        cell.getRowLength());
+  }
+
+  public static Cell createFirstOnRow(final byte[] row, int roffset, short rlength) {
+    return new FirstOnRowCell(row, roffset, rlength);
+  }
+
+  public static Cell createFirstOnRow(final byte[] row, final byte[] family, final byte[] col) {
+    return createFirstOnRow(row, 0, (short) row.length, family, 0, (byte) family.length, col, 0,
+      col.length);
+  }
+
+  public static Cell createFirstOnRow(final byte[] row, int roffset, short rlength,
+      final byte[] family, int foffset, byte flength, final byte[] col, int coffset, int clength) {
+    return new FirstOnRowColCell(row, roffset, rlength, family, foffset, flength, col, coffset,
+        clength);
+  }
+
+  public static Cell createFirstOnRow(final byte[] row) {
+    return createFirstOnRow(row, 0, (short) row.length);
+  }
+
+  public static Cell createFirstOnRowFamily(Cell cell, byte[] fArray, int foff, int flen) {
+    if (cell instanceof ByteBufferCell) {
+      return new FirstOnRowColByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength(), ByteBuffer.wrap(fArray), foff, (byte) flen,
+          HConstants.EMPTY_BYTE_BUFFER, 0, 0);
+    }
+    return new FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(),
+        fArray, foff, (byte) flen, HConstants.EMPTY_BYTE_ARRAY, 0, 0);
+  }
+
+  public static Cell createFirstOnRowCol(final Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return new FirstOnRowColByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength(), HConstants.EMPTY_BYTE_BUFFER, 0, (byte) 0,
+          ((ByteBufferCell) cell).getQualifierByteBuffer(),
+          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
+    }
+    return new FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(),
+        HConstants.EMPTY_BYTE_ARRAY, 0, (byte) 0, cell.getQualifierArray(),
+        cell.getQualifierOffset(), cell.getQualifierLength());
+  }
+
+  public static Cell createFirstOnNextRow(final Cell cell) {
+    byte[] nextRow = new byte[cell.getRowLength() + 1];
+    CellUtil.copyRowTo(cell, nextRow, 0);
+    nextRow[nextRow.length - 1] = 0;// maybe not necessary
+    return new FirstOnRowCell(nextRow, 0, (short) nextRow.length);
+  }
+
+  /**
+   * Create a Cell that is smaller than all other possible Cells for the given Cell's rk:cf and
+   * passed qualifier.
+   * @param cell
+   * @param qArray
+   * @param qoffest
+   * @param qlength
+   * @return Last possible Cell on passed Cell's rk:cf and passed qualifier.
+   */
+  public static Cell createFirstOnRowCol(final Cell cell, byte[] qArray, int qoffest, int qlength) {
+    if (cell instanceof ByteBufferCell) {
+      return new FirstOnRowColByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength(), ((ByteBufferCell) cell).getFamilyByteBuffer(),
+          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
+          ByteBuffer.wrap(qArray), qoffest, qlength);
+    }
+    return new FirstOnRowColCell(cell.getRowArray(), cell.getRowOffset(),
+        cell.getRowLength(), cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
+        qArray, qoffest, qlength);
+  }
+
+  /**
+   * Creates the first cell with the row/family/qualifier of this cell and the given timestamp. Uses
+   * the "maximum" type that guarantees that the new cell is the lowest possible for this
+   * combination of row, family, qualifier, and timestamp. This cell's own timestamp is ignored.
+   * @param cell - cell
+   * @param ts
+   */
+  public static Cell createFirstOnRowColTS(Cell cell, long ts) {
+    if (cell instanceof ByteBufferCell) {
+      return new FirstOnRowColTSByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
+          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
+          ((ByteBufferCell) cell).getFamilyByteBuffer(),
+          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
+          ((ByteBufferCell) cell).getQualifierByteBuffer(),
+          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength(), ts);
+    }
+    return new FirstOnRowColTSCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(),
+        cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
+        cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength(), ts);
+  }
+
+  /**
+   * Create a Cell that is larger than all other possible Cells for the given Cell's row.
+   * @param cell
+   * @return Last possible Cell on passed Cell's row.
+   */
+  public static Cell createLastOnRow(final Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return new LastOnRowByteBufferCell(
+          ((ByteBufferCell) cell).getRowByteBuffer(), ((ByteBufferCell) cell).getRowPosition(),
+          cell.getRowLength());
+    }
+    return new LastOnRowCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());
+  }
+
+  public static Cell createLastOnRow(final byte[] row) {
+    return new LastOnRowCell(row, 0, (short) row.length);
+  }
+
+  /**
+   * Create a Cell that is larger than all other possible Cells for the given Cell's rk:cf:q. Used
+   * in creating "fake keys" for the multi-column Bloom filter optimization to skip the row/column
+   * we already know is not in the file.
+   * @param cell
+   * @return Last possible Cell on passed Cell's rk:cf:q.
+   */
+  public static Cell createLastOnRowCol(final Cell cell) {
+    if (cell instanceof ByteBufferCell) {
+      return new LastOnRowColByteBufferCell(((ByteBufferCell) cell).getRowByteBuffer(),
+          ((ByteBufferCell) cell).getRowPosition(), cell.getRowLength(),
+          ((ByteBufferCell) cell).getFamilyByteBuffer(),
+          ((ByteBufferCell) cell).getFamilyPosition(), cell.getFamilyLength(),
+          ((ByteBufferCell) cell).getQualifierByteBuffer(),
+          ((ByteBufferCell) cell).getQualifierPosition(), cell.getQualifierLength());
+    }
+    return new LastOnRowColCell(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength(),
+        cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength(),
+        cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());
+  }
+
+  /**
+   * Create a Delete Family Cell for the specified row and family that would be smaller than all
+   * other possible Delete Family KeyValues that have the same row and family. Used for seeking.
+   * @param row - row key (arbitrary byte array)
+   * @param fam - family name
+   * @return First Delete Family possible key on passed <code>row</code>.
+   */
+  public static Cell createFirstDeleteFamilyCellOnRow(final byte[] row, final byte[] fam) {
+    return new FirstOnRowDeleteFamilyCell(row, fam);
+  }
+
+}
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/TagUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/TagUtil.java
index 0f010a0..a4962f4 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/TagUtil.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/TagUtil.java
@@ -232,7 +232,7 @@ public final class TagUtil {
    * Add to <code>tagsOrNull</code> any Tags <code>cell</code> is carrying or null if none.
    */
   public static List<Tag> carryForwardTags(final List<Tag> tagsOrNull, final Cell cell) {
-    Iterator<Tag> itr = CellUtil.tagsIterator(cell);
+    Iterator<Tag> itr = PrivateCellUtil.tagsIterator(cell);
     if (itr == EMPTY_TAGS_ITR) {
       // If no Tags, return early.
       return tagsOrNull;
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java
index ec3bfd5..76e5c9b 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java
@@ -29,6 +29,7 @@ import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.ExtendedCell;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.KeyValueUtil;
@@ -749,7 +750,7 @@ abstract class BufferedDataBlockEncoder extends AbstractDataBlockEncoder {
     @Override
     public int compareKey(CellComparator comparator, Cell key) {
       keyOnlyKV.setKey(current.keyBuffer, 0, current.keyLength);
-      return CellUtil.compareKeyIgnoresMvcc(comparator, key, keyOnlyKV);
+      return PrivateCellUtil.compareKeyIgnoresMvcc(comparator, key, keyOnlyKV);
     }
 
     @Override
@@ -1027,9 +1028,9 @@ abstract class BufferedDataBlockEncoder extends AbstractDataBlockEncoder {
         // the tags using Dictionary compression in such a case
         if (tagCompressionContext != null) {
           // Not passing tagsLength considering that parsing of the tagsLength is not costly
-          CellUtil.compressTags(out, cell, tagCompressionContext);
+          PrivateCellUtil.compressTags(out, cell, tagCompressionContext);
         } else {
-          CellUtil.writeTags(out, cell, tagsLength);
+          PrivateCellUtil.writeTags(out, cell, tagsLength);
         }
       }
       size += tagsLength + KeyValue.TAGS_LENGTH_SIZE;
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java
index bd644c1..6762bb8 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/DiffKeyDeltaEncoder.java
@@ -23,7 +23,7 @@ import java.nio.ByteBuffer;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -229,11 +229,11 @@ public class DiffKeyDeltaEncoder extends BufferedDataBlockEncoder {
       // put column family
       byte familyLength = cell.getFamilyLength();
       out.write(familyLength);
-      CellUtil.writeFamily(out, cell, familyLength);
+      PrivateCellUtil.writeFamily(out, cell, familyLength);
     } else {
       // Finding common prefix
       int preKeyLength = KeyValueUtil.keyLength(prevCell);
-      commonPrefix = CellUtil.findCommonPrefixInFlatKey(cell, prevCell, true, false);
+      commonPrefix = PrivateCellUtil.findCommonPrefixInFlatKey(cell, prevCell, true, false);
       if (kLength == preKeyLength) {
         flag |= FLAG_SAME_KEY_LENGTH;
       }
@@ -281,8 +281,8 @@ public class DiffKeyDeltaEncoder extends BufferedDataBlockEncoder {
     if (commonPrefix < rLen + KeyValue.ROW_LENGTH_SIZE) {
       // Previous and current rows are different. Copy the differing part of
       // the row, skip the column family, and copy the qualifier.
-      CellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
-      CellUtil.writeQualifier(out, cell, cell.getQualifierLength());
+      PrivateCellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
+      PrivateCellUtil.writeQualifier(out, cell, cell.getQualifierLength());
     } else {
       // The common part includes the whole row. As the column family is the
       // same across the whole file, it will automatically be included in the
@@ -290,7 +290,7 @@ public class DiffKeyDeltaEncoder extends BufferedDataBlockEncoder {
       // What we write here is the non common part of the qualifier
       int commonQualPrefix = commonPrefix - (rLen + KeyValue.ROW_LENGTH_SIZE)
           - (cell.getFamilyLength() + KeyValue.FAMILY_LENGTH_SIZE);
-      CellUtil.writeQualifierSkippingBytes(out, cell, cell.getQualifierLength(),
+      PrivateCellUtil.writeQualifierSkippingBytes(out, cell, cell.getQualifierLength(),
         commonQualPrefix);
     }
     if ((flag & FLAG_TIMESTAMP_IS_DIFF) == 0) {
@@ -302,7 +302,7 @@ public class DiffKeyDeltaEncoder extends BufferedDataBlockEncoder {
     if ((flag & FLAG_SAME_TYPE) == 0) {
       out.write(cell.getTypeByte());
     }
-    CellUtil.writeValue(out, cell, vLength);
+    PrivateCellUtil.writeValue(out, cell, vLength);
     return kLength + vLength + KeyValue.KEYVALUE_INFRASTRUCTURE_SIZE;
   }
 
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java
index 03cf768..a337776 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/FastDiffDeltaEncoder.java
@@ -24,7 +24,7 @@ import java.nio.ByteBuffer;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -263,14 +263,14 @@ public class FastDiffDeltaEncoder extends BufferedDataBlockEncoder {
       ByteBufferUtils.putCompressedInt(out, kLength);
       ByteBufferUtils.putCompressedInt(out, vLength);
       ByteBufferUtils.putCompressedInt(out, 0);
-      CellUtil.writeFlatKey(cell, (DataOutput)out);
+      PrivateCellUtil.writeFlatKey(cell, (DataOutput)out);
       // Write the value part
-      CellUtil.writeValue(out, cell, cell.getValueLength());
+      PrivateCellUtil.writeValue(out, cell, cell.getValueLength());
     } else {
       int preKeyLength = KeyValueUtil.keyLength(prevCell);
       int preValLength = prevCell.getValueLength();
       // find a common prefix and skip it
-      int commonPrefix = CellUtil.findCommonPrefixInFlatKey(cell, prevCell, true, false);
+      int commonPrefix = PrivateCellUtil.findCommonPrefixInFlatKey(cell, prevCell, true, false);
 
       if (kLength == preKeyLength) {
         flag |= FLAG_SAME_KEY_LENGTH;
@@ -291,7 +291,7 @@ public class FastDiffDeltaEncoder extends BufferedDataBlockEncoder {
       // Check if current and previous values are the same. Compare value
       // length first as an optimization.
       if (vLength == preValLength
-          && CellUtil.matchingValue(cell, prevCell, vLength, preValLength)) {
+          && PrivateCellUtil.matchingValue(cell, prevCell, vLength, preValLength)) {
         flag |= FLAG_SAME_VALUE;
       }
 
@@ -307,8 +307,8 @@ public class FastDiffDeltaEncoder extends BufferedDataBlockEncoder {
       if (commonPrefix < rLen + KeyValue.ROW_LENGTH_SIZE) {
         // Previous and current rows are different. Copy the differing part of
         // the row, skip the column family, and copy the qualifier.
-        CellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
-        CellUtil.writeQualifier(out, cell, cell.getQualifierLength());
+        PrivateCellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
+        PrivateCellUtil.writeQualifier(out, cell, cell.getQualifierLength());
       } else {
         // The common part includes the whole row. As the column family is the
         // same across the whole file, it will automatically be included in the
@@ -316,7 +316,7 @@ public class FastDiffDeltaEncoder extends BufferedDataBlockEncoder {
         // What we write here is the non common part of the qualifier
         int commonQualPrefix = commonPrefix - (rLen + KeyValue.ROW_LENGTH_SIZE)
             - (cell.getFamilyLength() + KeyValue.FAMILY_LENGTH_SIZE);
-        CellUtil.writeQualifierSkippingBytes(out, cell, cell.getQualifierLength(),
+        PrivateCellUtil.writeQualifierSkippingBytes(out, cell, cell.getQualifierLength(),
           commonQualPrefix);
       }
       // Write non common ts part
@@ -329,7 +329,7 @@ public class FastDiffDeltaEncoder extends BufferedDataBlockEncoder {
 
       // Write the value if it is not the same as before.
       if ((flag & FLAG_SAME_VALUE) == 0) {
-        CellUtil.writeValue(out, cell, vLength);
+        PrivateCellUtil.writeValue(out, cell, vLength);
       }
     }
     return kLength + vLength + KeyValue.KEYVALUE_INFRASTRUCTURE_SIZE;
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/NoneEncoder.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/NoneEncoder.java
index 56e0837..29b855a 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/NoneEncoder.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/NoneEncoder.java
@@ -22,7 +22,7 @@ import java.io.DataOutputStream;
 import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -50,7 +50,7 @@ public class NoneEncoder {
       int tagsLength = cell.getTagsLength();
       out.writeShort(tagsLength);
       if (tagsLength > 0) {
-        CellUtil.writeTags(out, cell, tagsLength);
+        PrivateCellUtil.writeTags(out, cell, tagsLength);
       }
       size += tagsLength + KeyValue.TAGS_LENGTH_SIZE;
     }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java
index 8edb305..a488e48 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/PrefixKeyDeltaEncoder.java
@@ -24,7 +24,7 @@ import java.nio.ByteBuffer;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -60,17 +60,17 @@ public class PrefixKeyDeltaEncoder extends BufferedDataBlockEncoder {
       ByteBufferUtils.putCompressedInt(out, klength);
       ByteBufferUtils.putCompressedInt(out, vlength);
       ByteBufferUtils.putCompressedInt(out, 0);
-      CellUtil.writeFlatKey(cell, (DataOutput)out);
+      PrivateCellUtil.writeFlatKey(cell, (DataOutput)out);
     } else {
       // find a common prefix and skip it
-      int common = CellUtil.findCommonPrefixInFlatKey(cell, state.prevCell, true, true);
+      int common = PrivateCellUtil.findCommonPrefixInFlatKey(cell, state.prevCell, true, true);
       ByteBufferUtils.putCompressedInt(out, klength - common);
       ByteBufferUtils.putCompressedInt(out, vlength);
       ByteBufferUtils.putCompressedInt(out, common);
       writeKeyExcludingCommon(cell, common, out);
     }
     // Write the value part
-    CellUtil.writeValue(out, cell, vlength);
+    PrivateCellUtil.writeValue(out, cell, vlength);
     int size = klength + vlength + KeyValue.KEYVALUE_INFRASTRUCTURE_SIZE;
     size += afterEncodingKeyValue(cell, out, encodingContext);
     state.prevCell = cell;
@@ -83,11 +83,11 @@ public class PrefixKeyDeltaEncoder extends BufferedDataBlockEncoder {
     if (commonPrefix < rLen + KeyValue.ROW_LENGTH_SIZE) {
       // Previous and current rows are different. Need to write the differing part followed by
       // cf,q,ts and type
-      CellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
+      PrivateCellUtil.writeRowKeyExcludingCommon(cell, rLen, commonPrefix, out);
       byte fLen = cell.getFamilyLength();
       out.writeByte(fLen);
-      CellUtil.writeFamily(out, cell, fLen);
-      CellUtil.writeQualifier(out, cell, cell.getQualifierLength());
+      PrivateCellUtil.writeFamily(out, cell, fLen);
+      PrivateCellUtil.writeQualifier(out, cell, cell.getQualifierLength());
       out.writeLong(cell.getTimestamp());
       out.writeByte(cell.getTypeByte());
     } else {
@@ -99,7 +99,7 @@ public class PrefixKeyDeltaEncoder extends BufferedDataBlockEncoder {
       int commonQualPrefix = Math.min(commonPrefix, qLen);
       int qualPartLenToWrite = qLen - commonQualPrefix;
       if (qualPartLenToWrite > 0) {
-        CellUtil.writeQualifierSkippingBytes(out, cell, qLen, commonQualPrefix);
+        PrivateCellUtil.writeQualifierSkippingBytes(out, cell, qLen, commonQualPrefix);
       }
       commonPrefix -= commonQualPrefix;
       // Common part in TS also?
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/RowIndexSeekerV1.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/RowIndexSeekerV1.java
index 8611b34..0ebcae0 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/RowIndexSeekerV1.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/RowIndexSeekerV1.java
@@ -24,6 +24,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.ByteBufferKeyValue;
 import org.apache.hadoop.hbase.SizeCachedKeyValue;
@@ -190,7 +191,7 @@ public class RowIndexSeekerV1 extends AbstractEncodedSeeker {
     }
     do {
       int comp;
-      comp = CellUtil.compareKeyIgnoresMvcc(comparator, seekCell, current.currentKey);
+      comp = PrivateCellUtil.compareKeyIgnoresMvcc(comparator, seekCell, current.currentKey);
       if (comp == 0) { // exact match
         if (seekBefore) {
           if (!previous.isValid()) {
@@ -244,7 +245,7 @@ public class RowIndexSeekerV1 extends AbstractEncodedSeeker {
 
   @Override
   public int compareKey(CellComparator comparator, Cell key) {
-    return CellUtil.compareKeyIgnoresMvcc(comparator, key, current.currentKey);
+    return PrivateCellUtil.compareKeyIgnoresMvcc(comparator, key, current.currentKey);
   }
 
   protected void decodeFirst() {
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowBloomHashKey.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowBloomHashKey.java
index 6007b92..2587ceb 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowBloomHashKey.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowBloomHashKey.java
@@ -19,6 +19,7 @@ package org.apache.hadoop.hbase.util;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 
 @InterfaceAudience.Private
@@ -30,7 +31,7 @@ public class RowBloomHashKey extends CellHashKey {
 
   @Override
   public byte get(int offset) {
-    return CellUtil.getRowByte(t, offset);
+    return PrivateCellUtil.getRowByte(t, offset);
   }
 
   @Override
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowColBloomHashKey.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowColBloomHashKey.java
index 82aba07..41260f4 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowColBloomHashKey.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/RowColBloomHashKey.java
@@ -19,6 +19,7 @@ package org.apache.hadoop.hbase.util;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.yetus.audience.InterfaceAudience;
 
@@ -57,7 +58,7 @@ public class RowColBloomHashKey extends CellHashKey {
     }
     int refLen = Bytes.SIZEOF_SHORT + rowLength;
     if (offset < refLen) {
-      return CellUtil.getRowByte(t, offset - Bytes.SIZEOF_SHORT);
+      return PrivateCellUtil.getRowByte(t, offset - Bytes.SIZEOF_SHORT);
     }
     if (offset == refLen) {
       // The fam length should return 0 assuming there is no column family.
@@ -67,7 +68,7 @@ public class RowColBloomHashKey extends CellHashKey {
     refLen += qualLength + Bytes.SIZEOF_BYTE;
     // skip the family len because actual cells may have family also
     if (offset < refLen) {
-      return CellUtil.getQualifierByte(t,
+      return PrivateCellUtil.getQualifierByte(t,
         offset - (Bytes.SIZEOF_SHORT + rowLength + Bytes.SIZEOF_BYTE));
     }
     // TODO : check if ts and type can be removed
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestByteBufferKeyValue.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestByteBufferKeyValue.java
index ff6c4f7..c5ce8de 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestByteBufferKeyValue.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestByteBufferKeyValue.java
@@ -166,9 +166,9 @@ public class TestByteBufferKeyValue {
     Tag tag2 = resTags.get(1);
     assertEquals(tag2.getType(), tag2.getType());
     assertEquals(TagUtil.getValueAsString(t2), TagUtil.getValueAsString(tag2));
-    Tag res = CellUtil.getTag(offheapKV, (byte) 2);
+    Tag res = PrivateCellUtil.getTag(offheapKV, (byte) 2);
     assertEquals(TagUtil.getValueAsString(t2), TagUtil.getValueAsString(tag2));
-    res = CellUtil.getTag(offheapKV, (byte) 3);
+    res = PrivateCellUtil.getTag(offheapKV, (byte) 3);
     assertNull(res);
   }
 
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java
index b4226ce..a6c9dd6 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java
@@ -72,23 +72,28 @@ public class TestCellComparator {
   public void testCompareCellWithKey() throws Exception {
     KeyValue kv1 = new KeyValue(row1, fam1, qual1, val);
     KeyValue kv2 = new KeyValue(row2, fam1, qual1, val);
-    assertTrue((CellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) < 0);
+    assertTrue(
+      (PrivateCellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) < 0);
 
     kv1 = new KeyValue(row1, fam2, qual1, val);
     kv2 = new KeyValue(row1, fam1, qual1, val);
-    assertTrue((CellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
+    assertTrue(
+      (PrivateCellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
 
     kv1 = new KeyValue(row1, fam1, qual1, 1l, val);
     kv2 = new KeyValue(row1, fam1, qual1, 2l, val);
-    assertTrue((CellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
+    assertTrue(
+      (PrivateCellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
 
     kv1 = new KeyValue(row1, fam1, qual1, 1l, Type.Put);
     kv2 = new KeyValue(row1, fam1, qual1, 1l, Type.Maximum);
-    assertTrue((CellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
+    assertTrue(
+      (PrivateCellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) > 0);
 
     kv1 = new KeyValue(row1, fam1, qual1, 1l, Type.Put);
     kv2 = new KeyValue(row1, fam1, qual1, 1l, Type.Put);
-    assertTrue((CellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) == 0);
+    assertTrue(
+      (PrivateCellUtil.compare(comparator, kv1, kv2.getKey(), 0, kv2.getKey().length)) == 0);
   }
 
   @Test
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellUtil.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellUtil.java
index 3bd1b66..397476f 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellUtil.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellUtil.java
@@ -23,7 +23,6 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
 import java.math.BigDecimal;
 import java.nio.ByteBuffer;
@@ -266,43 +265,43 @@ public class TestCellUtil {
     byte[] d = Bytes.toBytes("d");
 
     // overlaps
-    Assert.assertTrue(CellUtil.overlappingKeys(a, b, a, b));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, c, a, b));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, b, a, c));
-    Assert.assertTrue(CellUtil.overlappingKeys(b, c, a, c));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, c, b, c));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, d, b, c));
-    Assert.assertTrue(CellUtil.overlappingKeys(b, c, a, d));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(a, b, a, b));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(a, c, a, b));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(a, b, a, c));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(b, c, a, c));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(a, c, b, c));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(a, d, b, c));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(b, c, a, d));
 
-    Assert.assertTrue(CellUtil.overlappingKeys(empty, b, a, b));
-    Assert.assertTrue(CellUtil.overlappingKeys(empty, b, a, c));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(empty, b, a, b));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(empty, b, a, c));
 
-    Assert.assertTrue(CellUtil.overlappingKeys(a, b, empty, b));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, b, empty, c));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(a, b, empty, b));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(a, b, empty, c));
 
-    Assert.assertTrue(CellUtil.overlappingKeys(a, empty, a, b));
-    Assert.assertTrue(CellUtil.overlappingKeys(a, empty, a, c));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(a, empty, a, b));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(a, empty, a, c));
 
-    Assert.assertTrue(CellUtil.overlappingKeys(a, b, empty, empty));
-    Assert.assertTrue(CellUtil.overlappingKeys(empty, empty, a, b));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(a, b, empty, empty));
+    Assert.assertTrue(PrivateCellUtil.overlappingKeys(empty, empty, a, b));
 
     // non overlaps
-    Assert.assertFalse(CellUtil.overlappingKeys(a, b, c, d));
-    Assert.assertFalse(CellUtil.overlappingKeys(c, d, a, b));
-
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, c, d));
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, c, empty));
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, d, empty));
-    Assert.assertFalse(CellUtil.overlappingKeys(c, d, b, c));
-    Assert.assertFalse(CellUtil.overlappingKeys(c, empty, b, c));
-    Assert.assertFalse(CellUtil.overlappingKeys(d, empty, b, c));
-
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, a, b));
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, empty, b));
-    Assert.assertFalse(CellUtil.overlappingKeys(b, c, empty, a));
-    Assert.assertFalse(CellUtil.overlappingKeys(a,b, b, c));
-    Assert.assertFalse(CellUtil.overlappingKeys(empty, b, b, c));
-    Assert.assertFalse(CellUtil.overlappingKeys(empty, a, b, c));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(a, b, c, d));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(c, d, a, b));
+
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(b, c, c, d));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(b, c, c, empty));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(b, c, d, empty));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(c, d, b, c));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(c, empty, b, c));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(d, empty, b, c));
+
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(b, c, a, b));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(b, c, empty, b));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(b, c, empty, a));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(a,b, b, c));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(empty, b, b, c));
+    Assert.assertFalse(PrivateCellUtil.overlappingKeys(empty, a, b, c));
   }
 
   @Test
@@ -310,43 +309,43 @@ public class TestCellUtil {
     // The whole key matching case
     KeyValue kv1 = new KeyValue("r1".getBytes(), "f1".getBytes(), "q1".getBytes(), null);
     Assert.assertEquals(kv1.getKeyLength(),
-        CellUtil.findCommonPrefixInFlatKey(kv1, kv1, true, true));
+      PrivateCellUtil.findCommonPrefixInFlatKey(kv1, kv1, true, true));
     Assert.assertEquals(kv1.getKeyLength(),
-        CellUtil.findCommonPrefixInFlatKey(kv1, kv1, false, true));
+      PrivateCellUtil.findCommonPrefixInFlatKey(kv1, kv1, false, true));
     Assert.assertEquals(kv1.getKeyLength() - KeyValue.TIMESTAMP_TYPE_SIZE,
-        CellUtil.findCommonPrefixInFlatKey(kv1, kv1, true, false));
+      PrivateCellUtil.findCommonPrefixInFlatKey(kv1, kv1, true, false));
     // The rk length itself mismatch
     KeyValue kv2 = new KeyValue("r12".getBytes(), "f1".getBytes(), "q1".getBytes(), null);
-    Assert.assertEquals(1, CellUtil.findCommonPrefixInFlatKey(kv1, kv2, true, true));
+    Assert.assertEquals(1, PrivateCellUtil.findCommonPrefixInFlatKey(kv1, kv2, true, true));
     // part of rk is same
     KeyValue kv3 = new KeyValue("r14".getBytes(), "f1".getBytes(), "q1".getBytes(), null);
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + "r1".getBytes().length,
-        CellUtil.findCommonPrefixInFlatKey(kv2, kv3, true, true));
+      PrivateCellUtil.findCommonPrefixInFlatKey(kv2, kv3, true, true));
     // entire rk is same but different cf name
     KeyValue kv4 = new KeyValue("r14".getBytes(), "f2".getBytes(), "q1".getBytes(), null);
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + kv3.getRowLength() + KeyValue.FAMILY_LENGTH_SIZE
-        + "f".getBytes().length, CellUtil.findCommonPrefixInFlatKey(kv3, kv4, false, true));
+        + "f".getBytes().length, PrivateCellUtil.findCommonPrefixInFlatKey(kv3, kv4, false, true));
     // rk and family are same and part of qualifier
     KeyValue kv5 = new KeyValue("r14".getBytes(), "f2".getBytes(), "q123".getBytes(), null);
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + kv3.getRowLength() + KeyValue.FAMILY_LENGTH_SIZE
         + kv4.getFamilyLength() + kv4.getQualifierLength(),
-        CellUtil.findCommonPrefixInFlatKey(kv4, kv5, true, true));
+        PrivateCellUtil.findCommonPrefixInFlatKey(kv4, kv5, true, true));
     // rk, cf and q are same. ts differs
     KeyValue kv6 = new KeyValue("rk".getBytes(), 1234L);
     KeyValue kv7 = new KeyValue("rk".getBytes(), 1235L);
     // only last byte out of 8 ts bytes in ts part differs
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + kv6.getRowLength() + KeyValue.FAMILY_LENGTH_SIZE
         + kv6.getFamilyLength() + kv6.getQualifierLength() + 7,
-        CellUtil.findCommonPrefixInFlatKey(kv6, kv7, true, true));
+        PrivateCellUtil.findCommonPrefixInFlatKey(kv6, kv7, true, true));
     // rk, cf, q and ts are same. Only type differs
     KeyValue kv8 = new KeyValue("rk".getBytes(), 1234L, Type.Delete);
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + kv6.getRowLength() + KeyValue.FAMILY_LENGTH_SIZE
         + kv6.getFamilyLength() + kv6.getQualifierLength() + KeyValue.TIMESTAMP_SIZE,
-        CellUtil.findCommonPrefixInFlatKey(kv6, kv8, true, true));
+        PrivateCellUtil.findCommonPrefixInFlatKey(kv6, kv8, true, true));
     // With out TS_TYPE check
     Assert.assertEquals(KeyValue.ROW_LENGTH_SIZE + kv6.getRowLength() + KeyValue.FAMILY_LENGTH_SIZE
         + kv6.getFamilyLength() + kv6.getQualifierLength(),
-        CellUtil.findCommonPrefixInFlatKey(kv6, kv8, true, false));
+        PrivateCellUtil.findCommonPrefixInFlatKey(kv6, kv8, true, false));
   }
 
   /**
@@ -427,7 +426,7 @@ public class TestCellUtil {
     byte[] vDest = CellUtil.cloneValue(bbCell);
     assertTrue(Bytes.equals(v, vDest));
     byte[] tDest = new byte[tags.length];
-    CellUtil.copyTagTo(bbCell, tDest, 0);
+    PrivateCellUtil.copyTagsTo(bbCell, tDest, 0);
     assertTrue(Bytes.equals(tags, tDest));
   }
 
@@ -447,7 +446,7 @@ public class TestCellUtil {
     Cell bbCell2 = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
     assertTrue(CellUtil.matchingRows(bbCell1, bbCell2));
     assertTrue(CellUtil.matchingRows(kv, bbCell2));
-    assertTrue(CellUtil.matchingRow(bbCell1, r));
+    assertTrue(CellUtil.matchingRows(bbCell1, r));
     assertTrue(CellUtil.matchingFamily(bbCell1, bbCell2));
     assertTrue(CellUtil.matchingFamily(kv, bbCell2));
     assertTrue(CellUtil.matchingFamily(bbCell1, f));
@@ -475,20 +474,20 @@ public class TestCellUtil {
     KeyValue kv = new KeyValue(r, f, q, v);
     ByteBuffer buffer = ByteBuffer.wrap(kv.getBuffer());
     Cell bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertEquals(ri, CellUtil.getRowAsInt(bbCell));
-    assertEquals(vl, CellUtil.getValueAsLong(bbCell));
+    assertEquals(ri, PrivateCellUtil.getRowAsInt(bbCell));
+    assertEquals(vl, PrivateCellUtil.getValueAsLong(bbCell));
     double vd = 3005.5;
     v = Bytes.toBytes(vd);
     kv = new KeyValue(r, f, q, v);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertEquals(vd, CellUtil.getValueAsDouble(bbCell), 0.0);
+    assertEquals(vd, PrivateCellUtil.getValueAsDouble(bbCell), 0.0);
     BigDecimal bd = new BigDecimal(9999);
     v = Bytes.toBytes(bd);
     kv = new KeyValue(r, f, q, v);
     buffer = ByteBuffer.wrap(kv.getBuffer());
     bbCell = new ByteBufferKeyValue(buffer, 0, buffer.remaining());
-    assertEquals(bd, CellUtil.getValueAsBigDecimal(bbCell));
+    assertEquals(bd, PrivateCellUtil.getValueAsBigDecimal(bbCell));
   }
 
   @Test
@@ -502,7 +501,7 @@ public class TestCellUtil {
     KeyValue kv = new KeyValue(r, f, q1, 0, q1.length, 1234L, Type.Put, v, 0, v.length, tags);
     NonExtendedCell nonExtCell = new NonExtendedCell(kv);
     ByteArrayOutputStream os = new ByteArrayOutputStream();
-    int writeCell = CellUtil.writeCell(nonExtCell, os, true);
+    int writeCell = PrivateCellUtil.writeCell(nonExtCell, os, true);
     byte[] byteArray = os.toByteArray();
     KeyValue res = new KeyValue(byteArray);
     assertTrue(CellUtil.equals(kv, res));
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java
index b13a8d2..4ff4f05 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java
@@ -470,7 +470,7 @@ public class TestKeyValue extends TestCase {
     }
     assertTrue(meta1Ok);
     assertTrue(meta2Ok);
-    Iterator<Tag> tagItr = CellUtil.tagsIterator(kv);
+    Iterator<Tag> tagItr = PrivateCellUtil.tagsIterator(kv);
     //Iterator<Tag> tagItr = kv.tagsIterator();
     assertTrue(tagItr.hasNext());
     Tag next = tagItr.next();
@@ -484,7 +484,7 @@ public class TestKeyValue extends TestCase {
     Bytes.equals(TagUtil.cloneValue(next), metaValue2);
     assertFalse(tagItr.hasNext());
 
-    tagItr = CellUtil.tagsIterator(kv);
+    tagItr = PrivateCellUtil.tagsIterator(kv);
     assertTrue(tagItr.hasNext());
     next = tagItr.next();
     assertEquals(10, next.getValueLength());
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSerialization.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSerialization.java
index d26d11c..2e7e020 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSerialization.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSerialization.java
@@ -24,8 +24,7 @@ import java.io.InputStream;
 import java.io.OutputStream;
 
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
-import org.apache.hadoop.hbase.ExtendedCell;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.util.Bytes;
@@ -86,8 +85,8 @@ public class CellSerialization implements Serialization<Cell> {
 
     @Override
     public void serialize(Cell kv) throws IOException {
-      dos.writeInt(CellUtil.estimatedSerializedSizeOf(kv) - Bytes.SIZEOF_INT);
-      CellUtil.writeCell(kv, dos, true);
+      dos.writeInt(PrivateCellUtil.estimatedSerializedSizeOf(kv) - Bytes.SIZEOF_INT);
+      PrivateCellUtil.writeCell(kv, dos, true);
     }
   }
 }
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSortReducer.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSortReducer.java
index 5c2b41f..ed6b219 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSortReducer.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/CellSortReducer.java
@@ -23,7 +23,7 @@ import java.util.TreeSet;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.io.ImmutableBytesWritable;
 import org.apache.hadoop.hbase.util.MapReduceCell;
 import org.apache.hadoop.mapreduce.Reducer;
@@ -45,7 +45,7 @@ public class CellSortReducer
     TreeSet<Cell> map = new TreeSet<>(CellComparatorImpl.COMPARATOR);
     for (Cell kv : kvs) {
       try {
-        map.add(CellUtil.deepClone(kv));
+        map.add(PrivateCellUtil.deepClone(kv));
       } catch (CloneNotSupportedException e) {
         throw new IOException(e);
       }
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java
index e666f90..162939e 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/HFileOutputFormat2.java
@@ -51,8 +51,8 @@ import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionLocation;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
-import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.client.ColumnFamilyDescriptor;
 import org.apache.hadoop.hbase.client.ColumnFamilyDescriptorBuilder;
@@ -247,7 +247,7 @@ public class HFileOutputFormat2
         }
 
         byte[] rowKey = CellUtil.cloneRow(kv);
-        int length = (CellUtil.estimatedSerializedSizeOf(kv)) - Bytes.SIZEOF_INT;
+        int length = (PrivateCellUtil.estimatedSerializedSizeOf(kv)) - Bytes.SIZEOF_INT;
         byte[] family = CellUtil.cloneFamily(kv);
         byte[] tableNameBytes = null;
         if (writeMultipleTables) {
@@ -337,7 +337,7 @@ public class HFileOutputFormat2
 
         // we now have the proper WAL writer. full steam ahead
         // TODO : Currently in SettableTimeStamp but this will also move to ExtendedCell
-        CellUtil.updateLatestStamp(cell, this.now);
+        PrivateCellUtil.updateLatestStamp(cell, this.now);
         wl.writer.append(kv);
         wl.written += length;
 
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/Import.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/Import.java
index 3bb966a..f857d4b 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/Import.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/Import.java
@@ -43,6 +43,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.TableName;
@@ -133,9 +134,9 @@ public class Import extends Configured implements Tool {
 
     @Override
     public void write(DataOutput out) throws IOException {
-      out.writeInt(CellUtil.estimatedSerializedSizeOfKey(kv));
+      out.writeInt(PrivateCellUtil.estimatedSerializedSizeOfKey(kv));
       out.writeInt(0);
-      CellUtil.writeFlatKey(kv, out);
+      PrivateCellUtil.writeFlatKey(kv, out);
     }
 
     @Override
@@ -210,9 +211,8 @@ public class Import extends Configured implements Tool {
           LOG.trace("Considering the row."
               + Bytes.toString(row.get(), row.getOffset(), row.getLength()));
         }
-        if (filter == null
-            || !filter.filterRowKey(CellUtil.createFirstOnRow(row.get(), row.getOffset(),
-                (short) row.getLength()))) {
+        if (filter == null || !filter.filterRowKey(
+          PrivateCellUtil.createFirstOnRow(row.get(), row.getOffset(), (short) row.getLength()))) {
           for (Cell kv : value.rawCells()) {
             kv = filterKv(filter, kv);
             // skip if we filtered it out
@@ -276,7 +276,7 @@ public class Import extends Configured implements Tool {
               + Bytes.toString(row.get(), row.getOffset(), row.getLength()));
         }
         if (filter == null
-            || !filter.filterRowKey(CellUtil.createFirstOnRow(row.get(), row.getOffset(),
+            || !filter.filterRowKey(PrivateCellUtil.createFirstOnRow(row.get(), row.getOffset(),
                 (short) row.getLength()))) {
           for (Cell kv : value.rawCells()) {
             kv = filterKv(filter, kv);
@@ -332,7 +332,7 @@ public class Import extends Configured implements Tool {
             + Bytes.toString(key.get(), key.getOffset(), key.getLength()));
       }
       if (filter == null
-          || !filter.filterRowKey(CellUtil.createFirstOnRow(key.get(), key.getOffset(),
+          || !filter.filterRowKey(PrivateCellUtil.createFirstOnRow(key.get(), key.getOffset(),
               (short) key.getLength()))) {
         processKV(key, result, context, put, delete);
       }
@@ -354,7 +354,7 @@ public class Import extends Configured implements Tool {
          * submit multiple DeleteFamily tombstones in single Delete request then we are maintaining
          * only newest in hbase table and ignoring other. Check - HBASE-12065
          */
-        if (CellUtil.isDeleteFamily(kv)) {
+        if (PrivateCellUtil.isDeleteFamily(kv)) {
           Delete deleteFamily = new Delete(key.get());
           deleteFamily.add(kv);
           if (durability != null) {
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/TableSnapshotInputFormatImpl.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/TableSnapshotInputFormatImpl.java
index bcaa448..bee4926 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/TableSnapshotInputFormatImpl.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/TableSnapshotInputFormatImpl.java
@@ -25,10 +25,10 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HDFSBlocksDistribution;
 import org.apache.hadoop.hbase.HDFSBlocksDistribution.HostAndWeight;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.client.ClientSideRegionScanner;
 import org.apache.hadoop.hbase.client.IsolationLevel;
@@ -363,7 +363,7 @@ public class TableSnapshotInputFormatImpl {
       if (numSplits > 1) {
         byte[][] sp = sa.split(hri.getStartKey(), hri.getEndKey(), numSplits, true);
         for (int i = 0; i < sp.length - 1; i++) {
-          if (CellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(), sp[i],
+          if (PrivateCellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(), sp[i],
                   sp[i + 1])) {
             // compute HDFS locations from snapshot files (which will get the locations for
             // referred hfiles)
@@ -379,8 +379,8 @@ public class TableSnapshotInputFormatImpl {
           }
         }
       } else {
-        if (CellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(), hri.getStartKey(),
-                hri.getEndKey())) {
+        if (PrivateCellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(),
+          hri.getStartKey(), hri.getEndKey())) {
           // compute HDFS locations from snapshot files (which will get the locations for
           // referred hfiles)
           List<String> hosts = getBestLocations(conf,
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/WALPlayer.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/WALPlayer.java
index 1d106a2..15c33cb 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/WALPlayer.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/mapreduce/WALPlayer.java
@@ -166,7 +166,7 @@ public class WALPlayer extends Configured implements Tool {
               // Aggregate as much as possible into a single Put/Delete
               // operation before writing to the context.
               if (lastCell == null || lastCell.getTypeByte() != cell.getTypeByte()
-                  || !CellUtil.matchingRow(lastCell, cell)) {
+                  || !CellUtil.matchingRows(lastCell, cell)) {
                 // row or type changed, write out aggregate KVs.
                 if (put != null) {
                   context.write(tableOut, put);
diff --git a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/util/MapReduceCell.java b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/util/MapReduceCell.java
index c0f74a5..f3bac52 100644
--- a/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/util/MapReduceCell.java
+++ b/hbase-mapreduce/src/main/java/org/apache/hadoop/hbase/util/MapReduceCell.java
@@ -25,6 +25,7 @@ import org.apache.hadoop.hbase.ByteBufferCell;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.ExtendedCell;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 
 /**
@@ -226,43 +227,43 @@ public class MapReduceCell extends ByteBufferCell implements ExtendedCell {
 
   @Override
   public void setSequenceId(long seqId) throws IOException {
-    CellUtil.setSequenceId(cell, seqId);
+    PrivateCellUtil.setSequenceId(cell, seqId);
   }
 
   @Override
   public void setTimestamp(long ts) throws IOException {
-    CellUtil.setTimestamp(cell, ts);
+    PrivateCellUtil.setTimestamp(cell, ts);
   }
 
   @Override
   public void setTimestamp(byte[] ts, int tsOffset) throws IOException {
-    CellUtil.setTimestamp(cell, ts, tsOffset);
+    PrivateCellUtil.setTimestamp(cell, ts, tsOffset);
   }
 
   @Override
   public long heapSize() {
-    return CellUtil.estimatedHeapSizeOf(cell);
+    return PrivateCellUtil.estimatedHeapSizeOf(cell);
   }
 
   @Override
   public int write(OutputStream out, boolean withTags) throws IOException {
-    return CellUtil.writeCell(cell, out, withTags);
+    return PrivateCellUtil.writeCell(cell, out, withTags);
   }
 
   @Override
   public int getSerializedSize(boolean withTags) {
-    return CellUtil.estimatedSerializedSizeOf(cell) - Bytes.SIZEOF_INT;
+    return PrivateCellUtil.estimatedSerializedSizeOf(cell) - Bytes.SIZEOF_INT;
   }
 
   @Override
   public void write(ByteBuffer buf, int offset) {
-    CellUtil.writeCellToBuffer(cell, buf, offset);
+    PrivateCellUtil.writeCellToBuffer(cell, buf, offset);
   }
 
   @Override
   public ExtendedCell deepClone() {
     try {
-      return (ExtendedCell) CellUtil.deepClone(cell);
+      return (ExtendedCell) PrivateCellUtil.deepClone(cell);
     } catch (CloneNotSupportedException e) {
       throw new RuntimeException(e);
     }
diff --git a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestHFileOutputFormat2.java b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestHFileOutputFormat2.java
index 372737a..ffe3fe1 100644
--- a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestHFileOutputFormat2.java
+++ b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestHFileOutputFormat2.java
@@ -713,7 +713,7 @@ public class TestHFileOutputFormat2  {
             assertEquals(FAMILIES.length, res.rawCells().length);
             Cell first = res.rawCells()[0];
             for (Cell kv : res.rawCells()) {
-              assertTrue(CellUtil.matchingRow(first, kv));
+              assertTrue(CellUtil.matchingRows(first, kv));
               assertTrue(Bytes.equals(CellUtil.cloneValue(first), CellUtil.cloneValue(kv)));
             }
           }
diff --git a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java
index 861f180..062108d 100644
--- a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java
+++ b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java
@@ -45,6 +45,7 @@ import org.apache.hadoop.hbase.util.MapReduceCell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeepDeletedCells;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.TableName;
@@ -375,7 +376,7 @@ public class TestImportExport {
       ResultScanner scanner = t.getScanner(s);
       Result r = scanner.next();
       Cell[] res = r.rawCells();
-      assertTrue(CellUtil.isDeleteFamily(res[0]));
+      assertTrue(PrivateCellUtil.isDeleteFamily(res[0]));
       assertEquals(now+4, res[1].getTimestamp());
       assertEquals(now+3, res[2].getTimestamp());
       assertTrue(CellUtil.isDelete(res[3]));
diff --git a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTSVWithOperationAttributes.java b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTSVWithOperationAttributes.java
index 2fc287f..a47bef1 100644
--- a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTSVWithOperationAttributes.java
+++ b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTSVWithOperationAttributes.java
@@ -218,8 +218,8 @@ public class TestImportTSVWithOperationAttributes implements Configurable {
             LOG.debug("Getting results " + res.size());
             assertTrue(res.size() == 2);
             List<Cell> kvs = res.listCells();
-            assertTrue(CellUtil.matchingRow(kvs.get(0), Bytes.toBytes("KEY")));
-            assertTrue(CellUtil.matchingRow(kvs.get(1), Bytes.toBytes("KEY")));
+            assertTrue(CellUtil.matchingRows(kvs.get(0), Bytes.toBytes("KEY")));
+            assertTrue(CellUtil.matchingRows(kvs.get(1), Bytes.toBytes("KEY")));
             assertTrue(CellUtil.matchingValue(kvs.get(0), Bytes.toBytes("VALUE" + valueMultiplier)));
             assertTrue(CellUtil.matchingValue(kvs.get(1),
                 Bytes.toBytes("VALUE" + 2 * valueMultiplier)));
diff --git a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTSVWithVisibilityLabels.java b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTSVWithVisibilityLabels.java
index 8967ac7..4692847 100644
--- a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTSVWithVisibilityLabels.java
+++ b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTSVWithVisibilityLabels.java
@@ -448,8 +448,8 @@ public class TestImportTSVWithVisibilityLabels implements Configurable {
           LOG.debug("Getting results " + res.size());
           assertTrue(res.size() == 2);
           List<Cell> kvs = res.listCells();
-          assertTrue(CellUtil.matchingRow(kvs.get(0), Bytes.toBytes("KEY")));
-          assertTrue(CellUtil.matchingRow(kvs.get(1), Bytes.toBytes("KEY")));
+          assertTrue(CellUtil.matchingRows(kvs.get(0), Bytes.toBytes("KEY")));
+          assertTrue(CellUtil.matchingRows(kvs.get(1), Bytes.toBytes("KEY")));
           assertTrue(CellUtil.matchingValue(kvs.get(0), Bytes.toBytes("VALUE" + valueMultiplier)));
           assertTrue(CellUtil.matchingValue(kvs.get(1),
               Bytes.toBytes("VALUE" + 2 * valueMultiplier)));
diff --git a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTsv.java b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTsv.java
index 7b6e684..6ad7694 100644
--- a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTsv.java
+++ b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportTsv.java
@@ -480,8 +480,8 @@ public class TestImportTsv implements Configurable {
           numRows++;
           assertEquals(2, res.size());
           List<Cell> kvs = res.listCells();
-          assertTrue(CellUtil.matchingRow(kvs.get(0), Bytes.toBytes("KEY")));
-          assertTrue(CellUtil.matchingRow(kvs.get(1), Bytes.toBytes("KEY")));
+          assertTrue(CellUtil.matchingRows(kvs.get(0), Bytes.toBytes("KEY")));
+          assertTrue(CellUtil.matchingRows(kvs.get(1), Bytes.toBytes("KEY")));
           assertTrue(CellUtil.matchingValue(kvs.get(0), Bytes.toBytes("VALUE" + valueMultiplier)));
           assertTrue(CellUtil.matchingValue(kvs.get(1), Bytes.toBytes("VALUE" + 2 * valueMultiplier)));
           // Only one result set is expected, so let it loop.
diff --git a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestSyncTable.java b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestSyncTable.java
index 9a0c160..1e940d4 100644
--- a/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestSyncTable.java
+++ b/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/mapreduce/TestSyncTable.java
@@ -145,7 +145,7 @@ public class TestSyncTable {
         Cell sourceCell = sourceCells[j];
         Cell targetCell = targetCells[j];
         try {
-          if (!CellUtil.matchingRow(sourceCell, targetCell)) {
+          if (!CellUtil.matchingRows(sourceCell, targetCell)) {
             Assert.fail("Rows don't match");
           }
           if (!CellUtil.matchingFamily(sourceCell, targetCell)) {
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/PrefixTreeSeeker.java b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/PrefixTreeSeeker.java
index 4fbb8a6..b027eb1 100644
--- a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/PrefixTreeSeeker.java
+++ b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/PrefixTreeSeeker.java
@@ -24,6 +24,7 @@ import org.apache.hadoop.hbase.ByteBufferCell;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.SettableSequenceId;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -81,7 +82,7 @@ public class PrefixTreeSeeker implements EncodedSeeker {
 
   @Override
   public ByteBuffer getValueShallowCopy() {
-    return CellUtil.getValueBufferShallowCopy(ptSearcher.current());
+    return PrivateCellUtil.getValueBufferShallowCopy(ptSearcher.current());
   }
 
   /**
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArrayScanner.java b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArrayScanner.java
index 44d2852..7d6beab 100644
--- a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArrayScanner.java
+++ b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArrayScanner.java
@@ -22,6 +22,7 @@ import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellScanner;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.codec.prefixtree.PrefixTreeBlockMeta;
 import org.apache.hadoop.hbase.codec.prefixtree.decode.column.ColumnReader;
 import org.apache.hadoop.hbase.codec.prefixtree.decode.row.RowNodeReader;
@@ -420,7 +421,7 @@ public class PrefixTreeArrayScanner extends PrefixTreeCell implements CellScanne
 
   protected int populateNonRowFieldsAndCompareTo(int cellNum, Cell key) {
     populateNonRowFields(cellNum);
-    return CellUtil.compareKeyIgnoresMvcc(comparator, this, key);
+    return PrivateCellUtil.compareKeyIgnoresMvcc(comparator, this, key);
   }
 
   protected void populateFirstNonRowFields() {
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArraySearcher.java b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArraySearcher.java
index c993d12..7eb2517 100644
--- a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArraySearcher.java
+++ b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeArraySearcher.java
@@ -21,6 +21,7 @@ package org.apache.hadoop.hbase.codec.prefixtree.decode;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.codec.prefixtree.PrefixTreeBlockMeta;
 import org.apache.hadoop.hbase.codec.prefixtree.scanner.CellScannerPosition;
 import org.apache.hadoop.hbase.codec.prefixtree.scanner.CellSearcher;
@@ -91,7 +92,7 @@ public class PrefixTreeArraySearcher extends PrefixTreeArrayReversibleScanner im
       }
 
       //keep hunting for the rest of the row
-      byte searchForByte = CellUtil.getRowByte(key, currentNodeDepth);
+      byte searchForByte = PrivateCellUtil.getRowByte(key, currentNodeDepth);
       fanIndex = currentRowNode.whichFanNode(searchForByte);
       if(fanIndex < 0){//no matching row.  return early
         int insertionPoint = -fanIndex - 1;
@@ -140,7 +141,7 @@ public class PrefixTreeArraySearcher extends PrefixTreeArrayReversibleScanner im
       }
 
       //keep hunting for the rest of the row
-      byte searchForByte = CellUtil.getRowByte(key, currentNodeDepth);
+      byte searchForByte = PrivateCellUtil.getRowByte(key, currentNodeDepth);
       fanIndex = currentRowNode.whichFanNode(searchForByte);
       if(fanIndex < 0){//no matching row.  return early
         int insertionPoint = -fanIndex - 1;
@@ -287,7 +288,7 @@ public class PrefixTreeArraySearcher extends PrefixTreeArrayReversibleScanner im
       if (i >= key.getRowLength()) {// key was shorter, so it's first
         return -1;
       }
-      byte keyByte = CellUtil.getRowByte(key, i);
+      byte keyByte = PrivateCellUtil.getRowByte(key, i);
       byte thisByte = rowBuffer[i];
       if (keyByte == thisByte) {
         continue;
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeCell.java b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeCell.java
index ca8c378..198ded0 100644
--- a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeCell.java
+++ b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/decode/PrefixTreeCell.java
@@ -24,7 +24,7 @@ import org.apache.hadoop.hbase.ByteBufferCell;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellComparatorImpl;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.SettableSequenceId;
@@ -107,7 +107,7 @@ public class PrefixTreeCell extends ByteBufferCell implements SettableSequenceId
       return false;
     }
     // Temporary hack to maintain backwards compatibility with KeyValue.equals
-    return CellUtil.equalsIgnoreMvccVersion(this, (Cell) obj);
+    return PrivateCellUtil.equalsIgnoreMvccVersion(this, (Cell) obj);
 
     // TODO return CellComparator.equals(this, (Cell)obj);//see HBASE-6907
   }
diff --git a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/encode/PrefixTreeEncoder.java b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/encode/PrefixTreeEncoder.java
index 5c4eed8..8ba8828 100644
--- a/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/encode/PrefixTreeEncoder.java
+++ b/hbase-prefix-tree/src/main/java/org/apache/hadoop/hbase/codec/prefixtree/encode/PrefixTreeEncoder.java
@@ -26,6 +26,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.codec.prefixtree.PrefixTreeBlockMeta;
 import org.apache.hadoop.hbase.codec.prefixtree.encode.column.ColumnSectionWriter;
@@ -274,7 +275,7 @@ public class PrefixTreeEncoder implements CellOutputStream {
   public void write(Cell cell) {
     ensurePerCellCapacities();
 
-    rowTokenizer.addSorted(CellUtil.fillRowRange(cell, rowRange));
+    rowTokenizer.addSorted(PrivateCellUtil.fillRowRange(cell, rowRange));
     addFamilyPart(cell);
     addQualifierPart(cell);
     addTagPart(cell);
@@ -283,7 +284,7 @@ public class PrefixTreeEncoder implements CellOutputStream {
 
 
   private void addTagPart(Cell cell) {
-    CellUtil.fillTagRange(cell, tagsRange);
+    PrivateCellUtil.fillTagRange(cell, tagsRange);
     tagsDeduplicator.add(tagsRange);
   }
 
@@ -329,13 +330,13 @@ public class PrefixTreeEncoder implements CellOutputStream {
 
   private void addFamilyPart(Cell cell) {
     if (MULITPLE_FAMILIES_POSSIBLE || totalCells == 0) {
-      CellUtil.fillFamilyRange(cell, familyRange);
+      PrivateCellUtil.fillFamilyRange(cell, familyRange);
       familyDeduplicator.add(familyRange);
     }
   }
 
   private void addQualifierPart(Cell cell) {
-    CellUtil.fillQualifierRange(cell, qualifierRange);
+    PrivateCellUtil.fillQualifierRange(cell, qualifierRange);
     qualifierDeduplicator.add(qualifierRange);
   }
 
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/BaseTestRowData.java b/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/BaseTestRowData.java
index 95df90f..d006740 100644
--- a/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/BaseTestRowData.java
+++ b/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/BaseTestRowData.java
@@ -37,7 +37,7 @@ public abstract class BaseTestRowData implements TestRowData {
     for (int i = 1; i < inputs.size(); ++i) {
       KeyValue lastKv = inputs.get(i - 1);
       KeyValue kv = inputs.get(i);
-      if (!CellUtil.matchingRow(lastKv, kv)) {
+      if (!CellUtil.matchingRows(lastKv, kv)) {
         rowStartIndexes.add(i);
       }
     }
diff --git a/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/TestPrefixTreeSearcher.java b/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/TestPrefixTreeSearcher.java
index 7a9862f..0dbec21 100644
--- a/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/TestPrefixTreeSearcher.java
+++ b/hbase-prefix-tree/src/test/java/org/apache/hadoop/hbase/codec/prefixtree/row/TestPrefixTreeSearcher.java
@@ -27,6 +27,7 @@ import java.util.List;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.nio.ByteBuff;
@@ -150,7 +151,7 @@ public class TestPrefixTreeSearcher {
           KeyValue kv = rows.getInputs().get(i);
 
           //nextRow
-          Cell inputNextRow = CellUtil.createFirstOnNextRow(kv);
+          Cell inputNextRow = PrivateCellUtil.createFirstOnNextRow(kv);
 
           CellScannerPosition position = beforeVsAfterOnMiss
               ? searcher.positionAtOrBefore(inputNextRow)
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/client/ClientSideRegionScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/client/ClientSideRegionScanner.java
index 6871717..529a2f9 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/client/ClientSideRegionScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/client/ClientSideRegionScanner.java
@@ -29,6 +29,7 @@ import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.client.metrics.ScanMetrics;
 import org.apache.hadoop.hbase.regionserver.HRegion;
 import org.apache.hadoop.hbase.regionserver.RegionScanner;
@@ -83,7 +84,7 @@ public class ClientSideRegionScanner extends AbstractClientScanner {
     if (this.scanMetrics != null) {
       long resultSize = 0;
       for (Cell cell : values) {
-        resultSize += CellUtil.estimatedSerializedSizeOf(cell);
+        resultSize += PrivateCellUtil.estimatedSerializedSizeOf(cell);
       }
       this.scanMetrics.countOfBytesInResults.addAndGet(resultSize);
       this.scanMetrics.countOfRowsScanned.incrementAndGet();
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/client/TableSnapshotScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/client/TableSnapshotScanner.java
index ab361c1..36b2bb2 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/client/TableSnapshotScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/client/TableSnapshotScanner.java
@@ -30,6 +30,7 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.snapshot.RestoreSnapshotHelper;
 import org.apache.hadoop.hbase.util.FSUtils;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -128,7 +129,7 @@ public class TableSnapshotScanner extends AbstractClientScanner {
       if (hri.isOffline() && (hri.isSplit() || hri.isSplitParent())) {
         continue;
       }
-      if (CellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(), hri.getStartKey(),
+      if (PrivateCellUtil.overlappingKeys(scan.getStartRow(), scan.getStopRow(), hri.getStartKey(),
         hri.getEndKey())) {
         regions.add(hri);
       }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
index fec17bc..1dfffd6 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java
@@ -32,6 +32,7 @@ import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.Scan;
 import org.apache.hadoop.hbase.io.hfile.CacheConfig;
@@ -210,11 +211,11 @@ public class HalfStoreFileReader extends StoreFileReader {
       @Override
       public int seekTo(Cell key) throws IOException {
         if (top) {
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) < 0) {
+          if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) < 0) {
             return -1;
           }
         } else {
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
+          if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
             // we would place the scanner in the second half.
             // it might be an error to return false here ever...
             boolean res = delegate.seekBefore(splitCell);
@@ -235,11 +236,11 @@ public class HalfStoreFileReader extends StoreFileReader {
         // except
         // that we call reseekTo (and not seekTo) on the delegate.
         if (top) {
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) < 0) {
+          if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) < 0) {
             return -1;
           }
         } else {
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
+          if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
             // we would place the scanner in the second half.
             // it might be an error to return false here ever...
             boolean res = delegate.seekBefore(splitCell);
@@ -261,13 +262,13 @@ public class HalfStoreFileReader extends StoreFileReader {
       public boolean seekBefore(Cell key) throws IOException {
         if (top) {
           Optional<Cell> fk = getFirstKey();
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, fk.get()) <= 0) {
+          if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(), key, fk.get()) <= 0) {
             return false;
           }
         } else {
           // The equals sign isn't strictly necessary just here to be consistent
           // with seekTo
-          if (CellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
+          if (PrivateCellUtil.compareKeyIgnoresMvcc(getComparator(), key, splitCell) >= 0) {
             boolean ret = this.delegate.seekBefore(splitCell);
             if (ret) {
               atEnd = false;
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/CompoundBloomFilterWriter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/CompoundBloomFilterWriter.java
index 3242b73..7e5db08 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/CompoundBloomFilterWriter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/CompoundBloomFilterWriter.java
@@ -28,6 +28,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.BloomType;
@@ -177,7 +178,8 @@ public class CompoundBloomFilterWriter extends CompoundBloomFilterBase
         firstKeyInChunk = CellUtil.copyRow(cell);
       } else {
         firstKeyInChunk =
-            CellUtil.getCellKeySerializedAsKeyValueKey(CellUtil.createFirstOnRowCol(cell));
+            PrivateCellUtil
+                .getCellKeySerializedAsKeyValueKey(PrivateCellUtil.createFirstOnRowCol(cell));
       }
       allocateNewChunk();
     }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlockIndex.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlockIndex.java
index ead156b..557a69c 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlockIndex.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlockIndex.java
@@ -39,6 +39,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 //import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.KeyOnlyKeyValue;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -265,7 +266,7 @@ public class HFileBlockIndex {
 
         // Adding blockKeys
         for (Cell key : blockKeys) {
-          heapSize += ClassSize.align(CellUtil.estimatedHeapSizeOf(key));
+          heapSize += ClassSize.align(PrivateCellUtil.estimatedHeapSizeOf(key));
         }
       }
       // Add comparator and the midkey atomicreference
@@ -767,7 +768,7 @@ public class HFileBlockIndex {
         // TODO avoid array call.
         nonRootIndex.asSubByteBuffer(midKeyOffset, midLength, pair);
         nonRootIndexkeyOnlyKV.setKey(pair.getFirst(), pair.getSecond(), midLength);
-        int cmp = CellUtil.compareKeyIgnoresMvcc(comparator, key, nonRootIndexkeyOnlyKV);
+        int cmp = PrivateCellUtil.compareKeyIgnoresMvcc(comparator, key, nonRootIndexkeyOnlyKV);
 
         // key lives above the midpoint
         if (cmp > 0)
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFilePrettyPrinter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFilePrettyPrinter.java
index a800ef1..1087465 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFilePrettyPrinter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFilePrettyPrinter.java
@@ -59,6 +59,7 @@ import org.apache.hadoop.hbase.HBaseConfiguration;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.TableName;
@@ -322,7 +323,7 @@ public class HFilePrettyPrinter extends Configured implements Tool {
       if (this.isSeekToRow) {
         // seek to the first kv on this row
         shouldScanKeysValues =
-          (scanner.seekTo(CellUtil.createFirstOnRow(this.row)) != -1);
+          (scanner.seekTo(PrivateCellUtil.createFirstOnRow(this.row)) != -1);
       } else {
         shouldScanKeysValues = scanner.seekTo();
       }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java
index 7068fe1..f2416bc 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java
@@ -37,6 +37,7 @@ import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.ByteBufferKeyValue;
 import org.apache.hadoop.hbase.SizeCachedKeyValue;
@@ -728,7 +729,8 @@ public class HFileReaderImpl implements HFile.Reader, Configurable {
         offsetFromPos += Bytes.SIZEOF_LONG;
         blockBuffer.asSubByteBuffer(blockBuffer.position() + offsetFromPos, klen, pair);
         bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), klen);
-        int comp = CellUtil.compareKeyIgnoresMvcc(reader.getComparator(), key, bufBackedKeyOnlyKv);
+        int comp =
+            PrivateCellUtil.compareKeyIgnoresMvcc(reader.getComparator(), key, bufBackedKeyOnlyKv);
         offsetFromPos += klen + vlen;
         if (this.reader.getFileContext().isIncludesTags()) {
           // Read short as unsigned, high byte first
@@ -811,7 +813,7 @@ public class HFileReaderImpl implements HFile.Reader, Configurable {
         } else {
           // The comparison with no_next_index_key has to be checked
           if (this.nextIndexedKey != null &&
-              (this.nextIndexedKey == KeyValueScanner.NO_NEXT_INDEXED_KEY || CellUtil
+              (this.nextIndexedKey == KeyValueScanner.NO_NEXT_INDEXED_KEY || PrivateCellUtil
                   .compareKeyIgnoresMvcc(reader.getComparator(), key, nextIndexedKey) < 0)) {
             // The reader shall continue to scan the current data block instead
             // of querying the
@@ -865,7 +867,7 @@ public class HFileReaderImpl implements HFile.Reader, Configurable {
         return false;
       }
       Cell firstKey = getFirstKeyCellInBlock(seekToBlock);
-      if (CellUtil.compareKeyIgnoresMvcc(reader.getComparator(), firstKey, key) >= 0) {
+      if (PrivateCellUtil.compareKeyIgnoresMvcc(reader.getComparator(), firstKey, key) >= 0) {
         long previousBlockOffset = seekToBlock.getPrevBlockOffset();
         // The key we are interested in
         if (previousBlockOffset == -1) {
@@ -1229,7 +1231,7 @@ public class HFileReaderImpl implements HFile.Reader, Configurable {
     public int compareKey(CellComparator comparator, Cell key) {
       blockBuffer.asSubByteBuffer(blockBuffer.position() + KEY_VALUE_LEN_SIZE, currKeyLen, pair);
       this.bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), currKeyLen);
-      return CellUtil.compareKeyIgnoresMvcc(comparator, key, this.bufBackedKeyOnlyKv);
+      return PrivateCellUtil.compareKeyIgnoresMvcc(comparator, key, this.bufBackedKeyOnlyKv);
     }
 
     @Override
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java
index 33cfa1d..bd98cdd 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java
@@ -39,6 +39,7 @@ import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.CellComparatorImpl.MetaCellComparator;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -239,7 +240,7 @@ public class HFileWriterImpl implements HFile.Writer {
       throw new IOException("Key cannot be null or empty");
     }
     if (lastCell != null) {
-      int keyComp = CellUtil.compareKeyIgnoresMvcc(comparator, lastCell, cell);
+      int keyComp = PrivateCellUtil.compareKeyIgnoresMvcc(comparator, lastCell, cell);
 
       if (keyComp > 0) {
         throw new IOException("Added a key not lexically larger than"
@@ -341,7 +342,7 @@ public class HFileWriterImpl implements HFile.Writer {
     int onDiskSize = blockWriter.getOnDiskSizeWithHeader();
     Cell indexEntry =
       getMidpoint(this.comparator, lastCellOfPreviousBlock, firstCellInBlock);
-    dataBlockIndexWriter.addEntry(CellUtil.getCellKeySerializedAsKeyValueKey(indexEntry),
+    dataBlockIndexWriter.addEntry(PrivateCellUtil.getCellKeySerializedAsKeyValueKey(indexEntry),
       lastDataBlockOffset, onDiskSize);
     totalUncompressedBytes += blockWriter.getUncompressedSizeWithHeader();
     if (cacheConf.shouldCacheDataOnWrite()) {
@@ -397,7 +398,7 @@ public class HFileWriterImpl implements HFile.Writer {
       }
       // If midRow is null, just return 'right'. Can't do optimization.
       if (midRow == null) return right;
-      return CellUtil.createFirstOnRow(midRow);
+      return PrivateCellUtil.createFirstOnRow(midRow);
     }
     // Rows are same. Compare on families.
     diff = comparator.compareFamilies(left, right);
@@ -419,7 +420,7 @@ public class HFileWriterImpl implements HFile.Writer {
       // If midRow is null, just return 'right'. Can't do optimization.
       if (midRow == null) return right;
       // Return new Cell where we use right row and then a mid sort family.
-      return CellUtil.createFirstOnRowFamily(right, midRow, 0, midRow.length);
+      return PrivateCellUtil.createFirstOnRowFamily(right, midRow, 0, midRow.length);
     }
     // Families are same. Compare on qualifiers.
     diff = comparator.compareQualifiers(left, right);
@@ -441,7 +442,7 @@ public class HFileWriterImpl implements HFile.Writer {
       // If midRow is null, just return 'right'. Can't do optimization.
       if (midRow == null) return right;
       // Return new Cell where we use right row and family and then a mid sort qualifier.
-      return CellUtil.createFirstOnRowCol(right, midRow, 0, midRow.length);
+      return PrivateCellUtil.createFirstOnRowCol(right, midRow, 0, midRow.length);
     }
     // No opportunity for optimization. Just return right key.
     return right;
@@ -738,7 +739,7 @@ public class HFileWriterImpl implements HFile.Writer {
 
     blockWriter.write(cell);
 
-    totalKeyLength += CellUtil.estimatedSerializedSizeOfKey(cell);
+    totalKeyLength += PrivateCellUtil.estimatedSerializedSizeOfKey(cell);
     totalValueLength += cell.getValueLength();
 
     // Are we the first key in this block?
@@ -776,7 +777,7 @@ public class HFileWriterImpl implements HFile.Writer {
     if (lastCell != null) {
       // Make a copy. The copy is stuffed into our fileinfo map. Needs a clean
       // byte buffer. Won't take a tuple.
-      byte [] lastKey = CellUtil.getCellKeySerializedAsKeyValueKey(this.lastCell);
+      byte [] lastKey = PrivateCellUtil.getCellKeySerializedAsKeyValueKey(this.lastCell);
       fileInfo.append(FileInfo.LASTKEY, lastKey, false);
     }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/DefaultMobStoreCompactor.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/DefaultMobStoreCompactor.java
index 502a446..32552da 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/DefaultMobStoreCompactor.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/DefaultMobStoreCompactor.java
@@ -30,6 +30,7 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.regionserver.CellSink;
@@ -248,7 +249,7 @@ public class DefaultMobStoreCompactor extends DefaultCompactor {
                 Cell mobCell = mobStore.resolve(c, false);
                 if (mobCell.getValueLength() != 0) {
                   // put the mob data back to the store file
-                  CellUtil.setSequenceId(mobCell, c.getSequenceId());
+                  PrivateCellUtil.setSequenceId(mobCell, c.getSequenceId());
                   writer.append(mobCell);
                   cellsCountCompactedFromMob++;
                   cellsSizeCompactedFromMob += mobCell.getValueLength();
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java
index c66c571..1d9c10c 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java
@@ -45,6 +45,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagType;
@@ -175,7 +176,7 @@ public final class MobUtils {
    */
   public static boolean isMobReferenceCell(Cell cell) {
     if (cell.getTagsLength() > 0) {
-      Tag tag = CellUtil.getTag(cell, TagType.MOB_REFERENCE_TAG_TYPE);
+      Tag tag = PrivateCellUtil.getTag(cell, TagType.MOB_REFERENCE_TAG_TYPE);
       return tag != null;
     }
     return false;
@@ -188,7 +189,7 @@ public final class MobUtils {
    */
   public static Tag getTableNameTag(Cell cell) {
     if (cell.getTagsLength() > 0) {
-      return CellUtil.getTag(cell, TagType.MOB_TABLE_NAME_TAG_TYPE);
+      return PrivateCellUtil.getTag(cell, TagType.MOB_TABLE_NAME_TAG_TYPE);
     }
     return null;
   }
@@ -501,7 +502,7 @@ public final class MobUtils {
 
   public static Cell createMobRefCell(Cell cell, byte[] fileName, byte[] refCellTags) {
     byte[] refValue = Bytes.add(Bytes.toBytes(cell.getValueLength()), fileName);
-    return CellUtil.createCell(cell, refValue, TagUtil.concatTags(refCellTags, cell));
+    return PrivateCellUtil.createCell(cell, refValue, TagUtil.concatTags(refCellTags, cell));
   }
 
   /**
@@ -761,7 +762,7 @@ public final class MobUtils {
    * @return The real mob value length.
    */
   public static int getMobValueLength(Cell cell) {
-    return CellUtil.getValueAsInt(cell);
+    return PrivateCellUtil.getValueAsInt(cell);
   }
 
   /**
@@ -891,7 +892,7 @@ public final class MobUtils {
    * @return A delete marker with the ref tag.
    */
   public static Cell createMobRefDeleteMarker(Cell cell) {
-    return CellUtil.createCell(cell, TagUtil.concatTags(REF_DELETE_MARKER_TAG_BYTES, cell));
+    return PrivateCellUtil.createCell(cell, TagUtil.concatTags(REF_DELETE_MARKER_TAG_BYTES, cell));
   }
 
   /**
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/protobuf/ReplicationProtbufUtil.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/protobuf/ReplicationProtbufUtil.java
index 0967e94..dbf7b5e 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/protobuf/ReplicationProtbufUtil.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/protobuf/ReplicationProtbufUtil.java
@@ -31,8 +31,8 @@ import java.util.UUID;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellScanner;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.io.SizedCellScanner;
 import org.apache.hadoop.hbase.ipc.HBaseRpcController;
@@ -146,7 +146,7 @@ public class ReplicationProtbufUtil {
       List<Cell> cells = edit.getCells();
       // Add up the size.  It is used later serializing out the kvs.
       for (Cell cell: cells) {
-        size += CellUtil.estimatedSerializedSizeOf(cell);
+        size += PrivateCellUtil.estimatedSerializedSizeOf(cell);
       }
       // Collect up the cells
       allCells.add(cells);
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
index 3cb0e54..0d88cf4 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java
@@ -91,6 +91,7 @@ import org.apache.hadoop.hbase.ExtendedCellBuilderFactory;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HConstants.OperationStatusCode;
 import org.apache.hadoop.hbase.HDFSBlocksDistribution;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.NamespaceDescriptor;
@@ -2958,7 +2959,8 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
         Cell cell = cells.get(i);
         //  Check if time is LATEST, change to time of most recent addition if so
         //  This is expensive.
-        if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP && CellUtil.isDeleteType(cell)) {
+        if (cell.getTimestamp() == HConstants.LATEST_TIMESTAMP
+            && PrivateCellUtil.isDeleteType(cell)) {
           byte[] qual = CellUtil.cloneQualifier(cell);
 
           Integer count = kvCount.get(qual);
@@ -2981,7 +2983,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
             updateDeleteLatestVersionTimeStamp(cell, get, count, byteNow);
           }
         } else {
-          CellUtil.updateLatestStamp(cell, byteNow, 0);
+          PrivateCellUtil.updateLatestStamp(cell, byteNow, 0);
         }
       }
     }
@@ -2993,14 +2995,14 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
 
     if (result.size() < count) {
       // Nothing to delete
-      CellUtil.updateLatestStamp(cell, byteNow, 0);
+      PrivateCellUtil.updateLatestStamp(cell, byteNow, 0);
       return;
     }
     if (result.size() > count) {
       throw new RuntimeException("Unexpected size: " + result.size());
     }
     Cell getCell = result.get(count - 1);
-    CellUtil.setTimestamp(cell, getCell.getTimestamp());
+    PrivateCellUtil.setTimestamp(cell, getCell.getTimestamp());
   }
 
   @Override
@@ -3753,7 +3755,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
         } else if (result.size() == 1 && !valueIsNull) {
           Cell kv = result.get(0);
           cellTs = kv.getTimestamp();
-          int compareResult = CellUtil.compareValue(kv, comparator);
+          int compareResult = PrivateCellUtil.compareValue(kv, comparator);
           matches = matches(op, compareResult);
         }
         // If matches put the new put or delete the new delete
@@ -3876,7 +3878,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
     for (List<Cell> cells: cellItr) {
       if (cells == null) return;
       for (Cell cell : cells) {
-        CellUtil.setSequenceId(cell, sequenceId);
+        PrivateCellUtil.setSequenceId(cell, sequenceId);
       }
     }
   }
@@ -3894,7 +3896,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
       assert cells instanceof RandomAccess;
       int listSize = cells.size();
       for (int i = 0; i < listSize; i++) {
-        CellUtil.updateLatestStamp(cells.get(i), now, 0);
+        PrivateCellUtil.updateLatestStamp(cells.get(i), now, 0);
       }
     }
   }
@@ -3919,7 +3921,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
         List<Tag> newTags = TagUtil.carryForwardTags(null, cell);
         newTags = TagUtil.carryForwardTTLTag(newTags, m.getTTL());
         // Rewrite the cell with the updated set of tags
-        cells.set(i, CellUtil.createCell(cell, newTags));
+        cells.set(i, PrivateCellUtil.createCell(cell, newTags));
       }
     }
   }
@@ -4379,7 +4381,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
               skippedEdits++;
               continue;
             }
-            CellUtil.setSequenceId(cell, currentReplaySeqId);
+            PrivateCellUtil.setSequenceId(cell, currentReplaySeqId);
 
             restoreEdit(store, cell, memstoreSize);
             editsCount++;
@@ -6151,7 +6153,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
      * @return true When there are more cells in the row to be read
      */
     private boolean moreCellsInRow(final Cell nextKv, Cell currentRowCell) {
-      return nextKv != null && CellUtil.matchingRow(nextKv, currentRowCell);
+      return nextKv != null && CellUtil.matchingRows(nextKv, currentRowCell);
     }
 
     /*
@@ -6302,8 +6304,8 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
             scannerContext.setTimeProgress(timeProgress);
             scannerContext.incrementBatchProgress(results.size());
             for (Cell cell : results) {
-              scannerContext.incrementSizeProgress(CellUtil.estimatedSerializedSizeOf(cell),
-                  CellUtil.estimatedHeapSizeOf(cell));
+              scannerContext.incrementSizeProgress(PrivateCellUtil.estimatedSerializedSizeOf(cell),
+                PrivateCellUtil.estimatedHeapSizeOf(cell));
             }
           }
 
@@ -6392,17 +6394,17 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
         throws IOException {
       Cell nextJoinedKv = joinedHeap.peek();
       boolean matchCurrentRow =
-          nextJoinedKv != null && CellUtil.matchingRow(nextJoinedKv, currentRowCell);
+          nextJoinedKv != null && CellUtil.matchingRows(nextJoinedKv, currentRowCell);
       boolean matchAfterSeek = false;
 
       // If the next value in the joined heap does not match the current row, try to seek to the
       // correct row
       if (!matchCurrentRow) {
-        Cell firstOnCurrentRow = CellUtil.createFirstOnRow(currentRowCell);
+        Cell firstOnCurrentRow = PrivateCellUtil.createFirstOnRow(currentRowCell);
         boolean seekSuccessful = this.joinedHeap.requestSeek(firstOnCurrentRow, true, true);
         matchAfterSeek =
             seekSuccessful && joinedHeap.peek() != null
-                && CellUtil.matchingRow(joinedHeap.peek(), currentRowCell);
+                && CellUtil.matchingRows(joinedHeap.peek(), currentRowCell);
       }
 
       return matchCurrentRow || matchAfterSeek;
@@ -6430,7 +6432,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
       assert this.joinedContinuationRow == null: "Trying to go to next row during joinedHeap read.";
       Cell next;
       while ((next = this.storeHeap.peek()) != null &&
-             CellUtil.matchingRow(next, curRowCell)) {
+             CellUtil.matchingRows(next, curRowCell)) {
         this.storeHeap.next(MOCKED_LIST);
       }
       resetFilters();
@@ -6478,7 +6480,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
       }
       boolean result = false;
       startRegionOperation();
-      Cell kv = CellUtil.createFirstOnRow(row, 0, (short) row.length);
+      Cell kv = PrivateCellUtil.createFirstOnRow(row, 0, (short) row.length);
       try {
         // use request seek to make use of the lazy seek option. See HBASE-5520
         result = this.storeHeap.requestSeek(kv, true, true);
@@ -7150,7 +7152,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
               if (walEdit.isEmpty()) {
                 // If walEdit is empty, we put nothing in WAL. WAL stamps Cells with sequence id.
                 // If no WAL, need to stamp it here.
-                CellUtil.setSequenceId(cell, sequenceId);
+                PrivateCellUtil.setSequenceId(cell, sequenceId);
               }
               applyToMemStore(getStore(cell), cell, memstoreAccounting);
             }
@@ -7569,8 +7571,8 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
               .setTags(TagUtil.fromList(tags))
               .build();
     } else {
-      CellUtil.updateLatestStamp(delta, now);
-      return CollectionUtils.isEmpty(tags) ? delta : CellUtil.createCell(delta, tags);
+      PrivateCellUtil.updateLatestStamp(delta, now);
+      return CollectionUtils.isEmpty(tags) ? delta : PrivateCellUtil.createCell(delta, tags);
     }
   }
 
@@ -7583,7 +7585,7 @@ public class HRegion implements HeapSize, PropagatingConfigurationObserver, Regi
       // throw DoNotRetryIOException instead of IllegalArgumentException
       throw new DoNotRetryIOException("Field is not a long, it's " + len + " bytes wide");
     }
-    return CellUtil.getValueAsLong(cell);
+    return PrivateCellUtil.getValueAsLong(cell);
   }
 
   /**
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionFileSystem.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionFileSystem.java
index fcd6c57..4fc9ffe 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionFileSystem.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionFileSystem.java
@@ -40,8 +40,8 @@ import org.apache.hadoop.fs.LocatedFileStatus;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.fs.permission.FsPermission;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.backup.HFileArchiver;
 import org.apache.hadoop.hbase.client.ColumnFamilyDescriptor;
 import org.apache.hadoop.hbase.client.RegionInfo;
@@ -666,7 +666,7 @@ public class HRegionFileSystem {
       try {
         if (top) {
           //check if larger than last key.
-          Cell splitKey = CellUtil.createFirstOnRow(splitRow);
+          Cell splitKey = PrivateCellUtil.createFirstOnRow(splitRow);
           Optional<Cell> lastKey = f.getLastKey();
           // If lastKey is null means storefile is empty.
           if (!lastKey.isPresent()) {
@@ -677,7 +677,7 @@ public class HRegionFileSystem {
           }
         } else {
           //check if smaller than first key
-          Cell splitKey = CellUtil.createLastOnRow(splitRow);
+          Cell splitKey = PrivateCellUtil.createLastOnRow(splitRow);
           Optional<Cell> firstKey = f.getFirstKey();
           // If firstKey is null means storefile is empty.
           if (!firstKey.isPresent()) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MutableSegment.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MutableSegment.java
index 68c0fa1..55ed993 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MutableSegment.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MutableSegment.java
@@ -25,6 +25,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.util.ClassSize;
@@ -60,7 +61,7 @@ public class MutableSegment extends Segment {
 
     // Get the Cells for the row/family/qualifier regardless of timestamp.
     // For this case we want to clean up any other puts
-    Cell firstCell = CellUtil.createFirstOnRowColTS(cell, HConstants.LATEST_TIMESTAMP);
+    Cell firstCell = PrivateCellUtil.createFirstOnRowColTS(cell, HConstants.LATEST_TIMESTAMP);
     SortedSet<Cell> ss = this.tailSet(firstCell);
     Iterator<Cell> it = ss.iterator();
     // versions visible to oldest scanner
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java
index 5d450cc..916696e 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java
@@ -58,6 +58,7 @@ import org.apache.hadoop.hbase.DoNotRetryIOException;
 import org.apache.hadoop.hbase.DroppedSnapshotException;
 import org.apache.hadoop.hbase.HBaseIOException;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.MultiActionResultTooLarge;
 import org.apache.hadoop.hbase.NotServingRegionException;
 import org.apache.hadoop.hbase.ServerName;
@@ -930,7 +931,7 @@ public class RSRpcServices implements HBaseRPCErrorHandler,
     if (r.maxCellSize > 0) {
       CellScanner cells = m.cellScanner();
       while (cells.advance()) {
-        int size = CellUtil.estimatedSerializedSizeOf(cells.current());
+        int size = PrivateCellUtil.estimatedSerializedSizeOf(cells.current());
         if (size > r.maxCellSize) {
           String msg = "Cell with size " + size + " exceeds limit of " + r.maxCellSize + " bytes";
           if (LOG.isDebugEnabled()) {
@@ -1300,7 +1301,7 @@ public class RSRpcServices implements HBaseRPCErrorHandler,
   Object addSize(RpcCallContext context, Result r, Object lastBlock) {
     if (context != null && r != null && !r.isEmpty()) {
       for (Cell c : r.rawCells()) {
-        context.incrementResponseCellSize(CellUtil.estimatedSerializedSizeOf(c));
+        context.incrementResponseCellSize(PrivateCellUtil.estimatedSerializedSizeOf(c));
 
         // Since byte buffers can point all kinds of crazy places it's harder to keep track
         // of which blocks are kept alive by what byte buffer.
@@ -3061,7 +3062,7 @@ public class RSRpcServices implements HBaseRPCErrorHandler,
               // so then we need to increase the numOfCompleteRows.
               if (results.isEmpty()) {
                 if (rsh.rowOfLastPartialResult != null &&
-                    !CellUtil.matchingRow(values.get(0), rsh.rowOfLastPartialResult)) {
+                    !CellUtil.matchingRows(values.get(0), rsh.rowOfLastPartialResult)) {
                   numOfCompleteRows++;
                   checkLimitOfRows(numOfCompleteRows, limitOfRows, moreRows, scannerContext,
                     builder);
@@ -3069,7 +3070,7 @@ public class RSRpcServices implements HBaseRPCErrorHandler,
               } else {
                 Result lastResult = results.get(results.size() - 1);
                 if (lastResult.mayHaveMoreCellsInRow() &&
-                    !CellUtil.matchingRow(values.get(0), lastResult.getRow())) {
+                    !CellUtil.matchingRows(values.get(0), lastResult.getRow())) {
                   numOfCompleteRows++;
                   checkLimitOfRows(numOfCompleteRows, limitOfRows, moreRows, scannerContext,
                     builder);
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedKeyValueHeap.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedKeyValueHeap.java
index 4d2ab9b..3997741 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedKeyValueHeap.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedKeyValueHeap.java
@@ -107,7 +107,7 @@ public class ReversedKeyValueHeap extends KeyValueHeap {
     KeyValueScanner scanner;
     while ((scanner = heap.poll()) != null) {
       Cell topKey = scanner.peek();
-      if ((CellUtil.matchingRow(seekKey, topKey) && comparator
+      if ((CellUtil.matchingRows(seekKey, topKey) && comparator
           .getComparator().compare(seekKey, topKey) <= 0)
           || comparator.getComparator().compareRows(seekKey, topKey) > 0) {
         heap.add(scanner);
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedRegionScannerImpl.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedRegionScannerImpl.java
index fa1ba6e..0ae8fac 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedRegionScannerImpl.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedRegionScannerImpl.java
@@ -24,6 +24,7 @@ import java.util.List;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.client.Scan;
 import org.apache.hadoop.hbase.regionserver.HRegion.RegionScannerImpl;
@@ -73,7 +74,7 @@ class ReversedRegionScannerImpl extends RegionScannerImpl {
   protected boolean nextRow(ScannerContext scannerContext, Cell curRowCell)
       throws IOException {
     assert super.joinedContinuationRow == null : "Trying to go to next row during joinedHeap read.";
-    this.storeHeap.seekToPreviousRow(CellUtil.createFirstOnRow(curRowCell));
+    this.storeHeap.seekToPreviousRow(PrivateCellUtil.createFirstOnRow(curRowCell));
     resetFilters();
     // Calling the hook in CP which allows it to do a fast forward
     if (this.region.getCoprocessorHost() != null) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedStoreScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedStoreScanner.java
index 04e6865..90e1129 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedStoreScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedStoreScanner.java
@@ -71,7 +71,7 @@ public class ReversedStoreScanner extends StoreScanner implements KeyValueScanne
       throws IOException {
     // Seek all scanners to the start of the Row (or if the exact matching row
     // key does not exist, then to the start of the previous matching Row).
-    if (CellUtil.matchingRow(seekKey, HConstants.EMPTY_START_ROW)) {
+    if (CellUtil.matchingRows(seekKey, HConstants.EMPTY_START_ROW)) {
       for (KeyValueScanner scanner : scanners) {
         scanner.seekToLastRow();
       }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/Segment.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/Segment.java
index 6f41f86..c054666 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/Segment.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/Segment.java
@@ -28,7 +28,7 @@ import java.util.concurrent.atomic.AtomicReference;
 import org.apache.commons.logging.Log;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.io.TimeRange;
@@ -318,7 +318,7 @@ public abstract class Segment {
   protected long heapSizeChange(Cell cell, boolean succ) {
     if (succ) {
       return ClassSize
-          .align(indexEntrySize() + CellUtil.estimatedHeapSizeOf(cell));
+          .align(indexEntrySize() + PrivateCellUtil.estimatedHeapSizeOf(cell));
     }
     return 0;
   }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/SegmentScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/SegmentScanner.java
index 626d43c..a8b0d3d 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/SegmentScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/SegmentScanner.java
@@ -25,7 +25,7 @@ import java.util.SortedSet;
 import org.apache.commons.lang3.NotImplementedException;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.client.Scan;
 
@@ -205,14 +205,14 @@ public class SegmentScanner implements KeyValueScanner {
     boolean keepSeeking;
     Cell key = cell;
     do {
-      Cell firstKeyOnRow = CellUtil.createFirstOnRow(key);
+      Cell firstKeyOnRow = PrivateCellUtil.createFirstOnRow(key);
       SortedSet<Cell> cellHead = segment.headSet(firstKeyOnRow);
       Cell lastCellBeforeRow = cellHead.isEmpty() ? null : cellHead.last();
       if (lastCellBeforeRow == null) {
         current = null;
         return false;
       }
-      Cell firstKeyOnPreviousRow = CellUtil.createFirstOnRow(lastCellBeforeRow);
+      Cell firstKeyOnPreviousRow = PrivateCellUtil.createFirstOnRow(lastCellBeforeRow);
       this.stopSkippingKVsIfNextRow = true;
       seek(firstKeyOnPreviousRow);
       this.stopSkippingKVsIfNextRow = false;
@@ -243,7 +243,7 @@ public class SegmentScanner implements KeyValueScanner {
       return false;
     }
 
-    Cell firstCellOnLastRow = CellUtil.createFirstOnRow(higherCell);
+    Cell firstCellOnLastRow = PrivateCellUtil.createFirstOnRow(higherCell);
 
     if (seek(firstCellOnLastRow)) {
       return true;
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileReader.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileReader.java
index 9f776b2..2e74ecf 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileReader.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileReader.java
@@ -36,9 +36,9 @@ import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellComparatorImpl;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.Scan;
 import org.apache.hadoop.hbase.io.FSDataInputStreamWrapper;
@@ -253,7 +253,7 @@ public class StoreFileReader {
         if (columns != null && columns.size() == 1) {
           byte[] column = columns.first();
           // create the required fake key
-          Cell kvKey = CellUtil.createFirstOnRow(row, HConstants.EMPTY_BYTE_ARRAY, column);
+          Cell kvKey = PrivateCellUtil.createFirstOnRow(row, HConstants.EMPTY_BYTE_ARRAY, column);
           return passesGeneralRowColBloomFilter(kvKey);
         }
 
@@ -336,7 +336,7 @@ public class StoreFileReader {
     if (cell.getTypeByte() == KeyValue.Type.Maximum.getCode() && cell.getFamilyLength() == 0) {
       kvKey = cell;
     } else {
-      kvKey = CellUtil.createFirstOnRowCol(cell);
+      kvKey = PrivateCellUtil.createFirstOnRowCol(cell);
     }
     return checkGeneralBloomFilter(null, kvKey, bloomFilter);
   }
@@ -381,7 +381,7 @@ public class StoreFileReader {
           // columns, a file might be skipped if using row+col Bloom filter.
           // In order to ensure this file is included an additional check is
           // required looking only for a row bloom.
-          Cell rowBloomKey = CellUtil.createFirstOnRow(kvKey);
+          Cell rowBloomKey = PrivateCellUtil.createFirstOnRow(kvKey);
           // hbase:meta does not have blooms. So we need not have special interpretation
           // of the hbase:meta cells.  We can safely use Bytes.BYTES_RAWCOMPARATOR for ROW Bloom
           if (keyIsAfterLast
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
index f52eb39..21e61b2 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java
@@ -32,9 +32,9 @@ import java.util.concurrent.atomic.LongAdder;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.yetus.audience.InterfaceStability;
 import org.apache.hadoop.hbase.client.Scan;
@@ -262,7 +262,7 @@ public class StoreFileScanner implements KeyValueScanner {
   protected void setCurrentCell(Cell newVal) throws IOException {
     this.cur = newVal;
     if (this.cur != null && this.reader.isBulkLoaded() && !this.reader.isSkipResetSeqId()) {
-      CellUtil.setSequenceId(cur, this.reader.getSequenceID());
+      PrivateCellUtil.setSequenceId(cur, this.reader.getSequenceID());
     }
   }
 
@@ -381,7 +381,8 @@ public class StoreFileScanner implements KeyValueScanner {
       if (reader.getBloomFilterType() == BloomType.ROWCOL) {
         haveToSeek = reader.passesGeneralRowColBloomFilter(kv);
       } else if (canOptimizeForNonNullColumn
-          && ((CellUtil.isDeleteFamily(kv) || CellUtil.isDeleteFamilyVersion(kv)))) {
+          && ((PrivateCellUtil.isDeleteFamily(kv)
+              || PrivateCellUtil.isDeleteFamilyVersion(kv)))) {
         // if there is no such delete family kv in the store file,
         // then no need to seek.
         haveToSeek = reader.passesDeleteFamilyBloomFilter(kv.getRowArray(), kv.getRowOffset(),
@@ -405,7 +406,7 @@ public class StoreFileScanner implements KeyValueScanner {
         // a higher timestamp than the max timestamp in this file. We know that
         // the next point when we have to consider this file again is when we
         // pass the max timestamp of this file (with the same row/column).
-        setCurrentCell(CellUtil.createFirstOnRowColTS(kv, maxTimestampInFile));
+        setCurrentCell(PrivateCellUtil.createFirstOnRowColTS(kv, maxTimestampInFile));
       } else {
         // This will be the case e.g. when we need to seek to the next
         // row/column, and we don't know exactly what they are, so we set the
@@ -423,7 +424,7 @@ public class StoreFileScanner implements KeyValueScanner {
     // key/value and the store scanner will progress to the next column. This
     // is obviously not a "real real" seek, but unlike the fake KV earlier in
     // this method, we want this to be propagated to ScanQueryMatcher.
-    setCurrentCell(CellUtil.createLastOnRowCol(kv));
+    setCurrentCell(PrivateCellUtil.createLastOnRowCol(kv));
 
     realSeekDone = true;
     return true;
@@ -492,14 +493,14 @@ public class StoreFileScanner implements KeyValueScanner {
         boolean keepSeeking = false;
         Cell key = originalKey;
         do {
-          Cell seekKey = CellUtil.createFirstOnRow(key);
+          Cell seekKey = PrivateCellUtil.createFirstOnRow(key);
           if (seekCount != null) seekCount.increment();
           if (!hfs.seekBefore(seekKey)) {
             this.cur = null;
             return false;
           }
           Cell curCell = hfs.getCell();
-          Cell firstKeyOfPreviousRow = CellUtil.createFirstOnRow(curCell);
+          Cell firstKeyOfPreviousRow = PrivateCellUtil.createFirstOnRow(curCell);
 
           if (seekCount != null) seekCount.increment();
           if (!seekAtOrAfter(hfs, firstKeyOfPreviousRow)) {
@@ -542,7 +543,7 @@ public class StoreFileScanner implements KeyValueScanner {
     if (!lastRow.isPresent()) {
       return false;
     }
-    Cell seekKey = CellUtil.createFirstOnRow(lastRow.get());
+    Cell seekKey = PrivateCellUtil.createFirstOnRow(lastRow.get());
     if (seek(seekKey)) {
       return true;
     } else {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java
index 5fc96ef..142e3c8 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileWriter.java
@@ -40,6 +40,7 @@ import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.ColumnFamilyDescriptorBuilder;
 import org.apache.hadoop.hbase.io.hfile.CacheConfig;
@@ -218,7 +219,7 @@ public class StoreFileWriter implements CellSink, ShipperListener {
 
   private void appendDeleteFamilyBloomFilter(final Cell cell)
       throws IOException {
-    if (!CellUtil.isDeleteFamily(cell) && !CellUtil.isDeleteFamilyVersion(cell)) {
+    if (!PrivateCellUtil.isDeleteFamily(cell) && !PrivateCellUtil.isDeleteFamilyVersion(cell)) {
       return;
     }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java
index 76dbb6b..43079a6 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java
@@ -35,6 +35,7 @@ import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.DoNotRetryIOException;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.client.IsolationLevel;
@@ -397,7 +398,7 @@ public class StoreScanner extends NonReversedNonLazyKeyValueScanner
           scanner.seek(seekKey);
           Cell c = scanner.peek();
           if (c != null) {
-            totalScannersSoughtBytes += CellUtil.estimatedSerializedSizeOf(c);
+            totalScannersSoughtBytes += PrivateCellUtil.estimatedSerializedSizeOf(c);
           }
         }
       } else {
@@ -568,7 +569,7 @@ public class StoreScanner extends NonReversedNonLazyKeyValueScanner
         ++kvsScanned;
       }
       checkScanOrder(prevCell, cell, comparator);
-      int cellSize = CellUtil.estimatedSerializedSizeOf(cell);
+      int cellSize = PrivateCellUtil.estimatedSerializedSizeOf(cell);
       bytesRead += cellSize;
       prevCell = cell;
       scannerContext.setLastPeekedCell(cell);
@@ -606,7 +607,8 @@ public class StoreScanner extends NonReversedNonLazyKeyValueScanner
             totalBytesRead += cellSize;
 
             // Update the progress of the scanner context
-            scannerContext.incrementSizeProgress(cellSize, CellUtil.estimatedHeapSizeOf(cell));
+            scannerContext.incrementSizeProgress(cellSize,
+              PrivateCellUtil.estimatedHeapSizeOf(cell));
             scannerContext.incrementBatchProgress(1);
 
             if (matcher.isUserScan() && totalBytesRead > maxRowSize) {
@@ -940,7 +942,7 @@ public class StoreScanner extends NonReversedNonLazyKeyValueScanner
   }
 
   protected boolean seekToNextRow(Cell c) throws IOException {
-    return reseek(CellUtil.createLastOnRow(c));
+    return reseek(PrivateCellUtil.createLastOnRow(c));
   }
 
   /**
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java
index 0456980..732fc06 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StripeMultiFileWriter.java
@@ -29,6 +29,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.util.Bytes;
 
@@ -297,7 +298,7 @@ public abstract class StripeMultiFileWriter extends AbstractMultiFileWriter {
         sanityCheckLeft(left, cell);
         doCreateWriter = true;
       } else if (lastRowInCurrentWriter != null
-          && !CellUtil.matchingRow(cell, lastRowInCurrentWriter, 0,
+          && !PrivateCellUtil.matchingRows(cell, lastRowInCurrentWriter, 0,
             lastRowInCurrentWriter.length)) {
         if (LOG.isDebugEnabled()) {
           LOG.debug("Stopping to use a writer after [" + Bytes.toString(lastRowInCurrentWriter)
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/TimeRangeTracker.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/TimeRangeTracker.java
index 203bea3..ba5332f 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/TimeRangeTracker.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/TimeRangeTracker.java
@@ -25,6 +25,7 @@ import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.io.TimeRange;
 import org.apache.yetus.audience.InterfaceAudience;
 
@@ -102,7 +103,7 @@ public abstract class TimeRangeTracker {
    */
   public void includeTimestamp(final Cell cell) {
     includeTimestamp(cell.getTimestamp());
-    if (CellUtil.isDeleteColumnOrFamily(cell)) {
+    if (PrivateCellUtil.isDeleteColumnOrFamily(cell)) {
       includeTimestamp(0);
     }
   }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java
index dc1f41c..6ed8fef 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/Compactor.java
@@ -33,8 +33,8 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.io.compress.Compression;
 import org.apache.hadoop.hbase.io.hfile.HFile;
@@ -390,7 +390,7 @@ public abstract class Compactor<T extends CellSink> {
           if (cleanSeqId && c.getSequenceId() <= smallestReadPoint) {
             lastCleanCell = c;
             lastCleanCellSeqId = c.getSequenceId();
-            CellUtil.setSequenceId(c, 0);
+            PrivateCellUtil.setSequenceId(c, 0);
           } else {
             lastCleanCell = null;
             lastCleanCellSeqId = 0;
@@ -420,7 +420,7 @@ public abstract class Compactor<T extends CellSink> {
               // HBASE-16931, set back sequence id to avoid affecting scan order unexpectedly.
               // ShipperListener will do a clone of the last cells it refer, so need to set back
               // sequence id before ShipperListener.beforeShipped
-              CellUtil.setSequenceId(lastCleanCell, lastCleanCellSeqId);
+              PrivateCellUtil.setSequenceId(lastCleanCell, lastCleanCellSeqId);
             }
             // Clone the cells that are in the writer so that they are freed of references,
             // if they are holding any.
@@ -437,7 +437,7 @@ public abstract class Compactor<T extends CellSink> {
         }
         if (lastCleanCell != null) {
           // HBASE-16931, set back sequence id to avoid affecting scan order unexpectedly
-          CellUtil.setSequenceId(lastCleanCell, lastCleanCellSeqId);
+          PrivateCellUtil.setSequenceId(lastCleanCell, lastCleanCellSeqId);
         }
         // Log the progress of long running compactions every minute if
         // logging at DEBUG level
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ExplicitColumnTracker.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ExplicitColumnTracker.java
index 16a22da..099b5df 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ExplicitColumnTracker.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ExplicitColumnTracker.java
@@ -23,6 +23,7 @@ import java.util.NavigableSet;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.querymatcher.ScanQueryMatcher.MatchCode;
 
@@ -103,7 +104,7 @@ public class ExplicitColumnTracker implements ColumnTracker {
   public ScanQueryMatcher.MatchCode checkColumn(Cell cell, byte type) {
     // delete markers should never be passed to an
     // *Explicit*ColumnTracker
-    assert !CellUtil.isDelete(type);
+    assert !PrivateCellUtil.isDelete(type);
     do {
       // No more columns left, we are done with this query
       if (done()) {
@@ -152,7 +153,7 @@ public class ExplicitColumnTracker implements ColumnTracker {
   @Override
   public ScanQueryMatcher.MatchCode checkVersions(Cell cell, long timestamp, byte type,
       boolean ignoreCount) throws IOException {
-    assert !CellUtil.isDelete(type);
+    assert !PrivateCellUtil.isDelete(type);
     if (ignoreCount) {
       return ScanQueryMatcher.MatchCode.INCLUDE;
     }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java
index 5d4077f..89b6287 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MajorCompactionScanQueryMatcher.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.ScanInfo;
 
@@ -58,7 +59,7 @@ public class MajorCompactionScanQueryMatcher extends DropDeletesCompactionScanQu
     // 7. Delete marker need to be version counted together with puts
     // they affect
     //
-    if (CellUtil.isDelete(typeByte)) {
+    if (PrivateCellUtil.isDelete(typeByte)) {
       if (mvccVersion > maxReadPointToTrackVersions) {
         // We can not drop this delete marker yet, and also we should not use this delete marker to
         // mask any cell yet.
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java
index 989ea12..2d60ace 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/MinorCompactionScanQueryMatcher.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.ScanInfo;
 
@@ -43,7 +44,7 @@ public class MinorCompactionScanQueryMatcher extends CompactionScanQueryMatcher
     }
     long mvccVersion = cell.getSequenceId();
     byte typeByte = cell.getTypeByte();
-    if (CellUtil.isDelete(typeByte)) {
+    if (PrivateCellUtil.isDelete(typeByte)) {
       if (mvccVersion > maxReadPointToTrackVersions) {
         // we should not use this delete marker to mask any cell yet.
         return MatchCode.INCLUDE;
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NewVersionBehaviorTracker.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NewVersionBehaviorTracker.java
index d7bec80..4027766 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NewVersionBehaviorTracker.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NewVersionBehaviorTracker.java
@@ -30,6 +30,7 @@ import java.util.TreeSet;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.querymatcher.ScanQueryMatcher.MatchCode;
@@ -165,7 +166,8 @@ public class NewVersionBehaviorTracker implements ColumnTracker, DeleteTracker {
    * Else return MAX_VALUE.
    */
   protected long prepare(Cell cell) {
-    boolean matchCq = CellUtil.matchingQualifier(cell, lastCqArray, lastCqOffset, lastCqLength);
+    boolean matchCq =
+        PrivateCellUtil.matchingQualifier(cell, lastCqArray, lastCqOffset, lastCqLength);
     if (!matchCq) {
       // The last cell is family-level delete and this is not, or the cq is changed,
       // we should construct delColMap as a deep copy of delFamMap.
@@ -175,7 +177,7 @@ public class NewVersionBehaviorTracker implements ColumnTracker, DeleteTracker {
       }
       countCurrentCol = 0;
     }
-    if (matchCq && !CellUtil.isDelete(lastCqType) && lastCqType == cell.getTypeByte()
+    if (matchCq && !PrivateCellUtil.isDelete(lastCqType) && lastCqType == cell.getTypeByte()
         && lastCqTs == cell.getTimestamp()) {
       // Put with duplicate timestamp, ignore.
       return lastCqMvcc;
@@ -300,7 +302,7 @@ public class NewVersionBehaviorTracker implements ColumnTracker, DeleteTracker {
   @Override
   public MatchCode checkVersions(Cell cell, long timestamp, byte type,
       boolean ignoreCount) throws IOException {
-    assert !CellUtil.isDelete(type);
+    assert !PrivateCellUtil.isDelete(type);
     // We drop old version in #isDeleted, so here we won't SKIP because of versioning. But we should
     // consider TTL.
     if (ignoreCount) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java
index c633bc5..05413b6 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/NormalUserScanQueryMatcher.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeepDeletedCells;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.client.Scan;
@@ -66,7 +67,7 @@ public abstract class NormalUserScanQueryMatcher extends UserScanQueryMatcher {
     }
     long timestamp = cell.getTimestamp();
     byte typeByte = cell.getTypeByte();
-    if (CellUtil.isDelete(typeByte)) {
+    if (PrivateCellUtil.isDelete(typeByte)) {
       boolean includeDeleteMarker = seePastDeleteMarkers ? tr.withinTimeRange(timestamp)
           : tr.withinOrAfterTimeRange(timestamp);
       if (includeDeleteMarker) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanQueryMatcher.java
index 8c1c4a3..c636333 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanQueryMatcher.java
@@ -25,6 +25,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.KeyValueUtil;
@@ -148,7 +149,7 @@ public abstract class ScanQueryMatcher implements ShipperListener {
     // Look for a TTL tag first. Use it instead of the family setting if
     // found. If a cell has multiple TTLs, resolve the conflict by using the
     // first tag encountered.
-    Iterator<Tag> i = CellUtil.tagsIterator(cell);
+    Iterator<Tag> i = PrivateCellUtil.tagsIterator(cell);
     while (i.hasNext()) {
       Tag t = i.next();
       if (TagType.TTL_TAG_TYPE == t.getType()) {
@@ -296,7 +297,7 @@ public abstract class ScanQueryMatcher implements ShipperListener {
     // see TestFromClientSide3#testScanAfterDeletingSpecifiedRow
     // see TestFromClientSide3#testScanAfterDeletingSpecifiedRowV2
     if (cell.getQualifierLength() == 0) {
-      Cell nextKey = CellUtil.createNextOnRowCol(cell);
+      Cell nextKey = PrivateCellUtil.createNextOnRowCol(cell);
       if (nextKey != cell) {
         return nextKey;
       }
@@ -305,10 +306,10 @@ public abstract class ScanQueryMatcher implements ShipperListener {
     }
     ColumnCount nextColumn = columns.getColumnHint();
     if (nextColumn == null) {
-      return CellUtil.createLastOnRowCol(cell);
+      return PrivateCellUtil.createLastOnRowCol(cell);
     } else {
-      return CellUtil.createFirstOnRowCol(cell, nextColumn.getBuffer(), nextColumn.getOffset(),
-        nextColumn.getLength());
+      return PrivateCellUtil.createFirstOnRowCol(cell, nextColumn.getBuffer(),
+        nextColumn.getOffset(), nextColumn.getLength());
     }
   }
 
@@ -318,7 +319,7 @@ public abstract class ScanQueryMatcher implements ShipperListener {
    * @return result of the compare between the indexed key and the key portion of the passed cell
    */
   public int compareKeyForNextRow(Cell nextIndexed, Cell currentCell) {
-    return CellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell, 0, 0, null, 0,
+    return PrivateCellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell, 0, 0, null, 0,
       0, HConstants.OLDEST_TIMESTAMP, Type.Minimum.getCode());
   }
 
@@ -330,10 +331,10 @@ public abstract class ScanQueryMatcher implements ShipperListener {
   public int compareKeyForNextColumn(Cell nextIndexed, Cell currentCell) {
     ColumnCount nextColumn = columns.getColumnHint();
     if (nextColumn == null) {
-      return CellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell, 0, 0, null,
+      return PrivateCellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell, 0, 0, null,
         0, 0, HConstants.OLDEST_TIMESTAMP, Type.Minimum.getCode());
     } else {
-      return CellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell,
+      return PrivateCellUtil.compareKeyBasedOnColHint(rowComparator, nextIndexed, currentCell,
         currentCell.getFamilyOffset(), currentCell.getFamilyLength(), nextColumn.getBuffer(),
         nextColumn.getOffset(), nextColumn.getLength(), HConstants.LATEST_TIMESTAMP,
         Type.Maximum.getCode());
@@ -353,7 +354,7 @@ public abstract class ScanQueryMatcher implements ShipperListener {
   @Override
   public void beforeShipped() throws IOException {
     if (this.currentRow != null) {
-      this.currentRow = CellUtil.createFirstOnRow(CellUtil.copyRow(this.currentRow));
+      this.currentRow = PrivateCellUtil.createFirstOnRow(CellUtil.copyRow(this.currentRow));
     }
     if (columns != null) {
       columns.beforeShipped();
@@ -361,7 +362,7 @@ public abstract class ScanQueryMatcher implements ShipperListener {
   }
 
   protected static Cell createStartKeyFromRow(byte[] startRow, ScanInfo scanInfo) {
-    return CellUtil.createFirstDeleteFamilyCellOnRow(startRow, scanInfo.getFamily());
+    return PrivateCellUtil.createFirstDeleteFamilyCellOnRow(startRow, scanInfo.getFamily());
   }
 
   protected static Pair<DeleteTracker, ColumnTracker> getTrackers(RegionCoprocessorHost host,
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanWildcardColumnTracker.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanWildcardColumnTracker.java
index 02267bf..59f9919 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanWildcardColumnTracker.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/ScanWildcardColumnTracker.java
@@ -24,6 +24,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.querymatcher.ScanQueryMatcher.MatchCode;
@@ -130,7 +131,7 @@ public class ScanWildcardColumnTracker implements ColumnTracker {
    * delete
    */
   private MatchCode checkVersion(byte type, long timestamp) {
-    if (!CellUtil.isDelete(type)) {
+    if (!PrivateCellUtil.isDelete(type)) {
       currentCount++;
     }
     if (currentCount > maxVersions) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java
index ed0123d..ab9aca7 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/StripeCompactionScanQueryMatcher.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.regionserver.ScanInfo;
 
@@ -56,7 +57,7 @@ public class StripeCompactionScanQueryMatcher extends DropDeletesCompactionScanQ
     }
     long mvccVersion = cell.getSequenceId();
     byte typeByte = cell.getTypeByte();
-    if (CellUtil.isDelete(typeByte)) {
+    if (PrivateCellUtil.isDelete(typeByte)) {
       if (mvccVersion > maxReadPointToTrackVersions) {
         return MatchCode.INCLUDE;
       }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/UserScanQueryMatcher.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/UserScanQueryMatcher.java
index 16afa83..7501594 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/UserScanQueryMatcher.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/querymatcher/UserScanQueryMatcher.java
@@ -22,6 +22,7 @@ import java.util.NavigableSet;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.client.Scan;
@@ -63,7 +64,7 @@ public abstract class UserScanQueryMatcher extends ScanQueryMatcher {
     if (scan.includeStartRow()) {
       return createStartKeyFromRow(scan.getStartRow(), scanInfo);
     } else {
-      return CellUtil.createLastOnRow(scan.getStartRow());
+      return PrivateCellUtil.createLastOnRow(scan.getStartRow());
     }
   }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/AbstractFSWAL.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/AbstractFSWAL.java
index 8455968..f8b27c0 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/AbstractFSWAL.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/AbstractFSWAL.java
@@ -53,8 +53,8 @@ import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.fs.PathFilter;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.client.RegionInfo;
 import org.apache.hadoop.hbase.exceptions.TimeoutIOException;
 import org.apache.hadoop.hbase.io.util.MemorySizeUtil;
@@ -936,7 +936,7 @@ public abstract class AbstractFSWAL<W extends WriterBase> implements WAL {
     long len = 0;
     if (!listeners.isEmpty()) {
       for (Cell cell : e.getEdit().getCells()) {
-        len += CellUtil.estimatedSerializedSizeOf(cell);
+        len += PrivateCellUtil.estimatedSerializedSizeOf(cell);
       }
       for (WALActionsListener listener : listeners) {
         listener.postAppend(len, elapsedTime, e.getKey(), e.getEdit());
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/FSWALEntry.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/FSWALEntry.java
index 0b798a8..88092f1 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/FSWALEntry.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/FSWALEntry.java
@@ -28,6 +28,7 @@ import java.util.TreeSet;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.client.RegionInfo;
 import org.apache.hadoop.hbase.regionserver.MultiVersionConcurrencyControl;
 import org.apache.hadoop.hbase.util.Bytes;
@@ -116,7 +117,7 @@ class FSWALEntry extends Entry {
     long regionSequenceId = we.getWriteNumber();
     if (!this.getEdit().isReplay() && inMemstore) {
       for (Cell c : getEdit().getCells()) {
-        CellUtil.setSequenceId(c, regionSequenceId);
+        PrivateCellUtil.setSequenceId(c, regionSequenceId);
       }
     }
     getKey().setWriteEntry(we);
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/SecureWALCellCodec.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/SecureWALCellCodec.java
index eec0497..469d692 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/SecureWALCellCodec.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/SecureWALCellCodec.java
@@ -28,7 +28,7 @@ import org.apache.commons.io.IOUtils;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.codec.KeyValueCodecWithTags;
@@ -208,19 +208,19 @@ public class SecureWALCellCodec extends WALCellCodec {
       // Write row, qualifier, and family
       short rowLength = cell.getRowLength();
       StreamUtils.writeRawVInt32(bos, rowLength);
-      CellUtil.writeRow(bos, cell, rowLength);
+      PrivateCellUtil.writeRow(bos, cell, rowLength);
       byte familyLength = cell.getFamilyLength();
       StreamUtils.writeRawVInt32(bos, familyLength);
-      CellUtil.writeFamily(bos, cell, familyLength);
+      PrivateCellUtil.writeFamily(bos, cell, familyLength);
       int qualifierLength = cell.getQualifierLength();
       StreamUtils.writeRawVInt32(bos, qualifierLength);
-      CellUtil.writeQualifier(bos, cell, qualifierLength);
+      PrivateCellUtil.writeQualifier(bos, cell, qualifierLength);
       // Write the rest ie. ts, type, value and tags parts
       StreamUtils.writeLong(bos, cell.getTimestamp());
       bos.write(cell.getTypeByte());
-      CellUtil.writeValue(bos, cell, cell.getValueLength());
+      PrivateCellUtil.writeValue(bos, cell, cell.getValueLength());
       if (tlen > 0) {
-        CellUtil.writeTags(bos, cell, tlen);
+        PrivateCellUtil.writeTags(bos, cell, tlen);
       }
       bos.close();
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/WALCellCodec.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/WALCellCodec.java
index 50f8e13..7ad6bd3 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/WALCellCodec.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/WALCellCodec.java
@@ -26,6 +26,7 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -208,21 +209,21 @@ public class WALCellCodec implements Codec {
       // To support tags
       int tagsLength = cell.getTagsLength();
       StreamUtils.writeRawVInt32(out, tagsLength);
-      CellUtil.compressRow(out, cell, compression.rowDict);
-      CellUtil.compressFamily(out, cell, compression.familyDict);
-      CellUtil.compressQualifier(out, cell, compression.qualifierDict);
+      PrivateCellUtil.compressRow(out, cell, compression.rowDict);
+      PrivateCellUtil.compressFamily(out, cell, compression.familyDict);
+      PrivateCellUtil.compressQualifier(out, cell, compression.qualifierDict);
       // Write timestamp, type and value as uncompressed.
       StreamUtils.writeLong(out, cell.getTimestamp());
       out.write(cell.getTypeByte());
-      CellUtil.writeValue(out, cell, cell.getValueLength());
+      PrivateCellUtil.writeValue(out, cell, cell.getValueLength());
       if (tagsLength > 0) {
         if (compression.tagCompressionContext != null) {
           // Write tags using Dictionary compression
-          CellUtil.compressTags(out, cell, compression.tagCompressionContext);
+          PrivateCellUtil.compressTags(out, cell, compression.tagCompressionContext);
         } else {
           // Tag compression is disabled within the WAL compression. Just write the tags bytes as
           // it is.
-          CellUtil.writeTags(out, cell, tagsLength);
+          PrivateCellUtil.writeTags(out, cell, tagsLength);
         }
       }
     }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSink.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSink.java
index 0fbc74f..05b1f21 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSink.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSink.java
@@ -305,7 +305,7 @@ public class ReplicationSink {
    */
   private boolean isNewRowOrType(final Cell previousCell, final Cell cell) {
     return previousCell == null || previousCell.getTypeByte() != cell.getTypeByte() ||
-        !CellUtil.matchingRow(previousCell, cell);
+        !CellUtil.matchingRows(previousCell, cell);
   }
 
   private java.util.UUID toUUID(final HBaseProtos.UUID uuid) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlFilter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlFilter.java
index 9fc63e1..bfc415c 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlFilter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlFilter.java
@@ -24,6 +24,7 @@ import java.util.Map;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.exceptions.DeserializationException;
 import org.apache.hadoop.hbase.filter.FilterBase;
@@ -97,7 +98,7 @@ class AccessControlFilter extends FilterBase {
       return ReturnCode.INCLUDE;
     }
     if (prevFam.getBytes() == null
-        || !(CellUtil.matchingFamily(cell, prevFam.getBytes(), prevFam.getOffset(),
+        || !(PrivateCellUtil.matchingFamily(cell, prevFam.getBytes(), prevFam.getOffset(),
             prevFam.getLength()))) {
       prevFam.set(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());
       // Similar to VisibilityLabelFilter
@@ -106,7 +107,7 @@ class AccessControlFilter extends FilterBase {
       prevQual.unset();
     }
     if (prevQual.getBytes() == null
-        || !(CellUtil.matchingQualifier(cell, prevQual.getBytes(), prevQual.getOffset(),
+        || !(PrivateCellUtil.matchingQualifier(cell, prevQual.getBytes(), prevQual.getOffset(),
             prevQual.getLength()))) {
       prevQual.set(cell.getQualifierArray(), cell.getQualifierOffset(),
           cell.getQualifierLength());
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java
index 6c2eb60..4e67f6e 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java
@@ -19,6 +19,7 @@
 package org.apache.hadoop.hbase.security.access;
 
 import org.apache.hadoop.hbase.CompareOperator;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.client.Admin;
 import org.apache.hadoop.hbase.shaded.com.google.common.collect.ArrayListMultimap;
 import org.apache.hadoop.hbase.shaded.com.google.common.collect.ListMultimap;
@@ -739,7 +740,7 @@ public class AccessControlLists {
       return null;
     }
     List<Permission> results = Lists.newArrayList();
-    Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsIterator = PrivateCellUtil.tagsIterator(cell);
     while (tagsIterator.hasNext()) {
       Tag tag = tagsIterator.next();
       if (tag.getType() == ACL_TAG_TYPE) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java
index 334d1ed..0a4f22c 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java
@@ -52,6 +52,7 @@ import org.apache.hadoop.hbase.CoprocessorEnvironment;
 import org.apache.hadoop.hbase.DoNotRetryIOException;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.NamespaceDescriptor;
@@ -892,11 +893,11 @@ public class AccessController implements MasterCoprocessor, RegionCoprocessor,
         // Prepend the supplied perms in a new ACL tag to an update list of tags for the cell
         List<Tag> tags = new ArrayList<>();
         tags.add(new ArrayBackedTag(AccessControlLists.ACL_TAG_TYPE, perms));
-        Iterator<Tag> tagIterator = CellUtil.tagsIterator(cell);
+        Iterator<Tag> tagIterator = PrivateCellUtil.tagsIterator(cell);
         while (tagIterator.hasNext()) {
           tags.add(tagIterator.next());
         }
-        newCells.add(CellUtil.createCell(cell, tags));
+        newCells.add(PrivateCellUtil.createCell(cell, tags));
       }
       // This is supposed to be safe, won't CME
       e.setValue(newCells);
@@ -921,7 +922,7 @@ public class AccessController implements MasterCoprocessor, RegionCoprocessor,
       return;
     }
     for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {
-      Iterator<Tag> tagsItr = CellUtil.tagsIterator(cellScanner.current());
+      Iterator<Tag> tagsItr = PrivateCellUtil.tagsIterator(cellScanner.current());
       while (tagsItr.hasNext()) {
         if (tagsItr.next().getType() == AccessControlLists.ACL_TAG_TYPE) {
           throw new AccessDeniedException("Mutation contains cell with reserved type tag");
@@ -2059,7 +2060,7 @@ public class AccessController implements MasterCoprocessor, RegionCoprocessor,
     List<Tag> aclTags = Lists.newArrayList();
     ListMultimap<String,Permission> perms = ArrayListMultimap.create();
     if (oldCell != null) {
-      Iterator<Tag> tagIterator = CellUtil.tagsIterator(oldCell);
+      Iterator<Tag> tagIterator = PrivateCellUtil.tagsIterator(oldCell);
       while (tagIterator.hasNext()) {
         Tag tag = tagIterator.next();
         if (tag.getType() != AccessControlLists.ACL_TAG_TYPE) {
@@ -2098,7 +2099,7 @@ public class AccessController implements MasterCoprocessor, RegionCoprocessor,
       return newCell;
     }
 
-    Cell rewriteCell = CellUtil.createCell(newCell, tags);
+    Cell rewriteCell = PrivateCellUtil.createCell(newCell, tags);
     return rewriteCell;
   }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/DefaultVisibilityLabelServiceImpl.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/DefaultVisibilityLabelServiceImpl.java
index 5bd7c3f..e913b21 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/DefaultVisibilityLabelServiceImpl.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/DefaultVisibilityLabelServiceImpl.java
@@ -47,6 +47,7 @@ import org.apache.hadoop.hbase.AuthUtil;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants.OperationStatusCode;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagType;
 import org.apache.hadoop.hbase.TagUtil;
@@ -184,7 +185,7 @@ public class DefaultVisibilityLabelServiceImpl implements VisibilityLabelService
         if (CellUtil.matchingQualifier(cell, LABEL_QUALIFIER)) {
           labels.put(
               Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()),
-              CellUtil.getRowAsInt(cell));
+              PrivateCellUtil.getRowAsInt(cell));
         } else {
           // These are user cells who has authorization for this label
           String user = Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(),
@@ -194,7 +195,7 @@ public class DefaultVisibilityLabelServiceImpl implements VisibilityLabelService
             auths = new ArrayList<>();
             userAuths.put(user, auths);
           }
-          auths.add(CellUtil.getRowAsInt(cell));
+          auths.add(PrivateCellUtil.getRowAsInt(cell));
         }
       }
     }
@@ -350,7 +351,7 @@ public class DefaultVisibilityLabelServiceImpl implements VisibilityLabelService
         scanner.next(results);
         if (results.isEmpty()) break;
         Cell cell = results.get(0);
-        int ordinal = CellUtil.getRowAsInt(cell);
+        int ordinal = PrivateCellUtil.getRowAsInt(cell);
         String label = this.labelsCache.getLabel(ordinal);
         if (label != null) {
           auths.add(label);
@@ -387,7 +388,7 @@ public class DefaultVisibilityLabelServiceImpl implements VisibilityLabelService
         scanner.next(results);
         if (results.isEmpty()) break;
         Cell cell = results.get(0);
-        int ordinal = CellUtil.getRowAsInt(cell);
+        int ordinal = PrivateCellUtil.getRowAsInt(cell);
         String label = this.labelsCache.getLabel(ordinal);
         if (label != null) {
           auths.add(label);
@@ -491,7 +492,7 @@ public class DefaultVisibilityLabelServiceImpl implements VisibilityLabelService
       @Override
       public boolean evaluate(Cell cell) throws IOException {
         boolean visibilityTagPresent = false;
-        Iterator<Tag> tagsItr = CellUtil.tagsIterator(cell);
+        Iterator<Tag> tagsItr = PrivateCellUtil.tagsIterator(cell);
         while (tagsItr.hasNext()) {
           boolean includeKV = true;
           Tag tag = tagsItr.next();
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java
index a3841aa..84edf37 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityController.java
@@ -44,13 +44,13 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.AuthUtil;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellScanner;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.CoprocessorEnvironment;
 import org.apache.hadoop.hbase.DoNotRetryIOException;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
 import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.MetaTableAccessor;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.Tag;
@@ -58,7 +58,6 @@ import org.apache.hadoop.hbase.TagType;
 import org.apache.hadoop.hbase.TagUtil;
 import org.apache.hadoop.hbase.client.Admin;
 import org.apache.hadoop.hbase.client.Append;
-import org.apache.hadoop.hbase.client.ColumnFamilyDescriptor;
 import org.apache.hadoop.hbase.client.Delete;
 import org.apache.hadoop.hbase.client.Get;
 import org.apache.hadoop.hbase.client.Increment;
@@ -369,13 +368,13 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
             List<Cell> updatedCells = new ArrayList<>();
             for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {
               Cell cell = cellScanner.current();
-              List<Tag> tags = CellUtil.getTags(cell);
+              List<Tag> tags = PrivateCellUtil.getTags(cell);
               if (modifiedTagFound) {
                 // Rewrite the tags by removing the modified tags.
                 removeReplicationVisibilityTag(tags);
               }
               tags.addAll(visibilityTags);
-              Cell updatedCell = CellUtil.createCell(cell, tags);
+              Cell updatedCell = PrivateCellUtil.createCell(cell, tags);
               updatedCells.add(updatedCell);
             }
             m.getFamilyCellMap().clear();
@@ -428,7 +427,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
 
     if (result.size() < get.getMaxVersions()) {
       // Nothing to delete
-      CellUtil.updateLatestStamp(cell, byteNow, 0);
+      PrivateCellUtil.updateLatestStamp(cell, byteNow, 0);
       return;
     }
     if (result.size() > get.getMaxVersions()) {
@@ -436,7 +435,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
           + ". Results more than the max versions obtained.");
     }
     Cell getCell = result.get(get.getMaxVersions() - 1);
-    CellUtil.setTimestamp(cell, getCell.getTimestamp());
+    PrivateCellUtil.setTimestamp(cell, getCell.getTimestamp());
 
     // We are bypassing here because in the HRegion.updateDeleteLatestVersionTimeStamp we would
     // update with the current timestamp after again doing a get. As the hook as already determined
@@ -472,7 +471,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
       // cell visiblilty tags
       // have been modified
       Tag modifiedTag = null;
-      Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+      Iterator<Tag> tagsIterator = PrivateCellUtil.tagsIterator(cell);
       while (tagsIterator.hasNext()) {
         Tag tag = tagsIterator.next();
         if (tag.getType() == TagType.STRING_VIS_TAG_TYPE) {
@@ -484,7 +483,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
       pair.setSecond(modifiedTag);
       return pair;
     }
-    Iterator<Tag> tagsItr = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsItr = PrivateCellUtil.tagsIterator(cell);
     while (tagsItr.hasNext()) {
       if (RESERVED_VIS_TAG_TYPES.contains(tagsItr.next().getType())) {
         return pair;
@@ -514,7 +513,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
     if (isSystemOrSuperUser()) {
       return true;
     }
-    Iterator<Tag> tagsItr = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsItr = PrivateCellUtil.tagsIterator(cell);
     while (tagsItr.hasNext()) {
       if (RESERVED_VIS_TAG_TYPES.contains(tagsItr.next().getType())) {
         return false;
@@ -731,7 +730,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
     tags.addAll(this.visibilityLabelService.createVisibilityExpTags(cellVisibility.getExpression(),
         true, authCheck));
     // Carry forward all other tags
-    Iterator<Tag> tagsItr = CellUtil.tagsIterator(newCell);
+    Iterator<Tag> tagsItr = PrivateCellUtil.tagsIterator(newCell);
     while (tagsItr.hasNext()) {
       Tag tag = tagsItr.next();
       if (tag.getType() != TagType.VISIBILITY_TAG_TYPE
@@ -740,7 +739,7 @@ public class VisibilityController implements MasterCoprocessor, RegionCoprocesso
       }
     }
 
-    Cell rewriteCell = CellUtil.createCell(newCell, tags);
+    Cell rewriteCell = PrivateCellUtil.createCell(newCell, tags);
     return rewriteCell;
   }
 
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityLabelFilter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityLabelFilter.java
index f9a04cc..2bde9b5 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityLabelFilter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityLabelFilter.java
@@ -23,6 +23,7 @@ import java.util.Map;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.filter.FilterBase;
 import org.apache.hadoop.hbase.util.ByteRange;
 import org.apache.hadoop.hbase.util.SimpleMutableByteRange;
@@ -58,7 +59,7 @@ class VisibilityLabelFilter extends FilterBase {
   @Override
   public ReturnCode filterCell(final Cell cell) throws IOException {
     if (curFamily.getBytes() == null
-        || !(CellUtil.matchingFamily(cell, curFamily.getBytes(), curFamily.getOffset(),
+        || !(PrivateCellUtil.matchingFamily(cell, curFamily.getBytes(), curFamily.getOffset(),
             curFamily.getLength()))) {
       curFamily.set(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());
       // For this family, all the columns can have max of curFamilyMaxVersions versions. No need to
@@ -68,9 +69,8 @@ class VisibilityLabelFilter extends FilterBase {
       // Family is changed. Just unset curQualifier.
       curQualifier.unset();
     }
-    if (curQualifier.getBytes() == null
-        || !(CellUtil.matchingQualifier(cell, curQualifier.getBytes(), curQualifier.getOffset(),
-            curQualifier.getLength()))) {
+    if (curQualifier.getBytes() == null || !(PrivateCellUtil.matchingQualifier(cell,
+      curQualifier.getBytes(), curQualifier.getOffset(), curQualifier.getLength()))) {
       curQualifier.set(cell.getQualifierArray(), cell.getQualifierOffset(),
           cell.getQualifierLength());
       curQualMetVersions = 0;
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityReplicationEndpoint.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityReplicationEndpoint.java
index b9a1203..4c86323 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityReplicationEndpoint.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityReplicationEndpoint.java
@@ -29,6 +29,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.hbase.ArrayBackedTag;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagType;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -101,7 +102,7 @@ public class VisibilityReplicationEndpoint implements ReplicationEndpoint {
                 continue;
               }
               // Recreate the cell with the new tags and the existing tags
-              Cell newCell = CellUtil.createCell(cell, nonVisTags);
+              Cell newCell = PrivateCellUtil.createCell(cell, nonVisTags);
               newEdit.add(newCell);
             } else {
               newEdit.add(cell);
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java
index 964c0f7..3fb66b8 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java
@@ -40,6 +40,7 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.ArrayBackedTag;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagType;
 import org.apache.hadoop.hbase.TagUtil;
@@ -212,7 +213,7 @@ public class VisibilityUtils {
    */
   public static Byte extractVisibilityTags(Cell cell, List<Tag> tags) {
     Byte serializationFormat = null;
-    Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsIterator = PrivateCellUtil.tagsIterator(cell);
     while (tagsIterator.hasNext()) {
       Tag tag = tagsIterator.next();
       if (tag.getType() == TagType.VISIBILITY_EXP_SERIALIZATION_FORMAT_TAG_TYPE) {
@@ -239,7 +240,7 @@ public class VisibilityUtils {
   public static Byte extractAndPartitionTags(Cell cell, List<Tag> visTags,
       List<Tag> nonVisTags) {
     Byte serializationFormat = null;
-    Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsIterator = PrivateCellUtil.tagsIterator(cell);
     while (tagsIterator.hasNext()) {
       Tag tag = tagsIterator.next();
       if (tag.getType() == TagType.VISIBILITY_EXP_SERIALIZATION_FORMAT_TAG_TYPE) {
@@ -255,7 +256,7 @@ public class VisibilityUtils {
   }
 
   public static boolean isVisibilityTagsPresent(Cell cell) {
-    Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+    Iterator<Tag> tagsIterator = PrivateCellUtil.tagsIterator(cell);
     while (tagsIterator.hasNext()) {
       Tag tag = tagsIterator.next();
       if (tag.getType() == VISIBILITY_TAG_TYPE) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/util/RowColBloomContext.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/util/RowColBloomContext.java
index 90cbcb0..0b9889f 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/util/RowColBloomContext.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/util/RowColBloomContext.java
@@ -24,6 +24,7 @@ import java.io.IOException;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparator;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.io.hfile.HFile.Writer;
 import org.apache.yetus.audience.InterfaceAudience;
 
@@ -41,9 +42,9 @@ public class RowColBloomContext extends BloomContext {
   @Override
   public void addLastBloomKey(Writer writer) throws IOException {
     if (this.getLastCell() != null) {
-      Cell firstOnRow = CellUtil.createFirstOnRowCol(this.getLastCell());
+      Cell firstOnRow = PrivateCellUtil.createFirstOnRowCol(this.getLastCell());
       // This copy happens only once when the writer is closed
-      byte[] key = CellUtil.getCellKeySerializedAsKeyValueKey(firstOnRow);
+      byte[] key = PrivateCellUtil.getCellKeySerializedAsKeyValueKey(firstOnRow);
       writer.appendFileInfo(LAST_BLOOM_KEY, key);
     }
   }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/DisabledWALProvider.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/DisabledWALProvider.java
index 1458631..76b65a7 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/DisabledWALProvider.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/DisabledWALProvider.java
@@ -31,8 +31,8 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.client.RegionInfo;
 import org.apache.hadoop.hbase.regionserver.wal.WALActionsListener;
 import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;
@@ -167,7 +167,7 @@ class DisabledWALProvider implements WALProvider {
         final long start = System.nanoTime();
         long len = 0;
         for (Cell cell : edits.getCells()) {
-          len += CellUtil.estimatedSerializedSizeOf(cell);
+          len += PrivateCellUtil.estimatedSerializedSizeOf(cell);
         }
         final long elapsed = (System.nanoTime() - start) / 1000000L;
         for (WALActionsListener listener : this.listeners) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALEdit.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALEdit.java
index 260e6db..2feb356 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALEdit.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALEdit.java
@@ -26,6 +26,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.RegionInfo;
 import org.apache.hadoop.hbase.codec.Codec;
@@ -166,7 +167,7 @@ public class WALEdit implements HeapSize {
   public long heapSize() {
     long ret = ClassSize.ARRAYLIST;
     for (Cell cell : cells) {
-      ret += CellUtil.estimatedHeapSizeOf(cell);
+      ret += PrivateCellUtil.estimatedHeapSizeOf(cell);
     }
     return ret;
   }
@@ -174,7 +175,7 @@ public class WALEdit implements HeapSize {
   public long estimatedSerializedSizeOf() {
     long ret = 0;
     for (Cell cell: cells) {
-      ret += CellUtil.estimatedSerializedSizeOf(cell);
+      ret += PrivateCellUtil.estimatedSerializedSizeOf(cell);
     }
     return ret;
   }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALPrettyPrinter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALPrettyPrinter.java
index d4c320b..839ea31 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALPrettyPrinter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALPrettyPrinter.java
@@ -41,6 +41,7 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseConfiguration;
 import org.apache.hadoop.hbase.HBaseInterfaceAudience;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagUtil;
 import org.apache.yetus.audience.InterfaceAudience;
@@ -339,7 +340,7 @@ public class WALPrettyPrinter {
     stringMap.put("vlen", cell.getValueLength());
     if (cell.getTagsLength() > 0) {
       List<String> tagsString = new ArrayList<>();
-      Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+      Iterator<Tag> tagsIterator = PrivateCellUtil.tagsIterator(cell);
       while (tagsIterator.hasNext()) {
         Tag tag = tagsIterator.next();
         tagsString.add((tag.getType()) + ":" + Bytes.toStringBinary(TagUtil.cloneValue(tag)));
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALSplitter.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALSplitter.java
index e39d7ab..215d2ed 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALSplitter.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/wal/WALSplitter.java
@@ -2354,7 +2354,7 @@ public class WALSplitter {
 
       boolean isNewRowOrType =
           previousCell == null || previousCell.getTypeByte() != cell.getTypeByte()
-              || !CellUtil.matchingRow(previousCell, cell);
+              || !CellUtil.matchingRows(previousCell, cell);
       if (isNewRowOrType) {
         // Create new mutation
         if (CellUtil.isDelete(cell)) {
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java
index 1a85997..dce04bd 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java
@@ -3464,7 +3464,7 @@ public class HBaseTestingUtility extends HBaseCommonTestingUtility {
     if (!result.isEmpty()) {
       // verify that we are on the row we want:
       Cell kv = result.get(0);
-      if (!CellUtil.matchingRow(kv, get.getRow())) {
+      if (!CellUtil.matchingRows(kv, get.getRow())) {
         result.clear();
       }
     }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/TestPartialResultsFromClientSide.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/TestPartialResultsFromClientSide.java
index d23b4e4..3b2b6fe 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/TestPartialResultsFromClientSide.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/TestPartialResultsFromClientSide.java
@@ -386,7 +386,7 @@ public class TestPartialResultsFromClientSide {
       // Estimate the cell heap size. One difference is that on server side, the KV Heap size is
       // estimated differently in case the cell is backed up by MSLAB byte[] (no overhead for
       // backing array). Thus below calculation is a bit brittle.
-      CELL_HEAP_SIZE = CellUtil.estimatedHeapSizeOf(result.rawCells()[0])
+      CELL_HEAP_SIZE = PrivateCellUtil.estimatedHeapSizeOf(result.rawCells()[0])
           - (ClassSize.ARRAY+3);
       if (LOG.isInfoEnabled()) LOG.info("Cell heap size: " + CELL_HEAP_SIZE);
       scanner.close();
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/TestServerSideScanMetricsFromClientSide.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/TestServerSideScanMetricsFromClientSide.java
index 7c0e471..2639821 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/TestServerSideScanMetricsFromClientSide.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/TestServerSideScanMetricsFromClientSide.java
@@ -144,7 +144,7 @@ public class TestServerSideScanMetricsFromClientSide {
       assertTrue(result.rawCells() != null);
       assertTrue(result.rawCells().length == 1);
 
-      CELL_HEAP_SIZE = CellUtil.estimatedHeapSizeOf(result.rawCells()[0]);
+      CELL_HEAP_SIZE = PrivateCellUtil.estimatedHeapSizeOf(result.rawCells()[0]);
       scanner.close();
     }
 
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/TestTagRewriteCell.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/TestTagRewriteCell.java
index 54ae775..686c934 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/TestTagRewriteCell.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/TestTagRewriteCell.java
@@ -31,7 +31,7 @@ public class TestTagRewriteCell {
   public void testHeapSize() {
     Cell originalCell = CellUtil.createCell(Bytes.toBytes("row"), Bytes.toBytes("value"));
     final int fakeTagArrayLength = 10;
-    Cell trCell = CellUtil.createCell(originalCell, new byte[fakeTagArrayLength]);
+    Cell trCell = PrivateCellUtil.createCell(originalCell, new byte[fakeTagArrayLength]);
 
     // Get the heapSize before the internal tags array in trCell are nuked
     long trCellHeapSize = ((HeapSize)trCell).heapSize();
@@ -39,7 +39,7 @@ public class TestTagRewriteCell {
     // Make another TagRewriteCell with the original TagRewriteCell
     // This happens on systems with more than one RegionObserver/Coproc loaded (such as
     // VisibilityController and AccessController)
-    Cell trCell2 = CellUtil.createCell(trCell, new byte[fakeTagArrayLength]);
+    Cell trCell2 = PrivateCellUtil.createCell(trCell, new byte[fakeTagArrayLength]);
 
     assertTrue("TagRewriteCell containing a TagRewriteCell's heapsize should be larger than a " +
         "single TagRewriteCell's heapsize", trCellHeapSize < ((HeapSize)trCell2).heapSize());
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncTableScanMetrics.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncTableScanMetrics.java
index b877dac..b30ba0b 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncTableScanMetrics.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestAsyncTableScanMetrics.java
@@ -27,8 +27,8 @@ import java.util.List;
 import java.util.concurrent.ForkJoinPool;
 
 import org.apache.commons.io.IOUtils;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.client.metrics.ScanMetrics;
 import org.apache.hadoop.hbase.testclassification.ClientTests;
@@ -147,7 +147,7 @@ public class TestAsyncTableScanMetrics {
     List<Result> results = pair.getFirst();
     assertEquals(3, results.size());
     long bytes = results.stream().flatMap(r -> Arrays.asList(r.rawCells()).stream())
-        .mapToLong(c -> CellUtil.estimatedSerializedSizeOf(c)).sum();
+        .mapToLong(c -> PrivateCellUtil.estimatedSerializedSizeOf(c)).sum();
     ScanMetrics scanMetrics = pair.getSecond();
     assertEquals(NUM_REGIONS, scanMetrics.countOfRegions.get());
     assertEquals(bytes, scanMetrics.countOfBytesInResults.get());
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java
index 85d84de..c8eea98 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java
@@ -59,6 +59,7 @@ import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
 import org.apache.hadoop.hbase.HRegionLocation;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeepDeletedCells;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.MiniHBaseCluster;
@@ -263,7 +264,7 @@ public class TestFromClientSide {
      s.setMaxVersions();
      scanner = h.getScanner(s);
      kvs = scanner.next().rawCells();
-     assertTrue(CellUtil.isDeleteFamily(kvs[0]));
+     assertTrue(PrivateCellUtil.isDeleteFamily(kvs[0]));
      assertArrayEquals(T3, CellUtil.cloneValue(kvs[1]));
      assertTrue(CellUtil.isDelete(kvs[2]));
      assertArrayEquals(T2, CellUtil.cloneValue(kvs[3]));
@@ -5064,7 +5065,7 @@ public class TestFromClientSide {
     int numBytes = 0;
     for (Result result : scanner.next(1)) {
       for (Cell cell: result.listCells()) {
-        numBytes += CellUtil.estimatedSerializedSizeOf(cell);
+        numBytes += PrivateCellUtil.estimatedSerializedSizeOf(cell);
       }
     }
     scanner.close();
@@ -5081,7 +5082,7 @@ public class TestFromClientSide {
     numBytes = 0;
     for (Result result : scanner.next(1)) {
       for (Cell cell: result.listCells()) {
-        numBytes += CellUtil.estimatedSerializedSizeOf(cell);
+        numBytes += PrivateCellUtil.estimatedSerializedSizeOf(cell);
       }
     }
     scanner.close();
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFilter.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFilter.java
index 070a26c..3779b32 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFilter.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/filter/TestFilter.java
@@ -282,7 +282,7 @@ public class TestFilter {
     scanner.next(results);
     for (Cell keyValue : results) {
       assertTrue("The rows with ROWS_TWO as row key should be appearing.",
-          CellUtil.matchingRow(keyValue, ROWS_THREE[1]));
+          CellUtil.matchingRows(keyValue, ROWS_THREE[1]));
     }
     // again try to reseek to a value before ROWS_THREE[1]
     scanner.reseek(ROWS_ONE[1]);
@@ -1720,7 +1720,7 @@ public class TestFilter {
       for (Cell kv : results) {
         LOG.info("row=" + row + ", result=" + kv.toString() +
             ", match=" + kvs[idx].toString());
-        assertTrue("Row mismatch", CellUtil.matchingRow(kv, kvs[idx]));
+        assertTrue("Row mismatch", CellUtil.matchingRows(kv, kvs[idx]));
         assertTrue("Family mismatch", CellUtil.matchingFamily(kv, kvs[idx]));
         assertTrue("Qualifier mismatch", CellUtil.matchingQualifier(kv, kvs[idx]));
         assertTrue("Value mismatch", CellUtil.matchingValue(kv, kvs[idx]));
@@ -1752,7 +1752,7 @@ public class TestFilter {
         LOG.info("row=" + row + ", result=" + kv.toString() +
             ", match=" + kvs[idx].toString());
 
-        assertTrue("Row mismatch", CellUtil.matchingRow(kv, kvs[idx]));
+        assertTrue("Row mismatch", CellUtil.matchingRows(kv, kvs[idx]));
         assertTrue("Family mismatch", CellUtil.matchingFamily(kv, kvs[idx]));
         assertTrue("Qualifier mismatch", CellUtil.matchingQualifier(kv, kvs[idx]));
         assertFalse("Should not have returned whole value", CellUtil.matchingValue(kv, kvs[idx]));
@@ -2078,7 +2078,7 @@ public class TestFilter {
     int i = 5;
     for (boolean done = true; done; i++) {
       done = scanner.next(results);
-      assertTrue(CellUtil.matchingRow(results.get(0), Bytes.toBytes("row" + i)));
+      assertTrue(CellUtil.matchingRows(results.get(0), Bytes.toBytes("row" + i)));
       assertEquals(Bytes.toInt(CellUtil.cloneValue(results.get(0))), i%2);
       results.clear();
     }
@@ -2096,7 +2096,7 @@ public class TestFilter {
     results = new ArrayList<>();
     for (i=0; i<=4; i+=2) {
       scanner.next(results);
-      assertTrue(CellUtil.matchingRow(results.get(0), Bytes.toBytes("row" + i)));
+      assertTrue(CellUtil.matchingRows(results.get(0), Bytes.toBytes("row" + i)));
       assertEquals(Bytes.toInt(CellUtil.cloneValue(results.get(0))), i%2);
       results.clear();
     }
@@ -2112,13 +2112,13 @@ public class TestFilter {
     results = new ArrayList<>();
     for (i=0; i<=4; i+=2) {
       scanner.next(results);
-      assertTrue(CellUtil.matchingRow(results.get(0), Bytes.toBytes("row" + i)));
+      assertTrue(CellUtil.matchingRows(results.get(0), Bytes.toBytes("row" + i)));
       assertEquals(Bytes.toInt(CellUtil.cloneValue(results.get(0))), i%2);
       results.clear();
     }
     for (i=5; i<=9; i++) {
       scanner.next(results);
-      assertTrue(CellUtil.matchingRow(results.get(0), Bytes.toBytes("row" + i)));
+      assertTrue(CellUtil.matchingRows(results.get(0), Bytes.toBytes("row" + i)));
       assertEquals(Bytes.toInt(CellUtil.cloneValue(results.get(0))), i%2);
       results.clear();
     }
@@ -2133,13 +2133,13 @@ public class TestFilter {
     results = new ArrayList<>();
     for (i=0; i<=4; i+=2) {
       scanner.next(results);
-      assertTrue(CellUtil.matchingRow(results.get(0), Bytes.toBytes("row" + i)));
+      assertTrue(CellUtil.matchingRows(results.get(0), Bytes.toBytes("row" + i)));
       assertEquals(Bytes.toInt(CellUtil.cloneValue(results.get(0))), i%2);
       results.clear();
     }
     for (i=5; i<=9; i++) {
       scanner.next(results);
-      assertTrue(CellUtil.matchingRow(results.get(0), Bytes.toBytes("row" + i)));
+      assertTrue(CellUtil.matchingRows(results.get(0), Bytes.toBytes("row" + i)));
       assertEquals(Bytes.toInt(CellUtil.cloneValue(results.get(0))), i%2);
       results.clear();
     }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestDataBlockEncoders.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestDataBlockEncoders.java
index 635d192..08edf06 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestDataBlockEncoders.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestDataBlockEncoders.java
@@ -39,6 +39,7 @@ import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.KeyValueUtil;
@@ -237,7 +238,7 @@ public class TestDataBlockEncoders {
     for (boolean seekBefore : new boolean[] { false, true }) {
       checkSeekingConsistency(encodedSeekers, seekBefore, sampleKv.get(sampleKv.size() - 1));
       KeyValue midKv = sampleKv.get(sampleKv.size() / 2);
-      Cell lastMidKv =CellUtil.createLastOnRowCol(midKv);
+      Cell lastMidKv =PrivateCellUtil.createLastOnRowCol(midKv);
       checkSeekingConsistency(encodedSeekers, seekBefore, lastMidKv);
     }
     LOG.info("Done");
@@ -292,9 +293,9 @@ public class TestDataBlockEncoders {
       do {
         KeyValue expectedKeyValue = sampleKv.get(i);
         Cell cell = seeker.getCell();
-        if (CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, expectedKeyValue,
+        if (PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, expectedKeyValue,
           cell) != 0) {
-          int commonPrefix = CellUtil
+          int commonPrefix = PrivateCellUtil
               .findCommonPrefixInFlatKey(expectedKeyValue, cell, false, true);
           fail(String.format("next() produces wrong results "
               + "encoder: %s i: %d commonPrefix: %d" + "\n expected %s\n actual      %s", encoder
@@ -327,8 +328,8 @@ public class TestDataBlockEncoders {
           getEncodingContext(Compression.Algorithm.NONE, encoding), this.useOffheapData);
       Cell key = encoder.getFirstKeyCellInBlock(new SingleByteBuff(encodedBuffer));
       KeyValue firstKv = sampleKv.get(0);
-      if (0 != CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, key, firstKv)) {
-        int commonPrefix = CellUtil.findCommonPrefixInFlatKey(key, firstKv, false, true);
+      if (0 != PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, key, firstKv)) {
+        int commonPrefix = PrivateCellUtil.findCommonPrefixInFlatKey(key, firstKv, false, true);
         fail(String.format("Bug in '%s' commonPrefix %d", encoder.toString(), commonPrefix));
       }
     }
@@ -346,7 +347,7 @@ public class TestDataBlockEncoders {
       Cell actualKeyValue = seeker.getCell();
       ByteBuffer actualKey = null;
       if (seeker instanceof PrefixTreeSeeker) {
-        byte[] serializedKey = CellUtil.getCellKeySerializedAsKeyValueKey(seeker.getKey());
+        byte[] serializedKey = PrivateCellUtil.getCellKeySerializedAsKeyValueKey(seeker.getKey());
         actualKey = ByteBuffer.wrap(KeyValueUtil.createKeyValueFromKey(serializedKey).getKey());
       } else {
         actualKey = ByteBuffer.wrap(((KeyValue) seeker.getKey()).getKey());
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestPrefixTreeEncoding.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestPrefixTreeEncoding.java
index 6732927..f325d8a 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestPrefixTreeEncoding.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestPrefixTreeEncoding.java
@@ -38,6 +38,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.Tag;
@@ -121,20 +122,21 @@ public class TestPrefixTreeEncoding {
     seeker.setCurrentBuffer(new SingleByteBuff(readBuffer));
 
     // Seek before the first keyvalue;
-    Cell seekKey = CellUtil.createFirstDeleteFamilyCellOnRow(getRowKey(batchId, 0), CF_BYTES);
+    Cell seekKey =
+        PrivateCellUtil.createFirstDeleteFamilyCellOnRow(getRowKey(batchId, 0), CF_BYTES);
     seeker.seekToKeyInBlock(seekKey, true);
     assertEquals(null, seeker.getCell());
 
     // Seek before the middle keyvalue;
-    seekKey = CellUtil.createFirstDeleteFamilyCellOnRow(getRowKey(batchId, NUM_ROWS_PER_BATCH / 3),
-        CF_BYTES);
+    seekKey = PrivateCellUtil
+        .createFirstDeleteFamilyCellOnRow(getRowKey(batchId, NUM_ROWS_PER_BATCH / 3), CF_BYTES);
     seeker.seekToKeyInBlock(seekKey, true);
     assertNotNull(seeker.getCell());
     assertArrayEquals(getRowKey(batchId, NUM_ROWS_PER_BATCH / 3 - 1),
       CellUtil.cloneRow(seeker.getCell()));
 
     // Seek before the last keyvalue;
-    seekKey = CellUtil.createFirstDeleteFamilyCellOnRow(Bytes.toBytes("zzzz"), CF_BYTES);
+    seekKey = PrivateCellUtil.createFirstDeleteFamilyCellOnRow(Bytes.toBytes("zzzz"), CF_BYTES);
     seeker.seekToKeyInBlock(seekKey, true);
     assertNotNull(seeker.getCell());
     assertArrayEquals(getRowKey(batchId, NUM_ROWS_PER_BATCH - 1),
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestSeekToBlockWithEncoders.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestSeekToBlockWithEncoders.java
index dfafdb8..23d3fbe 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestSeekToBlockWithEncoders.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/encoding/TestSeekToBlockWithEncoders.java
@@ -26,9 +26,9 @@ import java.util.List;
 
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseCommonTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.io.compress.Compression;
 import org.apache.hadoop.hbase.io.hfile.HFileContext;
@@ -154,7 +154,7 @@ public class TestSeekToBlockWithEncoders {
     KeyValue kv4 = new KeyValue(Bytes.toBytes("row11baa"), Bytes.toBytes("f1"),
         Bytes.toBytes("q1"), Bytes.toBytes("val"));
     sampleKv.add(kv4);
-    Cell toSeek = CellUtil.createLastOnRow(kv3);
+    Cell toSeek = PrivateCellUtil.createLastOnRow(kv3);
     seekToTheKey(kv3, sampleKv, toSeek);
   }
 
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFile.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFile.java
index 39419ca..cc4a716 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFile.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFile.java
@@ -46,6 +46,7 @@ import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseCommonTestingUtility;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.KeyValueUtil;
@@ -487,8 +488,8 @@ public class TestHFile  {
         KeyValue.Type.Maximum.getCode(),
         HConstants.EMPTY_BYTE_ARRAY);
     Cell mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) <= 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) == 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) <= 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) == 0);
   }
 
   @Test
@@ -496,53 +497,53 @@ public class TestHFile  {
     Cell left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     Cell right = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     Cell mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) <= 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) <= 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("b"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
 
     left = CellUtil.createCell(Bytes.toBytes("g"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("i"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("bbbbbbb"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
     assertEquals(1, mid.getRowLength());
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("b"), Bytes.toBytes("a"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("aaaaaaaa"), Bytes.toBytes("b"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
     assertEquals(2, mid.getFamilyLength());
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("aaaaaaaaa"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) < 0);
     assertEquals(2, mid.getQualifierLength());
 
     left = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("a"), Bytes.toBytes("a"), Bytes.toBytes("b"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) <= 0);
     assertEquals(1, mid.getQualifierLength());
 
     // Assert that if meta comparator, it returns the right cell -- i.e. no
@@ -550,8 +551,8 @@ public class TestHFile  {
     left = CellUtil.createCell(Bytes.toBytes("g"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     right = CellUtil.createCell(Bytes.toBytes("i"), Bytes.toBytes("a"), Bytes.toBytes("a"));
     mid = HFileWriterImpl.getMidpoint(CellComparatorImpl.META_COMPARATOR, left, right);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
-    assertTrue(CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) == 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, left, mid) < 0);
+    assertTrue(PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, mid, right) == 0);
 
     /**
      * See HBASE-7845
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlockIndex.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlockIndex.java
index 01dcc18..c5bc9d7 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlockIndex.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlockIndex.java
@@ -46,6 +46,7 @@ import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseCommonTestingUtility;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.fs.HFileSystem;
@@ -230,8 +231,8 @@ public class TestHFileBlockIndex {
       HFileBlock b =
           indexReader.seekToDataBlock(keyOnlyKey, null, true,
             true, false, null);
-      if (CellUtil.compare(CellComparatorImpl.COMPARATOR, keyOnlyKey, firstKeyInFile,
-          0, firstKeyInFile.length) < 0) {
+      if (PrivateCellUtil.compare(CellComparatorImpl.COMPARATOR, keyOnlyKey, firstKeyInFile, 0,
+        firstKeyInFile.length) < 0) {
         assertTrue(b == null);
         ++i;
         continue;
@@ -636,7 +637,7 @@ public class TestHFileBlockIndex {
           values[i] = CellUtil.cloneValue(kv);
           keyStrSet.add(Bytes.toStringBinary(k));
           if (i > 0) {
-            assertTrue((CellUtil.compare(CellComparatorImpl.COMPARATOR, kv, keys[i - 1],
+            assertTrue((PrivateCellUtil.compare(CellComparatorImpl.COMPARATOR, kv, keys[i - 1],
                 0, keys[i - 1].length)) > 0);
           }
         }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestScannerFromBucketCache.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestScannerFromBucketCache.java
index 6c7d686..c6e26cb 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestScannerFromBucketCache.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestScannerFromBucketCache.java
@@ -32,9 +32,9 @@ import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.ByteBufferKeyValue;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.client.Durability;
@@ -122,14 +122,14 @@ public class TestScannerFromBucketCache {
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
       // do the scan again and verify. This time it should be from the lru cache
       actual = performScan(row1, fam1);
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
 
     } finally {
@@ -160,7 +160,7 @@ public class TestScannerFromBucketCache {
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
       // Wait for the bucket cache threads to move the data to offheap
       Thread.sleep(500);
@@ -169,7 +169,7 @@ public class TestScannerFromBucketCache {
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertTrue(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
 
     } catch (InterruptedException e) {
@@ -201,7 +201,7 @@ public class TestScannerFromBucketCache {
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
       // Wait for the bucket cache threads to move the data to offheap
       Thread.sleep(500);
@@ -253,14 +253,14 @@ public class TestScannerFromBucketCache {
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
       // do the scan again and verify. This time it should be from the bucket cache in onheap mode
       actual = performScan(row1, fam1);
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
         assertFalse(actual.get(i) instanceof ByteBufferKeyValue);
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
 
     } finally {
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekTo.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekTo.java
index 5f8a6c3..91894dc 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekTo.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekTo.java
@@ -37,9 +37,9 @@ import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellComparatorImpl;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.ByteBufferKeyValue;
 import org.apache.hadoop.hbase.Tag;
@@ -173,7 +173,7 @@ public class TestSeekTo {
     assertEquals("i", toRowStr(scanner.getCell()));
     Cell cell = scanner.getCell();
     if (tagUsage != TagUsage.NO_TAG && cell.getTagsLength() > 0) {
-      Iterator<Tag> tagsIterator = CellUtil.tagsIterator(cell);
+      Iterator<Tag> tagsIterator = PrivateCellUtil.tagsIterator(cell);
       while (tagsIterator.hasNext()) {
         Tag next = tagsIterator.next();
         assertEquals("myTag1", Bytes.toString(TagUtil.cloneValue(next)));
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/assignment/TestSplitTableRegionProcedure.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/assignment/TestSplitTableRegionProcedure.java
index 4b63f0e..1cdd9c5 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/master/assignment/TestSplitTableRegionProcedure.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/master/assignment/TestSplitTableRegionProcedure.java
@@ -519,7 +519,7 @@ public class TestSplitTableRegionProcedure {
       Cell[] raw = result.rawCells();
       assertEquals(families.length, result.size());
       for (int j = 0; j < families.length; j++) {
-        assertTrue(CellUtil.matchingRow(raw[j], row));
+        assertTrue(CellUtil.matchingRows(raw[j], row));
         assertTrue(CellUtil.matchingFamily(raw[j], families[j]));
       }
     }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestBlocksRead.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestBlocksRead.java
index 5c4fb60..c40b24a 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestBlocksRead.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestBlocksRead.java
@@ -189,7 +189,7 @@ public class TestBlocksRead  {
 
   private static void verifyData(Cell kv, String expectedRow,
       String expectedCol, long expectedVersion) {
-    assertTrue("RowCheck", CellUtil.matchingRow(kv,  Bytes.toBytes(expectedRow)));
+    assertTrue("RowCheck", CellUtil.matchingRows(kv,  Bytes.toBytes(expectedRow)));
     assertTrue("ColumnCheck", CellUtil.matchingQualifier(kv, Bytes.toBytes(expectedCol)));
     assertEquals("TSCheck", expectedVersion, kv.getTimestamp());
     assertTrue("ValueCheck", CellUtil.matchingValue(kv, genValue(expectedRow, expectedCol, expectedVersion)));
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestDefaultMemStore.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestDefaultMemStore.java
index 6197a08..6451d42 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestDefaultMemStore.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestDefaultMemStore.java
@@ -186,7 +186,7 @@ public class TestDefaultMemStore {
       while (s.next(result)) {
         LOG.info(result);
         // Assert the stuff is coming out in right order.
-        assertTrue(CellUtil.matchingRow(result.get(0), Bytes.toBytes(count)));
+        assertTrue(CellUtil.matchingRows(result.get(0), Bytes.toBytes(count)));
         count++;
         // Row count is same as column count.
         assertEquals(rowCount, result.size());
@@ -210,7 +210,7 @@ public class TestDefaultMemStore {
       while (s.next(result)) {
         LOG.info(result);
         // Assert the stuff is coming out in right order.
-        assertTrue(CellUtil.matchingRow(result.get(0), Bytes.toBytes(count)));
+        assertTrue(CellUtil.matchingRows(result.get(0), Bytes.toBytes(count)));
         // Row count is same as column count.
         assertEquals("count=" + count + ", result=" + result, rowCount, result.size());
         count++;
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
index d75bec0..10fcd63 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
@@ -86,6 +86,7 @@ import org.apache.hadoop.hbase.HConstants.OperationStatusCode;
 import org.apache.hadoop.hbase.HDFSBlocksDistribution;
 import org.apache.hadoop.hbase.HRegionInfo;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.MiniHBaseCluster;
@@ -2367,11 +2368,11 @@ public class TestHRegion {
       InternalScanner s = region.getScanner(scan);
       List<Cell> results = new ArrayList<>();
       s.next(results);
-      assertTrue(CellUtil.matchingRow(results.get(0), rowA));
+      assertTrue(CellUtil.matchingRows(results.get(0), rowA));
 
       results.clear();
       s.next(results);
-      assertTrue(CellUtil.matchingRow(results.get(0), rowB));
+      assertTrue(CellUtil.matchingRows(results.get(0), rowB));
     } finally {
       HBaseTestingUtility.closeRegionAndWAL(this.region);
       this.region = null;
@@ -2608,7 +2609,7 @@ public class TestHRegion {
       Result res = region.get(get);
       assertEquals(expected.length, res.size());
       for (int i = 0; i < res.size(); i++) {
-        assertTrue(CellUtil.matchingRow(expected[i], res.rawCells()[i]));
+        assertTrue(CellUtil.matchingRows(expected[i], res.rawCells()[i]));
         assertTrue(CellUtil.matchingFamily(expected[i], res.rawCells()[i]));
         assertTrue(CellUtil.matchingQualifier(expected[i], res.rawCells()[i]));
       }
@@ -2883,7 +2884,7 @@ public class TestHRegion {
       res = new ArrayList<>();
       is.next(res);
       for (int i = 0; i < res.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected1.get(i), res.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected1.get(i), res.get(i)));
       }
 
       // Result 2
@@ -2894,7 +2895,7 @@ public class TestHRegion {
       res = new ArrayList<>();
       is.next(res);
       for (int i = 0; i < res.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected2.get(i), res.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected2.get(i), res.get(i)));
       }
     } finally {
       HBaseTestingUtility.closeRegionAndWAL(this.region);
@@ -3014,7 +3015,7 @@ public class TestHRegion {
 
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
     } finally {
       HBaseTestingUtility.closeRegionAndWAL(this.region);
@@ -3096,7 +3097,7 @@ public class TestHRegion {
 
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
     } finally {
       HBaseTestingUtility.closeRegionAndWAL(this.region);
@@ -3216,7 +3217,7 @@ public class TestHRegion {
 
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
     } finally {
       HBaseTestingUtility.closeRegionAndWAL(this.region);
@@ -3342,7 +3343,7 @@ public class TestHRegion {
 
       // Verify result
       for (int i = 0; i < expected.size(); i++) {
-        assertTrue(CellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
+        assertTrue(PrivateCellUtil.equalsIgnoreMvccVersion(expected.get(i), actual.get(i)));
       }
     } finally {
       HBaseTestingUtility.closeRegionAndWAL(this.region);
@@ -4869,7 +4870,7 @@ public class TestHRegion {
       Cell[] raw = result.rawCells();
       assertEquals(families.length, result.size());
       for (int j = 0; j < families.length; j++) {
-        assertTrue(CellUtil.matchingRow(raw[j], row));
+        assertTrue(CellUtil.matchingRows(raw[j], row));
         assertTrue(CellUtil.matchingFamily(raw[j], families[j]));
         assertTrue(CellUtil.matchingQualifier(raw[j], qf));
       }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStore.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStore.java
index e90656d..64ee8dc 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStore.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStore.java
@@ -69,6 +69,7 @@ import org.apache.hadoop.hbase.HBaseConfiguration;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.MemoryCompactionPolicy;
 import org.apache.hadoop.hbase.TableName;
@@ -1049,13 +1050,13 @@ public class TestHStore {
     Cell cell0 = CellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row).setFamily(family)
         .setQualifier(qf1).setTimestamp(timestamp).setType(CellBuilder.DataType.Put)
         .setValue(qf1).build();
-    CellUtil.setSequenceId(cell0, seqId);
+    PrivateCellUtil.setSequenceId(cell0, seqId);
     testNumberOfMemStoreScannersAfterFlush(Arrays.asList(cell0), Collections.emptyList());
 
     Cell cell1 = CellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row).setFamily(family)
         .setQualifier(qf2).setTimestamp(timestamp).setType(CellBuilder.DataType.Put)
         .setValue(qf1).build();
-    CellUtil.setSequenceId(cell1, seqId);
+    PrivateCellUtil.setSequenceId(cell1, seqId);
     testNumberOfMemStoreScannersAfterFlush(Arrays.asList(cell0), Arrays.asList(cell1));
 
     seqId = 101;
@@ -1063,7 +1064,7 @@ public class TestHStore {
     Cell cell2 = CellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row2).setFamily(family)
         .setQualifier(qf2).setTimestamp(timestamp).setType(CellBuilder.DataType.Put)
         .setValue(qf1).build();
-     CellUtil.setSequenceId(cell2, seqId);
+    PrivateCellUtil.setSequenceId(cell2, seqId);
     testNumberOfMemStoreScannersAfterFlush(Arrays.asList(cell0), Arrays.asList(cell1, cell2));
   }
 
@@ -1118,7 +1119,7 @@ public class TestHStore {
     Cell c = CellBuilderFactory.create(CellBuilderType.DEEP_COPY).setRow(row).setFamily(family)
         .setQualifier(qualifier).setTimestamp(ts).setType(CellBuilder.DataType.Put)
         .setValue(value).build();
-    CellUtil.setSequenceId(c, sequenceId);
+    PrivateCellUtil.setSequenceId(c, sequenceId);
     return c;
   }
 
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStoreFile.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStoreFile.java
index edc27a1..4715e95 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStoreFile.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHStoreFile.java
@@ -42,6 +42,7 @@ import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.TableName;
@@ -375,7 +376,7 @@ public class TestHStoreFile extends HBaseTestCase {
              (topScanner.isSeeked() && topScanner.next())) {
         key = ByteBuffer.wrap(((KeyValue) topScanner.getKey()).getKey());
 
-        if ((CellUtil.compare(topScanner.getReader().getComparator(), midKV, key.array(),
+        if ((PrivateCellUtil.compare(topScanner.getReader().getComparator(), midKV, key.array(),
           key.arrayOffset(), key.limit())) > 0) {
           fail("key=" + Bytes.toStringBinary(key) + " < midkey=" +
               midkey);
@@ -428,8 +429,8 @@ public class TestHStoreFile extends HBaseTestCase {
           topScanner.next()) {
         key = ByteBuffer.wrap(((KeyValue) topScanner.getKey()).getKey());
         keyOnlyKV.setKey(key.array(), 0 + key.arrayOffset(), key.limit());
-        assertTrue(CellUtil.compare(topScanner.getReader().getComparator(), keyOnlyKV, badmidkey, 0,
-          badmidkey.length) >= 0);
+        assertTrue(PrivateCellUtil.compare(topScanner.getReader().getComparator(), keyOnlyKV,
+          badmidkey, 0, badmidkey.length) >= 0);
         if (first) {
           first = false;
           KeyValue keyKV = KeyValueUtil.createKeyValueFromKey(key);
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestKeepDeletes.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestKeepDeletes.java
index aabfa16..5a20882 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestKeepDeletes.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestKeepDeletes.java
@@ -33,6 +33,7 @@ import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeepDeletedCells;
 import org.apache.hadoop.hbase.client.Delete;
 import org.apache.hadoop.hbase.client.Get;
@@ -349,15 +350,15 @@ public class TestKeepDeletes {
     List<Cell> kvs = new ArrayList<>();
     scan.next(kvs);
     assertEquals(8, kvs.size());
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(0)));
+    assertTrue(PrivateCellUtil.isDeleteFamily(kvs.get(0)));
     assertArrayEquals(CellUtil.cloneValue(kvs.get(1)), T3);
     assertTrue(CellUtil.isDelete(kvs.get(2)));
     assertTrue(CellUtil.isDelete(kvs.get(3))); // .isDeleteType());
     assertArrayEquals(CellUtil.cloneValue(kvs.get(4)), T2);
     assertArrayEquals(CellUtil.cloneValue(kvs.get(5)), T1);
     // we have 3 CFs, so there are two more delete markers
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(6)));
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(7)));
+    assertTrue(PrivateCellUtil.isDeleteFamily(kvs.get(6)));
+    assertTrue(PrivateCellUtil.isDeleteFamily(kvs.get(7)));
 
     // verify that raw scans honor the passed timerange
     s = new Scan();
@@ -379,11 +380,11 @@ public class TestKeepDeletes {
     kvs = new ArrayList<>();
     scan.next(kvs);
     assertEquals(4, kvs.size());
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(0)));
+    assertTrue(PrivateCellUtil.isDeleteFamily(kvs.get(0)));
     assertArrayEquals(CellUtil.cloneValue(kvs.get(1)), T1);
     // we have 3 CFs
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(2)));
-    assertTrue(CellUtil.isDeleteFamily(kvs.get(3)));
+    assertTrue(PrivateCellUtil.isDeleteFamily(kvs.get(2)));
+    assertTrue(PrivateCellUtil.isDeleteFamily(kvs.get(3)));
 
     // filter old delete markers
     s = new Scan();
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMultiColumnScanner.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMultiColumnScanner.java
index b23e0c5..bd7639e 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMultiColumnScanner.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMultiColumnScanner.java
@@ -42,6 +42,7 @@ import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueTestUtil;
 import org.apache.hadoop.hbase.client.Delete;
@@ -265,8 +266,8 @@ public class TestMultiColumnScanner {
             }
             assertTrue("Scanner returned additional key/value: " + kv + ", "
                 + queryInfo + deleteInfo + ";", kvPos < kvs.size());
-            assertTrue("Scanner returned wrong key/value; " + queryInfo
-                + deleteInfo + ";", CellUtil.equalsIgnoreMvccVersion(kvs.get(kvPos), (kv)));
+            assertTrue("Scanner returned wrong key/value; " + queryInfo + deleteInfo + ";",
+              PrivateCellUtil.equalsIgnoreMvccVersion(kvs.get(kvPos), (kv)));
             ++kvPos;
             ++numResults;
           }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRecoveredEdits.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRecoveredEdits.java
index 45dc786..e559b48 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRecoveredEdits.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRecoveredEdits.java
@@ -37,6 +37,7 @@ import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HRegionInfo;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.MemoryCompactionPolicy;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.client.Get;
@@ -187,7 +188,8 @@ public class TestRecoveredEdits {
           boolean found = false;
           for (CellScanner scanner = r.cellScanner(); scanner.advance();) {
             Cell current = scanner.current();
-            if (CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, cell, current) == 0) {
+            if (PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, cell,
+              current) == 0) {
               found = true;
               break;
             }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScanner.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScanner.java
index d9fd3de..2b36d79 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScanner.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScanner.java
@@ -155,7 +155,7 @@ public class TestScanner {
       for (boolean first = true; s.next(results);) {
         kv = results.get(0);
         if (first) {
-          assertTrue(CellUtil.matchingRow(kv,  startrow));
+          assertTrue(CellUtil.matchingRows(kv,  startrow));
           first = false;
         }
         count++;
@@ -546,7 +546,7 @@ public class TestScanner {
       // make sure returns column2 of firstRow
       assertTrue("result is not correct, keyValues : " + results,
           results.size() == 1);
-      assertTrue(CellUtil.matchingRow(results.get(0), firstRowBytes)); 
+      assertTrue(CellUtil.matchingRows(results.get(0), firstRowBytes));
       assertTrue(CellUtil.matchingFamily(results.get(0), fam2));
 
       results = new ArrayList<>();
@@ -554,7 +554,7 @@ public class TestScanner {
 
       // get secondRow
       assertTrue(results.size() == 2);
-      assertTrue(CellUtil.matchingRow(results.get(0), secondRowBytes));
+      assertTrue(CellUtil.matchingRows(results.get(0), secondRowBytes));
       assertTrue(CellUtil.matchingFamily(results.get(0), fam1));
       assertTrue(CellUtil.matchingFamily(results.get(1), fam2));
     } finally {
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestSeekOptimizations.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestSeekOptimizations.java
index eb3fe44..50b1d62 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestSeekOptimizations.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestSeekOptimizations.java
@@ -40,6 +40,7 @@ import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.Delete;
 import org.apache.hadoop.hbase.client.Put;
@@ -459,7 +460,7 @@ public class TestSeekOptimizations {
 
     int i;
     for (i = 0; i < minLen
-        && CellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, expected.get(i),
+        && PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.COMPARATOR, expected.get(i),
           actual.get(i)) == 0; ++i) {
     }
 
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFileRefresherChore.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFileRefresherChore.java
index 04dcb14..7919391 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFileRefresherChore.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreFileRefresherChore.java
@@ -145,7 +145,7 @@ public class TestStoreFileRefresherChore {
       Cell[] raw = result.rawCells();
       assertEquals(families.length, result.size());
       for (int j = 0; j < families.length; j++) {
-        assertTrue(CellUtil.matchingRow(raw[j], row));
+        assertTrue(CellUtil.matchingRows(raw[j], row));
         assertTrue(CellUtil.matchingFamily(raw[j], families[j]));
         assertTrue(CellUtil.matchingQualifier(raw[j], qf));
       }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreScanner.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreScanner.java
index 3172054..b275e93 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreScanner.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreScanner.java
@@ -47,6 +47,7 @@ import org.apache.hadoop.hbase.CellComparatorImpl;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HBaseConfiguration;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeepDeletedCells;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.client.Get;
@@ -195,12 +196,12 @@ public class TestStoreScanner {
     public Cell getNextIndexedKey() {
       // Fake block boundaries by having index of next block change as we go through scan.
       return count.get() > CELL_GRID_BLOCK4_BOUNDARY?
-          CellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK5_BOUNDARY]):
+          PrivateCellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK5_BOUNDARY]):
             count.get() > CELL_GRID_BLOCK3_BOUNDARY?
-                CellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK4_BOUNDARY]):
+                PrivateCellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK4_BOUNDARY]):
                   count.get() > CELL_GRID_BLOCK2_BOUNDARY?
-                      CellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK3_BOUNDARY]):
-                        CellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK2_BOUNDARY]);
+                      PrivateCellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK3_BOUNDARY]):
+                        PrivateCellUtil.createFirstOnRow(CELL_GRID[CELL_GRID_BLOCK2_BOUNDARY]);
     }
   };
 
@@ -239,7 +240,8 @@ public class TestStoreScanner {
     @Override
     public Cell getNextIndexedKey() {
       // Fake block boundaries by having index of next block change as we go through scan.
-      return CellUtil.createFirstOnRow(CELL_WITH_VERSIONS[CELL_WITH_VERSIONS_BLOCK2_BOUNDARY]);
+      return PrivateCellUtil
+          .createFirstOnRow(CELL_WITH_VERSIONS[CELL_WITH_VERSIONS_BLOCK2_BOUNDARY]);
     }
   };
 
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestTags.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestTags.java
index 9a72100..8e3c372 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestTags.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestTags.java
@@ -326,7 +326,7 @@ public class TestTags {
             CellScanner cellScanner = next.cellScanner();
             cellScanner.advance();
             Cell current = cellScanner.current();
-            if (CellUtil.matchingRow(current, row)) {
+            if (CellUtil.matchingRows(current, row)) {
               assertEquals(1, TestCoprocessorForTags.tags.size());
               Tag tag = TestCoprocessorForTags.tags.get(0);
               assertEquals(bigTagLen, tag.getValueLength());
@@ -351,7 +351,7 @@ public class TestTags {
             CellScanner cellScanner = next.cellScanner();
             cellScanner.advance();
             Cell current = cellScanner.current();
-            if (CellUtil.matchingRow(current, row)) {
+            if (CellUtil.matchingRows(current, row)) {
               assertEquals(1, TestCoprocessorForTags.tags.size());
               Tag tag = TestCoprocessorForTags.tags.get(0);
               assertEquals(bigTagLen, tag.getValueLength());
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/querymatcher/TestUserScanQueryMatcher.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/querymatcher/TestUserScanQueryMatcher.java
index 2d80b3f..4cde038 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/querymatcher/TestUserScanQueryMatcher.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/querymatcher/TestUserScanQueryMatcher.java
@@ -27,8 +27,8 @@ import java.util.List;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.hbase.Cell;
-import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeepDeletedCells;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.regionserver.ScanInfo;
@@ -58,7 +58,7 @@ public class TestUserScanQueryMatcher extends AbstractTestScanQueryMatcher {
           HConstants.DEFAULT_BLOCKSIZE, 0, rowComparator, false),
       get.getFamilyMap().get(fam2), now - ttl, now, null);
     Cell kv = new KeyValue(row1, fam2, col2, 1, data);
-    Cell cell = CellUtil.createLastOnRowCol(kv);
+    Cell cell = PrivateCellUtil.createLastOnRowCol(kv);
     qm.setToNewRow(kv);
     MatchCode code = qm.match(cell);
     assertFalse(code.compareTo(MatchCode.SEEK_NEXT_COL) != 0);
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/ExpAsStringVisibilityLabelServiceImpl.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/ExpAsStringVisibilityLabelServiceImpl.java
index 7adeb9e..93bbc42 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/ExpAsStringVisibilityLabelServiceImpl.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/ExpAsStringVisibilityLabelServiceImpl.java
@@ -39,6 +39,7 @@ import org.apache.hadoop.hbase.AuthUtil;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HConstants.OperationStatusCode;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.ArrayBackedTag;
 import org.apache.hadoop.hbase.TagType;
@@ -284,7 +285,7 @@ public class ExpAsStringVisibilityLabelServiceImpl implements VisibilityLabelSer
         boolean visibilityTagPresent = false;
         // Save an object allocation where we can
         if (cell.getTagsLength() > 0) {
-          Iterator<Tag> tagsItr = CellUtil.tagsIterator(cell);
+          Iterator<Tag> tagsItr = PrivateCellUtil.tagsIterator(cell);
           while (tagsItr.hasNext()) {
             boolean includeKV = true;
             Tag tag = tagsItr.next();
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsReplication.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsReplication.java
index a3d7507..99525e2 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsReplication.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsReplication.java
@@ -40,6 +40,7 @@ import org.apache.hadoop.hbase.HBaseTestingUtility;
 import org.apache.hadoop.hbase.HColumnDescriptor;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.TableName;
@@ -417,7 +418,7 @@ public class TestVisibilityLabelsReplication {
             List<Tag> tagList = new ArrayList<>(kv.getTags().size() + 1);
             tagList.add(tag);
             tagList.addAll(kv.getTags());
-            Cell newcell = CellUtil.createCell(kv, tagList);
+            Cell newcell = PrivateCellUtil.createCell(kv, tagList);
             ((List<Cell>) updatedCells).add(newcell);
           }
         }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/util/HFileTestUtil.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/util/HFileTestUtil.java
index acf555b..ada3ba5 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/util/HFileTestUtil.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/util/HFileTestUtil.java
@@ -33,6 +33,7 @@ import org.apache.hadoop.hbase.ArrayBackedTag;
 import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.CellUtil;
 import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.Tag;
 import org.apache.hadoop.hbase.TagType;
@@ -136,7 +137,7 @@ public class HFileTestUtil {
           kv = MobUtils.createMobRefCell(kv, key, tableNameTag);
 
           // verify that the kv has the tag.
-          Tag t = CellUtil.getTag(kv, TagType.MOB_TABLE_NAME_TAG_TYPE);
+          Tag t = PrivateCellUtil.getTag(kv, TagType.MOB_TABLE_NAME_TAG_TYPE);
           if (t == null) {
             throw new IllegalStateException("Tag didn't stick to KV " + kv.toString());
           }
@@ -160,7 +161,7 @@ public class HFileTestUtil {
     ResultScanner s = table.getScanner(new Scan());
     for (Result r : s) {
       for (Cell c : r.listCells()) {
-        Tag t = CellUtil.getTag(c, TagType.MOB_TABLE_NAME_TAG_TYPE);
+        Tag t = PrivateCellUtil.getTag(c, TagType.MOB_TABLE_NAME_TAG_TYPE);
         if (t == null) {
           fail(c.toString() + " has null tag");
           continue;
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/util/TestCoprocessorScanPolicy.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/util/TestCoprocessorScanPolicy.java
index 6224495..e0f2986 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/util/TestCoprocessorScanPolicy.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/util/TestCoprocessorScanPolicy.java
@@ -262,7 +262,7 @@ public class TestCoprocessorScanPolicy {
           if (version == 0) {
             return c -> true;
           } else {
-            if (row == null || !CellUtil.matchingRow(firstCell, row)) {
+            if (row == null || !CellUtil.matchingRows(firstCell, row)) {
               row = CellUtil.cloneRow(firstCell);
               // reset qualifier as there is a row change
               qualifier = null;
diff --git a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java
index 271b70c..4e15a9c 100644
--- a/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java
+++ b/hbase-thrift/src/main/java/org/apache/hadoop/hbase/thrift2/ThriftUtilities.java
@@ -30,6 +30,7 @@ import org.apache.commons.collections4.MapUtils;
 import org.apache.hadoop.hbase.CompareOperator;
 import org.apache.hadoop.hbase.HRegionInfo;
 import org.apache.hadoop.hbase.HRegionLocation;
+import org.apache.hadoop.hbase.PrivateCellUtil;
 import org.apache.hadoop.hbase.ServerName;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.hadoop.hbase.Cell;
@@ -171,7 +172,7 @@ public class ThriftUtilities {
       col.setTimestamp(kv.getTimestamp());
       col.setValue(CellUtil.cloneValue(kv));
       if (kv.getTagsLength() > 0) {
-        col.setTags(CellUtil.getTagArray(kv));
+        col.setTags(PrivateCellUtil.getTagsArray(kv));
       }
       columnValues.add(col);
     }
