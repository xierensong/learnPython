diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java
index 4ff3592..293ac54 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java
@@ -105,6 +105,7 @@
 import org.apache.hadoop.hbase.regionserver.HRegionServer;
 import org.apache.hadoop.hbase.regionserver.RSRpcServices;
 import org.apache.hadoop.hbase.regionserver.RegionSplitPolicy;
+import org.apache.hadoop.hbase.replication.master.MobFileCompactChore;
 import org.apache.hadoop.hbase.replication.regionserver.Replication;
 import org.apache.hadoop.hbase.security.UserProvider;
 import org.apache.hadoop.hbase.util.Bytes;
@@ -209,6 +210,7 @@
   private LogCleaner logCleaner;
   private HFileCleaner hfileCleaner;
   private ExpiredMobFileCleanerChore expiredMobFileCleanerChore;
+  private MobFileCompactChore mobFileCompactChore;
 
   MasterCoprocessorHost cpHost;
 
@@ -613,6 +615,8 @@ private void finishActiveMasterInitialization(MonitoredTask status)
 
     this.expiredMobFileCleanerChore = new ExpiredMobFileCleanerChore(this);
     Threads.setDaemonThreadRunning(expiredMobFileCleanerChore.getThread());
+    this.mobFileCompactChore = new MobFileCompactChore(this);
+    Threads.setDaemonThreadRunning(mobFileCompactChore.getThread());
 
     if (this.cpHost != null) {
       // don't let cp initialization errors kill the master
@@ -863,6 +867,9 @@ private void stopChores() {
     if (this.expiredMobFileCleanerChore != null) {
       this.expiredMobFileCleanerChore.interrupt();
     }
+    if (this.mobFileCompactChore != null) {
+      this.mobFileCompactChore.interrupt();
+    }
     if (this.balancerChore != null) {
       this.balancerChore.interrupt();
     }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobConstants.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobConstants.java
index f40c952..2b9bca3 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobConstants.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobConstants.java
@@ -72,8 +72,19 @@
   public static final long DEFAULT_MOB_CACHE_EVICT_PERIOD = 3600l;
 
   public final static String TEMP_DIR_NAME = ".tmp";
+  public final static String BULKLOAD_DIR_NAME = ".bulkload";
   public final static byte[] MOB_TABLE_LOCK_SUFFIX = Bytes.toBytes(".mobLock");
   public final static String EMPTY_STRING = "";
+
+  public static final String MOB_COMPACTION_MERGEABLE_SIZE = "hbase.mob.compaction.mergeable.size";
+  public static final long DEFAULT_MOB_COMPACTION_MERGEABLE_SIZE = 128 * 1024 * 1024;
+  public static final String MOB_DELFILE_MAX_COUNT = "hbase.mob.delfile.max.count";
+  public static final int DEFAULT_MOB_DELFILE_MAX_COUNT = 3;
+  public static final String MOB_COMPACTION_BATCH_SIZE = "hbase.mob.compaction.batch.size";
+  public static final int DEFAULT_MOB_COMPACTION_BATCH_SIZE = Integer.MAX_VALUE;
+  public static final String MOB_COMPACTION_CHORE_PERIOD =
+    "hbase.master.mob.compaction.chore.period";
+  public static final int DEFAULT_MOB_COMPACTION_CHORE_PERIOD = 24 * 60 * 60 * 1000 * 7; // a week
   private MobConstants() {
 
   }
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java
index 43521d2..d8b1376 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/MobUtils.java
@@ -52,6 +52,7 @@
 import org.apache.hadoop.hbase.io.hfile.HFileContext;
 import org.apache.hadoop.hbase.io.hfile.HFileContextBuilder;
 import org.apache.hadoop.hbase.regionserver.BloomType;
+import org.apache.hadoop.hbase.regionserver.HStore;
 import org.apache.hadoop.hbase.regionserver.StoreFile;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.FSUtils;
@@ -416,7 +417,7 @@ public static KeyValue createMobRefKeyValue(Cell cell, byte[] fileName, Tag tabl
   }
 
   /**
-   * Creates a directory of mob files for flushing.
+   * Creates a writer for the mob file in temp directory.
    * @param conf The current configuration.
    * @param fs The current file system.
    * @param family The descriptor of the current column family.
@@ -435,17 +436,110 @@ public static KeyValue createMobRefKeyValue(Cell cell, byte[] fileName, Tag tabl
       throws IOException {
     MobFileName mobFileName = MobFileName.create(startKey, date, UUID.randomUUID().toString()
         .replaceAll("-", ""));
+    return createWriter(conf, fs, family, mobFileName, basePath, maxKeyCount, compression,
+      cacheConfig);
+  }
+
+  /**
+   * Creates a writer for the ref file in temp directory.
+   * @param conf The current configuration.
+   * @param fs The current file system.
+   * @param family The descriptor of the current column family.
+   * @param basePath The basic path for a temp directory.
+   * @param maxKeyCount The key count.
+   * @param cacheConfig The current cache config.
+   * @return The writer for the mob file.
+   * @throws IOException
+   */
+  public static StoreFile.Writer createRefFileWriter(Configuration conf, FileSystem fs,
+    HColumnDescriptor family, Path basePath, long maxKeyCount, CacheConfig cacheConfig)
+    throws IOException {
+    HFileContext hFileContext = new HFileContextBuilder().withIncludesMvcc(true)
+      .withIncludesTags(true).withCompression(family.getCompactionCompression())
+      .withCompressTags(family.shouldCompressTags()).withChecksumType(HStore.getChecksumType(conf))
+      .withBytesPerCheckSum(HStore.getBytesPerChecksum(conf)).withBlockSize(family.getBlocksize())
+      .withHBaseCheckSum(true).withDataBlockEncoding(family.getDataBlockEncoding()).build();
+    Path tempPath = new Path(basePath, UUID.randomUUID().toString().replaceAll("-", ""));
+    StoreFile.Writer w = new StoreFile.WriterBuilder(conf, cacheConfig, fs).withFilePath(tempPath)
+      .withComparator(KeyValue.COMPARATOR).withBloomType(family.getBloomFilterType())
+      .withMaxKeyCount(maxKeyCount).withFileContext(hFileContext).build();
+    return w;
+  }
+
+  /**
+   * Creates a writer for the mob file in temp directory.
+   * @param conf The current configuration.
+   * @param fs The current file system.
+   * @param family The descriptor of the current column family.
+   * @param date The date string, its format is yyyymmmdd.
+   * @param basePath The basic path for a temp directory.
+   * @param maxKeyCount The key count.
+   * @param compression The compression algorithm.
+   * @param startKey The start key.
+   * @param cacheConfig The current cache config.
+   * @return The writer for the mob file.
+   * @throws IOException
+   */
+  public static StoreFile.Writer createWriter(Configuration conf, FileSystem fs,
+      HColumnDescriptor family, String date, Path basePath, long maxKeyCount,
+      Compression.Algorithm compression, byte[] startKey, CacheConfig cacheConfig)
+      throws IOException {
+    MobFileName mobFileName = MobFileName.create(startKey, date, UUID.randomUUID().toString()
+        .replaceAll("-", ""));
+    return createWriter(conf, fs, family, mobFileName, basePath, maxKeyCount, compression,
+      cacheConfig);
+  }
+
+  /**
+   * Creates a writer for the del file in temp directory.
+   * @param conf The current configuration.
+   * @param fs The current file system.
+   * @param family The descriptor of the current column family.
+   * @param date The date string, its format is yyyymmmdd.
+   * @param basePath The basic path for a temp directory.
+   * @param maxKeyCount The key count.
+   * @param compression The compression algorithm.
+   * @param startKey The start key.
+   * @param cacheConfig The current cache config.
+   * @return The writer for the del file.
+   * @throws IOException
+   */
+  public static StoreFile.Writer createDelFileWriter(Configuration conf, FileSystem fs,
+      HColumnDescriptor family, String date, Path basePath, long maxKeyCount,
+      Compression.Algorithm compression, byte[] startKey, CacheConfig cacheConfig)
+      throws IOException {
+    String suffix = UUID
+      .randomUUID().toString().replaceAll("-", "") + "_del";
+    MobFileName mobFileName = MobFileName.create(startKey, date, suffix);
+    return createWriter(conf, fs, family, mobFileName, basePath, maxKeyCount, compression,
+      cacheConfig);
+  }
+
+  /**
+   * Creates a writer for the del file in temp directory.
+   * @param conf The current configuration.
+   * @param fs The current file system.
+   * @param family The descriptor of the current column family.
+   * @param mobFileName The mob file name.
+   * @param basePath The basic path for a temp directory.
+   * @param maxKeyCount The key count.
+   * @param compression The compression algorithm.
+   * @param cacheConfig The current cache config.
+   * @return The writer for the mob file.
+   * @throws IOException
+   */
+  private static StoreFile.Writer createWriter(Configuration conf, FileSystem fs,
+    HColumnDescriptor family, MobFileName mobFileName, Path basePath, long maxKeyCount,
+    Compression.Algorithm compression, CacheConfig cacheConfig) throws IOException {
     HFileContext hFileContext = new HFileContextBuilder().withCompression(compression)
-        .withIncludesMvcc(false).withIncludesTags(true)
-        .withChecksumType(HFile.DEFAULT_CHECKSUM_TYPE)
-        .withBytesPerCheckSum(HFile.DEFAULT_BYTES_PER_CHECKSUM)
-        .withBlockSize(family.getBlocksize()).withHBaseCheckSum(true)
-        .withDataBlockEncoding(family.getDataBlockEncoding()).build();
+      .withIncludesMvcc(false).withIncludesTags(true).withChecksumType(HFile.DEFAULT_CHECKSUM_TYPE)
+      .withBytesPerCheckSum(HFile.DEFAULT_BYTES_PER_CHECKSUM).withBlockSize(family.getBlocksize())
+      .withHBaseCheckSum(true).withDataBlockEncoding(family.getDataBlockEncoding()).build();
 
     StoreFile.Writer w = new StoreFile.WriterBuilder(conf, cacheConfig, fs)
-        .withFilePath(new Path(basePath, mobFileName.getFileName()))
-        .withComparator(KeyValue.COMPARATOR).withBloomType(BloomType.NONE)
-        .withMaxKeyCount(maxKeyCount).withFileContext(hFileContext).build();
+      .withFilePath(new Path(basePath, mobFileName.getFileName()))
+      .withComparator(KeyValue.COMPARATOR).withBloomType(BloomType.NONE)
+      .withMaxKeyCount(maxKeyCount).withFileContext(hFileContext).build();
     return w;
   }
 
@@ -456,12 +550,13 @@ public static KeyValue createMobRefKeyValue(Cell cell, byte[] fileName, Tag tabl
    * @param path The path where the mob file is saved.
    * @param targetPath The directory path where the source file is renamed to.
    * @param cacheConfig The current cache config.
+   * @return The target file path the source file is renamed to.
    * @throws IOException
    */
-  public static void commitFile(Configuration conf, FileSystem fs, final Path sourceFile,
+  public static Path commitFile(Configuration conf, FileSystem fs, final Path sourceFile,
       Path targetPath, CacheConfig cacheConfig) throws IOException {
     if (sourceFile == null) {
-      return;
+      return null;
     }
     Path dstPath = new Path(targetPath, sourceFile.getName());
     validateMobFile(conf, fs, sourceFile, cacheConfig);
@@ -474,6 +569,7 @@ public static void commitFile(Configuration conf, FileSystem fs, final Path sour
     if (!fs.rename(sourceFile, dstPath)) {
       throw new IOException("Failed rename of " + sourceFile + " to " + dstPath);
     }
+    return dstPath;
   }
 
   /**
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/MobFileCompactionRequest.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/MobFileCompactionRequest.java
new file mode 100644
index 0000000..61b3c54
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/MobFileCompactionRequest.java
@@ -0,0 +1,48 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob.filecompactions;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+
+/**
+ * The compaction request for mob files.
+ */
+@InterfaceAudience.Private
+public abstract class MobFileCompactionRequest {
+
+  protected long selectionTime;
+  protected CompactionType type = CompactionType.PART_FILES;
+
+  public void setCompactionType(CompactionType type) {
+    this.type = type;
+  }
+
+  protected enum CompactionType {
+
+    /**
+     * Part of mob files are selected.
+     */
+    PART_FILES,
+
+    /**
+     * All of mob files are selected.
+     */
+    ALL_FILES;
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/MobFileCompactor.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/MobFileCompactor.java
new file mode 100644
index 0000000..0c782ab
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/MobFileCompactor.java
@@ -0,0 +1,75 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob.filecompactions;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.util.FSUtils;
+
+/**
+ * A mob file compactor to directly compact the mob files.
+ */
+@InterfaceAudience.Private
+public abstract class MobFileCompactor {
+
+  protected FileSystem fs;
+  protected Configuration conf;
+  protected TableName tableName;
+  protected HColumnDescriptor column;
+
+  protected Path mobTableDir;
+  protected Path mobFamilyDir;
+
+  public MobFileCompactor(Configuration conf, FileSystem fs, TableName tableName,
+    HColumnDescriptor column) {
+    this.conf = conf;
+    this.fs = fs;
+    this.tableName = tableName;
+    this.column = column;
+    mobTableDir = FSUtils.getTableDir(MobUtils.getMobHome(conf), tableName);
+    mobFamilyDir = MobUtils.getMobFamilyPath(conf, tableName, column.getNameAsString());
+  }
+
+  /**
+   * Compacts the mob files for the current column family.
+   * @return The paths of new mob files generated in the compaction.
+   * @throws IOException
+   */
+  public List<Path> compact() throws IOException {
+    return compact(Arrays.asList(fs.listStatus(mobFamilyDir)));
+  }
+
+  /**
+   * Compacts the candidate mob files.
+   * @param files The candidate mob files.
+   * @return The paths of new mob files generated in the compaction.
+   * @throws IOException
+   */
+  public abstract List<Path> compact(List<FileStatus> files) throws IOException;
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/PartitionMobFileCompactionRequest.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/PartitionMobFileCompactionRequest.java
new file mode 100644
index 0000000..5cba152
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/PartitionMobFileCompactionRequest.java
@@ -0,0 +1,128 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob.filecompactions;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;
+
+/**
+ * An implementation of {@link MobFileCompactionRequest} that is used in
+ * {@link PartitionMobFileCompactor}.
+ */
+@InterfaceAudience.Private
+public class PartitionMobFileCompactionRequest extends MobFileCompactionRequest {
+
+  protected Collection<FileStatus> delFiles;
+  protected Collection<CompactedPartition> compactedPartitions;
+
+  public PartitionMobFileCompactionRequest(Collection<CompactedPartition> compactedPartitions,
+    Collection<FileStatus> delFiles) {
+    this.selectionTime = EnvironmentEdgeManager.currentTime();
+    this.compactedPartitions = compactedPartitions;
+    this.delFiles = delFiles;
+  }
+
+  /**
+   * The partition in the mob file compaction.
+   * The mob files that have the same start key and date in their names belong to
+   * the same partition.
+   */
+  protected static class CompactedPartition {
+    private List<FileStatus> files = new ArrayList<FileStatus>();
+    private CompactedPartitionId partitionId;
+
+    public CompactedPartition(CompactedPartitionId partitionId) {
+      this.partitionId = partitionId;
+    }
+
+    public CompactedPartitionId getPartitionId() {
+      return this.partitionId;
+    }
+
+    public void addFile(FileStatus file) {
+      files.add(file);
+    }
+
+    public List<FileStatus> listFiles() {
+      return Collections.unmodifiableList(files);
+    }
+  }
+
+  /**
+   * The partition id this consists of start key and date of the mob file name. 
+   */
+  protected static class CompactedPartitionId {
+
+    private String startKey;
+    private String date;
+
+    public CompactedPartitionId(String startKey, String date) {
+      if (startKey == null || date == null) {
+        throw new IllegalArgumentException("Neither of start key and date could be null");
+      }
+      this.startKey = startKey;
+      this.date = date;
+    }
+
+    public String getStartKey() {
+      return this.startKey;
+    }
+
+    public String getDate() {
+      return this.date;
+    }
+
+    @Override
+    public int hashCode() {
+      int result = 17;
+      result = 31 * result + startKey.hashCode();
+      result = 31 * result + date.hashCode();
+      return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (this == obj) {
+        return true;
+      }
+      if (!(obj instanceof CompactedPartitionId)) {
+        return false;
+      }
+      CompactedPartitionId another = (CompactedPartitionId) obj;
+      if (!this.startKey.equals(another.startKey)) {
+        return false;
+      }
+      if (!this.date.equals(another.date)) {
+        return false;
+      }
+      return true;
+    }
+
+    @Override
+    public String toString() {
+      return new StringBuilder(startKey).append("-").append(date).toString();
+    }
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/PartitionMobFileCompactor.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/PartitionMobFileCompactor.java
new file mode 100644
index 0000000..33dfb8e
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mob/filecompactions/PartitionMobFileCompactor.java
@@ -0,0 +1,483 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob.filecompactions;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValueUtil;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.Tag;
+import org.apache.hadoop.hbase.TagType;
+import org.apache.hadoop.hbase.client.HTable;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.io.hfile.CacheConfig;
+import org.apache.hadoop.hbase.mapreduce.LoadIncrementalHFiles;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.mob.MobFileName;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.mob.filecompactions.MobFileCompactionRequest.CompactionType;
+import org.apache.hadoop.hbase.mob.filecompactions.PartitionMobFileCompactionRequest.CompactedPartition;
+import org.apache.hadoop.hbase.mob.filecompactions.PartitionMobFileCompactionRequest.CompactedPartitionId;
+import org.apache.hadoop.hbase.regionserver.BloomType;
+import org.apache.hadoop.hbase.regionserver.HStore;
+import org.apache.hadoop.hbase.regionserver.ScanInfo;
+import org.apache.hadoop.hbase.regionserver.ScanType;
+import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.regionserver.StoreFile.Writer;
+import org.apache.hadoop.hbase.regionserver.StoreFileInfo;
+import org.apache.hadoop.hbase.regionserver.StoreFileScanner;
+import org.apache.hadoop.hbase.regionserver.StoreScanner;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.Pair;
+
+/**
+ * An implementation of {@link MobFileCompactor} that compacts the mob files in partitions.
+ */
+@InterfaceAudience.Private
+public class PartitionMobFileCompactor extends MobFileCompactor {
+
+  private static final Log LOG = LogFactory.getLog(PartitionMobFileCompactor.class);
+  protected long mergeableSize;
+  protected int delFileMaxCount;
+  /** The number of files compacted in a batch */
+  protected int compactionBatch;
+  protected int compactionKVMax;
+
+  private Path tempPath;
+  private Path bulkloadPath;
+  private CacheConfig compactionCacheConfig;
+  private Tag tableNameTag;
+
+  public PartitionMobFileCompactor(Configuration conf, FileSystem fs, TableName tableName,
+    HColumnDescriptor column) {
+    super(conf, fs, tableName, column);
+    mergeableSize = conf.getLong(MobConstants.MOB_COMPACTION_MERGEABLE_SIZE,
+      MobConstants.DEFAULT_MOB_COMPACTION_MERGEABLE_SIZE);
+    delFileMaxCount = conf.getInt(MobConstants.MOB_DELFILE_MAX_COUNT,
+      MobConstants.DEFAULT_MOB_DELFILE_MAX_COUNT);
+    // default is no limit
+    compactionBatch = conf.getInt(MobConstants.MOB_COMPACTION_BATCH_SIZE,
+      MobConstants.DEFAULT_MOB_COMPACTION_BATCH_SIZE);
+    tempPath = new Path(MobUtils.getMobHome(conf), MobConstants.TEMP_DIR_NAME);
+    bulkloadPath = new Path(tempPath, new Path(MobConstants.BULKLOAD_DIR_NAME,
+      column.getNameAsString()));
+    compactionKVMax = this.conf.getInt(HConstants.COMPACTION_KV_MAX,
+      HConstants.COMPACTION_KV_MAX_DEFAULT);
+    Configuration copyOfConf = new Configuration(conf);
+    copyOfConf.setFloat(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY, 0f);
+    compactionCacheConfig = new CacheConfig(copyOfConf);
+    tableNameTag = new Tag(TagType.MOB_TABLE_NAME_TAG_TYPE, tableName.getName());
+  }
+
+  @Override
+  public List<Path> compact(List<FileStatus> files) throws IOException {
+    if (files == null || files.isEmpty()) {
+      return null;
+    }
+    // find the files to compact.
+    PartitionMobFileCompactionRequest request = select(files);
+    // compact the files.
+    return performCompact(request);
+  }
+
+  /**
+   * Selects the compacted mob/del files.
+   * Iterates the candidates to find out all the del files and small mob files.
+   * @param candidates All the candidates.
+   * @return A compaction request.
+   */
+  protected PartitionMobFileCompactionRequest select(List<FileStatus> candidates) {
+    Collection<FileStatus> allDelFiles = new ArrayList<FileStatus>();
+    Map<CompactedPartitionId, CompactedPartition> filesToCompact =
+      new HashMap<CompactedPartitionId, CompactedPartition>();
+    int smallFilesCount = 0;
+    for (FileStatus file : candidates) {
+      if (file.isFile()) {
+        // group the del files and small files.
+        if (StoreFileInfo.isDelFile(file.getPath())) {
+          allDelFiles.add(file);
+        } else if (file.getLen() < mergeableSize) {
+          // add the small files to the merge pool
+          MobFileName fileName = MobFileName.create(file.getPath().getName());
+          CompactedPartitionId id = new CompactedPartitionId(fileName.getStartKey(), fileName.getDate());
+          CompactedPartition compactedPartition = filesToCompact.get(id);
+          if (compactedPartition == null) {
+            compactedPartition = new CompactedPartition(id);
+            compactedPartition.addFile(file);
+            filesToCompact.put(id, compactedPartition);
+          } else {
+            compactedPartition.addFile(file);
+          }
+          smallFilesCount++;
+        }
+      }
+    }
+    PartitionMobFileCompactionRequest request = new PartitionMobFileCompactionRequest(
+      filesToCompact.values(), allDelFiles);
+    if (candidates.size() == (allDelFiles.size() + smallFilesCount)) {
+      // all the files are selected
+      request.setCompactionType(CompactionType.ALL_FILES);
+    }
+    return request;
+  }
+
+  /**
+   * Performs the compaction on the selected files.
+   * <ol>
+   * <li>Compacts the del files.</li>
+   * <li>Compacts the selected small mob files and all the del files.</li>
+   * <li>If all the candidates are selected, delete the del files.</li>
+   * </ol>
+   * @param request The compaction request.
+   * @return The paths of new mob files generated in the compaction.
+   * @throws IOException
+   */
+  protected List<Path> performCompact(PartitionMobFileCompactionRequest request) throws IOException {
+    // merge the del files
+    List<Path> delFilePaths = new ArrayList<Path>();
+    for (FileStatus delFile : request.delFiles) {
+      delFilePaths.add(delFile.getPath());
+    }
+    List<Path> newDelPaths = compactDelFiles(request, delFilePaths);
+    List<StoreFile> delFiles = new ArrayList<StoreFile>();
+    for (Path newDelPath : newDelPaths) {
+      StoreFile sf = new StoreFile(fs, newDelPath, conf, compactionCacheConfig, BloomType.NONE);
+      delFiles.add(sf);
+    }
+    // compact the mob files by partitions.
+    List<Path> paths = compactMobFiles(request, delFiles);
+    // archive the del files if the all mob files are selected.
+    if (request.type == CompactionType.ALL_FILES && !newDelPaths.isEmpty()) {
+      try {
+        MobUtils.removeMobFiles(conf, fs, tableName, mobTableDir, column.getName(), delFiles);
+      } catch (IOException e) {
+        LOG.error("Fail to archive the del files " + delFiles, e);
+      }
+    }
+    return paths;
+  }
+
+  /**
+   * Compacts the selected small mob files and all the del files.
+   * @param request The compaction request.
+   * @param delFiles The del files.
+   * @return The paths of new mob files after compactions.
+   * @throws IOException
+   */
+  protected List<Path> compactMobFiles(PartitionMobFileCompactionRequest request,
+    List<StoreFile> delFiles) throws IOException {
+    Collection<CompactedPartition> partitions = request.compactedPartitions;
+    if (partitions == null || partitions.isEmpty()) {
+      return Collections.emptyList();
+    }
+    List<Path> paths = new ArrayList<Path>();
+    HTable table = new HTable(conf, tableName);
+    try {
+      // compact the mob files by partitions.
+      for (CompactedPartition partition : partitions) {
+        paths.addAll(compactMobFilePartition(request, partition, 0, delFiles, table));
+      }
+    } finally {
+      try {
+        table.close();
+      } catch (IOException e) {
+        LOG.error("Fail to close the HTable", e);
+      }
+    }
+    return paths;
+  }
+
+  /**
+   * Compacts a partition of selected small mob files and all the del files.
+   * @param request The compaction request.
+   * @param partition A compaction partition.
+   * @param offset The offset of the compacted files in this partition.
+   * @param delFiles The del files.
+   * @param table The current table.
+   * @return The paths of new mob files after compactions.
+   * @throws IOException
+   */
+  private List<Path> compactMobFilePartition(PartitionMobFileCompactionRequest request,
+    CompactedPartition partition, int offset, List<StoreFile> delFiles, HTable table)
+      throws IOException {
+    List<Path> newFiles = new ArrayList<Path>();
+    List<FileStatus> files = partition.listFiles();
+    boolean isLastBatch = false;
+    int batch = compactionBatch;
+    if (files.size() - offset <= compactionBatch) {
+      isLastBatch = true;
+      batch = files.size() - offset;
+    }
+    if (batch == 1 && delFiles.isEmpty()) {
+      // only one file left and no del files, do not compact it.
+      return Collections.emptyList();
+    }
+    // add the selected mob files and del files into filesToCompact
+    List<StoreFile> filesToCompact = new ArrayList<StoreFile>();
+    for (int i = offset; i < batch + offset; i++) {
+      StoreFile sf = new StoreFile(fs, files.get(i).getPath(), conf, compactionCacheConfig,
+        BloomType.NONE);
+      filesToCompact.add(sf);
+    }
+    // Pair(maxSeqId, cellsCount)
+    Pair<Long, Long> fileInfo = getFileInfo(filesToCompact);
+    filesToCompact.addAll(delFiles);
+    // open scanners to the selected mob files and del files.
+    List scanners = StoreFileScanner.getScannersForStoreFiles(filesToCompact, false, true, false,
+      null, HConstants.LATEST_TIMESTAMP);
+    Scan scan = new Scan();
+    scan.setMaxVersions(column.getMaxVersions());
+    long ttl = HStore.determineTTLFromFamily(column);
+    ScanInfo scanInfo = new ScanInfo(column, ttl, 0, KeyValue.COMPARATOR);
+    StoreScanner scanner = new StoreScanner(scan, scanInfo, ScanType.COMPACT_DROP_DELETES, null,
+      scanners, 0L, HConstants.LATEST_TIMESTAMP);
+    // open writers for the mob files and new ref store files.
+    Writer writer = null;
+    Writer refFileWriter = null;
+    Path filePath = null;
+    Path refFilePath = null;
+    long mobCells = 0;
+    try {
+      writer = MobUtils.createWriter(conf, fs, column, partition.getPartitionId().getDate(), tempPath,
+        Long.MAX_VALUE, column.getCompactionCompression(), partition.getPartitionId().getStartKey(),
+        compactionCacheConfig);
+      filePath = writer.getPath();
+      byte[] fileName = Bytes.toBytes(filePath.getName());
+      // create a temp file and open a write for it in the bulkloadPath
+      refFileWriter = MobUtils.createRefFileWriter(conf, fs, column, bulkloadPath, fileInfo
+        .getSecond().longValue(), compactionCacheConfig);
+      refFilePath = refFileWriter.getPath();
+      List<Cell> cells = new ArrayList<Cell>();
+      boolean hasMore = false;
+      do {
+        hasMore = scanner.next(cells, compactionKVMax);
+        for (Cell cell : cells) {
+          KeyValue kv = KeyValueUtil.ensureKeyValue(cell);
+          writer.append(kv);
+          KeyValue reference = MobUtils.createMobRefKeyValue(kv, fileName, tableNameTag);
+          refFileWriter.append(reference);
+          mobCells++;
+        }
+        cells.clear();
+      } while (hasMore);
+    } finally {
+      scanner.close();
+      if (writer != null) {
+        writer.appendMetadata(fileInfo.getFirst(), false, mobCells);
+        try {
+          writer.close();
+        } catch (IOException e) {
+          LOG.error("Fail to close the writer of the file " + filePath, e);
+        }
+      }
+      if (refFileWriter != null) {
+        refFileWriter.appendMetadata(fileInfo.getFirst(), false);
+        refFileWriter.appendFileInfo(StoreFile.BULKLOAD_TIME_KEY,
+          Bytes.toBytes(request.selectionTime));
+        try {
+          refFileWriter.close();
+        } catch (IOException e) {
+          LOG.error("Fail to close the writer of the ref file " + refFilePath, e);
+        }
+      }
+    }
+    if (mobCells > 0) {
+      // commit mob file
+      MobUtils.commitFile(conf, fs, filePath, mobFamilyDir, compactionCacheConfig);
+      // bulkload the ref file
+      try {
+        LoadIncrementalHFiles bulkload = new LoadIncrementalHFiles(conf);
+        bulkload.doBulkLoad(bulkloadPath, table);
+      } catch (Exception e) {
+        // delete the committed mob file and bulkload files in bulkloadPath
+        deletePath(new Path(mobFamilyDir, filePath.getName()));
+        deletePath(bulkloadPath);
+        throw new IOException(e);
+      }
+      // archive old files
+      List<StoreFile> archivedFiles = filesToCompact.subList(offset, batch);
+      try {
+        MobUtils.removeMobFiles(conf, fs, tableName, mobTableDir, column.getName(), archivedFiles);
+      } catch (IOException e) {
+        LOG.error("Fail to archive the files " + archivedFiles, e);
+      }
+    } else {
+      // remove the new files
+      // the mob file is empty, delete it instead of committing.
+      deletePath(filePath);
+      // the mob file is empty, delete it instead of committing.
+      deletePath(refFilePath);
+    }
+    // next round
+    if (!isLastBatch) {
+      newFiles.addAll(compactMobFilePartition(request, partition, offset + compactionBatch, delFiles,
+        table));
+    }
+    return newFiles;
+  }
+
+  /**
+   * Compacts the del files in batches which avoids opening too many files.
+   * @param request The compaction request.
+   * @param delFilePaths
+   * @return
+   * @throws IOException
+   */
+  protected List<Path> compactDelFiles(PartitionMobFileCompactionRequest request,
+    List<Path> delFilePaths) throws IOException {
+    if (delFilePaths.size() > delFileMaxCount) {
+      // when there are more del files than the number that is allowed, merge it firstly.
+      int index = 0;
+      List<StoreFile> delFiles = new ArrayList<StoreFile>();
+      List<Path> paths = new ArrayList<Path>();
+      for (Path delFilePath : delFilePaths) {
+        // compact the del files in batches.
+        if (index < compactionBatch) {
+          StoreFile delFile = new StoreFile(fs, delFilePath, conf, compactionCacheConfig,
+            BloomType.NONE);
+          delFiles.add(delFile);
+          index++;
+        } else {
+          // merge del store files in a batch.
+          paths.add(mergeDelFiles(request, delFiles));
+          delFiles.clear();
+          index = 0;
+        }
+      }
+      if (index > 0) {
+        // when the number of del files does not reach the compactionBatch and no more del
+        // files are left, directly merge them.
+        paths.add(mergeDelFiles(request, delFiles));
+        delFiles.clear();
+      }
+      // check whether the number of the del files is less than delFileMaxCount.
+      return compactDelFiles(request, paths);
+    } else {
+      return delFilePaths;
+    }
+  }
+
+  /**
+   * Merges the del file in a batch.
+   * @param request The compaction request.
+   * @param delFiles The del files.
+   * @return The path of new del file after merging.
+   * @throws IOException
+   */
+  private Path mergeDelFiles(PartitionMobFileCompactionRequest request, List<StoreFile> delFiles)
+    throws IOException {
+    // create a scanner for the del files.
+    List scanners = StoreFileScanner.getScannersForStoreFiles(delFiles, false, true, false, null,
+      HConstants.LATEST_TIMESTAMP);
+    Scan scan = new Scan();
+    scan.setMaxVersions(column.getMaxVersions());
+    long ttl = HStore.determineTTLFromFamily(column);
+    ScanInfo scanInfo = new ScanInfo(column, ttl, 0, KeyValue.COMPARATOR);
+    StoreScanner scanner = new StoreScanner(scan, scanInfo, ScanType.COMPACT_RETAIN_DELETES, null,
+      scanners, 0L, HConstants.LATEST_TIMESTAMP);
+    Writer writer = null;
+    Path filePath = null;
+    try {
+      writer = MobUtils.createDelFileWriter(conf, fs, column,
+        MobUtils.formatDate(new Date(request.selectionTime)), tempPath, Long.MAX_VALUE,
+        column.getCompactionCompression(), HConstants.EMPTY_START_ROW, compactionCacheConfig);
+      filePath = writer.getPath();
+      List<Cell> cells = new ArrayList<Cell>();
+      boolean hasMore = false;
+      do {
+        hasMore = scanner.next(cells, compactionKVMax);
+        for (Cell cell : cells) {
+          KeyValue kv = KeyValueUtil.ensureKeyValue(cell);
+          writer.append(kv);
+        }
+        cells.clear();
+      } while (hasMore);
+    } finally {
+      scanner.close();
+      if (writer != null) {
+        try {
+          writer.close();
+        } catch (IOException e) {
+          LOG.error("Fail to close the writer of the file " + filePath, e);
+        }
+      }
+    }
+    // commit the new del file
+    Path path = MobUtils.commitFile(conf, fs, filePath, mobFamilyDir, compactionCacheConfig);
+    // archive the old del files
+    try {
+      MobUtils.removeMobFiles(conf, fs, tableName, mobTableDir, column.getName(), delFiles);
+    } catch (IOException e) {
+      LOG.error("Fail to archive the old del files " + delFiles, e);
+    }
+    return path;
+  }
+
+  /**
+   * Gets the max seqId and number of cells of the store files.
+   * @param storeFiles The store files.
+   * @return The pair of the max seqId and number of cells of the store files.
+   * @throws IOException
+   */
+  private Pair<Long, Long> getFileInfo(List<StoreFile> storeFiles) throws IOException {
+    long maxSeqId = 0;
+    long maxKeyCount = 0;
+    for (StoreFile sf : storeFiles) {
+      // the readers will be closed later after the merge.
+      maxSeqId = Math.max(maxSeqId, sf.getMaxSequenceId());
+      byte[] count = sf.createReader().loadFileInfo().get(StoreFile.MOB_CELLS_COUNT);
+      if (count != null) {
+        maxKeyCount += Bytes.toLong(count);
+      }
+    }
+    return new Pair<Long, Long>(Long.valueOf(maxSeqId), Long.valueOf(maxKeyCount));
+  }
+
+  /**
+   * Deletes a file.
+   * @param path The path of the deleted file.
+   */
+  private void deletePath(Path path) {
+    try {
+      if (path != null) {
+        fs.delete(path, true);
+      }
+    } catch (IOException e) {
+      LOG.error("Fail to delete the file " + path, e);
+    }
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java
index ad7318b..b9f4038 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java
@@ -363,7 +363,7 @@ protected void createCacheConf(final HColumnDescriptor family) {
    * @param family
    * @return TTL in seconds of the specified family
    */
-  static long determineTTLFromFamily(final HColumnDescriptor family) {
+  public static long determineTTLFromFamily(final HColumnDescriptor family) {
     // HCD.getTimeToLive returns ttl in seconds.  Convert to milliseconds.
     long ttl = family.getTimeToLive();
     if (ttl == HConstants.FOREVER) {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java
index 5519b4b..a0f434a 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java
@@ -273,7 +273,7 @@ private StoreScanner(Store store, ScanInfo scanInfo, Scan scan,
       0);
   }
   
-  StoreScanner(final Scan scan, ScanInfo scanInfo,
+  public StoreScanner(final Scan scan, ScanInfo scanInfo,
       ScanType scanType, final NavigableSet<byte[]> columns,
       final List<KeyValueScanner> scanners, long earliestPutTs, long readPt)
           throws IOException {
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/replication/master/MobFileCompactChore.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/replication/master/MobFileCompactChore.java
new file mode 100644
index 0000000..388ab93
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/replication/master/MobFileCompactChore.java
@@ -0,0 +1,104 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.replication.master;
+
+import java.io.IOException;
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.hbase.Chore;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.TableDescriptors;
+import org.apache.hadoop.hbase.master.HMaster;
+import org.apache.hadoop.hbase.master.TableLockManager;
+import org.apache.hadoop.hbase.master.TableLockManager.TableLock;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.mob.filecompactions.MobFileCompactor;
+import org.apache.hadoop.hbase.mob.filecompactions.PartitionMobFileCompactor;
+
+/**
+ * The Class MobFileCompactChore for running compaction regularly to merge small mob files.
+ */
+@InterfaceAudience.Private
+public class MobFileCompactChore extends Chore{
+
+  private static final Log LOG = LogFactory.getLog(MobFileCompactChore.class);
+  private HMaster master;
+  private TableLockManager tableLockManager;
+
+  public MobFileCompactChore(HMaster master) {
+    super(master.getServerName() + "-MobFileCompactChore", master.getConfiguration().getInt(
+      MobConstants.MOB_COMPACTION_CHORE_PERIOD, MobConstants.DEFAULT_MOB_COMPACTION_CHORE_PERIOD),
+      master);
+    this.master = master;
+    this.tableLockManager = master.getTableLockManager();
+  }
+
+  @Override
+  protected void chore() {
+    try {
+      TableDescriptors htds = master.getTableDescriptors();
+      Map<String, HTableDescriptor> map = htds.getAll();
+      for (HTableDescriptor htd : map.values()) {
+        for (HColumnDescriptor hcd : htd.getColumnFamilies()) {
+          if (hcd.isMobEnabled()) {
+            // compact only for mob-enabled column.
+            // obtain a write table lock before performing compaction to avoid race condition
+            // with major compaction in mob-enabled column.
+            boolean tableLocked = false;
+            TableLock lock = null;
+            if (tableLockManager != null) {
+              lock = tableLockManager.writeLock(MobUtils.getTableLockName(htd.getTableName()),
+                "Run MobFileCompactChore");
+            }
+            try {
+              if (lock != null) {
+                lock.acquire();
+                tableLocked = true;
+              } else {
+                tableLocked = true;
+              }
+              MobFileCompactor compactor = new PartitionMobFileCompactor(master.getConfiguration(),
+                master.getFileSystem(), htd.getTableName(), hcd);
+              compactor.compact();
+            } catch (Exception e) {
+              LOG.error("Fail to compact the mob files for the column " + hcd.getNameAsString()
+                + " in the table " + htd.getNameAsString(), e);
+            } finally {
+              if (lock != null && tableLocked) {
+                try {
+                  lock.release();
+                } catch (IOException e) {
+                  LOG.error(
+                    "Fail to release the write lock for the table " + htd.getNameAsString(), e);
+                }
+              }
+            }
+          }
+        }
+      }
+    } catch (Exception e) {
+      LOG.error("Fail to clean the expired mob files", e);
+    }
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/filecompactions/TestMobFileCompactor.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/filecompactions/TestMobFileCompactor.java
new file mode 100644
index 0000000..514f4f7
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/filecompactions/TestMobFileCompactor.java
@@ -0,0 +1,322 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob.filecompactions;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Random;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.LargeTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.Admin;
+import org.apache.hadoop.hbase.client.Delete;
+import org.apache.hadoop.hbase.client.Durability;
+import org.apache.hadoop.hbase.client.HTable;
+import org.apache.hadoop.hbase.client.Put;
+import org.apache.hadoop.hbase.client.Result;
+import org.apache.hadoop.hbase.client.ResultScanner;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.regionserver.HRegion;
+import org.apache.hadoop.hbase.regionserver.StoreFileInfo;
+import org.apache.hadoop.hbase.regionserver.TestMobCompaction;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(LargeTests.class)
+public class TestMobFileCompactor {
+  static final Log LOG = LogFactory.getLog(TestMobCompaction.class.getName());
+  private final static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
+  private Configuration conf = null;
+  private String tableName;
+  private static HTable hTable;
+  private static Admin admin;
+  private static HTableDescriptor desc;
+  private static HColumnDescriptor hcd;
+  private static FileSystem fs;
+  private final static String row = "row_";
+  private final static String family = "family";
+  private final static String column = "column";
+
+  @BeforeClass
+  public static void setUpBeforeClass() throws Exception {
+    TEST_UTIL.getConfiguration().setInt("hbase.master.info.port", 0);
+    TEST_UTIL.getConfiguration().setBoolean("hbase.regionserver.info.port.auto", true);
+    TEST_UTIL.startMiniCluster(1);
+  }
+
+  @AfterClass
+  public static void tearDownAfterClass() throws Exception {
+    TEST_UTIL.shutdownMiniCluster();
+  }
+
+  @Before
+  public void setUp() throws Exception {
+    fs = TEST_UTIL.getTestFileSystem();
+    conf = TEST_UTIL.getConfiguration();
+    long tid = System.currentTimeMillis();
+    tableName = "testMob" + tid;
+    desc = new HTableDescriptor(TableName.valueOf(tableName));
+    hcd = new HColumnDescriptor(family);
+    hcd.setMobEnabled(true);
+    hcd.setMobThreshold(0L);
+    hcd.setMaxVersions(4);
+    desc.addFamily(hcd);
+    admin = TEST_UTIL.getHBaseAdmin();
+    admin.createTable(desc);
+    hTable = new HTable(conf, tableName);
+    hTable.setAutoFlush(false, false);
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    admin.disableTable(TableName.valueOf(tableName));
+    admin.deleteTable(TableName.valueOf(tableName));
+    admin.close();
+    fs.delete(TEST_UTIL.getDataTestDir(), true);
+  }
+
+  @Test
+  public void testCompactionWithoutDelFiles() throws Exception {
+    int count = 10;
+    //create table and generate 10 mob files
+    generateMobTable(count, 1);
+
+    assertEquals("Before compaction: mob rows", count, countMobRows(hTable));
+    assertEquals("Before compaction: mob file count", count, countMobFiles());
+    assertEquals("Before compaction: del file count", 0, countDelFiles());
+
+    MobFileCompactor compactor = new PartitionMobFileCompactor(conf, fs, desc.getTableName(), hcd);
+    compactor.compact();
+
+    assertEquals("After compaction: mob rows", count, countMobRows(hTable));
+    assertEquals("After compaction: mob file count", 1, countMobFiles());
+    assertEquals("After compaction: del file count", 0, countDelFiles());
+  }
+
+  @Test
+  public void testCompactionWithDelFiles() throws Exception {
+    int count = 8;
+    //create table and generate 8 mob files
+    generateMobTable(count, 1);
+
+    //get mob files
+    assertEquals("Before compaction: mob file count", count, countMobFiles());
+    assertEquals(count, countMobRows(hTable));
+
+    // now let's delete one cell
+    Delete delete = new Delete(Bytes.toBytes(row + 0));
+    delete.deleteFamily(Bytes.toBytes(family));
+    hTable.delete(delete);
+    hTable.flushCommits();
+    admin.flush(TableName.valueOf(tableName));
+
+    List<HRegion> regions = TEST_UTIL.getHBaseCluster().getRegions(Bytes.toBytes(tableName));
+    for(HRegion region : regions) {
+      region.waitForFlushesAndCompactions();
+      region.compactStores(true);
+    }
+
+    assertEquals("Before compaction: mob rows", count-1, countMobRows(hTable));
+    assertEquals("Before compaction: mob file count", count, countMobFiles());
+    assertEquals("Before compaction: del file count", 1, countDelFiles());
+
+    // do the mob file compaction
+    MobFileCompactor compactor = new PartitionMobFileCompactor(conf, fs, desc.getTableName(), hcd);
+    compactor.compact();
+
+    assertEquals("After compaction: mob rows", count-1, countMobRows(hTable));
+    assertEquals("After compaction: mob file count", 1, countMobFiles());
+    assertEquals("After compaction: del file count", 0, countDelFiles());
+  }
+
+  @Test
+  public void testCompactionWithDelFilesAndNotMergeAllFiles() throws Exception {
+    int mergeSize = 5000;
+    // change the mob compaction merge size
+    conf.setLong(MobConstants.MOB_COMPACTION_MERGEABLE_SIZE, mergeSize);
+
+    int count = 8;
+    // create table and generate 8 mob files
+    generateMobTable(count, 1);
+
+    // get mob files
+    assertEquals("Before compaction: mob file count", count, countMobFiles());
+    assertEquals(count, countMobRows(hTable));
+
+    int largeFilesCount = countLargeFiles(mergeSize);;
+
+    // now let's delete one cell
+    Delete delete = new Delete(Bytes.toBytes(row + 0));
+    delete.deleteFamily(Bytes.toBytes(family));
+    hTable.delete(delete);
+    hTable.flushCommits();
+    admin.flush(TableName.valueOf(tableName));
+
+    List<HRegion> regions = TEST_UTIL.getHBaseCluster().getRegions(Bytes.toBytes(tableName));
+    for(HRegion region : regions) {
+      region.waitForFlushesAndCompactions();
+      region.compactStores(true);
+    }
+    assertEquals("Before compaction: mob rows", count-1, countMobRows(hTable));
+    assertEquals("Before compaction: mob file count", count, countMobFiles());
+    assertEquals("Before compaction: del file count", 1, countDelFiles());
+
+    // do the mob file compaction
+    MobFileCompactor compactor = new PartitionMobFileCompactor(conf, fs, desc.getTableName(), hcd);
+    compactor.compact();
+
+    assertEquals("After compaction: mob rows", count-1, countMobRows(hTable));
+    // After the compaction, the files smaller than the mob compaction merge size is merge to one file
+    assertEquals("After compaction: mob file count", largeFilesCount + 1, countMobFiles());
+    assertEquals("After compaction: del file count", 1, countDelFiles());
+
+    // reset the conf the the default
+    conf.setLong(MobConstants.MOB_COMPACTION_MERGEABLE_SIZE,
+        MobConstants.DEFAULT_MOB_COMPACTION_MERGEABLE_SIZE);
+  }
+
+  /**
+   * count the number of rows in the given table.
+   * @param table
+   * @return the number of rows
+   */
+  private int countMobRows(final HTable table) throws IOException {
+    Scan scan = new Scan();
+    // Do not retrieve the mob data when scanning
+    scan.setAttribute(MobConstants.MOB_SCAN_RAW, Bytes.toBytes(Boolean.TRUE));
+    ResultScanner results = table.getScanner(scan);
+    int count = 0;
+    for (Result res : results) {
+      count++;
+    }
+    results.close();
+    return count;
+  }
+
+  /**
+   * count the number of mob files in the mob path.
+   * @return the number of the mob files
+   */
+  private int countMobFiles() throws IOException {
+    Path mobDirPath = MobUtils.getMobFamilyPath(MobUtils.getMobRegionPath(conf,
+        TableName.valueOf(tableName)), family);
+    int count = 0;
+    if (fs.exists(mobDirPath)) {
+      FileStatus[] files = fs.listStatus(mobDirPath);
+      for(FileStatus file : files) {
+        if(!StoreFileInfo.isDelFile(file.getPath())) {
+          count++;
+        }
+      }
+    }
+    return count;
+  }
+
+  /**
+   * count the number of del files in the mob path.
+   * @return the number of the del files
+   */
+  private int countDelFiles() throws IOException {
+    Path mobDirPath = MobUtils.getMobFamilyPath(MobUtils.getMobRegionPath(conf,
+        TableName.valueOf(tableName)), family);
+    int count = 0;
+    if (fs.exists(mobDirPath)) {
+      FileStatus[] files = fs.listStatus(mobDirPath);
+      for(FileStatus file : files) {
+        if(StoreFileInfo.isDelFile(file.getPath())) {
+          count++;
+        }
+      }
+    }
+    return count;
+  }
+
+  /**
+   * count the number of files.
+   * @param size the size of the file
+   * @return the number of files large than the size
+   */
+  private int countLargeFiles(int size) throws IOException {
+    Path mobDirPath = MobUtils.getMobFamilyPath(MobUtils.getMobRegionPath(
+        TEST_UTIL.getConfiguration(), TableName.valueOf(tableName)), family);
+    int count = 0;
+    if (fs.exists(mobDirPath)) {
+      FileStatus[] files = fs.listStatus(mobDirPath);
+      for(FileStatus file : files) {
+        // ignore the del files in the mob path
+        if((!StoreFileInfo.isDelFile(file.getPath())) && (file.getLen() > size)) {
+          count++;
+        }
+      }
+    }
+    return count;
+  }
+
+  /**
+   * generate the mob table and insert some data in the table.
+   * @param count the mob file number
+   * @param flushStep the number of flush step
+   */
+  private void generateMobTable(int count, int flushStep)
+      throws IOException, InterruptedException {
+    if (count <= 0 || flushStep <= 0)
+      return;
+    int index = 0;
+    for (int i = 0; i < count; i++) {
+      byte[] mobVal = makeDummyData(100*(i+1));
+      Put put = new Put(Bytes.toBytes(row + i));
+      put.setDurability(Durability.SKIP_WAL);
+      put.add(Bytes.toBytes(family), Bytes.toBytes(column), mobVal);
+      hTable.put(put);
+      if (index++ % flushStep == 0) {
+        hTable.flushCommits();
+        admin.flush(TableName.valueOf(tableName));
+      }
+    }
+  }
+
+  /**
+   * make the dummy data with the size.
+   * @param the size of data
+   * @return the dummy data
+   */
+  private byte[] makeDummyData(int size) {
+    byte[] dummyData = new byte[size];
+    new Random().nextBytes(dummyData);
+    return dummyData;
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/filecompactions/TestPartitionMobFileCompactionRequest.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/filecompactions/TestPartitionMobFileCompactionRequest.java
new file mode 100644
index 0000000..76d60bb
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/filecompactions/TestPartitionMobFileCompactionRequest.java
@@ -0,0 +1,60 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob.filecompactions;
+
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.SmallTests;
+import org.apache.hadoop.hbase.mob.filecompactions.PartitionMobFileCompactionRequest.CompactedPartition;
+import org.apache.hadoop.hbase.mob.filecompactions.PartitionMobFileCompactionRequest.CompactedPartitionId;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(SmallTests.class)
+public class TestPartitionMobFileCompactionRequest {
+
+  @Test
+  public void testCompactedPartitionId() {
+    String startKey1 = "startKey1";
+    String startKey2 = "startKey2";
+    String date1 = "date1";
+    String date2 = "date2";
+    CompactedPartitionId partitionId1 = new CompactedPartitionId(startKey1, date1);
+    CompactedPartitionId partitionId2 = new CompactedPartitionId(startKey2, date2);
+    CompactedPartitionId partitionId3 = new CompactedPartitionId(startKey1, date2);
+
+    Assert.assertTrue(partitionId1.equals(partitionId1));
+    Assert.assertFalse(partitionId1.equals(partitionId2));
+    Assert.assertFalse(partitionId1.equals(partitionId3));
+    Assert.assertFalse(partitionId2.equals(partitionId3));
+
+    Assert.assertEquals(startKey1, partitionId1.getStartKey());
+    Assert.assertEquals(date1, partitionId1.getDate());
+  }
+
+  @Test
+  public void testCompactedPartition() {
+    CompactedPartitionId partitionId = new CompactedPartitionId("startKey1", "date1");
+    CompactedPartition partition = new CompactedPartition(partitionId);
+    FileStatus file = new FileStatus(1, false, 1, 1024, 1, new Path("/test"));
+    partition.addFile(file);
+    Assert.assertEquals(file, partition.listFiles().get(0));
+  }
+}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/filecompactions/TestPartitionMobFileCompactor.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/filecompactions/TestPartitionMobFileCompactor.java
new file mode 100644
index 0000000..afcecb1
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/mob/filecompactions/TestPartitionMobFileCompactor.java
@@ -0,0 +1,235 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.mob.filecompactions;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Random;
+import java.util.UUID;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.LargeTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.io.hfile.CacheConfig;
+import org.apache.hadoop.hbase.io.hfile.HFileContext;
+import org.apache.hadoop.hbase.io.hfile.HFileContextBuilder;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.mob.MobFileName;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.mob.filecompactions.MobFileCompactionRequest.CompactionType;
+import org.apache.hadoop.hbase.mob.filecompactions.PartitionMobFileCompactionRequest.CompactedPartition;
+import org.apache.hadoop.hbase.regionserver.StoreFile;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.FSUtils;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(LargeTests.class)
+public class TestPartitionMobFileCompactor {
+  private final static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
+  private final static String family = "family";
+  private final static String qf = "qf";
+  private HColumnDescriptor hcd = new HColumnDescriptor(family);
+  protected static final char FIRST_CHAR = 'a';
+  protected static final char LAST_CHAR = 'z';
+  private Configuration conf = TEST_UTIL.getConfiguration();
+  private CacheConfig cacheConf = new CacheConfig(conf);
+  private byte[] startKey1;
+  private byte[] startKey2;
+  private Random random = new Random();
+  private FileSystem fs;
+  private List<String> expectedStartKeys = new ArrayList<>();
+  private List<FileStatus> delFiles = new ArrayList<>();
+  private List<FileStatus> allFiles = new ArrayList<>();
+
+  @BeforeClass
+  public static void setUpBeforeClass() throws Exception {
+    TEST_UTIL.getConfiguration().setInt("hbase.master.info.port", 0);
+    TEST_UTIL.getConfiguration().setBoolean("hbase.regionserver.info.port.auto", true);
+    TEST_UTIL.getConfiguration().setInt("hfile.format.version", 3);
+    TEST_UTIL.startMiniCluster(1);
+  }
+
+  @AfterClass
+  public static void tearDownAfterClass() throws Exception {
+    TEST_UTIL.shutdownMiniCluster();
+  }
+
+  public void init(String tableName) throws Exception {
+    fs = FileSystem.get(conf);
+    Path testDir = FSUtils.getRootDir(conf);
+    Path mobTestDir = new Path(testDir, MobConstants.MOB_DIR_NAME);
+    Path basePath = new Path(new Path(mobTestDir, tableName), family);
+
+    String mobSuffix = UUID.randomUUID().toString().replaceAll("-", "");
+    startKey1 = Bytes.toBytes(random.nextInt());
+    startKey2 = Bytes.toBytes(random.nextInt());
+    MobFileName mobFileName1 = MobFileName.create(startKey1, MobUtils.formatDate(new Date()),
+        mobSuffix);
+    MobFileName mobFileName2 = MobFileName.create(startKey2, MobUtils.formatDate(new Date()),
+        mobSuffix);
+    expectedStartKeys.add(mobFileName1.getStartKey());
+    expectedStartKeys.add(mobFileName2.getStartKey());
+    // create two mob files.
+    createStoreFile(basePath, mobFileName1, family, qf);
+    createStoreFile(basePath, mobFileName2, family, qf);
+
+    String delSuffix = UUID.randomUUID().toString().replaceAll("-", "") + "_del";
+    MobFileName delFileName1 = MobFileName.create(startKey1, MobUtils.formatDate(new Date()),
+        delSuffix);
+    MobFileName delFileName2 = MobFileName.create(startKey2, MobUtils.formatDate(new Date()),
+        delSuffix);
+    // create two del files
+    createStoreFile(basePath, delFileName1, family, qf);
+    createStoreFile(basePath, delFileName2, family, qf);
+
+    for (FileStatus file : fs.listStatus(basePath)) {
+      allFiles.add(file);
+      if (file.getPath().getName().endsWith("_del")) {
+        delFiles.add(file);
+      }
+    }
+  }
+
+  @Test
+  public void testCompactionSelect() throws Exception {
+    String tableName = "testCompactionSelect";
+    init(tableName);
+    PartitionMobFileCompactor compactor = new PartitionMobFileCompactor(conf, fs,
+        TableName.valueOf(tableName), hcd) {
+      @Override
+      public List<Path> compact(List<FileStatus> files) throws IOException {
+        if (files == null || files.isEmpty()) {
+          return null;
+        }
+        PartitionMobFileCompactionRequest request = select(files);
+        // assert the compaction type is all files
+         Assert.assertTrue((request.type).equals(CompactionType.ALL_FILES));
+        // assert get the right partitions
+        compareCompactedPartitions(request.compactedPartitions);
+        // assert get the right del files
+        compareDelFiles(request.delFiles);
+        return null;
+      }
+    };
+    compactor.compact(allFiles);
+  }
+
+  @Test
+  public void testCompactDelFiles() throws Exception {
+    String tableName = "testCompactDelFiles";
+    init(tableName);
+    // set the max del file count
+    TEST_UTIL.getConfiguration().setInt(MobConstants.MOB_DELFILE_MAX_COUNT, 1);
+    PartitionMobFileCompactor compactor = new PartitionMobFileCompactor(conf, fs,
+        TableName.valueOf(tableName), hcd) {
+      @Override
+      protected List<Path> performCompact(PartitionMobFileCompactionRequest request)
+          throws IOException {
+        List<Path> delFilePaths = new ArrayList<Path>();
+        for (FileStatus delFile : request.delFiles) {
+          delFilePaths.add(delFile.getPath());
+        }
+        List<Path> newDelPaths = compactDelFiles(request, delFilePaths);
+        // assert the del files are merged.
+        Assert.assertTrue(newDelPaths.size() == 1);
+        return null;
+      }
+    };
+    compactor.compact(allFiles);
+  }
+
+  /**
+   * compare the compacted partitions.
+   * @param partitions the collection of CompactedPartitions
+   */
+  private void compareCompactedPartitions(Collection<CompactedPartition> partitions) {
+    List<String> actualKeys = new ArrayList<>();
+    for (CompactedPartition partition : partitions) {
+      actualKeys.add(partition.getPartitionId().getStartKey());
+    }
+    Collections.sort(expectedStartKeys);
+    Collections.sort(actualKeys);
+    Assert.assertEquals(expectedStartKeys.size(), actualKeys.size());
+    for (int i = 0; i < expectedStartKeys.size(); i++) {
+      Assert.assertEquals(expectedStartKeys.get(i), actualKeys.get(i));
+    }
+  }
+
+  /**
+   * compare the del files.
+   * @param allDelFiles all the del files
+   */
+  private void compareDelFiles(Collection<FileStatus> allDelFiles) {
+    int i = 0;
+    for (FileStatus file : allDelFiles) {
+      Assert.assertEquals(delFiles.get(i), file);
+      i++;
+    }
+  }
+
+  /**
+   * create store file
+   * @param basePath the path to create file
+   * @mobFileName the mob file name
+   * @family the family name
+   * @qualifier the column qualifier
+   */
+  private void createStoreFile(Path basePath, MobFileName mobFileName, String family, String qualifier)
+      throws IOException {
+    HFileContext meta = new HFileContextBuilder().withBlockSize(8 * 1024).build();
+    StoreFile.Writer mobFileWriter = new StoreFile.WriterBuilder(conf, cacheConf, fs)
+        .withFileContext(meta).withFilePath(new Path(basePath, mobFileName.getFileName())).build();
+    writeStoreFile(mobFileWriter, Bytes.toBytes(family), Bytes.toBytes(qualifier));
+  }
+
+  /**
+   * write data to store file
+   * @param writer the storefile writer
+   * @family the family name
+   * @qualifier the column qualifier
+   */
+  private static void writeStoreFile(final StoreFile.Writer writer, byte[] family, byte[] qualifier)
+      throws IOException {
+    long now = System.currentTimeMillis();
+    try {
+      for (char d = FIRST_CHAR; d <= LAST_CHAR; d++) {
+        for (char e = FIRST_CHAR; e <= LAST_CHAR; e++) {
+          byte[] b = new byte[] { (byte) d, (byte) e };
+          writer.append(new KeyValue(b, family, qualifier, now, b));
+        }
+      }
+    } finally {
+      writer.close();
+    }
+  }
+}
