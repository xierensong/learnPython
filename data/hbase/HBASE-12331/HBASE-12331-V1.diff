diff --git a/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobCloneSnapshotFromClient.java b/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobCloneSnapshotFromClient.java
new file mode 100644
index 0000000..141cba8
--- /dev/null
+++ b/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobCloneSnapshotFromClient.java
@@ -0,0 +1,298 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.snapshot;
+
+import static org.junit.Assert.fail;
+
+import java.io.IOException;
+import java.util.Set;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.IntegrationTestBase;
+import org.apache.hadoop.hbase.IntegrationTestingUtility;
+import org.apache.hadoop.hbase.IntegrationTests;
+import org.apache.hadoop.hbase.NamespaceDescriptor;
+import org.apache.hadoop.hbase.NamespaceNotFoundException;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.Admin;
+import org.apache.hadoop.hbase.client.HTable;
+import org.apache.hadoop.hbase.master.snapshot.SnapshotManager;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.util.ToolRunner;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import com.google.common.collect.Sets;
+
+/**
+ * Test clone snapshots from the client
+ */
+@Category(IntegrationTests.class)
+public class IntegrationTestMobCloneSnapshotFromClient extends IntegrationTestBase {
+
+  private static final byte[] FAMILY = Bytes.toBytes("cf");
+  private byte[] emptySnapshot;
+  private byte[] snapshotName0;
+  private byte[] snapshotName1;
+  private byte[] snapshotName2;
+  private int snapshot0Rows;
+  private int snapshot1Rows;
+  private TableName tableName;
+  private Admin admin;
+
+  @Override
+  public void setUpCluster() throws Exception {
+    util = getTestingUtil(getConf());
+    setUpBaseConf(util.getConfiguration());
+    util.initializeCluster(1);
+  }
+
+  public static void setUpBaseConf(Configuration conf) {
+    conf.setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED, true);
+    conf.setBoolean("hbase.online.schema.update.enable", true);
+    conf.setInt("hbase.hstore.compactionThreshold", 10);
+    conf.setInt("hbase.regionserver.msginterval", 100);
+    conf.setInt("hbase.client.pause", 250);
+    conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 6);
+    conf.setBoolean(
+        "hbase.master.enabletable.roundrobin", true);
+    conf.setInt(MobConstants.MOB_FILE_CACHE_SIZE_KEY, 0);
+  }
+
+  /**
+   * Initialize the tests with a table filled with some data
+   * and two snapshots (snapshotName0, snapshotName1) of different states.
+   * The tableName, snapshotNames and the number of rows in the snapshot are initialized.
+   */
+  public void setUpTest() throws Exception {
+
+    this.admin = util.getHBaseAdmin();
+    long tid = System.currentTimeMillis();
+    tableName = TableName.valueOf("testtb-" + tid);
+    emptySnapshot = Bytes.toBytes("emptySnaptb-" + tid);
+    snapshotName0 = Bytes.toBytes("snaptb0-" + tid);
+    snapshotName1 = Bytes.toBytes("snaptb1-" + tid);
+    snapshotName2 = Bytes.toBytes("snaptb2-" + tid);
+
+    // create Table and disable it
+    MobSnapshotTestingUtils.createMobTable(util, tableName, getNumReplicas(), FAMILY);
+    admin.disableTable(tableName);
+
+    // take an empty snapshot
+    admin.snapshot(emptySnapshot, tableName);
+
+    HTable table = new HTable(util.getConfiguration(), tableName);
+    try {
+      // enable table and insert data
+      admin.enableTable(tableName);
+      MobSnapshotTestingUtils.loadMobData(util, table, 100, FAMILY);
+      snapshot0Rows = MobSnapshotTestingUtils.countMobRows(table);
+      admin.disableTable(tableName);
+
+      // take a snapshot
+      admin.snapshot(snapshotName0, tableName);
+
+      // enable table and insert more data
+      admin.enableTable(tableName);
+      MobSnapshotTestingUtils.loadMobData(util, table, 100, FAMILY);
+      snapshot1Rows = MobSnapshotTestingUtils.countMobRows(table);
+      admin.disableTable(tableName);
+
+      // take a snapshot of the updated table
+      admin.snapshot(snapshotName1, tableName);
+
+      // re-enable table
+      admin.enableTable(tableName);
+    } finally {
+      table.close();
+    }
+  }
+
+  public void cleanUpTest() throws Exception {
+    if (admin.tableExists(tableName)) {
+      util.deleteTable(tableName);
+    }
+    if (util.isDistributedCluster()) {
+      util.getHBaseClusterInterface().restoreInitialStatus();
+    } else {
+      SnapshotTestingUtils.deleteAllSnapshots(admin);
+      SnapshotTestingUtils.deleteArchiveDirectory(util);
+    }
+  }
+
+  protected int getNumReplicas() {
+    return 3;
+  }
+
+  @Test
+  public void testAll() throws Exception {
+    testCloneNonExistentSnapshot();
+    testCloneOnMissingNamespace();
+    testCloneSnapshot();
+    testCloneSnapshotCrossNamespace();
+    testCloneLinksAfterDelete();
+  }
+
+  public void testCloneNonExistentSnapshot() throws Exception {
+    setUpTest();
+    String snapshotName = "random-snapshot-" + System.currentTimeMillis();
+    TableName tableName = TableName.valueOf("random-table-" + System.currentTimeMillis());
+    try {
+      admin.cloneSnapshot(snapshotName, tableName);
+      fail("Expected SnapshotDoesNotExistException, got succeeded cloneSnapshot()");
+    } catch (SnapshotDoesNotExistException e) {
+      // expected
+    }
+    cleanUpTest();
+  }
+
+  public void testCloneOnMissingNamespace() throws Exception {
+    setUpTest();
+    TableName clonedTableName = TableName.valueOf("unknownNS:clonetb");
+    try {
+      admin.cloneSnapshot(snapshotName1, clonedTableName);
+      fail("Expected NamespaceNotFoundException, got succeeded cloneSnapshot()");
+    } catch (NamespaceNotFoundException e) {
+      // expected
+    }
+    cleanUpTest();
+  }
+
+  public void testCloneSnapshot() throws Exception {
+    setUpTest();
+    TableName clonedTableName = TableName.valueOf("clonedtb-" + System.currentTimeMillis());
+    testCloneSnapshot(clonedTableName, snapshotName0, snapshot0Rows);
+    testCloneSnapshot(clonedTableName, snapshotName1, snapshot1Rows);
+    testCloneSnapshot(clonedTableName, emptySnapshot, 0);
+    cleanUpTest();
+  }
+
+  private void testCloneSnapshot(final TableName tableName, final byte[] snapshotName,
+      int snapshotRows) throws IOException, InterruptedException {
+    // create a new table from snapshot
+    admin.cloneSnapshot(snapshotName, tableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, snapshotRows);
+
+    verifyReplicasCameOnline(tableName);
+    util.deleteTable(tableName);
+  }
+
+  protected void verifyReplicasCameOnline(TableName tableName) throws IOException {
+    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
+  }
+
+  public void testCloneSnapshotCrossNamespace() throws Exception {
+    setUpTest();
+    String nsName = "testCloneSnapshotCrossNamespace" + System.currentTimeMillis();
+    admin.createNamespace(NamespaceDescriptor.create(nsName).build());
+    TableName clonedTableName =
+        TableName.valueOf(nsName, "clonedtb-" + System.currentTimeMillis());
+    testCloneSnapshot(clonedTableName, snapshotName0, snapshot0Rows);
+    testCloneSnapshot(clonedTableName, snapshotName1, snapshot1Rows);
+    testCloneSnapshot(clonedTableName, emptySnapshot, 0);
+    admin.deleteNamespace(nsName);
+    cleanUpTest();
+  }
+
+  /**
+   * Verify that tables created from the snapshot are still alive after source table deletion.
+   * @throws Exception
+   */
+  public void testCloneLinksAfterDelete() throws Exception {
+    setUpTest();
+    // Clone a table from the first snapshot
+    TableName clonedTableName = TableName.valueOf("clonedtb1-" + System.currentTimeMillis());
+    admin.cloneSnapshot(snapshotName0, clonedTableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, clonedTableName, snapshot0Rows);
+
+    // Take a snapshot of this cloned table.
+    admin.disableTable(clonedTableName);
+    admin.snapshot(snapshotName2, clonedTableName);
+
+    // Clone the snapshot of the cloned table
+    TableName clonedTableName2 = TableName.valueOf("clonedtb2-" + System.currentTimeMillis());
+    admin.cloneSnapshot(snapshotName2, clonedTableName2);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, clonedTableName2, snapshot0Rows);
+    admin.disableTable(clonedTableName2);
+
+    // Remove the original table
+    util.deleteTable(tableName);
+    waitCleanerRun();
+
+    // Verify the first cloned table
+    admin.enableTable(clonedTableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, clonedTableName, snapshot0Rows);
+
+    // Verify the second cloned table
+    admin.enableTable(clonedTableName2);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, clonedTableName2, snapshot0Rows);
+    admin.disableTable(clonedTableName2);
+
+    // Delete the first cloned table
+    util.deleteTable(clonedTableName);
+    waitCleanerRun();
+
+    // Verify the second cloned table
+    admin.enableTable(clonedTableName2);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, clonedTableName2, snapshot0Rows);
+
+    // Clone a new table from cloned
+    TableName clonedTableName3 = TableName.valueOf("clonedtb3-" + System.currentTimeMillis());
+    admin.cloneSnapshot(snapshotName2, clonedTableName3);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, clonedTableName3, snapshot0Rows);
+
+    // Delete the cloned tables
+    util.deleteTable(clonedTableName2);
+    util.deleteTable(clonedTableName3);
+    admin.deleteSnapshot(snapshotName2);
+    cleanUpTest();
+  }
+
+  private void waitCleanerRun() throws InterruptedException {
+    if (!util.isDistributedCluster()) {
+      util.getMiniHBaseCluster().getMaster().getHFileCleaner().choreForTesting();
+    }
+  }
+
+  @Override
+  public int runTestFromCommandLine() throws Exception {
+    testAll();
+    return 0;
+  }
+
+  @Override
+  public TableName getTablename() {
+    return tableName;
+  }
+
+  @Override
+  protected Set<String> getColumnFamilies() {
+    return Sets.newHashSet(Bytes.toString(FAMILY));
+  }
+
+  public static void main(String[] args) throws Exception {
+    Configuration conf = HBaseConfiguration.create();
+    IntegrationTestingUtility.setUseDistributedCluster(conf);
+    int status =  ToolRunner.run(conf, new IntegrationTestMobCloneSnapshotFromClient(), args);
+    System.exit(status);
+  }
+}
\ No newline at end of file
diff --git a/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobExportSnapshot.java b/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobExportSnapshot.java
new file mode 100644
index 0000000..3c5a0f7
--- /dev/null
+++ b/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobExportSnapshot.java
@@ -0,0 +1,423 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.snapshot;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.IntegrationTestBase;
+import org.apache.hadoop.hbase.IntegrationTestingUtility;
+import org.apache.hadoop.hbase.IntegrationTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.Admin;
+import org.apache.hadoop.hbase.master.snapshot.SnapshotManager;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.mob.MobUtils;
+import org.apache.hadoop.hbase.protobuf.generated.HBaseProtos.SnapshotDescription;
+import org.apache.hadoop.hbase.protobuf.generated.SnapshotProtos.SnapshotFileInfo;
+import org.apache.hadoop.hbase.protobuf.generated.SnapshotProtos.SnapshotRegionManifest;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.FSUtils;
+import org.apache.hadoop.hbase.util.Pair;
+import org.apache.hadoop.util.ToolRunner;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import com.google.common.collect.Sets;
+
+/**
+ * Test Export Snapshot Tool
+ */
+@Category(IntegrationTests.class)
+public class IntegrationTestMobExportSnapshot extends IntegrationTestBase {
+
+  private final Log LOG = LogFactory.getLog(getClass());
+
+  private final static byte[] FAMILY = Bytes.toBytes("cf");
+  private byte[] emptySnapshotName;
+  private byte[] snapshotName;
+  private int tableNumFiles;
+  private TableName tableName;
+  private Admin admin;
+
+  @Override
+  public void setUpCluster() throws Exception {
+    util = getTestingUtil(getConf());
+    setUpBaseConf(util.getConfiguration());
+    util.initializeCluster(1);
+
+    if (!util.isDistributedCluster()) {
+      // also need MR when running without a real cluster
+      util.startMiniMapReduceCluster();
+    }
+  }
+
+  @Override
+  public void cleanUpCluster() throws Exception {
+    if (!util.isDistributedCluster()) {
+      util.shutdownMiniMapReduceCluster();
+    }
+    super.cleanUpCluster();
+  }
+
+  public static void setUpBaseConf(Configuration conf) {
+    conf.setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED, true);
+    conf.setInt("hbase.regionserver.msginterval", 100);
+    conf.setInt("hbase.client.pause", 250);
+    conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 6);
+    conf.setBoolean("hbase.master.enabletable.roundrobin", true);
+    conf.setInt("mapreduce.map.maxattempts", 10);
+    conf.setInt(MobConstants.MOB_FILE_CACHE_SIZE_KEY, 0);
+  }
+
+  /**
+   * Create a table and take a snapshot of the table used by the export test.
+   */
+  public void setUpTest() throws Exception {
+
+    this.admin = util.getHBaseAdmin();
+    long tid = System.currentTimeMillis();
+    tableName = TableName.valueOf("testtb-" + tid);
+    snapshotName = Bytes.toBytes("snaptb0-" + tid);
+    emptySnapshotName = Bytes.toBytes("emptySnaptb0-" + tid);
+
+    // create Table
+    MobSnapshotTestingUtils.createMobTable(util, tableName, 1, FAMILY);
+
+    // Take an empty snapshot
+    admin.snapshot(emptySnapshotName, tableName);
+
+    // Add some rows
+    MobSnapshotTestingUtils.loadMobData(util, tableName, 10, FAMILY);
+    tableNumFiles = admin.getTableRegions(tableName).size();
+
+    // take a snapshot
+    admin.snapshot(snapshotName, tableName);
+  }
+
+  public void cleanUpTest() throws Exception {
+    if (admin.tableExists(tableName)) {
+      util.deleteTable(tableName);
+    }
+    if (util.isDistributedCluster()) {
+      util.getHBaseClusterInterface().restoreInitialStatus();
+    } else {
+      SnapshotTestingUtils.deleteAllSnapshots(admin);
+      SnapshotTestingUtils.deleteArchiveDirectory(util);
+    }
+  }
+
+  @Test
+  public void testAll() throws Exception {
+    testBalanceSplit();
+    testExportWithTargetName();
+    testExportFileSystemState();
+    testConsecutiveExports();
+    testEmptyExportFileSystemState();
+    testExportFileSystemStateWithSkipTmp();
+    testExportRetry();
+  }
+
+  /**
+   * Verfy the result of getBalanceSplits() method.
+   * The result are groups of files, used as input list for the "export" mappers.
+   * All the groups should have similar amount of data.
+   *
+   * The input list is a pair of file path and length.
+   * The getBalanceSplits() function sort it by length,
+   * and assign to each group a file, going back and forth through the groups.
+   */
+  public void testBalanceSplit() throws Exception {
+    setUpTest();
+    // Create a list of files
+    List<Pair<SnapshotFileInfo, Long>> files = new ArrayList<Pair<SnapshotFileInfo, Long>>();
+    for (long i = 0; i <= 20; i++) {
+      SnapshotFileInfo fileInfo = SnapshotFileInfo.newBuilder()
+        .setType(SnapshotFileInfo.Type.HFILE)
+        .setHfile("file-" + i)
+        .build();
+      files.add(new Pair<SnapshotFileInfo, Long>(fileInfo, i));
+    }
+
+    // Create 5 groups (total size 210)
+    //    group 0: 20, 11, 10,  1 (total size: 42)
+    //    group 1: 19, 12,  9,  2 (total size: 42)
+    //    group 2: 18, 13,  8,  3 (total size: 42)
+    //    group 3: 17, 12,  7,  4 (total size: 42)
+    //    group 4: 16, 11,  6,  5 (total size: 42)
+    List<List<Pair<SnapshotFileInfo, Long>>> splits = ExportSnapshot.getBalancedSplits(files, 5);
+    assertEquals(5, splits.size());
+
+    String[] split0 = new String[] {"file-20", "file-11", "file-10", "file-1", "file-0"};
+    verifyBalanceSplit(splits.get(0), split0, 42);
+    String[] split1 = new String[] {"file-19", "file-12", "file-9",  "file-2"};
+    verifyBalanceSplit(splits.get(1), split1, 42);
+    String[] split2 = new String[] {"file-18", "file-13", "file-8",  "file-3"};
+    verifyBalanceSplit(splits.get(2), split2, 42);
+    String[] split3 = new String[] {"file-17", "file-14", "file-7",  "file-4"};
+    verifyBalanceSplit(splits.get(3), split3, 42);
+    String[] split4 = new String[] {"file-16", "file-15", "file-6",  "file-5"};
+    verifyBalanceSplit(splits.get(4), split4, 42);
+    cleanUpTest();
+  }
+
+  private void verifyBalanceSplit(final List<Pair<SnapshotFileInfo, Long>> split,
+      final String[] expected, final long expectedSize) throws Exception {
+    setUpTest();
+    assertEquals(expected.length, split.size());
+    long totalSize = 0;
+    for (int i = 0; i < expected.length; ++i) {
+      Pair<SnapshotFileInfo, Long> fileInfo = split.get(i);
+      assertEquals(expected[i], fileInfo.getFirst().getHfile());
+      totalSize += fileInfo.getSecond();
+    }
+    assertEquals(expectedSize, totalSize);
+    cleanUpTest();
+  }
+
+  /**
+   * Verify if exported snapshot and copied files matches the original one.
+   */
+  public void testExportFileSystemState() throws Exception {
+    setUpTest();
+    testExportFileSystemState(tableName, snapshotName, snapshotName, tableNumFiles);
+    cleanUpTest();
+  }
+
+  public void testExportFileSystemStateWithSkipTmp() throws Exception {
+    setUpTest();
+    util.getConfiguration().setBoolean(ExportSnapshot.CONF_SKIP_TMP, true);
+    testExportFileSystemState(tableName, snapshotName, snapshotName, tableNumFiles);
+    cleanUpTest();
+  }
+
+  public void testEmptyExportFileSystemState() throws Exception {
+    setUpTest();
+    testExportFileSystemState(tableName, emptySnapshotName, emptySnapshotName, 0);
+    cleanUpTest();
+  }
+
+  public void testConsecutiveExports() throws Exception {
+    setUpTest();
+    Path copyDir = getLocalDestinationDir();
+    testExportFileSystemState(tableName, snapshotName, snapshotName, tableNumFiles, copyDir, false);
+    testExportFileSystemState(tableName, snapshotName, snapshotName, tableNumFiles, copyDir, true);
+    removeExportDir(copyDir);
+    cleanUpTest();
+  }
+
+  public void testExportWithTargetName() throws Exception {
+    setUpTest();
+    final byte[] targetName = Bytes.toBytes("testExportWithTargetName");
+    testExportFileSystemState(tableName, snapshotName, targetName, tableNumFiles);
+    cleanUpTest();
+  }
+
+  private void testExportFileSystemState(final TableName tableName, final byte[] snapshotName,
+      final byte[] targetName, int filesExpected) throws Exception {
+    Path copyDir = getHdfsDestinationDir();
+    testExportFileSystemState(tableName, snapshotName, targetName, filesExpected, copyDir, false);
+    removeExportDir(copyDir);
+  }
+
+  /**
+   * Test ExportSnapshot
+   */
+  private void testExportFileSystemState(final TableName tableName, final byte[] snapshotName,
+      final byte[] targetName, int filesExpected, Path copyDir, boolean overwrite)
+      throws Exception {
+    URI hdfsUri = FileSystem.get(util.getConfiguration()).getUri();
+    FileSystem fs = FileSystem.get(copyDir.toUri(), new Configuration());
+    copyDir = copyDir.makeQualified(fs);
+    List<String> opts = new ArrayList<String>();
+    opts.add("-snapshot");
+    opts.add(Bytes.toString(snapshotName));
+    opts.add("-copy-to");
+    opts.add(copyDir.toString());
+    if (targetName != snapshotName) {
+      opts.add("-target");
+      opts.add(Bytes.toString(targetName));
+    }
+    if (overwrite) opts.add("-overwrite");
+
+    // Export Snapshot
+    int res = ExportSnapshot.innerMain(util.getConfiguration(),
+        opts.toArray(new String[opts.size()]));
+    assertEquals(0, res);
+
+    // Verify File-System state
+    FileStatus[] rootFiles = fs.listStatus(copyDir);
+    assertEquals(filesExpected > 0 ? 2 : 1, rootFiles.length);
+    for (FileStatus fileStatus: rootFiles) {
+      String name = fileStatus.getPath().getName();
+      assertTrue(fileStatus.isDirectory());
+      assertTrue(name.equals(HConstants.SNAPSHOT_DIR_NAME) ||
+                 name.equals(HConstants.HFILE_ARCHIVE_DIRECTORY));
+    }
+    Set<String> snapshotFiles = verifySnapshot(fs, copyDir, tableName, Bytes.toString(targetName));
+    assertEquals(filesExpected, snapshotFiles.size());
+  }
+
+  /**
+   * Check that ExportSnapshot will succede if something fails but the retry succede.
+   */
+  public void testExportRetry() throws Exception {
+    setUpTest();
+    assertEquals(0, runExportAndInjectFailures(snapshotName, true));
+    cleanUpTest();
+  }
+
+  /*
+   * Execute the ExportSnapshot job injecting failures
+   */
+  private int runExportAndInjectFailures(final byte[] snapshotName, boolean retry)
+      throws Exception {
+    Path copyDir = getLocalDestinationDir();
+    URI hdfsUri = FileSystem.get(util.getConfiguration()).getUri();
+    FileSystem fs = FileSystem.get(copyDir.toUri(), new Configuration());
+    copyDir = copyDir.makeQualified(fs);
+
+    Configuration conf = new Configuration(util.getConfiguration());
+    conf.setBoolean(ExportSnapshot.CONF_TEST_FAILURE, true);
+    conf.setBoolean(ExportSnapshot.CONF_TEST_RETRY, retry);
+
+    // Export Snapshot
+    Path sourceDir;
+    if (util.isDistributedCluster()) {
+      sourceDir = new Path(conf.get(HConstants.HBASE_DIR));
+    } else {
+      sourceDir = util.getHBaseCluster().getMaster().getMasterFileSystem().getRootDir();
+    }
+    int res = ExportSnapshot.innerMain(conf, new String[] {
+      "-snapshot", Bytes.toString(snapshotName),
+      "-copy-from", sourceDir.toString(),
+      "-copy-to", copyDir.toString()
+    });
+    return res;
+  }
+
+  /*
+   * Verify if the files exists
+   */
+  private Set<String> verifySnapshot(final FileSystem fs, final Path rootDir,
+      final TableName tableName, final String snapshotName) throws IOException {
+    final Path exportedSnapshot = new Path(rootDir,
+      new Path(HConstants.SNAPSHOT_DIR_NAME, snapshotName));
+    final Set<String> snapshotFiles = new HashSet<String>();
+    final Path exportedArchive = new Path(rootDir, HConstants.HFILE_ARCHIVE_DIRECTORY);
+    SnapshotReferenceUtil.visitReferencedFiles(util.getConfiguration(), fs, exportedSnapshot,
+          new SnapshotReferenceUtil.SnapshotVisitor() {
+        @Override
+        public void storeFile(final HRegionInfo regionInfo, final String family,
+            final SnapshotRegionManifest.StoreFile storeFile) throws IOException {
+          if(MobUtils.isMobRegionInfo(regionInfo))
+            return;
+          String hfile = storeFile.getName();
+          snapshotFiles.add(hfile);
+          if (storeFile.hasReference()) {
+            // Nothing to do here, we have already the reference embedded
+          } else {
+            verifyNonEmptyFile(new Path(exportedArchive,
+              new Path(FSUtils.getTableDir(new Path("./"), tableName),
+                  new Path(regionInfo.getEncodedName(), new Path(family, hfile)))));
+          }
+        }
+
+        @Override
+        public void logFile (final String server, final String logfile)
+            throws IOException {
+          snapshotFiles.add(logfile);
+          verifyNonEmptyFile(new Path(exportedSnapshot, new Path(server, logfile)));
+        }
+
+        private void verifyNonEmptyFile(final Path path) throws IOException {
+          assertTrue(path + " should exists", fs.exists(path));
+          assertTrue(path + " should not be empty", fs.getFileStatus(path).getLen() > 0);
+        }
+    });
+
+    // Verify Snapshot description
+    SnapshotDescription desc = SnapshotDescriptionUtils.readSnapshotInfo(fs, exportedSnapshot);
+    assertTrue(desc.getName().equals(snapshotName));
+    assertTrue(desc.getTable().equals(tableName.getNameAsString()));
+    return snapshotFiles;
+  }
+
+  private Path getHdfsDestinationDir() {
+    Path rootDir;
+    if (util.isDistributedCluster()) {
+      rootDir = new Path(conf.get(HConstants.HBASE_DIR));
+    } else {
+      rootDir = util.getHBaseCluster().getMaster().getMasterFileSystem().getRootDir();
+    }
+    Path path = new Path(new Path(rootDir, "export-test"), "export-" + System.currentTimeMillis());
+    LOG.info("HDFS export destination path: " + path);
+    return path;
+  }
+
+  private Path getLocalDestinationDir() {
+    Path path = util.getDataTestDir("local-export-" + System.currentTimeMillis());
+    LOG.info("Local export destination path: " + path);
+    return path;
+  }
+
+  private void removeExportDir(final Path path) throws IOException {
+    FileSystem fs = FileSystem.get(path.toUri(), new Configuration());
+    fs.delete(path, true);
+  }
+
+  @Override
+  public int runTestFromCommandLine() throws Exception {
+    testAll();
+    return 0;
+  }
+
+  @Override
+  public TableName getTablename() {
+    return tableName;
+  }
+
+  @Override
+  protected Set<String> getColumnFamilies() {
+    return Sets.newHashSet(Bytes.toString(FAMILY));
+  }
+
+  public static void main(String[] args) throws Exception {
+    Configuration conf = HBaseConfiguration.create();
+    IntegrationTestingUtility.setUseDistributedCluster(conf);
+    int status =  ToolRunner.run(conf, new IntegrationTestMobExportSnapshot(), args);
+    System.exit(status);
+  }
+}
\ No newline at end of file
diff --git a/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobRestoreFlushSnapshotFromClient.java b/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobRestoreFlushSnapshotFromClient.java
new file mode 100644
index 0000000..cd94336
--- /dev/null
+++ b/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobRestoreFlushSnapshotFromClient.java
@@ -0,0 +1,249 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.snapshot;
+
+import static org.junit.Assert.fail;
+
+import java.io.IOException;
+import java.util.Set;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.IntegrationTestBase;
+import org.apache.hadoop.hbase.IntegrationTestingUtility;
+import org.apache.hadoop.hbase.IntegrationTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.Admin;
+import org.apache.hadoop.hbase.client.HTable;
+import org.apache.hadoop.hbase.master.snapshot.SnapshotManager;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.protobuf.generated.HBaseProtos.SnapshotDescription;
+import org.apache.hadoop.hbase.regionserver.snapshot.RegionServerSnapshotManager;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.util.ToolRunner;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import com.google.common.collect.Sets;
+
+/**
+ * Test clone/restore snapshots from the client
+ *
+ * TODO This is essentially a clone of TestRestoreSnapshotFromClient.  This is worth refactoring
+ * this because there will be a few more flavors of snapshots that need to run these tests.
+ */
+@Category(IntegrationTests.class)
+public class IntegrationTestMobRestoreFlushSnapshotFromClient extends IntegrationTestBase {
+
+  final Log LOG = LogFactory.getLog(getClass());
+
+  private final byte[] FAMILY = Bytes.toBytes("cf");
+
+  private byte[] snapshotName0;
+  private byte[] snapshotName1;
+  private byte[] snapshotName2;
+  private int snapshot0Rows;
+  private int snapshot1Rows;
+  private TableName tableName;
+  private Admin admin;
+
+  /**
+   * Initialize the tests with a table filled with some data
+   * and two snapshots (snapshotName0, snapshotName1) of different states.
+   * The tableName, snapshotNames and the number of rows in the snapshot are initialized.
+   */
+  public void setUpTest() throws Exception {
+
+    this.admin = util.getHBaseAdmin();
+
+    long tid = System.currentTimeMillis();
+    tableName = TableName.valueOf("testtb-" + tid);
+    snapshotName0 = Bytes.toBytes("snaptb0-" + tid);
+    snapshotName1 = Bytes.toBytes("snaptb1-" + tid);
+    snapshotName2 = Bytes.toBytes("snaptb2-" + tid);
+
+    // create Table
+    MobSnapshotTestingUtils.createMobTable(util, tableName, 1, FAMILY);
+
+    HTable table = new HTable(util.getConfiguration(), tableName);
+    MobSnapshotTestingUtils.loadMobData(util, table, 100, FAMILY);
+    snapshot0Rows = MobSnapshotTestingUtils.countMobRows(table);
+    LOG.info("=== before snapshot with 100 rows");
+
+    // take a snapshot
+    admin.snapshot(Bytes.toString(snapshotName0), tableName,
+        SnapshotDescription.Type.FLUSH);
+
+    LOG.info("=== after snapshot with 100 rows");
+
+    // insert more data
+    MobSnapshotTestingUtils.loadMobData(util, table, 100, FAMILY);
+    snapshot1Rows = MobSnapshotTestingUtils.countMobRows(table);
+    LOG.info("=== before snapshot with 200 rows");
+
+    // take a snapshot of the updated table
+    admin.snapshot(Bytes.toString(snapshotName1), tableName,
+        SnapshotDescription.Type.FLUSH);
+    LOG.info("=== after snapshot with 200 rows");
+    table.close();
+  }
+
+  public void cleanUpTest() throws Exception {
+    if (admin.tableExists(tableName)) {
+      util.deleteTable(tableName);
+    }
+    if (util.isDistributedCluster()) {
+      util.getHBaseClusterInterface().restoreInitialStatus();
+    } else {
+      SnapshotTestingUtils.deleteAllSnapshots(admin);
+      SnapshotTestingUtils.deleteArchiveDirectory(util);
+    }
+  }
+
+  protected int getNumReplicas() {
+    return 3;
+  }
+
+  @Override
+  public void setUpCluster() throws Exception {
+    util = getTestingUtil(getConf());
+    setUpBaseConf(util.getConfiguration());
+    util.initializeCluster(1);
+  }
+
+  public static void setUpBaseConf(Configuration conf) {
+    conf.setBoolean("hbase.online.schema.update.enable", true);
+    conf.setInt("hbase.regionserver.msginterval", 100);
+    conf.setInt("hbase.client.pause", 250);
+    conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 6);
+    conf.setBoolean(
+        "hbase.master.enabletable.roundrobin", true);
+
+    // Enable snapshot
+    conf.setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED, true);
+    conf.setLong(RegionServerSnapshotManager.SNAPSHOT_TIMEOUT_MILLIS_KEY,
+      RegionServerSnapshotManager.SNAPSHOT_TIMEOUT_MILLIS_DEFAULT * 2);
+
+    conf.setInt(MobConstants.MOB_FILE_CACHE_SIZE_KEY, 0);
+  }
+
+  @Test
+  public void testAll() throws Exception {
+    testCloneNonExistentSnapshot();
+    testRestoreSnapshotOfCloned();
+    testRestoreSnapshot();
+    testTakeFlushSnapshot();
+    testCloneSnapshot();
+  }
+
+  public void testTakeFlushSnapshot() throws Exception {
+    setUpTest();
+    // taking happens in setup.
+    cleanUpTest();
+  }
+
+  public void testRestoreSnapshot() throws Exception {
+    setUpTest();
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, snapshot1Rows);
+
+    // Restore from snapshot-0
+    admin.disableTable(tableName);
+    admin.restoreSnapshot(snapshotName0);
+    admin.enableTable(tableName);
+    LOG.info("=== after restore with 500 row snapshot");
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, snapshot0Rows);
+
+    // Restore from snapshot-1
+    admin.disableTable(tableName);
+    admin.restoreSnapshot(snapshotName1);
+    admin.enableTable(tableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, snapshot1Rows);
+    cleanUpTest();
+  }
+
+  public void testCloneNonExistentSnapshot() throws Exception {
+    setUpTest();
+    String snapshotName = "random-snapshot-" + System.currentTimeMillis();
+    TableName tableName = TableName.valueOf("random-table-" + System.currentTimeMillis());
+    try {
+      admin.cloneSnapshot(snapshotName, tableName);
+      fail("Expected SnapshotDoesNotExistException, got succeeded cloneSnapshot()");
+    } catch (SnapshotDoesNotExistException e) {
+      // expected
+    }
+    cleanUpTest();
+  }
+
+  public void testCloneSnapshot() throws Exception {
+    setUpTest();
+    TableName clonedTableName = TableName.valueOf("clonedtb-" + System.currentTimeMillis());
+    testCloneSnapshot(clonedTableName, snapshotName0, snapshot0Rows);
+    testCloneSnapshot(clonedTableName, snapshotName1, snapshot1Rows);
+    cleanUpTest();
+  }
+
+  private void testCloneSnapshot(final TableName tableName, final byte[] snapshotName,
+      int snapshotRows) throws IOException, InterruptedException {
+    // create a new table from snapshot
+    admin.cloneSnapshot(snapshotName, tableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, snapshotRows);
+
+    util.deleteTable(tableName);
+  }
+
+  public void testRestoreSnapshotOfCloned() throws Exception {
+    setUpTest();
+    TableName clonedTableName = TableName.valueOf("clonedtb-" + System.currentTimeMillis());
+    admin.cloneSnapshot(snapshotName0, clonedTableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, clonedTableName, snapshot0Rows);
+    admin.snapshot(Bytes.toString(snapshotName2), clonedTableName, SnapshotDescription.Type.FLUSH);
+    util.deleteTable(clonedTableName);
+
+    admin.cloneSnapshot(snapshotName2, clonedTableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, clonedTableName, snapshot0Rows);
+    util.deleteTable(clonedTableName);
+    cleanUpTest();
+  }
+
+  @Override
+  public int runTestFromCommandLine() throws Exception {
+    testAll();
+    return 0;
+  }
+
+  @Override
+  public TableName getTablename() {
+    return tableName;
+  }
+
+  @Override
+  protected Set<String> getColumnFamilies() {
+    return Sets.newHashSet(Bytes.toString(FAMILY));
+  }
+
+  public static void main(String[] args) throws Exception {
+    Configuration conf = HBaseConfiguration.create();
+    IntegrationTestingUtility.setUseDistributedCluster(conf);
+    int status =  ToolRunner.run(conf, new IntegrationTestMobRestoreFlushSnapshotFromClient(), args);
+    System.exit(status);
+  }
+}
\ No newline at end of file
diff --git a/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobRestoreSnapshotFromClient.java b/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobRestoreSnapshotFromClient.java
new file mode 100644
index 0000000..0f7ca4f
--- /dev/null
+++ b/hbase-it/src/test/java/org/apache/hadoop/hbase/snapshot/IntegrationTestMobRestoreSnapshotFromClient.java
@@ -0,0 +1,367 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.snapshot;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Set;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.HColumnDescriptor;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.IntegrationTestBase;
+import org.apache.hadoop.hbase.IntegrationTestingUtility;
+import org.apache.hadoop.hbase.IntegrationTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.Admin;
+import org.apache.hadoop.hbase.client.HTable;
+import org.apache.hadoop.hbase.io.HFileLink;
+import org.apache.hadoop.hbase.master.snapshot.SnapshotManager;
+import org.apache.hadoop.hbase.mob.MobConstants;
+import org.apache.hadoop.hbase.protobuf.generated.HBaseProtos.SnapshotDescription;
+import org.apache.hadoop.hbase.protobuf.generated.SnapshotProtos.SnapshotRegionManifest;
+import org.apache.hadoop.hbase.regionserver.NoSuchColumnFamilyException;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.util.ToolRunner;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import com.google.common.collect.Sets;
+
+/**
+ * Test restore snapshots from the client
+ */
+@Category(IntegrationTests.class)
+public class IntegrationTestMobRestoreSnapshotFromClient extends IntegrationTestBase {
+
+  final Log LOG = LogFactory.getLog(getClass());
+  private static final byte[] FAMILY = Bytes.toBytes("cf");
+  private byte[] emptySnapshot;
+  private byte[] snapshotName0;
+  private byte[] snapshotName1;
+  private byte[] snapshotName2;
+  private int snapshot0Rows;
+  private int snapshot1Rows;
+  private TableName tableName;
+  private Admin admin;
+
+  /**
+   * Initialize the tests with a table filled with some data
+   * and two snapshots (snapshotName0, snapshotName1) of different states.
+   * The tableName, snapshotNames and the number of rows in the snapshot are initialized.
+   */
+  public void setUpTest() throws Exception {
+    this.admin = util.getHBaseAdmin();
+
+    long tid = System.currentTimeMillis();
+    tableName =
+        TableName.valueOf("testtb-" + tid);
+    emptySnapshot = Bytes.toBytes("emptySnaptb-" + tid);
+    snapshotName0 = Bytes.toBytes("snaptb0-" + tid);
+    snapshotName1 = Bytes.toBytes("snaptb1-" + tid);
+    snapshotName2 = Bytes.toBytes("snaptb2-" + tid);
+
+    // create Table and disable it
+    MobSnapshotTestingUtils.createMobTable(util, tableName, getNumReplicas(), FAMILY);
+
+    admin.disableTable(tableName);
+
+    // take an empty snapshot
+    admin.snapshot(emptySnapshot, tableName);
+
+    HTable table = new HTable(util.getConfiguration(), tableName);
+    // enable table and insert data
+    admin.enableTable(tableName);
+    MobSnapshotTestingUtils.loadMobData(util, table, 500, FAMILY);
+    snapshot0Rows = MobSnapshotTestingUtils.countMobRows(table);
+    admin.disableTable(tableName);
+
+    // take a snapshot
+    admin.snapshot(snapshotName0, tableName);
+
+    // enable table and insert more data
+    admin.enableTable(tableName);
+    MobSnapshotTestingUtils.loadMobData(util, table, 500, FAMILY);
+    snapshot1Rows = MobSnapshotTestingUtils.countMobRows(table);
+    table.close();
+  }
+
+  public void cleanUpTest() throws Exception {
+    if (admin.tableExists(tableName)) {
+      util.deleteTable(tableName);
+    }
+    if (util.isDistributedCluster()) {
+      util.getHBaseClusterInterface().restoreInitialStatus();
+    } else {
+      SnapshotTestingUtils.deleteAllSnapshots(admin);
+      SnapshotTestingUtils.deleteArchiveDirectory(util);
+    }
+  }
+
+  protected int getNumReplicas() {
+    return 3;
+  }
+
+  @Override
+  public void setUpCluster() throws Exception {
+    util = getTestingUtil(getConf());
+    setUpBaseConf(util.getConfiguration());
+    util.initializeCluster(1);
+  }
+
+  public static void setUpBaseConf(Configuration conf) {
+    conf.setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED, true);
+    conf.setBoolean("hbase.online.schema.update.enable", true);
+    conf.setInt("hbase.hstore.compactionThreshold", 10);
+    conf.setInt("hbase.regionserver.msginterval", 100);
+    conf.setInt("hbase.client.pause", 250);
+    conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 6);
+    conf.setBoolean(
+        "hbase.master.enabletable.roundrobin", true);
+    conf.setInt(MobConstants.MOB_FILE_CACHE_SIZE_KEY, 0);
+  }
+
+  @Test
+  public void testAll() throws Exception {
+    testRestoreSnapshot();
+    testCloneAndRestoreSnapshot();
+    testCorruptedSnapshot();
+    testRestoreSchemaChange();
+    testCloneSnapshotOfCloned();
+  }
+
+  public void testRestoreSnapshot() throws Exception {
+    setUpTest();
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, snapshot1Rows);
+    admin.disableTable(tableName);
+    admin.snapshot(snapshotName1, tableName);
+    // Restore from snapshot-0
+    admin.restoreSnapshot(snapshotName0);
+    admin.enableTable(tableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, snapshot0Rows);
+    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
+
+    // Restore from emptySnapshot
+    admin.disableTable(tableName);
+    admin.restoreSnapshot(emptySnapshot);
+    admin.enableTable(tableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, 0);
+    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
+
+    // Restore from snapshot-1
+    admin.disableTable(tableName);
+    admin.restoreSnapshot(snapshotName1);
+    admin.enableTable(tableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, snapshot1Rows);
+    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
+
+    // Restore from snapshot-1
+    util.deleteTable(tableName);
+    admin.restoreSnapshot(snapshotName1);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, snapshot1Rows);
+    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
+    cleanUpTest();
+  }
+
+  public void testRestoreSchemaChange() throws Exception {
+    setUpTest();
+    byte[] TEST_FAMILY2 = Bytes.toBytes("cf2");
+
+    HTable table = new HTable(util.getConfiguration(), tableName);
+
+    // Add one column family and put some data in it
+    admin.disableTable(tableName);
+    HColumnDescriptor hcd = new HColumnDescriptor(TEST_FAMILY2);
+    hcd.setMobEnabled(true);
+    hcd.setMobThreshold(0L);
+    admin.addColumn(tableName, hcd);
+    admin.enableTable(tableName);
+    assertEquals(2, table.getTableDescriptor().getFamilies().size());
+    HTableDescriptor htd = admin.getTableDescriptor(tableName);
+    assertEquals(2, htd.getFamilies().size());
+    MobSnapshotTestingUtils.loadMobData(util, table, 100, TEST_FAMILY2);
+    long snapshot2Rows = snapshot1Rows + 100;
+    assertEquals(snapshot2Rows, MobSnapshotTestingUtils.countMobRows(table));
+    assertEquals(100, MobSnapshotTestingUtils.countMobRows(table, TEST_FAMILY2));
+
+    // Take a snapshot
+    admin.disableTable(tableName);
+    admin.snapshot(snapshotName2, tableName);
+
+    // Restore the snapshot (without the cf)
+    admin.restoreSnapshot(snapshotName0);
+    admin.enableTable(tableName);
+    assertEquals(1, table.getTableDescriptor().getFamilies().size());
+    try {
+      MobSnapshotTestingUtils.countMobRows(table, TEST_FAMILY2);
+      fail("family '" + Bytes.toString(TEST_FAMILY2) + "' should not exists");
+    } catch (NoSuchColumnFamilyException e) {
+      // expected
+    }
+    assertEquals(snapshot0Rows, MobSnapshotTestingUtils.countMobRows(table));
+    htd = admin.getTableDescriptor(tableName);
+    assertEquals(1, htd.getFamilies().size());
+
+    // Restore back the snapshot (with the cf)
+    admin.disableTable(tableName);
+    admin.restoreSnapshot(snapshotName2);
+    admin.enableTable(tableName);
+    htd = admin.getTableDescriptor(tableName);
+    assertEquals(2, htd.getFamilies().size());
+    assertEquals(2, table.getTableDescriptor().getFamilies().size());
+    assertEquals(100, MobSnapshotTestingUtils.countMobRows(table, TEST_FAMILY2));
+    assertEquals(snapshot2Rows, MobSnapshotTestingUtils.countMobRows(table));
+    table.close();
+    cleanUpTest();
+  }
+
+  public void testCloneSnapshotOfCloned() throws Exception {
+    setUpTest();
+    TableName clonedTableName =
+        TableName.valueOf("clonedtb-" + System.currentTimeMillis());
+    admin.cloneSnapshot(snapshotName0, clonedTableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, clonedTableName, snapshot0Rows);
+    SnapshotTestingUtils.verifyReplicasCameOnline(clonedTableName, admin, getNumReplicas());
+    admin.disableTable(clonedTableName);
+    admin.snapshot(snapshotName2, clonedTableName);
+    util.deleteTable(clonedTableName);
+    waitCleanerRun();
+
+    admin.cloneSnapshot(snapshotName2, clonedTableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, clonedTableName, snapshot0Rows);
+    SnapshotTestingUtils.verifyReplicasCameOnline(clonedTableName, admin, getNumReplicas());
+    util.deleteTable(clonedTableName);
+    cleanUpTest();
+  }
+
+  public void testCloneAndRestoreSnapshot() throws Exception {
+    setUpTest();
+    util.deleteTable(tableName);
+    waitCleanerRun();
+
+    admin.cloneSnapshot(snapshotName0, tableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, snapshot0Rows);
+    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
+    waitCleanerRun();
+
+    admin.disableTable(tableName);
+    admin.restoreSnapshot(snapshotName0);
+    admin.enableTable(tableName);
+    MobSnapshotTestingUtils.verifyMobRowCount(util, tableName, snapshot0Rows);
+    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
+    cleanUpTest();
+  }
+
+  public void testCorruptedSnapshot() throws Exception {
+    setUpTest();
+    corruptSnapshot(util, Bytes.toString(snapshotName0));
+    TableName cloneName = TableName.valueOf("corruptedClone-" + System.currentTimeMillis());
+    try {
+      admin.cloneSnapshot(snapshotName0, cloneName);
+      fail("Expected CorruptedSnapshotException, got succeeded cloneSnapshot()");
+    } catch (CorruptedSnapshotException e) {
+      // Got the expected corruption exception.
+      // check for no references of the cloned table.
+      assertFalse(admin.tableExists(cloneName));
+    } catch (Exception e) {
+      fail("Expected CorruptedSnapshotException got: " + e);
+    }
+    cleanUpTest();
+  }
+
+  private void waitCleanerRun() throws InterruptedException {
+    if (!util.isDistributedCluster()) {
+      util.getMiniHBaseCluster().getMaster().getHFileCleaner().choreForTesting();
+    }
+  }
+
+  /**
+   * Corrupt the specified snapshot by deleting some files.
+   *
+   * @param util {@link HBaseTestingUtility}
+   * @param snapshotName name of the snapshot to corrupt
+   * @return array of the corrupted HFiles
+   * @throws IOException on unexecpted error reading the FS
+   */
+  public static ArrayList corruptSnapshot(final HBaseTestingUtility util, final String snapshotName)
+      throws IOException {
+    Path rootDir = new Path(util.getConfiguration().get(HConstants.HBASE_DIR));
+    final FileSystem fs =rootDir.getFileSystem(util.getConfiguration());
+    Path snapshotDir = SnapshotDescriptionUtils.getCompletedSnapshotDir(snapshotName,
+                                                                       rootDir);
+    SnapshotDescription snapshotDesc = SnapshotDescriptionUtils.readSnapshotInfo(fs, snapshotDir);
+    final TableName table = TableName.valueOf(snapshotDesc.getTable());
+
+    final ArrayList corruptedFiles = new ArrayList();
+    final Configuration conf = util.getConfiguration();
+    SnapshotReferenceUtil.visitTableStoreFiles(conf, fs, snapshotDir, snapshotDesc,
+        new SnapshotReferenceUtil.StoreFileVisitor() {
+      @Override
+      public void storeFile(final HRegionInfo regionInfo, final String family,
+            final SnapshotRegionManifest.StoreFile storeFile) throws IOException {
+        String region = regionInfo.getEncodedName();
+        String hfile = storeFile.getName();
+        HFileLink link = HFileLink.create(conf, table, region, family, hfile);
+        if (corruptedFiles.size() % 2 == 0) {
+          fs.delete(link.getAvailablePath(fs), true);
+          corruptedFiles.add(hfile);
+        }
+      }
+    });
+
+    assertTrue(corruptedFiles.size() > 0);
+    return corruptedFiles;
+  }
+
+  @Override
+  public int runTestFromCommandLine() throws Exception {
+    testAll();
+    return 0;
+  }
+
+  @Override
+  public TableName getTablename() {
+    return tableName;
+  }
+
+  @Override
+  protected Set<String> getColumnFamilies() {
+    return Sets.newHashSet(Bytes.toString(FAMILY));
+  }
+
+  public static void main(String[] args) throws Exception {
+    Configuration conf = HBaseConfiguration.create();
+    IntegrationTestingUtility.setUseDistributedCluster(conf);
+    int status =  ToolRunner.run(conf, new IntegrationTestMobRestoreSnapshotFromClient(), args);
+    System.exit(status);
+  }
+}
\ No newline at end of file
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobCloneSnapshotFromClient.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobCloneSnapshotFromClient.java
deleted file mode 100644
index a939422..0000000
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobCloneSnapshotFromClient.java
+++ /dev/null
@@ -1,250 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.hadoop.hbase.client;
-
-import java.io.IOException;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.hbase.HBaseTestingUtility;
-import org.apache.hadoop.hbase.HConstants;
-import org.apache.hadoop.hbase.LargeTests;
-import org.apache.hadoop.hbase.NamespaceDescriptor;
-import org.apache.hadoop.hbase.NamespaceNotFoundException;
-import org.apache.hadoop.hbase.TableName;
-import org.apache.hadoop.hbase.master.snapshot.SnapshotManager;
-import org.apache.hadoop.hbase.mob.MobConstants;
-import org.apache.hadoop.hbase.snapshot.MobSnapshotTestingUtils;
-import org.apache.hadoop.hbase.snapshot.SnapshotDoesNotExistException;
-import org.apache.hadoop.hbase.snapshot.SnapshotTestingUtils;
-import org.apache.hadoop.hbase.util.Bytes;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-
-/**
- * Test clone snapshots from the client
- */
-@Category(LargeTests.class)
-public class TestMobCloneSnapshotFromClient {
-  final Log LOG = LogFactory.getLog(getClass());
-
-  private final static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
-
-  private final byte[] FAMILY = Bytes.toBytes("cf");
-
-  private byte[] emptySnapshot;
-  private byte[] snapshotName0;
-  private byte[] snapshotName1;
-  private byte[] snapshotName2;
-  private int snapshot0Rows;
-  private int snapshot1Rows;
-  private TableName tableName;
-  private Admin admin;
-
-  @BeforeClass
-  public static void setUpBeforeClass() throws Exception {
-    TEST_UTIL.getConfiguration().setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED, true);
-    TEST_UTIL.getConfiguration().setBoolean("hbase.online.schema.update.enable", true);
-    TEST_UTIL.getConfiguration().setInt("hbase.hstore.compactionThreshold", 10);
-    TEST_UTIL.getConfiguration().setInt("hbase.regionserver.msginterval", 100);
-    TEST_UTIL.getConfiguration().setInt("hbase.client.pause", 250);
-    TEST_UTIL.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 6);
-    TEST_UTIL.getConfiguration().setBoolean(
-        "hbase.master.enabletable.roundrobin", true);
-    TEST_UTIL.getConfiguration().setInt(MobConstants.MOB_FILE_CACHE_SIZE_KEY, 0);
-    TEST_UTIL.startMiniCluster(3);
-  }
-
-  @AfterClass
-  public static void tearDownAfterClass() throws Exception {
-    TEST_UTIL.shutdownMiniCluster();
-  }
-
-  /**
-   * Initialize the tests with a table filled with some data
-   * and two snapshots (snapshotName0, snapshotName1) of different states.
-   * The tableName, snapshotNames and the number of rows in the snapshot are initialized.
-   */
-  @Before
-  public void setup() throws Exception {
-    this.admin = TEST_UTIL.getHBaseAdmin();
-
-    long tid = System.currentTimeMillis();
-    tableName = TableName.valueOf("testtb-" + tid);
-    emptySnapshot = Bytes.toBytes("emptySnaptb-" + tid);
-    snapshotName0 = Bytes.toBytes("snaptb0-" + tid);
-    snapshotName1 = Bytes.toBytes("snaptb1-" + tid);
-    snapshotName2 = Bytes.toBytes("snaptb2-" + tid);
-
-    // create Table and disable it
-    MobSnapshotTestingUtils.createMobTable(TEST_UTIL, tableName, getNumReplicas(), FAMILY);
-    admin.disableTable(tableName);
-
-    // take an empty snapshot
-    admin.snapshot(emptySnapshot, tableName);
-
-    HTable table = new HTable(TEST_UTIL.getConfiguration(), tableName);
-    try {
-      // enable table and insert data
-      admin.enableTable(tableName);
-      SnapshotTestingUtils.loadData(TEST_UTIL, table, 500, FAMILY);
-      snapshot0Rows = MobSnapshotTestingUtils.countMobRows(table);
-      admin.disableTable(tableName);
-
-      // take a snapshot
-      admin.snapshot(snapshotName0, tableName);
-
-      // enable table and insert more data
-      admin.enableTable(tableName);
-      SnapshotTestingUtils.loadData(TEST_UTIL, table, 500, FAMILY);
-      snapshot1Rows = MobSnapshotTestingUtils.countMobRows(table);
-      admin.disableTable(tableName);
-
-      // take a snapshot of the updated table
-      admin.snapshot(snapshotName1, tableName);
-
-      // re-enable table
-      admin.enableTable(tableName);
-    } finally {
-      table.close();
-    }
-  }
-
-  protected int getNumReplicas() {
-    return 1;
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    if (admin.tableExists(tableName)) {
-      TEST_UTIL.deleteTable(tableName);
-    }
-    SnapshotTestingUtils.deleteAllSnapshots(admin);
-    SnapshotTestingUtils.deleteArchiveDirectory(TEST_UTIL);
-  }
-
-  @Test(expected=SnapshotDoesNotExistException.class)
-  public void testCloneNonExistentSnapshot() throws IOException, InterruptedException {
-    String snapshotName = "random-snapshot-" + System.currentTimeMillis();
-    TableName tableName = TableName.valueOf("random-table-" + System.currentTimeMillis());
-    admin.cloneSnapshot(snapshotName, tableName);
-  }
-
-  @Test(expected = NamespaceNotFoundException.class)
-  public void testCloneOnMissingNamespace() throws IOException, InterruptedException {
-    TableName clonedTableName = TableName.valueOf("unknownNS:clonetb");
-    admin.cloneSnapshot(snapshotName1, clonedTableName);
-  }
-
-  @Test
-  public void testCloneSnapshot() throws IOException, InterruptedException {
-    TableName clonedTableName = TableName.valueOf("clonedtb-" + System.currentTimeMillis());
-    testCloneSnapshot(clonedTableName, snapshotName0, snapshot0Rows);
-    testCloneSnapshot(clonedTableName, snapshotName1, snapshot1Rows);
-    testCloneSnapshot(clonedTableName, emptySnapshot, 0);
-  }
-
-  private void testCloneSnapshot(final TableName tableName, final byte[] snapshotName,
-      int snapshotRows) throws IOException, InterruptedException {
-    // create a new table from snapshot
-    admin.cloneSnapshot(snapshotName, tableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, tableName, snapshotRows);
-
-    verifyReplicasCameOnline(tableName);
-    TEST_UTIL.deleteTable(tableName);
-  }
-
-  protected void verifyReplicasCameOnline(TableName tableName) throws IOException {
-    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
-  }
-
-  @Test
-  public void testCloneSnapshotCrossNamespace() throws IOException, InterruptedException {
-    String nsName = "testCloneSnapshotCrossNamespace";
-    admin.createNamespace(NamespaceDescriptor.create(nsName).build());
-    TableName clonedTableName =
-        TableName.valueOf(nsName, "clonedtb-" + System.currentTimeMillis());
-    testCloneSnapshot(clonedTableName, snapshotName0, snapshot0Rows);
-    testCloneSnapshot(clonedTableName, snapshotName1, snapshot1Rows);
-    testCloneSnapshot(clonedTableName, emptySnapshot, 0);
-  }
-
-  /**
-   * Verify that tables created from the snapshot are still alive after source table deletion.
-   */
-  @Test
-  public void testCloneLinksAfterDelete() throws IOException, InterruptedException {
-    // Clone a table from the first snapshot
-    TableName clonedTableName = TableName.valueOf("clonedtb1-" + System.currentTimeMillis());
-    admin.cloneSnapshot(snapshotName0, clonedTableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, clonedTableName, snapshot0Rows);
-
-    // Take a snapshot of this cloned table.
-    admin.disableTable(clonedTableName);
-    admin.snapshot(snapshotName2, clonedTableName);
-
-    // Clone the snapshot of the cloned table
-    TableName clonedTableName2 = TableName.valueOf("clonedtb2-" + System.currentTimeMillis());
-    admin.cloneSnapshot(snapshotName2, clonedTableName2);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, clonedTableName2, snapshot0Rows);
-    admin.disableTable(clonedTableName2);
-
-    // Remove the original table
-    TEST_UTIL.deleteTable(tableName);
-    waitCleanerRun();
-
-    // Verify the first cloned table
-    admin.enableTable(clonedTableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, clonedTableName, snapshot0Rows);
-
-    // Verify the second cloned table
-    admin.enableTable(clonedTableName2);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, clonedTableName2, snapshot0Rows);
-    admin.disableTable(clonedTableName2);
-
-    // Delete the first cloned table
-    TEST_UTIL.deleteTable(clonedTableName);
-    waitCleanerRun();
-
-    // Verify the second cloned table
-    admin.enableTable(clonedTableName2);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, clonedTableName2, snapshot0Rows);
-
-    // Clone a new table from cloned
-    TableName clonedTableName3 = TableName.valueOf("clonedtb3-" + System.currentTimeMillis());
-    admin.cloneSnapshot(snapshotName2, clonedTableName3);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, clonedTableName3, snapshot0Rows);
-
-    // Delete the cloned tables
-    TEST_UTIL.deleteTable(clonedTableName2);
-    TEST_UTIL.deleteTable(clonedTableName3);
-    admin.deleteSnapshot(snapshotName2);
-  }
-
-  // ==========================================================================
-  //  Helpers
-  // ==========================================================================
-
-  private void waitCleanerRun() throws InterruptedException {
-    TEST_UTIL.getMiniHBaseCluster().getMaster().getHFileCleaner().choreForTesting();
-  }
-}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobCloneSnapshotFromClientWithRegionReplicas.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobCloneSnapshotFromClientWithRegionReplicas.java
deleted file mode 100644
index 4ca0ecc..0000000
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobCloneSnapshotFromClientWithRegionReplicas.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.hadoop.hbase.client;
-
-import org.apache.hadoop.hbase.LargeTests;
-import org.junit.experimental.categories.Category;
-
-@Category(LargeTests.class)
-public class TestMobCloneSnapshotFromClientWithRegionReplicas extends
-    TestMobCloneSnapshotFromClient {
-  @Override
-  protected int getNumReplicas() {
-    return 3;
-  }
-}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobRestoreSnapshotFromClient.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobRestoreSnapshotFromClient.java
deleted file mode 100644
index c75e006..0000000
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobRestoreSnapshotFromClient.java
+++ /dev/null
@@ -1,303 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.hadoop.hbase.client;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.fail;
-
-import java.io.IOException;
-import java.util.HashSet;
-import java.util.Set;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.fs.Path;
-import org.apache.hadoop.hbase.HBaseTestingUtility;
-import org.apache.hadoop.hbase.HColumnDescriptor;
-import org.apache.hadoop.hbase.HConstants;
-import org.apache.hadoop.hbase.HTableDescriptor;
-import org.apache.hadoop.hbase.LargeTests;
-import org.apache.hadoop.hbase.TableName;
-import org.apache.hadoop.hbase.master.MasterFileSystem;
-import org.apache.hadoop.hbase.master.snapshot.SnapshotManager;
-import org.apache.hadoop.hbase.mob.MobConstants;
-import org.apache.hadoop.hbase.regionserver.NoSuchColumnFamilyException;
-import org.apache.hadoop.hbase.snapshot.CorruptedSnapshotException;
-import org.apache.hadoop.hbase.snapshot.MobSnapshotTestingUtils;
-import org.apache.hadoop.hbase.snapshot.SnapshotTestingUtils;
-import org.apache.hadoop.hbase.util.Bytes;
-import org.apache.hadoop.hbase.util.FSUtils;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-
-/**
- * Test restore snapshots from the client
- */
-@Category(LargeTests.class)
-public class TestMobRestoreSnapshotFromClient {
-  final Log LOG = LogFactory.getLog(getClass());
-
-  private final static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
-
-  private final byte[] FAMILY = Bytes.toBytes("cf");
-
-  private byte[] emptySnapshot;
-  private byte[] snapshotName0;
-  private byte[] snapshotName1;
-  private byte[] snapshotName2;
-  private int snapshot0Rows;
-  private int snapshot1Rows;
-  private TableName tableName;
-  private Admin admin;
-
-  @BeforeClass
-  public static void setUpBeforeClass() throws Exception {
-    TEST_UTIL.getConfiguration().setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED, true);
-    TEST_UTIL.getConfiguration().setBoolean("hbase.online.schema.update.enable", true);
-    TEST_UTIL.getConfiguration().setInt("hbase.hstore.compactionThreshold", 10);
-    TEST_UTIL.getConfiguration().setInt("hbase.regionserver.msginterval", 100);
-    TEST_UTIL.getConfiguration().setInt("hbase.client.pause", 250);
-    TEST_UTIL.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 6);
-    TEST_UTIL.getConfiguration().setBoolean(
-        "hbase.master.enabletable.roundrobin", true);
-    TEST_UTIL.getConfiguration().setInt(MobConstants.MOB_FILE_CACHE_SIZE_KEY, 0);
-    TEST_UTIL.startMiniCluster(3);
-  }
-
-  @AfterClass
-  public static void tearDownAfterClass() throws Exception {
-    TEST_UTIL.shutdownMiniCluster();
-  }
-
-  /**
-   * Initialize the tests with a table filled with some data
-   * and two snapshots (snapshotName0, snapshotName1) of different states.
-   * The tableName, snapshotNames and the number of rows in the snapshot are initialized.
-   */
-  @Before
-  public void setup() throws Exception {
-    this.admin = TEST_UTIL.getHBaseAdmin();
-
-    long tid = System.currentTimeMillis();
-    tableName =
-        TableName.valueOf("testtb-" + tid);
-    emptySnapshot = Bytes.toBytes("emptySnaptb-" + tid);
-    snapshotName0 = Bytes.toBytes("snaptb0-" + tid);
-    snapshotName1 = Bytes.toBytes("snaptb1-" + tid);
-    snapshotName2 = Bytes.toBytes("snaptb2-" + tid);
-
-    // create Table and disable it
-    MobSnapshotTestingUtils.createMobTable(TEST_UTIL, tableName, getNumReplicas(), FAMILY);
-
-    admin.disableTable(tableName);
-
-    // take an empty snapshot
-    admin.snapshot(emptySnapshot, tableName);
-
-    HTable table = new HTable(TEST_UTIL.getConfiguration(), tableName);
-    // enable table and insert data
-    admin.enableTable(tableName);
-    SnapshotTestingUtils.loadData(TEST_UTIL, table, 500, FAMILY);
-    snapshot0Rows = MobSnapshotTestingUtils.countMobRows(table);
-    admin.disableTable(tableName);
-
-    // take a snapshot
-    admin.snapshot(snapshotName0, tableName);
-
-    // enable table and insert more data
-    admin.enableTable(tableName);
-    SnapshotTestingUtils.loadData(TEST_UTIL, table, 500, FAMILY);
-    snapshot1Rows = MobSnapshotTestingUtils.countMobRows(table);
-    table.close();
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    TEST_UTIL.deleteTable(tableName);
-    SnapshotTestingUtils.deleteAllSnapshots(TEST_UTIL.getHBaseAdmin());
-    SnapshotTestingUtils.deleteArchiveDirectory(TEST_UTIL);
-  }
-
-  @Test
-  public void testRestoreSnapshot() throws IOException {
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, tableName, snapshot1Rows);
-    admin.disableTable(tableName);
-    admin.snapshot(snapshotName1, tableName);
-    // Restore from snapshot-0
-    admin.restoreSnapshot(snapshotName0);
-    admin.enableTable(tableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, tableName, snapshot0Rows);
-    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
-
-    // Restore from emptySnapshot
-    admin.disableTable(tableName);
-    admin.restoreSnapshot(emptySnapshot);
-    admin.enableTable(tableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, tableName, 0);
-    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
-
-    // Restore from snapshot-1
-    admin.disableTable(tableName);
-    admin.restoreSnapshot(snapshotName1);
-    admin.enableTable(tableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, tableName, snapshot1Rows);
-    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
-
-    // Restore from snapshot-1
-    TEST_UTIL.deleteTable(tableName);
-    admin.restoreSnapshot(snapshotName1);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, tableName, snapshot1Rows);
-    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
-  }
-
-  protected int getNumReplicas() {
-    return 1;
-  }
-
-  @Test
-  public void testRestoreSchemaChange() throws Exception {
-    byte[] TEST_FAMILY2 = Bytes.toBytes("cf2");
-
-    HTable table = new HTable(TEST_UTIL.getConfiguration(), tableName);
-
-    // Add one column family and put some data in it
-    admin.disableTable(tableName);
-    HColumnDescriptor hcd = new HColumnDescriptor(TEST_FAMILY2);
-    hcd.setMobEnabled(true);
-    hcd.setMobThreshold(3L);
-    admin.addColumn(tableName, hcd);
-    admin.enableTable(tableName);
-    assertEquals(2, table.getTableDescriptor().getFamilies().size());
-    HTableDescriptor htd = admin.getTableDescriptor(tableName);
-    assertEquals(2, htd.getFamilies().size());
-    SnapshotTestingUtils.loadData(TEST_UTIL, table, 500, TEST_FAMILY2);
-    long snapshot2Rows = snapshot1Rows + 500;
-    assertEquals(snapshot2Rows, MobSnapshotTestingUtils.countMobRows(table));
-    assertEquals(500, MobSnapshotTestingUtils.countMobRows(table, TEST_FAMILY2));
-    Set<String> fsFamilies = getFamiliesFromFS(tableName);
-    assertEquals(2, fsFamilies.size());
-
-    // Take a snapshot
-    admin.disableTable(tableName);
-    admin.snapshot(snapshotName2, tableName);
-
-    // Restore the snapshot (without the cf)
-    admin.restoreSnapshot(snapshotName0);
-    admin.enableTable(tableName);
-    assertEquals(1, table.getTableDescriptor().getFamilies().size());
-    try {
-      MobSnapshotTestingUtils.countMobRows(table, TEST_FAMILY2);
-      fail("family '" + Bytes.toString(TEST_FAMILY2) + "' should not exists");
-    } catch (NoSuchColumnFamilyException e) {
-      // expected
-    }
-    assertEquals(snapshot0Rows, MobSnapshotTestingUtils.countMobRows(table));
-    htd = admin.getTableDescriptor(tableName);
-    assertEquals(1, htd.getFamilies().size());
-    fsFamilies = getFamiliesFromFS(tableName);
-    assertEquals(1, fsFamilies.size());
-
-    // Restore back the snapshot (with the cf)
-    admin.disableTable(tableName);
-    admin.restoreSnapshot(snapshotName2);
-    admin.enableTable(tableName);
-    htd = admin.getTableDescriptor(tableName);
-    assertEquals(2, htd.getFamilies().size());
-    assertEquals(2, table.getTableDescriptor().getFamilies().size());
-    assertEquals(500, MobSnapshotTestingUtils.countMobRows(table, TEST_FAMILY2));
-    assertEquals(snapshot2Rows, MobSnapshotTestingUtils.countMobRows(table));
-    fsFamilies = getFamiliesFromFS(tableName);
-    assertEquals(2, fsFamilies.size());
-    table.close();
-  }
-
-  @Test
-  public void testCloneSnapshotOfCloned() throws IOException, InterruptedException {
-    TableName clonedTableName =
-        TableName.valueOf("clonedtb-" + System.currentTimeMillis());
-    admin.cloneSnapshot(snapshotName0, clonedTableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, clonedTableName, snapshot0Rows);
-    SnapshotTestingUtils.verifyReplicasCameOnline(clonedTableName, admin, getNumReplicas());
-    admin.disableTable(clonedTableName);
-    admin.snapshot(snapshotName2, clonedTableName);
-    TEST_UTIL.deleteTable(clonedTableName);
-    waitCleanerRun();
-
-    admin.cloneSnapshot(snapshotName2, clonedTableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, clonedTableName, snapshot0Rows);
-    SnapshotTestingUtils.verifyReplicasCameOnline(clonedTableName, admin, getNumReplicas());
-    TEST_UTIL.deleteTable(clonedTableName);
-  }
-
-  @Test
-  public void testCloneAndRestoreSnapshot() throws IOException, InterruptedException {
-    TEST_UTIL.deleteTable(tableName);
-    waitCleanerRun();
-
-    admin.cloneSnapshot(snapshotName0, tableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, tableName, snapshot0Rows);
-    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
-    waitCleanerRun();
-
-    admin.disableTable(tableName);
-    admin.restoreSnapshot(snapshotName0);
-    admin.enableTable(tableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(TEST_UTIL, tableName, snapshot0Rows);
-    SnapshotTestingUtils.verifyReplicasCameOnline(tableName, admin, getNumReplicas());
-  }
-
-  @Test
-  public void testCorruptedSnapshot() throws IOException, InterruptedException {
-    SnapshotTestingUtils.corruptSnapshot(TEST_UTIL, Bytes.toString(snapshotName0));
-    TableName cloneName = TableName.valueOf("corruptedClone-" + System.currentTimeMillis());
-    try {
-      admin.cloneSnapshot(snapshotName0, cloneName);
-      fail("Expected CorruptedSnapshotException, got succeeded cloneSnapshot()");
-    } catch (CorruptedSnapshotException e) {
-      // Got the expected corruption exception.
-      // check for no references of the cloned table.
-      assertFalse(admin.tableExists(cloneName));
-    } catch (Exception e) {
-      fail("Expected CorruptedSnapshotException got: " + e);
-    }
-  }
-
-  // ==========================================================================
-  //  Helpers
-  // ==========================================================================
-  private void waitCleanerRun() throws InterruptedException {
-    TEST_UTIL.getMiniHBaseCluster().getMaster().getHFileCleaner().choreForTesting();
-  }
-
-  private Set<String> getFamiliesFromFS(final TableName tableName) throws IOException {
-    MasterFileSystem mfs = TEST_UTIL.getMiniHBaseCluster().getMaster().getMasterFileSystem();
-    Set<String> families = new HashSet<String>();
-    Path tableDir = FSUtils.getTableDir(mfs.getRootDir(), tableName);
-    for (Path regionDir: FSUtils.getRegionDirs(mfs.getFileSystem(), tableDir)) {
-      for (Path familyDir: FSUtils.getFamilyDirs(mfs.getFileSystem(), regionDir)) {
-        families.add(familyDir.getName());
-      }
-    }
-    return families;
-  }
-}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobRestoreSnapshotFromClientWithRegionReplicas.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobRestoreSnapshotFromClientWithRegionReplicas.java
deleted file mode 100644
index 6dcf626..0000000
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobRestoreSnapshotFromClientWithRegionReplicas.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.hadoop.hbase.client;
-
-import org.apache.hadoop.hbase.LargeTests;
-import org.junit.experimental.categories.Category;
-
-@Category(LargeTests.class)
-public class TestMobRestoreSnapshotFromClientWithRegionReplicas extends
-    TestMobRestoreSnapshotFromClient {
-  @Override
-  protected int getNumReplicas() {
-    return 3;
-  }
-}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobSnapshotFromClient.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobSnapshotFromClient.java
index 947354f..6c8db79 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobSnapshotFromClient.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobSnapshotFromClient.java
@@ -100,7 +100,7 @@ public void setup() throws Exception {
   }
 
   protected int getNumReplicas() {
-    return 1;
+    return 3;
   }
 
   @After
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobSnapshotFromClientWithRegionReplicas.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobSnapshotFromClientWithRegionReplicas.java
deleted file mode 100644
index 81a00c9..0000000
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMobSnapshotFromClientWithRegionReplicas.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.hadoop.hbase.client;
-
-import org.apache.hadoop.hbase.LargeTests;
-import org.junit.experimental.categories.Category;
-
-@Category(LargeTests.class)
-public class TestMobSnapshotFromClientWithRegionReplicas extends
-    TestMobSnapshotFromClient {
-  @Override
-  protected int getNumReplicas() {
-    return 3;
-  }
-}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/MobSnapshotTestingUtils.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/MobSnapshotTestingUtils.java
index 2dcf83a..cc51b82 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/MobSnapshotTestingUtils.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/MobSnapshotTestingUtils.java
@@ -23,6 +23,8 @@
 import java.io.IOException;
 import java.util.List;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FSDataOutputStream;
 import org.apache.hadoop.fs.FileSystem;
@@ -34,7 +36,9 @@
 import org.apache.hadoop.hbase.HRegionInfo;
 import org.apache.hadoop.hbase.HTableDescriptor;
 import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.Durability;
 import org.apache.hadoop.hbase.client.HTable;
+import org.apache.hadoop.hbase.client.Put;
 import org.apache.hadoop.hbase.client.Result;
 import org.apache.hadoop.hbase.client.ResultScanner;
 import org.apache.hadoop.hbase.client.Scan;
@@ -45,10 +49,13 @@
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.FSTableDescriptors;
 import org.apache.hadoop.hbase.util.FSUtils;
+import org.apache.hadoop.hbase.util.MD5Hash;
 import org.junit.Assert;
 
 public class MobSnapshotTestingUtils {
 
+  private static byte[] KEYS = Bytes.toBytes("0123456789");
+
   /**
    * Create the Mob Table.
    */
@@ -65,7 +72,6 @@ public static void createMobTable(final HBaseTestingUtility util,
     }
     byte[][] splitKeys = SnapshotTestingUtils.getSplitKeys();
     util.getHBaseAdmin().createTable(htd, splitKeys);
-    SnapshotTestingUtils.waitForTableToBeOnline(util, tableName);
     assertEquals((splitKeys.length + 1) * regionReplication, util
         .getHBaseAdmin().getTableRegions(tableName).size());
   }
@@ -101,6 +107,45 @@ public static HTable createMobTable(final HBaseTestingUtility util,
     return new HTable(util.getConfiguration(), htd.getTableName());
   }
 
+  public static void loadMobData(final HBaseTestingUtility util, final TableName tableName, int rows,
+      byte[]... families) throws IOException, InterruptedException {
+    loadMobData(util, new HTable(util.getConfiguration(), tableName), rows, families);
+  }
+
+  public static void loadMobData(final HBaseTestingUtility util, final HTable table, int rows,
+      byte[]... families) throws IOException, InterruptedException {
+    table.setAutoFlush(false, true);
+
+    // Ensure one row per region
+    assertTrue(rows >= KEYS.length);
+    for (byte k0: KEYS) {
+      byte[] k = new byte[] { k0 };
+      byte[] value = Bytes.add(Bytes.toBytes(System.currentTimeMillis()), k);
+      byte[] key = Bytes.add(k, Bytes.toBytes(MD5Hash.getMD5AsHex(value)));
+      putData(table, families, key, value);
+      rows--;
+    }
+
+    // Add other extra rows. more rows, more files
+    while (rows-- > 0) {
+      byte[] value = Bytes.add(Bytes.toBytes(System.currentTimeMillis()), Bytes.toBytes(rows));
+      byte[] key = Bytes.toBytes(MD5Hash.getMD5AsHex(value));
+      putData(table, families, key, value);
+    }
+    table.flushCommits();
+  }
+
+  private static void putData(final HTable table, final byte[][] families,
+      final byte[] key, final byte[] value) throws IOException {
+    byte[] q = Bytes.toBytes("q");
+    Put put = new Put(key);
+    put.setDurability(Durability.SKIP_WAL);
+    for (byte[] family: families) {
+      put.add(family, q, value);
+    }
+    table.put(put);
+  }
+
   /**
    * Return the number of rows in the given table.
    */
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestMobExportSnapshot.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestMobExportSnapshot.java
deleted file mode 100644
index fc9d8e7..0000000
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestMobExportSnapshot.java
+++ /dev/null
@@ -1,439 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.hadoop.hbase.snapshot;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-import java.io.IOException;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.conf.Configuration;
-import org.apache.hadoop.fs.FileStatus;
-import org.apache.hadoop.fs.FileSystem;
-import org.apache.hadoop.fs.Path;
-import org.apache.hadoop.hbase.HBaseTestingUtility;
-import org.apache.hadoop.hbase.HConstants;
-import org.apache.hadoop.hbase.HRegionInfo;
-import org.apache.hadoop.hbase.MediumTests;
-import org.apache.hadoop.hbase.TableName;
-import org.apache.hadoop.hbase.client.Admin;
-import org.apache.hadoop.hbase.master.snapshot.SnapshotManager;
-import org.apache.hadoop.hbase.mob.MobConstants;
-import org.apache.hadoop.hbase.mob.MobUtils;
-import org.apache.hadoop.hbase.protobuf.generated.HBaseProtos.SnapshotDescription;
-import org.apache.hadoop.hbase.protobuf.generated.SnapshotProtos.SnapshotFileInfo;
-import org.apache.hadoop.hbase.protobuf.generated.SnapshotProtos.SnapshotRegionManifest;
-import org.apache.hadoop.hbase.snapshot.SnapshotTestingUtils.SnapshotMock;
-import org.apache.hadoop.hbase.util.Bytes;
-import org.apache.hadoop.hbase.util.FSUtils;
-import org.apache.hadoop.hbase.util.Pair;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-
-/**
- * Test Export Snapshot Tool
- */
-@Category(MediumTests.class)
-public class TestMobExportSnapshot {
-  private final Log LOG = LogFactory.getLog(getClass());
-
-  protected final static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();
-
-  private final static byte[] FAMILY = Bytes.toBytes("cf");
-
-  private byte[] emptySnapshotName;
-  private byte[] snapshotName;
-  private int tableNumFiles;
-  private TableName tableName;
-  private Admin admin;
-
-  public static void setUpBaseConf(Configuration conf) {
-    conf.setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED, true);
-    conf.setInt("hbase.regionserver.msginterval", 100);
-    conf.setInt("hbase.client.pause", 250);
-    conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 6);
-    conf.setBoolean("hbase.master.enabletable.roundrobin", true);
-    conf.setInt("mapreduce.map.maxattempts", 10);
-    conf.setInt(MobConstants.MOB_FILE_CACHE_SIZE_KEY, 0);
-  }
-
-  @BeforeClass
-  public static void setUpBeforeClass() throws Exception {
-    setUpBaseConf(TEST_UTIL.getConfiguration());
-    TEST_UTIL.startMiniCluster(3);
-    TEST_UTIL.startMiniMapReduceCluster();
-  }
-
-  @AfterClass
-  public static void tearDownAfterClass() throws Exception {
-    TEST_UTIL.shutdownMiniMapReduceCluster();
-    TEST_UTIL.shutdownMiniCluster();
-  }
-
-  /**
-   * Create a table and take a snapshot of the table used by the export test.
-   */
-  @Before
-  public void setUp() throws Exception {
-    this.admin = TEST_UTIL.getHBaseAdmin();
-
-    long tid = System.currentTimeMillis();
-    tableName = TableName.valueOf("testtb-" + tid);
-    snapshotName = Bytes.toBytes("snaptb0-" + tid);
-    emptySnapshotName = Bytes.toBytes("emptySnaptb0-" + tid);
-
-    // create Table
-    MobSnapshotTestingUtils.createMobTable(TEST_UTIL, tableName, 1, FAMILY);
-
-    // Take an empty snapshot
-    admin.snapshot(emptySnapshotName, tableName);
-
-    // Add some rows
-    SnapshotTestingUtils.loadData(TEST_UTIL, tableName, 50, FAMILY);
-    tableNumFiles = admin.getTableRegions(tableName).size();
-
-    // take a snapshot
-    admin.snapshot(snapshotName, tableName);
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    TEST_UTIL.deleteTable(tableName);
-    SnapshotTestingUtils.deleteAllSnapshots(TEST_UTIL.getHBaseAdmin());
-    SnapshotTestingUtils.deleteArchiveDirectory(TEST_UTIL);
-  }
-
-  /**
-   * Verfy the result of getBalanceSplits() method.
-   * The result are groups of files, used as input list for the "export" mappers.
-   * All the groups should have similar amount of data.
-   *
-   * The input list is a pair of file path and length.
-   * The getBalanceSplits() function sort it by length,
-   * and assign to each group a file, going back and forth through the groups.
-   */
-  @Test
-  public void testBalanceSplit() throws Exception {
-    // Create a list of files
-    List<Pair<SnapshotFileInfo, Long>> files = new ArrayList<Pair<SnapshotFileInfo, Long>>();
-    for (long i = 0; i <= 20; i++) {
-      SnapshotFileInfo fileInfo = SnapshotFileInfo.newBuilder()
-        .setType(SnapshotFileInfo.Type.HFILE)
-        .setHfile("file-" + i)
-        .build();
-      files.add(new Pair<SnapshotFileInfo, Long>(fileInfo, i));
-    }
-
-    // Create 5 groups (total size 210)
-    //    group 0: 20, 11, 10,  1 (total size: 42)
-    //    group 1: 19, 12,  9,  2 (total size: 42)
-    //    group 2: 18, 13,  8,  3 (total size: 42)
-    //    group 3: 17, 12,  7,  4 (total size: 42)
-    //    group 4: 16, 11,  6,  5 (total size: 42)
-    List<List<Pair<SnapshotFileInfo, Long>>> splits = ExportSnapshot.getBalancedSplits(files, 5);
-    assertEquals(5, splits.size());
-
-    String[] split0 = new String[] {"file-20", "file-11", "file-10", "file-1", "file-0"};
-    verifyBalanceSplit(splits.get(0), split0, 42);
-    String[] split1 = new String[] {"file-19", "file-12", "file-9",  "file-2"};
-    verifyBalanceSplit(splits.get(1), split1, 42);
-    String[] split2 = new String[] {"file-18", "file-13", "file-8",  "file-3"};
-    verifyBalanceSplit(splits.get(2), split2, 42);
-    String[] split3 = new String[] {"file-17", "file-14", "file-7",  "file-4"};
-    verifyBalanceSplit(splits.get(3), split3, 42);
-    String[] split4 = new String[] {"file-16", "file-15", "file-6",  "file-5"};
-    verifyBalanceSplit(splits.get(4), split4, 42);
-  }
-
-  private void verifyBalanceSplit(final List<Pair<SnapshotFileInfo, Long>> split,
-      final String[] expected, final long expectedSize) {
-    assertEquals(expected.length, split.size());
-    long totalSize = 0;
-    for (int i = 0; i < expected.length; ++i) {
-      Pair<SnapshotFileInfo, Long> fileInfo = split.get(i);
-      assertEquals(expected[i], fileInfo.getFirst().getHfile());
-      totalSize += fileInfo.getSecond();
-    }
-    assertEquals(expectedSize, totalSize);
-  }
-
-  /**
-   * Verify if exported snapshot and copied files matches the original one.
-   */
-  @Test
-  public void testExportFileSystemState() throws Exception {
-    testExportFileSystemState(tableName, snapshotName, snapshotName, tableNumFiles);
-  }
-
-  @Test
-  public void testExportFileSystemStateWithSkipTmp() throws Exception {
-    TEST_UTIL.getConfiguration().setBoolean(ExportSnapshot.CONF_SKIP_TMP, true);
-    testExportFileSystemState(tableName, snapshotName, snapshotName, tableNumFiles);
-  }
-
-  @Test
-  public void testEmptyExportFileSystemState() throws Exception {
-    testExportFileSystemState(tableName, emptySnapshotName, emptySnapshotName, 0);
-  }
-
-  @Test
-  public void testConsecutiveExports() throws Exception {
-    Path copyDir = getLocalDestinationDir();
-    testExportFileSystemState(tableName, snapshotName, snapshotName, tableNumFiles, copyDir, false);
-    testExportFileSystemState(tableName, snapshotName, snapshotName, tableNumFiles, copyDir, true);
-    removeExportDir(copyDir);
-  }
-
-  @Test
-  public void testExportWithTargetName() throws Exception {
-    final byte[] targetName = Bytes.toBytes("testExportWithTargetName");
-    testExportFileSystemState(tableName, snapshotName, targetName, tableNumFiles);
-  }
-
-  /**
-   * Mock a snapshot with files in the archive dir,
-   * two regions, and one reference file.
-   */
-  @Test
-  public void testSnapshotWithRefsExportFileSystemState() throws Exception {
-    Configuration conf = TEST_UTIL.getConfiguration();
-
-    Path rootDir = TEST_UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getRootDir();
-    FileSystem fs = TEST_UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getFileSystem();
-
-    SnapshotMock snapshotMock = new SnapshotMock(TEST_UTIL.getConfiguration(), fs, rootDir);
-    SnapshotMock.SnapshotBuilder builder = snapshotMock.createSnapshotV2("tableWithRefsV1");
-    testSnapshotWithRefsExportFileSystemState(builder);
-
-    snapshotMock = new SnapshotMock(TEST_UTIL.getConfiguration(), fs, rootDir);
-    builder = snapshotMock.createSnapshotV2("tableWithRefsV2");
-    testSnapshotWithRefsExportFileSystemState(builder);
-  }
-
-  /**
-   * Generates a couple of regions for the specified SnapshotMock,
-   * and then it will run the export and verification.
-   */
-  private void testSnapshotWithRefsExportFileSystemState(SnapshotMock.SnapshotBuilder builder)
-      throws Exception {
-    Path[] r1Files = builder.addRegion();
-    Path[] r2Files = builder.addRegion();
-    builder.commit();
-    int snapshotFilesCount = r1Files.length + r2Files.length;
-
-    byte[] snapshotName = Bytes.toBytes(builder.getSnapshotDescription().getName());
-    TableName tableName = builder.getTableDescriptor().getTableName();
-    testExportFileSystemState(tableName, snapshotName, snapshotName, snapshotFilesCount);
-  }
-
-  private void testExportFileSystemState(final TableName tableName, final byte[] snapshotName,
-      final byte[] targetName, int filesExpected) throws Exception {
-    Path copyDir = getHdfsDestinationDir();
-    testExportFileSystemState(tableName, snapshotName, targetName, filesExpected, copyDir, false);
-    removeExportDir(copyDir);
-  }
-
-  /**
-   * Test ExportSnapshot
-   */
-  private void testExportFileSystemState(final TableName tableName, final byte[] snapshotName,
-      final byte[] targetName, int filesExpected, Path copyDir, boolean overwrite)
-      throws Exception {
-    URI hdfsUri = FileSystem.get(TEST_UTIL.getConfiguration()).getUri();
-    FileSystem fs = FileSystem.get(copyDir.toUri(), new Configuration());
-    copyDir = copyDir.makeQualified(fs);
-
-    List<String> opts = new ArrayList<String>();
-    opts.add("-snapshot");
-    opts.add(Bytes.toString(snapshotName));
-    opts.add("-copy-to");
-    opts.add(copyDir.toString());
-    if (targetName != snapshotName) {
-      opts.add("-target");
-      opts.add(Bytes.toString(targetName));
-    }
-    if (overwrite) opts.add("-overwrite");
-
-    // Export Snapshot
-    int res = ExportSnapshot.innerMain(TEST_UTIL.getConfiguration(),
-        opts.toArray(new String[opts.size()]));
-    assertEquals(0, res);
-
-    // Verify File-System state
-    FileStatus[] rootFiles = fs.listStatus(copyDir);
-    assertEquals(filesExpected > 0 ? 2 : 1, rootFiles.length);
-    for (FileStatus fileStatus: rootFiles) {
-      String name = fileStatus.getPath().getName();
-      assertTrue(fileStatus.isDirectory());
-      assertTrue(name.equals(HConstants.SNAPSHOT_DIR_NAME) ||
-                 name.equals(HConstants.HFILE_ARCHIVE_DIRECTORY));
-    }
-
-    // compare the snapshot metadata and verify the hfiles
-    final FileSystem hdfs = FileSystem.get(hdfsUri, TEST_UTIL.getConfiguration());
-    final Path snapshotDir = new Path(HConstants.SNAPSHOT_DIR_NAME, Bytes.toString(snapshotName));
-    final Path targetDir = new Path(HConstants.SNAPSHOT_DIR_NAME, Bytes.toString(targetName));
-    verifySnapshotDir(hdfs, new Path(TEST_UTIL.getDefaultRootDirPath(), snapshotDir),
-        fs, new Path(copyDir, targetDir));
-    Set<String> snapshotFiles = verifySnapshot(fs, copyDir, tableName, Bytes.toString(targetName));
-    assertEquals(filesExpected, snapshotFiles.size());
-  }
-
-  /**
-   * Check that ExportSnapshot will return a failure if something fails.
-   */
-  @Test
-  public void testExportFailure() throws Exception {
-    assertEquals(1, runExportAndInjectFailures(snapshotName, false));
-  }
-
-  /**
-   * Check that ExportSnapshot will succede if something fails but the retry succede.
-   */
-  @Test
-  public void testExportRetry() throws Exception {
-    assertEquals(0, runExportAndInjectFailures(snapshotName, true));
-  }
-
-  /*
-   * Execute the ExportSnapshot job injecting failures
-   */
-  private int runExportAndInjectFailures(final byte[] snapshotName, boolean retry)
-      throws Exception {
-    Path copyDir = getLocalDestinationDir();
-    URI hdfsUri = FileSystem.get(TEST_UTIL.getConfiguration()).getUri();
-    FileSystem fs = FileSystem.get(copyDir.toUri(), new Configuration());
-    copyDir = copyDir.makeQualified(fs);
-
-    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());
-    conf.setBoolean(ExportSnapshot.CONF_TEST_FAILURE, true);
-    conf.setBoolean(ExportSnapshot.CONF_TEST_RETRY, retry);
-
-    // Export Snapshot
-    Path sourceDir = TEST_UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getRootDir();
-    int res = ExportSnapshot.innerMain(conf, new String[] {
-      "-snapshot", Bytes.toString(snapshotName),
-      "-copy-from", sourceDir.toString(),
-      "-copy-to", copyDir.toString()
-    });
-    return res;
-  }
-
-  /*
-   * verify if the snapshot folder on file-system 1 match the one on file-system 2
-   */
-  private void verifySnapshotDir(final FileSystem fs1, final Path root1,
-      final FileSystem fs2, final Path root2) throws IOException {
-    assertEquals(listFiles(fs1, root1, root1), listFiles(fs2, root2, root2));
-  }
-
-  /*
-   * Verify if the files exists
-   */
-  private Set<String> verifySnapshot(final FileSystem fs, final Path rootDir,
-      final TableName tableName, final String snapshotName) throws IOException {
-    final Path exportedSnapshot = new Path(rootDir,
-      new Path(HConstants.SNAPSHOT_DIR_NAME, snapshotName));
-    final Set<String> snapshotFiles = new HashSet<String>();
-    final Path exportedArchive = new Path(rootDir, HConstants.HFILE_ARCHIVE_DIRECTORY);
-    SnapshotReferenceUtil.visitReferencedFiles(TEST_UTIL.getConfiguration(), fs, exportedSnapshot,
-          new SnapshotReferenceUtil.SnapshotVisitor() {
-        @Override
-        public void storeFile(final HRegionInfo regionInfo, final String family,
-            final SnapshotRegionManifest.StoreFile storeFile) throws IOException {
-          if(MobUtils.isMobRegionInfo(regionInfo))
-            return;
-          String hfile = storeFile.getName();
-          snapshotFiles.add(hfile);
-          if (storeFile.hasReference()) {
-            // Nothing to do here, we have already the reference embedded
-          } else {
-            verifyNonEmptyFile(new Path(exportedArchive,
-              new Path(FSUtils.getTableDir(new Path("./"), tableName),
-                  new Path(regionInfo.getEncodedName(), new Path(family, hfile)))));
-          }
-        }
-
-        @Override
-        public void logFile (final String server, final String logfile)
-            throws IOException {
-          snapshotFiles.add(logfile);
-          verifyNonEmptyFile(new Path(exportedSnapshot, new Path(server, logfile)));
-        }
-
-        private void verifyNonEmptyFile(final Path path) throws IOException {
-          assertTrue(path + " should exists", fs.exists(path));
-          assertTrue(path + " should not be empty", fs.getFileStatus(path).getLen() > 0);
-        }
-    });
-
-    // Verify Snapshot description
-    SnapshotDescription desc = SnapshotDescriptionUtils.readSnapshotInfo(fs, exportedSnapshot);
-    assertTrue(desc.getName().equals(snapshotName));
-    assertTrue(desc.getTable().equals(tableName.getNameAsString()));
-    return snapshotFiles;
-  }
-
-  private Set<String> listFiles(final FileSystem fs, final Path root, final Path dir)
-      throws IOException {
-    Set<String> files = new HashSet<String>();
-    int rootPrefix = root.toString().length();
-    FileStatus[] list = FSUtils.listStatus(fs, dir);
-    if (list != null) {
-      for (FileStatus fstat: list) {
-        LOG.debug(fstat.getPath());
-        if (fstat.isDirectory()) {
-          files.addAll(listFiles(fs, root, fstat.getPath()));
-        } else {
-          files.add(fstat.getPath().toString().substring(rootPrefix));
-        }
-      }
-    }
-    return files;
-  }
-
-  private Path getHdfsDestinationDir() {
-    Path rootDir = TEST_UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getRootDir();
-    Path path = new Path(new Path(rootDir, "export-test"), "export-" + System.currentTimeMillis());
-    LOG.info("HDFS export destination path: " + path);
-    return path;
-  }
-
-  private Path getLocalDestinationDir() {
-    Path path = TEST_UTIL.getDataTestDir("local-export-" + System.currentTimeMillis());
-    LOG.info("Local export destination path: " + path);
-    return path;
-  }
-
-  private void removeExportDir(final Path path) throws IOException {
-    FileSystem fs = FileSystem.get(path.toUri(), new Configuration());
-    fs.delete(path, true);
-  }
-}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestMobRestoreFlushSnapshotFromClient.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestMobRestoreFlushSnapshotFromClient.java
deleted file mode 100644
index 2838d16..0000000
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestMobRestoreFlushSnapshotFromClient.java
+++ /dev/null
@@ -1,209 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.hadoop.hbase.snapshot;
-
-import java.io.IOException;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.hbase.HBaseTestingUtility;
-import org.apache.hadoop.hbase.HConstants;
-import org.apache.hadoop.hbase.LargeTests;
-import org.apache.hadoop.hbase.TableName;
-import org.apache.hadoop.hbase.client.Admin;
-import org.apache.hadoop.hbase.client.HTable;
-import org.apache.hadoop.hbase.master.MasterFileSystem;
-import org.apache.hadoop.hbase.master.snapshot.SnapshotManager;
-import org.apache.hadoop.hbase.mob.MobConstants;
-import org.apache.hadoop.hbase.protobuf.generated.HBaseProtos.SnapshotDescription;
-import org.apache.hadoop.hbase.regionserver.snapshot.RegionServerSnapshotManager;
-import org.apache.hadoop.hbase.util.Bytes;
-import org.apache.hadoop.hbase.util.FSUtils;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-
-/**
- * Test clone/restore snapshots from the client
- *
- * TODO This is essentially a clone of TestRestoreSnapshotFromClient.  This is worth refactoring
- * this because there will be a few more flavors of snapshots that need to run these tests.
- */
-@Category(LargeTests.class)
-public class TestMobRestoreFlushSnapshotFromClient {
-  final Log LOG = LogFactory.getLog(getClass());
-
-  private final static HBaseTestingUtility UTIL = new HBaseTestingUtility();
-
-  private final byte[] FAMILY = Bytes.toBytes("cf");
-
-  private byte[] snapshotName0;
-  private byte[] snapshotName1;
-  private byte[] snapshotName2;
-  private int snapshot0Rows;
-  private int snapshot1Rows;
-  private TableName tableName;
-  private Admin admin;
-
-  @BeforeClass
-  public static void setUpBeforeClass() throws Exception {
-    UTIL.getConfiguration().setBoolean("hbase.online.schema.update.enable", true);
-    UTIL.getConfiguration().setInt("hbase.regionserver.msginterval", 100);
-    UTIL.getConfiguration().setInt("hbase.client.pause", 250);
-    UTIL.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 6);
-    UTIL.getConfiguration().setBoolean(
-        "hbase.master.enabletable.roundrobin", true);
-
-    // Enable snapshot
-    UTIL.getConfiguration().setBoolean(SnapshotManager.HBASE_SNAPSHOT_ENABLED, true);
-    UTIL.getConfiguration().setLong(RegionServerSnapshotManager.SNAPSHOT_TIMEOUT_MILLIS_KEY,
-      RegionServerSnapshotManager.SNAPSHOT_TIMEOUT_MILLIS_DEFAULT * 2);
-
-    UTIL.getConfiguration().setInt(MobConstants.MOB_FILE_CACHE_SIZE_KEY, 0);
-
-    UTIL.startMiniCluster(3);
-  }
-
-  @AfterClass
-  public static void tearDownAfterClass() throws Exception {
-    UTIL.shutdownMiniCluster();
-  }
-
-  /**
-   * Initialize the tests with a table filled with some data
-   * and two snapshots (snapshotName0, snapshotName1) of different states.
-   * The tableName, snapshotNames and the number of rows in the snapshot are initialized.
-   */
-  @Before
-  public void setup() throws Exception {
-    this.admin = UTIL.getHBaseAdmin();
-
-    long tid = System.currentTimeMillis();
-    tableName = TableName.valueOf("testtb-" + tid);
-    snapshotName0 = Bytes.toBytes("snaptb0-" + tid);
-    snapshotName1 = Bytes.toBytes("snaptb1-" + tid);
-    snapshotName2 = Bytes.toBytes("snaptb2-" + tid);
-
-    // create Table
-    MobSnapshotTestingUtils.createMobTable(UTIL, tableName, 1, FAMILY);
-
-    HTable table = new HTable(UTIL.getConfiguration(), tableName);
-    SnapshotTestingUtils.loadData(UTIL, table, 500, FAMILY);
-    snapshot0Rows = MobSnapshotTestingUtils.countMobRows(table);
-    LOG.info("=== before snapshot with 500 rows");
-    logFSTree();
-
-    // take a snapshot
-    admin.snapshot(Bytes.toString(snapshotName0), tableName,
-        SnapshotDescription.Type.FLUSH);
-
-    LOG.info("=== after snapshot with 500 rows");
-    logFSTree();
-
-    // insert more data
-    SnapshotTestingUtils.loadData(UTIL, table, 500, FAMILY);
-    snapshot1Rows = MobSnapshotTestingUtils.countMobRows(table);
-    LOG.info("=== before snapshot with 1000 rows");
-    logFSTree();
-
-    // take a snapshot of the updated table
-    admin.snapshot(Bytes.toString(snapshotName1), tableName,
-        SnapshotDescription.Type.FLUSH);
-    LOG.info("=== after snapshot with 1000 rows");
-    logFSTree();
-    table.close();
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    SnapshotTestingUtils.deleteAllSnapshots(UTIL.getHBaseAdmin());
-    SnapshotTestingUtils.deleteArchiveDirectory(UTIL);
-  }
-
-  @Test
-  public void testTakeFlushSnapshot() throws IOException {
-    // taking happens in setup.
-  }
-
-  @Test
-  public void testRestoreSnapshot() throws IOException {
-    MobSnapshotTestingUtils.verifyMobRowCount(UTIL, tableName, snapshot1Rows);
-
-    // Restore from snapshot-0
-    admin.disableTable(tableName);
-    admin.restoreSnapshot(snapshotName0);
-    logFSTree();
-    admin.enableTable(tableName);
-    LOG.info("=== after restore with 500 row snapshot");
-    logFSTree();
-    MobSnapshotTestingUtils.verifyMobRowCount(UTIL, tableName, snapshot0Rows);
-
-    // Restore from snapshot-1
-    admin.disableTable(tableName);
-    admin.restoreSnapshot(snapshotName1);
-    admin.enableTable(tableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(UTIL, tableName, snapshot1Rows);
-  }
-
-  @Test(expected=SnapshotDoesNotExistException.class)
-  public void testCloneNonExistentSnapshot() throws IOException, InterruptedException {
-    String snapshotName = "random-snapshot-" + System.currentTimeMillis();
-    TableName tableName = TableName.valueOf("random-table-" + System.currentTimeMillis());
-    admin.cloneSnapshot(snapshotName, tableName);
-  }
-
-  @Test
-  public void testCloneSnapshot() throws IOException, InterruptedException {
-    TableName clonedTableName = TableName.valueOf("clonedtb-" + System.currentTimeMillis());
-    testCloneSnapshot(clonedTableName, snapshotName0, snapshot0Rows);
-    testCloneSnapshot(clonedTableName, snapshotName1, snapshot1Rows);
-  }
-
-  private void testCloneSnapshot(final TableName tableName, final byte[] snapshotName,
-      int snapshotRows) throws IOException, InterruptedException {
-    // create a new table from snapshot
-    admin.cloneSnapshot(snapshotName, tableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(UTIL, tableName, snapshotRows);
-
-    UTIL.deleteTable(tableName);
-  }
-
-  @Test
-  public void testRestoreSnapshotOfCloned() throws IOException, InterruptedException {
-    TableName clonedTableName = TableName.valueOf("clonedtb-" + System.currentTimeMillis());
-    admin.cloneSnapshot(snapshotName0, clonedTableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(UTIL, clonedTableName, snapshot0Rows);
-    admin.snapshot(Bytes.toString(snapshotName2), clonedTableName, SnapshotDescription.Type.FLUSH);
-    UTIL.deleteTable(clonedTableName);
-
-    admin.cloneSnapshot(snapshotName2, clonedTableName);
-    MobSnapshotTestingUtils.verifyMobRowCount(UTIL, clonedTableName, snapshot0Rows);
-    UTIL.deleteTable(clonedTableName);
-  }
-
-  // ==========================================================================
-  //  Helpers
-  // ==========================================================================
-  private void logFSTree() throws IOException {
-    MasterFileSystem mfs = UTIL.getMiniHBaseCluster().getMaster().getMasterFileSystem();
-    FSUtils.logFileSystemState(mfs.getFileSystem(), mfs.getRootDir(), LOG);
-  }
-}
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestMobSecureExportSnapshot.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestMobSecureExportSnapshot.java
deleted file mode 100644
index 9416540..0000000
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestMobSecureExportSnapshot.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/**
- * Copyright The Apache Software Foundation
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.hadoop.hbase.snapshot;
-
-import org.apache.hadoop.hbase.LargeTests;
-import org.apache.hadoop.hbase.mapreduce.HadoopSecurityEnabledUserProviderForTesting;
-import org.apache.hadoop.hbase.security.UserProvider;
-import org.apache.hadoop.hbase.security.access.AccessControlLists;
-import org.apache.hadoop.hbase.security.access.SecureTestUtil;
-
-import org.junit.BeforeClass;
-import org.junit.experimental.categories.Category;
-
-/**
- * Reruns TestMobExportSnapshot using MobExportSnapshot in secure mode.
- */
-@Category(LargeTests.class)
-public class TestMobSecureExportSnapshot extends TestMobExportSnapshot {
-  @BeforeClass
-  public static void setUpBeforeClass() throws Exception {
-    setUpBaseConf(TEST_UTIL.getConfiguration());
-
-    // set the always on security provider
-    UserProvider.setUserProviderForTesting(TEST_UTIL.getConfiguration(),
-      HadoopSecurityEnabledUserProviderForTesting.class);
-
-    // setup configuration
-    SecureTestUtil.enableSecurity(TEST_UTIL.getConfiguration());
-
-    TEST_UTIL.startMiniCluster(3);
-    TEST_UTIL.startMiniMapReduceCluster();
-
-    // Wait for the ACL table to become available
-    TEST_UTIL.waitTableEnabled(AccessControlLists.ACL_TABLE_NAME.getName());
-  }
-}
\ No newline at end of file
