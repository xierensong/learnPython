diff --git a/hbase-protocol/pom.xml b/hbase-protocol/pom.xml
index 56ab13a..60ec46f 100644
--- a/hbase-protocol/pom.xml
+++ b/hbase-protocol/pom.xml
@@ -180,6 +180,7 @@
                           <include>Comparator.proto</include>
                           <include>Encryption.proto</include>
                           <include>ErrorHandling.proto</include>
+                          <include>Export.proto</include>
                           <include>FS.proto</include>
                           <include>Filter.proto</include>
                           <include>HBase.proto</include>
diff --git a/hbase-protocol/src/main/java/org/apache/hadoop/hbase/protobuf/generated/ExportProtos.java b/hbase-protocol/src/main/java/org/apache/hadoop/hbase/protobuf/generated/ExportProtos.java
new file mode 100644
index 0000000..4a503fc
--- /dev/null
+++ b/hbase-protocol/src/main/java/org/apache/hadoop/hbase/protobuf/generated/ExportProtos.java
@@ -0,0 +1,1990 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: Export.proto
+
+package org.apache.hadoop.hbase.protobuf.generated;
+
+public final class ExportProtos {
+  private ExportProtos() {}
+  public static void registerAllExtensions(
+      com.google.protobuf.ExtensionRegistry registry) {
+  }
+  public interface ExportRequestOrBuilder
+      extends com.google.protobuf.MessageOrBuilder {
+
+    // required .hbase.pb.Scan scan = 1;
+    /**
+     * <code>required .hbase.pb.Scan scan = 1;</code>
+     */
+    boolean hasScan();
+    /**
+     * <code>required .hbase.pb.Scan scan = 1;</code>
+     */
+    org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan getScan();
+    /**
+     * <code>required .hbase.pb.Scan scan = 1;</code>
+     */
+    org.apache.hadoop.hbase.protobuf.generated.ClientProtos.ScanOrBuilder getScanOrBuilder();
+
+    // required string outputPath = 2;
+    /**
+     * <code>required string outputPath = 2;</code>
+     */
+    boolean hasOutputPath();
+    /**
+     * <code>required string outputPath = 2;</code>
+     */
+    java.lang.String getOutputPath();
+    /**
+     * <code>required string outputPath = 2;</code>
+     */
+    com.google.protobuf.ByteString
+        getOutputPathBytes();
+
+    // optional bool compressed = 3 [default = false];
+    /**
+     * <code>optional bool compressed = 3 [default = false];</code>
+     */
+    boolean hasCompressed();
+    /**
+     * <code>optional bool compressed = 3 [default = false];</code>
+     */
+    boolean getCompressed();
+
+    // optional string compressType = 4;
+    /**
+     * <code>optional string compressType = 4;</code>
+     */
+    boolean hasCompressType();
+    /**
+     * <code>optional string compressType = 4;</code>
+     */
+    java.lang.String getCompressType();
+    /**
+     * <code>optional string compressType = 4;</code>
+     */
+    com.google.protobuf.ByteString
+        getCompressTypeBytes();
+
+    // optional string compressCodec = 5;
+    /**
+     * <code>optional string compressCodec = 5;</code>
+     */
+    boolean hasCompressCodec();
+    /**
+     * <code>optional string compressCodec = 5;</code>
+     */
+    java.lang.String getCompressCodec();
+    /**
+     * <code>optional string compressCodec = 5;</code>
+     */
+    com.google.protobuf.ByteString
+        getCompressCodecBytes();
+  }
+  /**
+   * Protobuf type {@code hbase.pb.ExportRequest}
+   */
+  public static final class ExportRequest extends
+      com.google.protobuf.GeneratedMessage
+      implements ExportRequestOrBuilder {
+    // Use ExportRequest.newBuilder() to construct.
+    private ExportRequest(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
+      super(builder);
+      this.unknownFields = builder.getUnknownFields();
+    }
+    private ExportRequest(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
+
+    private static final ExportRequest defaultInstance;
+    public static ExportRequest getDefaultInstance() {
+      return defaultInstance;
+    }
+
+    public ExportRequest getDefaultInstanceForType() {
+      return defaultInstance;
+    }
+
+    private final com.google.protobuf.UnknownFieldSet unknownFields;
+    @java.lang.Override
+    public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+      return this.unknownFields;
+    }
+    private ExportRequest(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      initFields();
+      int mutable_bitField0_ = 0;
+      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
+          com.google.protobuf.UnknownFieldSet.newBuilder();
+      try {
+        boolean done = false;
+        while (!done) {
+          int tag = input.readTag();
+          switch (tag) {
+            case 0:
+              done = true;
+              break;
+            default: {
+              if (!parseUnknownField(input, unknownFields,
+                                     extensionRegistry, tag)) {
+                done = true;
+              }
+              break;
+            }
+            case 10: {
+              org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.Builder subBuilder = null;
+              if (((bitField0_ & 0x00000001) == 0x00000001)) {
+                subBuilder = scan_.toBuilder();
+              }
+              scan_ = input.readMessage(org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.PARSER, extensionRegistry);
+              if (subBuilder != null) {
+                subBuilder.mergeFrom(scan_);
+                scan_ = subBuilder.buildPartial();
+              }
+              bitField0_ |= 0x00000001;
+              break;
+            }
+            case 18: {
+              bitField0_ |= 0x00000002;
+              outputPath_ = input.readBytes();
+              break;
+            }
+            case 24: {
+              bitField0_ |= 0x00000004;
+              compressed_ = input.readBool();
+              break;
+            }
+            case 34: {
+              bitField0_ |= 0x00000008;
+              compressType_ = input.readBytes();
+              break;
+            }
+            case 42: {
+              bitField0_ |= 0x00000010;
+              compressCodec_ = input.readBytes();
+              break;
+            }
+          }
+        }
+      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+        throw e.setUnfinishedMessage(this);
+      } catch (java.io.IOException e) {
+        throw new com.google.protobuf.InvalidProtocolBufferException(
+            e.getMessage()).setUnfinishedMessage(this);
+      } finally {
+        this.unknownFields = unknownFields.build();
+        makeExtensionsImmutable();
+      }
+    }
+    public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+      return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.internal_static_hbase_pb_ExportRequest_descriptor;
+    }
+
+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+      return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.internal_static_hbase_pb_ExportRequest_fieldAccessorTable
+          .ensureFieldAccessorsInitialized(
+              org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest.class, org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest.Builder.class);
+    }
+
+    public static com.google.protobuf.Parser<ExportRequest> PARSER =
+        new com.google.protobuf.AbstractParser<ExportRequest>() {
+      public ExportRequest parsePartialFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return new ExportRequest(input, extensionRegistry);
+      }
+    };
+
+    @java.lang.Override
+    public com.google.protobuf.Parser<ExportRequest> getParserForType() {
+      return PARSER;
+    }
+
+    private int bitField0_;
+    // required .hbase.pb.Scan scan = 1;
+    public static final int SCAN_FIELD_NUMBER = 1;
+    private org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan scan_;
+    /**
+     * <code>required .hbase.pb.Scan scan = 1;</code>
+     */
+    public boolean hasScan() {
+      return ((bitField0_ & 0x00000001) == 0x00000001);
+    }
+    /**
+     * <code>required .hbase.pb.Scan scan = 1;</code>
+     */
+    public org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan getScan() {
+      return scan_;
+    }
+    /**
+     * <code>required .hbase.pb.Scan scan = 1;</code>
+     */
+    public org.apache.hadoop.hbase.protobuf.generated.ClientProtos.ScanOrBuilder getScanOrBuilder() {
+      return scan_;
+    }
+
+    // required string outputPath = 2;
+    public static final int OUTPUTPATH_FIELD_NUMBER = 2;
+    private java.lang.Object outputPath_;
+    /**
+     * <code>required string outputPath = 2;</code>
+     */
+    public boolean hasOutputPath() {
+      return ((bitField0_ & 0x00000002) == 0x00000002);
+    }
+    /**
+     * <code>required string outputPath = 2;</code>
+     */
+    public java.lang.String getOutputPath() {
+      java.lang.Object ref = outputPath_;
+      if (ref instanceof java.lang.String) {
+        return (java.lang.String) ref;
+      } else {
+        com.google.protobuf.ByteString bs =
+            (com.google.protobuf.ByteString) ref;
+        java.lang.String s = bs.toStringUtf8();
+        if (bs.isValidUtf8()) {
+          outputPath_ = s;
+        }
+        return s;
+      }
+    }
+    /**
+     * <code>required string outputPath = 2;</code>
+     */
+    public com.google.protobuf.ByteString
+        getOutputPathBytes() {
+      java.lang.Object ref = outputPath_;
+      if (ref instanceof java.lang.String) {
+        com.google.protobuf.ByteString b =
+            com.google.protobuf.ByteString.copyFromUtf8(
+                (java.lang.String) ref);
+        outputPath_ = b;
+        return b;
+      } else {
+        return (com.google.protobuf.ByteString) ref;
+      }
+    }
+
+    // optional bool compressed = 3 [default = false];
+    public static final int COMPRESSED_FIELD_NUMBER = 3;
+    private boolean compressed_;
+    /**
+     * <code>optional bool compressed = 3 [default = false];</code>
+     */
+    public boolean hasCompressed() {
+      return ((bitField0_ & 0x00000004) == 0x00000004);
+    }
+    /**
+     * <code>optional bool compressed = 3 [default = false];</code>
+     */
+    public boolean getCompressed() {
+      return compressed_;
+    }
+
+    // optional string compressType = 4;
+    public static final int COMPRESSTYPE_FIELD_NUMBER = 4;
+    private java.lang.Object compressType_;
+    /**
+     * <code>optional string compressType = 4;</code>
+     */
+    public boolean hasCompressType() {
+      return ((bitField0_ & 0x00000008) == 0x00000008);
+    }
+    /**
+     * <code>optional string compressType = 4;</code>
+     */
+    public java.lang.String getCompressType() {
+      java.lang.Object ref = compressType_;
+      if (ref instanceof java.lang.String) {
+        return (java.lang.String) ref;
+      } else {
+        com.google.protobuf.ByteString bs =
+            (com.google.protobuf.ByteString) ref;
+        java.lang.String s = bs.toStringUtf8();
+        if (bs.isValidUtf8()) {
+          compressType_ = s;
+        }
+        return s;
+      }
+    }
+    /**
+     * <code>optional string compressType = 4;</code>
+     */
+    public com.google.protobuf.ByteString
+        getCompressTypeBytes() {
+      java.lang.Object ref = compressType_;
+      if (ref instanceof java.lang.String) {
+        com.google.protobuf.ByteString b =
+            com.google.protobuf.ByteString.copyFromUtf8(
+                (java.lang.String) ref);
+        compressType_ = b;
+        return b;
+      } else {
+        return (com.google.protobuf.ByteString) ref;
+      }
+    }
+
+    // optional string compressCodec = 5;
+    public static final int COMPRESSCODEC_FIELD_NUMBER = 5;
+    private java.lang.Object compressCodec_;
+    /**
+     * <code>optional string compressCodec = 5;</code>
+     */
+    public boolean hasCompressCodec() {
+      return ((bitField0_ & 0x00000010) == 0x00000010);
+    }
+    /**
+     * <code>optional string compressCodec = 5;</code>
+     */
+    public java.lang.String getCompressCodec() {
+      java.lang.Object ref = compressCodec_;
+      if (ref instanceof java.lang.String) {
+        return (java.lang.String) ref;
+      } else {
+        com.google.protobuf.ByteString bs =
+            (com.google.protobuf.ByteString) ref;
+        java.lang.String s = bs.toStringUtf8();
+        if (bs.isValidUtf8()) {
+          compressCodec_ = s;
+        }
+        return s;
+      }
+    }
+    /**
+     * <code>optional string compressCodec = 5;</code>
+     */
+    public com.google.protobuf.ByteString
+        getCompressCodecBytes() {
+      java.lang.Object ref = compressCodec_;
+      if (ref instanceof java.lang.String) {
+        com.google.protobuf.ByteString b =
+            com.google.protobuf.ByteString.copyFromUtf8(
+                (java.lang.String) ref);
+        compressCodec_ = b;
+        return b;
+      } else {
+        return (com.google.protobuf.ByteString) ref;
+      }
+    }
+
+    private void initFields() {
+      scan_ = org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.getDefaultInstance();
+      outputPath_ = "";
+      compressed_ = false;
+      compressType_ = "";
+      compressCodec_ = "";
+    }
+    private byte memoizedIsInitialized = -1;
+    public final boolean isInitialized() {
+      byte isInitialized = memoizedIsInitialized;
+      if (isInitialized != -1) return isInitialized == 1;
+
+      if (!hasScan()) {
+        memoizedIsInitialized = 0;
+        return false;
+      }
+      if (!hasOutputPath()) {
+        memoizedIsInitialized = 0;
+        return false;
+      }
+      if (!getScan().isInitialized()) {
+        memoizedIsInitialized = 0;
+        return false;
+      }
+      memoizedIsInitialized = 1;
+      return true;
+    }
+
+    public void writeTo(com.google.protobuf.CodedOutputStream output)
+                        throws java.io.IOException {
+      getSerializedSize();
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        output.writeMessage(1, scan_);
+      }
+      if (((bitField0_ & 0x00000002) == 0x00000002)) {
+        output.writeBytes(2, getOutputPathBytes());
+      }
+      if (((bitField0_ & 0x00000004) == 0x00000004)) {
+        output.writeBool(3, compressed_);
+      }
+      if (((bitField0_ & 0x00000008) == 0x00000008)) {
+        output.writeBytes(4, getCompressTypeBytes());
+      }
+      if (((bitField0_ & 0x00000010) == 0x00000010)) {
+        output.writeBytes(5, getCompressCodecBytes());
+      }
+      getUnknownFields().writeTo(output);
+    }
+
+    private int memoizedSerializedSize = -1;
+    public int getSerializedSize() {
+      int size = memoizedSerializedSize;
+      if (size != -1) return size;
+
+      size = 0;
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeMessageSize(1, scan_);
+      }
+      if (((bitField0_ & 0x00000002) == 0x00000002)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeBytesSize(2, getOutputPathBytes());
+      }
+      if (((bitField0_ & 0x00000004) == 0x00000004)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeBoolSize(3, compressed_);
+      }
+      if (((bitField0_ & 0x00000008) == 0x00000008)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeBytesSize(4, getCompressTypeBytes());
+      }
+      if (((bitField0_ & 0x00000010) == 0x00000010)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeBytesSize(5, getCompressCodecBytes());
+      }
+      size += getUnknownFields().getSerializedSize();
+      memoizedSerializedSize = size;
+      return size;
+    }
+
+    private static final long serialVersionUID = 0L;
+    @java.lang.Override
+    protected java.lang.Object writeReplace()
+        throws java.io.ObjectStreamException {
+      return super.writeReplace();
+    }
+
+    @java.lang.Override
+    public boolean equals(final java.lang.Object obj) {
+      if (obj == this) {
+       return true;
+      }
+      if (!(obj instanceof org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest)) {
+        return super.equals(obj);
+      }
+      org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest other = (org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest) obj;
+
+      boolean result = true;
+      result = result && (hasScan() == other.hasScan());
+      if (hasScan()) {
+        result = result && getScan()
+            .equals(other.getScan());
+      }
+      result = result && (hasOutputPath() == other.hasOutputPath());
+      if (hasOutputPath()) {
+        result = result && getOutputPath()
+            .equals(other.getOutputPath());
+      }
+      result = result && (hasCompressed() == other.hasCompressed());
+      if (hasCompressed()) {
+        result = result && (getCompressed()
+            == other.getCompressed());
+      }
+      result = result && (hasCompressType() == other.hasCompressType());
+      if (hasCompressType()) {
+        result = result && getCompressType()
+            .equals(other.getCompressType());
+      }
+      result = result && (hasCompressCodec() == other.hasCompressCodec());
+      if (hasCompressCodec()) {
+        result = result && getCompressCodec()
+            .equals(other.getCompressCodec());
+      }
+      result = result &&
+          getUnknownFields().equals(other.getUnknownFields());
+      return result;
+    }
+
+    private int memoizedHashCode = 0;
+    @java.lang.Override
+    public int hashCode() {
+      if (memoizedHashCode != 0) {
+        return memoizedHashCode;
+      }
+      int hash = 41;
+      hash = (19 * hash) + getDescriptorForType().hashCode();
+      if (hasScan()) {
+        hash = (37 * hash) + SCAN_FIELD_NUMBER;
+        hash = (53 * hash) + getScan().hashCode();
+      }
+      if (hasOutputPath()) {
+        hash = (37 * hash) + OUTPUTPATH_FIELD_NUMBER;
+        hash = (53 * hash) + getOutputPath().hashCode();
+      }
+      if (hasCompressed()) {
+        hash = (37 * hash) + COMPRESSED_FIELD_NUMBER;
+        hash = (53 * hash) + hashBoolean(getCompressed());
+      }
+      if (hasCompressType()) {
+        hash = (37 * hash) + COMPRESSTYPE_FIELD_NUMBER;
+        hash = (53 * hash) + getCompressType().hashCode();
+      }
+      if (hasCompressCodec()) {
+        hash = (37 * hash) + COMPRESSCODEC_FIELD_NUMBER;
+        hash = (53 * hash) + getCompressCodec().hashCode();
+      }
+      hash = (29 * hash) + getUnknownFields().hashCode();
+      memoizedHashCode = hash;
+      return hash;
+    }
+
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest parseFrom(
+        com.google.protobuf.ByteString data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest parseFrom(
+        com.google.protobuf.ByteString data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest parseFrom(byte[] data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest parseFrom(
+        byte[] data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest parseFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest parseFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest parseDelimitedFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest parseDelimitedFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input, extensionRegistry);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest parseFrom(
+        com.google.protobuf.CodedInputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest parseFrom(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+
+    public static Builder newBuilder() { return Builder.create(); }
+    public Builder newBuilderForType() { return newBuilder(); }
+    public static Builder newBuilder(org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest prototype) {
+      return newBuilder().mergeFrom(prototype);
+    }
+    public Builder toBuilder() { return newBuilder(this); }
+
+    @java.lang.Override
+    protected Builder newBuilderForType(
+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+      Builder builder = new Builder(parent);
+      return builder;
+    }
+    /**
+     * Protobuf type {@code hbase.pb.ExportRequest}
+     */
+    public static final class Builder extends
+        com.google.protobuf.GeneratedMessage.Builder<Builder>
+       implements org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequestOrBuilder {
+      public static final com.google.protobuf.Descriptors.Descriptor
+          getDescriptor() {
+        return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.internal_static_hbase_pb_ExportRequest_descriptor;
+      }
+
+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+          internalGetFieldAccessorTable() {
+        return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.internal_static_hbase_pb_ExportRequest_fieldAccessorTable
+            .ensureFieldAccessorsInitialized(
+                org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest.class, org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest.Builder.class);
+      }
+
+      // Construct using org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest.newBuilder()
+      private Builder() {
+        maybeForceBuilderInitialization();
+      }
+
+      private Builder(
+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+        super(parent);
+        maybeForceBuilderInitialization();
+      }
+      private void maybeForceBuilderInitialization() {
+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
+          getScanFieldBuilder();
+        }
+      }
+      private static Builder create() {
+        return new Builder();
+      }
+
+      public Builder clear() {
+        super.clear();
+        if (scanBuilder_ == null) {
+          scan_ = org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.getDefaultInstance();
+        } else {
+          scanBuilder_.clear();
+        }
+        bitField0_ = (bitField0_ & ~0x00000001);
+        outputPath_ = "";
+        bitField0_ = (bitField0_ & ~0x00000002);
+        compressed_ = false;
+        bitField0_ = (bitField0_ & ~0x00000004);
+        compressType_ = "";
+        bitField0_ = (bitField0_ & ~0x00000008);
+        compressCodec_ = "";
+        bitField0_ = (bitField0_ & ~0x00000010);
+        return this;
+      }
+
+      public Builder clone() {
+        return create().mergeFrom(buildPartial());
+      }
+
+      public com.google.protobuf.Descriptors.Descriptor
+          getDescriptorForType() {
+        return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.internal_static_hbase_pb_ExportRequest_descriptor;
+      }
+
+      public org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest getDefaultInstanceForType() {
+        return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest.getDefaultInstance();
+      }
+
+      public org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest build() {
+        org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest result = buildPartial();
+        if (!result.isInitialized()) {
+          throw newUninitializedMessageException(result);
+        }
+        return result;
+      }
+
+      public org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest buildPartial() {
+        org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest result = new org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest(this);
+        int from_bitField0_ = bitField0_;
+        int to_bitField0_ = 0;
+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
+          to_bitField0_ |= 0x00000001;
+        }
+        if (scanBuilder_ == null) {
+          result.scan_ = scan_;
+        } else {
+          result.scan_ = scanBuilder_.build();
+        }
+        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
+          to_bitField0_ |= 0x00000002;
+        }
+        result.outputPath_ = outputPath_;
+        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
+          to_bitField0_ |= 0x00000004;
+        }
+        result.compressed_ = compressed_;
+        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
+          to_bitField0_ |= 0x00000008;
+        }
+        result.compressType_ = compressType_;
+        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
+          to_bitField0_ |= 0x00000010;
+        }
+        result.compressCodec_ = compressCodec_;
+        result.bitField0_ = to_bitField0_;
+        onBuilt();
+        return result;
+      }
+
+      public Builder mergeFrom(com.google.protobuf.Message other) {
+        if (other instanceof org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest) {
+          return mergeFrom((org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest)other);
+        } else {
+          super.mergeFrom(other);
+          return this;
+        }
+      }
+
+      public Builder mergeFrom(org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest other) {
+        if (other == org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest.getDefaultInstance()) return this;
+        if (other.hasScan()) {
+          mergeScan(other.getScan());
+        }
+        if (other.hasOutputPath()) {
+          bitField0_ |= 0x00000002;
+          outputPath_ = other.outputPath_;
+          onChanged();
+        }
+        if (other.hasCompressed()) {
+          setCompressed(other.getCompressed());
+        }
+        if (other.hasCompressType()) {
+          bitField0_ |= 0x00000008;
+          compressType_ = other.compressType_;
+          onChanged();
+        }
+        if (other.hasCompressCodec()) {
+          bitField0_ |= 0x00000010;
+          compressCodec_ = other.compressCodec_;
+          onChanged();
+        }
+        this.mergeUnknownFields(other.getUnknownFields());
+        return this;
+      }
+
+      public final boolean isInitialized() {
+        if (!hasScan()) {
+          return false;
+        }
+        if (!hasOutputPath()) {
+          return false;
+        }
+        if (!getScan().isInitialized()) {
+          return false;
+        }
+        return true;
+      }
+
+      public Builder mergeFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest parsedMessage = null;
+        try {
+          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+          parsedMessage = (org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest) e.getUnfinishedMessage();
+          throw e;
+        } finally {
+          if (parsedMessage != null) {
+            mergeFrom(parsedMessage);
+          }
+        }
+        return this;
+      }
+      private int bitField0_;
+
+      // required .hbase.pb.Scan scan = 1;
+      private org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan scan_ = org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.getDefaultInstance();
+      private com.google.protobuf.SingleFieldBuilder<
+          org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan, org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.Builder, org.apache.hadoop.hbase.protobuf.generated.ClientProtos.ScanOrBuilder> scanBuilder_;
+      /**
+       * <code>required .hbase.pb.Scan scan = 1;</code>
+       */
+      public boolean hasScan() {
+        return ((bitField0_ & 0x00000001) == 0x00000001);
+      }
+      /**
+       * <code>required .hbase.pb.Scan scan = 1;</code>
+       */
+      public org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan getScan() {
+        if (scanBuilder_ == null) {
+          return scan_;
+        } else {
+          return scanBuilder_.getMessage();
+        }
+      }
+      /**
+       * <code>required .hbase.pb.Scan scan = 1;</code>
+       */
+      public Builder setScan(org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan value) {
+        if (scanBuilder_ == null) {
+          if (value == null) {
+            throw new NullPointerException();
+          }
+          scan_ = value;
+          onChanged();
+        } else {
+          scanBuilder_.setMessage(value);
+        }
+        bitField0_ |= 0x00000001;
+        return this;
+      }
+      /**
+       * <code>required .hbase.pb.Scan scan = 1;</code>
+       */
+      public Builder setScan(
+          org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.Builder builderForValue) {
+        if (scanBuilder_ == null) {
+          scan_ = builderForValue.build();
+          onChanged();
+        } else {
+          scanBuilder_.setMessage(builderForValue.build());
+        }
+        bitField0_ |= 0x00000001;
+        return this;
+      }
+      /**
+       * <code>required .hbase.pb.Scan scan = 1;</code>
+       */
+      public Builder mergeScan(org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan value) {
+        if (scanBuilder_ == null) {
+          if (((bitField0_ & 0x00000001) == 0x00000001) &&
+              scan_ != org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.getDefaultInstance()) {
+            scan_ =
+              org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.newBuilder(scan_).mergeFrom(value).buildPartial();
+          } else {
+            scan_ = value;
+          }
+          onChanged();
+        } else {
+          scanBuilder_.mergeFrom(value);
+        }
+        bitField0_ |= 0x00000001;
+        return this;
+      }
+      /**
+       * <code>required .hbase.pb.Scan scan = 1;</code>
+       */
+      public Builder clearScan() {
+        if (scanBuilder_ == null) {
+          scan_ = org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.getDefaultInstance();
+          onChanged();
+        } else {
+          scanBuilder_.clear();
+        }
+        bitField0_ = (bitField0_ & ~0x00000001);
+        return this;
+      }
+      /**
+       * <code>required .hbase.pb.Scan scan = 1;</code>
+       */
+      public org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.Builder getScanBuilder() {
+        bitField0_ |= 0x00000001;
+        onChanged();
+        return getScanFieldBuilder().getBuilder();
+      }
+      /**
+       * <code>required .hbase.pb.Scan scan = 1;</code>
+       */
+      public org.apache.hadoop.hbase.protobuf.generated.ClientProtos.ScanOrBuilder getScanOrBuilder() {
+        if (scanBuilder_ != null) {
+          return scanBuilder_.getMessageOrBuilder();
+        } else {
+          return scan_;
+        }
+      }
+      /**
+       * <code>required .hbase.pb.Scan scan = 1;</code>
+       */
+      private com.google.protobuf.SingleFieldBuilder<
+          org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan, org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.Builder, org.apache.hadoop.hbase.protobuf.generated.ClientProtos.ScanOrBuilder>
+          getScanFieldBuilder() {
+        if (scanBuilder_ == null) {
+          scanBuilder_ = new com.google.protobuf.SingleFieldBuilder<
+              org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan, org.apache.hadoop.hbase.protobuf.generated.ClientProtos.Scan.Builder, org.apache.hadoop.hbase.protobuf.generated.ClientProtos.ScanOrBuilder>(
+                  scan_,
+                  getParentForChildren(),
+                  isClean());
+          scan_ = null;
+        }
+        return scanBuilder_;
+      }
+
+      // required string outputPath = 2;
+      private java.lang.Object outputPath_ = "";
+      /**
+       * <code>required string outputPath = 2;</code>
+       */
+      public boolean hasOutputPath() {
+        return ((bitField0_ & 0x00000002) == 0x00000002);
+      }
+      /**
+       * <code>required string outputPath = 2;</code>
+       */
+      public java.lang.String getOutputPath() {
+        java.lang.Object ref = outputPath_;
+        if (!(ref instanceof java.lang.String)) {
+          java.lang.String s = ((com.google.protobuf.ByteString) ref)
+              .toStringUtf8();
+          outputPath_ = s;
+          return s;
+        } else {
+          return (java.lang.String) ref;
+        }
+      }
+      /**
+       * <code>required string outputPath = 2;</code>
+       */
+      public com.google.protobuf.ByteString
+          getOutputPathBytes() {
+        java.lang.Object ref = outputPath_;
+        if (ref instanceof String) {
+          com.google.protobuf.ByteString b =
+              com.google.protobuf.ByteString.copyFromUtf8(
+                  (java.lang.String) ref);
+          outputPath_ = b;
+          return b;
+        } else {
+          return (com.google.protobuf.ByteString) ref;
+        }
+      }
+      /**
+       * <code>required string outputPath = 2;</code>
+       */
+      public Builder setOutputPath(
+          java.lang.String value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000002;
+        outputPath_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>required string outputPath = 2;</code>
+       */
+      public Builder clearOutputPath() {
+        bitField0_ = (bitField0_ & ~0x00000002);
+        outputPath_ = getDefaultInstance().getOutputPath();
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>required string outputPath = 2;</code>
+       */
+      public Builder setOutputPathBytes(
+          com.google.protobuf.ByteString value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000002;
+        outputPath_ = value;
+        onChanged();
+        return this;
+      }
+
+      // optional bool compressed = 3 [default = false];
+      private boolean compressed_ ;
+      /**
+       * <code>optional bool compressed = 3 [default = false];</code>
+       */
+      public boolean hasCompressed() {
+        return ((bitField0_ & 0x00000004) == 0x00000004);
+      }
+      /**
+       * <code>optional bool compressed = 3 [default = false];</code>
+       */
+      public boolean getCompressed() {
+        return compressed_;
+      }
+      /**
+       * <code>optional bool compressed = 3 [default = false];</code>
+       */
+      public Builder setCompressed(boolean value) {
+        bitField0_ |= 0x00000004;
+        compressed_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional bool compressed = 3 [default = false];</code>
+       */
+      public Builder clearCompressed() {
+        bitField0_ = (bitField0_ & ~0x00000004);
+        compressed_ = false;
+        onChanged();
+        return this;
+      }
+
+      // optional string compressType = 4;
+      private java.lang.Object compressType_ = "";
+      /**
+       * <code>optional string compressType = 4;</code>
+       */
+      public boolean hasCompressType() {
+        return ((bitField0_ & 0x00000008) == 0x00000008);
+      }
+      /**
+       * <code>optional string compressType = 4;</code>
+       */
+      public java.lang.String getCompressType() {
+        java.lang.Object ref = compressType_;
+        if (!(ref instanceof java.lang.String)) {
+          java.lang.String s = ((com.google.protobuf.ByteString) ref)
+              .toStringUtf8();
+          compressType_ = s;
+          return s;
+        } else {
+          return (java.lang.String) ref;
+        }
+      }
+      /**
+       * <code>optional string compressType = 4;</code>
+       */
+      public com.google.protobuf.ByteString
+          getCompressTypeBytes() {
+        java.lang.Object ref = compressType_;
+        if (ref instanceof String) {
+          com.google.protobuf.ByteString b =
+              com.google.protobuf.ByteString.copyFromUtf8(
+                  (java.lang.String) ref);
+          compressType_ = b;
+          return b;
+        } else {
+          return (com.google.protobuf.ByteString) ref;
+        }
+      }
+      /**
+       * <code>optional string compressType = 4;</code>
+       */
+      public Builder setCompressType(
+          java.lang.String value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000008;
+        compressType_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional string compressType = 4;</code>
+       */
+      public Builder clearCompressType() {
+        bitField0_ = (bitField0_ & ~0x00000008);
+        compressType_ = getDefaultInstance().getCompressType();
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional string compressType = 4;</code>
+       */
+      public Builder setCompressTypeBytes(
+          com.google.protobuf.ByteString value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000008;
+        compressType_ = value;
+        onChanged();
+        return this;
+      }
+
+      // optional string compressCodec = 5;
+      private java.lang.Object compressCodec_ = "";
+      /**
+       * <code>optional string compressCodec = 5;</code>
+       */
+      public boolean hasCompressCodec() {
+        return ((bitField0_ & 0x00000010) == 0x00000010);
+      }
+      /**
+       * <code>optional string compressCodec = 5;</code>
+       */
+      public java.lang.String getCompressCodec() {
+        java.lang.Object ref = compressCodec_;
+        if (!(ref instanceof java.lang.String)) {
+          java.lang.String s = ((com.google.protobuf.ByteString) ref)
+              .toStringUtf8();
+          compressCodec_ = s;
+          return s;
+        } else {
+          return (java.lang.String) ref;
+        }
+      }
+      /**
+       * <code>optional string compressCodec = 5;</code>
+       */
+      public com.google.protobuf.ByteString
+          getCompressCodecBytes() {
+        java.lang.Object ref = compressCodec_;
+        if (ref instanceof String) {
+          com.google.protobuf.ByteString b =
+              com.google.protobuf.ByteString.copyFromUtf8(
+                  (java.lang.String) ref);
+          compressCodec_ = b;
+          return b;
+        } else {
+          return (com.google.protobuf.ByteString) ref;
+        }
+      }
+      /**
+       * <code>optional string compressCodec = 5;</code>
+       */
+      public Builder setCompressCodec(
+          java.lang.String value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000010;
+        compressCodec_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional string compressCodec = 5;</code>
+       */
+      public Builder clearCompressCodec() {
+        bitField0_ = (bitField0_ & ~0x00000010);
+        compressCodec_ = getDefaultInstance().getCompressCodec();
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional string compressCodec = 5;</code>
+       */
+      public Builder setCompressCodecBytes(
+          com.google.protobuf.ByteString value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000010;
+        compressCodec_ = value;
+        onChanged();
+        return this;
+      }
+
+      // @@protoc_insertion_point(builder_scope:hbase.pb.ExportRequest)
+    }
+
+    static {
+      defaultInstance = new ExportRequest(true);
+      defaultInstance.initFields();
+    }
+
+    // @@protoc_insertion_point(class_scope:hbase.pb.ExportRequest)
+  }
+
+  public interface ExportResponseOrBuilder
+      extends com.google.protobuf.MessageOrBuilder {
+
+    // required uint64 rowCount = 1;
+    /**
+     * <code>required uint64 rowCount = 1;</code>
+     */
+    boolean hasRowCount();
+    /**
+     * <code>required uint64 rowCount = 1;</code>
+     */
+    long getRowCount();
+
+    // required uint64 cellCount = 2;
+    /**
+     * <code>required uint64 cellCount = 2;</code>
+     */
+    boolean hasCellCount();
+    /**
+     * <code>required uint64 cellCount = 2;</code>
+     */
+    long getCellCount();
+  }
+  /**
+   * Protobuf type {@code hbase.pb.ExportResponse}
+   */
+  public static final class ExportResponse extends
+      com.google.protobuf.GeneratedMessage
+      implements ExportResponseOrBuilder {
+    // Use ExportResponse.newBuilder() to construct.
+    private ExportResponse(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
+      super(builder);
+      this.unknownFields = builder.getUnknownFields();
+    }
+    private ExportResponse(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
+
+    private static final ExportResponse defaultInstance;
+    public static ExportResponse getDefaultInstance() {
+      return defaultInstance;
+    }
+
+    public ExportResponse getDefaultInstanceForType() {
+      return defaultInstance;
+    }
+
+    private final com.google.protobuf.UnknownFieldSet unknownFields;
+    @java.lang.Override
+    public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+      return this.unknownFields;
+    }
+    private ExportResponse(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      initFields();
+      int mutable_bitField0_ = 0;
+      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
+          com.google.protobuf.UnknownFieldSet.newBuilder();
+      try {
+        boolean done = false;
+        while (!done) {
+          int tag = input.readTag();
+          switch (tag) {
+            case 0:
+              done = true;
+              break;
+            default: {
+              if (!parseUnknownField(input, unknownFields,
+                                     extensionRegistry, tag)) {
+                done = true;
+              }
+              break;
+            }
+            case 8: {
+              bitField0_ |= 0x00000001;
+              rowCount_ = input.readUInt64();
+              break;
+            }
+            case 16: {
+              bitField0_ |= 0x00000002;
+              cellCount_ = input.readUInt64();
+              break;
+            }
+          }
+        }
+      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+        throw e.setUnfinishedMessage(this);
+      } catch (java.io.IOException e) {
+        throw new com.google.protobuf.InvalidProtocolBufferException(
+            e.getMessage()).setUnfinishedMessage(this);
+      } finally {
+        this.unknownFields = unknownFields.build();
+        makeExtensionsImmutable();
+      }
+    }
+    public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+      return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.internal_static_hbase_pb_ExportResponse_descriptor;
+    }
+
+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+      return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.internal_static_hbase_pb_ExportResponse_fieldAccessorTable
+          .ensureFieldAccessorsInitialized(
+              org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.class, org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.Builder.class);
+    }
+
+    public static com.google.protobuf.Parser<ExportResponse> PARSER =
+        new com.google.protobuf.AbstractParser<ExportResponse>() {
+      public ExportResponse parsePartialFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return new ExportResponse(input, extensionRegistry);
+      }
+    };
+
+    @java.lang.Override
+    public com.google.protobuf.Parser<ExportResponse> getParserForType() {
+      return PARSER;
+    }
+
+    private int bitField0_;
+    // required uint64 rowCount = 1;
+    public static final int ROWCOUNT_FIELD_NUMBER = 1;
+    private long rowCount_;
+    /**
+     * <code>required uint64 rowCount = 1;</code>
+     */
+    public boolean hasRowCount() {
+      return ((bitField0_ & 0x00000001) == 0x00000001);
+    }
+    /**
+     * <code>required uint64 rowCount = 1;</code>
+     */
+    public long getRowCount() {
+      return rowCount_;
+    }
+
+    // required uint64 cellCount = 2;
+    public static final int CELLCOUNT_FIELD_NUMBER = 2;
+    private long cellCount_;
+    /**
+     * <code>required uint64 cellCount = 2;</code>
+     */
+    public boolean hasCellCount() {
+      return ((bitField0_ & 0x00000002) == 0x00000002);
+    }
+    /**
+     * <code>required uint64 cellCount = 2;</code>
+     */
+    public long getCellCount() {
+      return cellCount_;
+    }
+
+    private void initFields() {
+      rowCount_ = 0L;
+      cellCount_ = 0L;
+    }
+    private byte memoizedIsInitialized = -1;
+    public final boolean isInitialized() {
+      byte isInitialized = memoizedIsInitialized;
+      if (isInitialized != -1) return isInitialized == 1;
+
+      if (!hasRowCount()) {
+        memoizedIsInitialized = 0;
+        return false;
+      }
+      if (!hasCellCount()) {
+        memoizedIsInitialized = 0;
+        return false;
+      }
+      memoizedIsInitialized = 1;
+      return true;
+    }
+
+    public void writeTo(com.google.protobuf.CodedOutputStream output)
+                        throws java.io.IOException {
+      getSerializedSize();
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        output.writeUInt64(1, rowCount_);
+      }
+      if (((bitField0_ & 0x00000002) == 0x00000002)) {
+        output.writeUInt64(2, cellCount_);
+      }
+      getUnknownFields().writeTo(output);
+    }
+
+    private int memoizedSerializedSize = -1;
+    public int getSerializedSize() {
+      int size = memoizedSerializedSize;
+      if (size != -1) return size;
+
+      size = 0;
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeUInt64Size(1, rowCount_);
+      }
+      if (((bitField0_ & 0x00000002) == 0x00000002)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeUInt64Size(2, cellCount_);
+      }
+      size += getUnknownFields().getSerializedSize();
+      memoizedSerializedSize = size;
+      return size;
+    }
+
+    private static final long serialVersionUID = 0L;
+    @java.lang.Override
+    protected java.lang.Object writeReplace()
+        throws java.io.ObjectStreamException {
+      return super.writeReplace();
+    }
+
+    @java.lang.Override
+    public boolean equals(final java.lang.Object obj) {
+      if (obj == this) {
+       return true;
+      }
+      if (!(obj instanceof org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse)) {
+        return super.equals(obj);
+      }
+      org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse other = (org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse) obj;
+
+      boolean result = true;
+      result = result && (hasRowCount() == other.hasRowCount());
+      if (hasRowCount()) {
+        result = result && (getRowCount()
+            == other.getRowCount());
+      }
+      result = result && (hasCellCount() == other.hasCellCount());
+      if (hasCellCount()) {
+        result = result && (getCellCount()
+            == other.getCellCount());
+      }
+      result = result &&
+          getUnknownFields().equals(other.getUnknownFields());
+      return result;
+    }
+
+    private int memoizedHashCode = 0;
+    @java.lang.Override
+    public int hashCode() {
+      if (memoizedHashCode != 0) {
+        return memoizedHashCode;
+      }
+      int hash = 41;
+      hash = (19 * hash) + getDescriptorForType().hashCode();
+      if (hasRowCount()) {
+        hash = (37 * hash) + ROWCOUNT_FIELD_NUMBER;
+        hash = (53 * hash) + hashLong(getRowCount());
+      }
+      if (hasCellCount()) {
+        hash = (37 * hash) + CELLCOUNT_FIELD_NUMBER;
+        hash = (53 * hash) + hashLong(getCellCount());
+      }
+      hash = (29 * hash) + getUnknownFields().hashCode();
+      memoizedHashCode = hash;
+      return hash;
+    }
+
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse parseFrom(
+        com.google.protobuf.ByteString data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse parseFrom(
+        com.google.protobuf.ByteString data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse parseFrom(byte[] data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse parseFrom(
+        byte[] data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse parseFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse parseFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse parseDelimitedFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse parseDelimitedFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input, extensionRegistry);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse parseFrom(
+        com.google.protobuf.CodedInputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse parseFrom(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+
+    public static Builder newBuilder() { return Builder.create(); }
+    public Builder newBuilderForType() { return newBuilder(); }
+    public static Builder newBuilder(org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse prototype) {
+      return newBuilder().mergeFrom(prototype);
+    }
+    public Builder toBuilder() { return newBuilder(this); }
+
+    @java.lang.Override
+    protected Builder newBuilderForType(
+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+      Builder builder = new Builder(parent);
+      return builder;
+    }
+    /**
+     * Protobuf type {@code hbase.pb.ExportResponse}
+     */
+    public static final class Builder extends
+        com.google.protobuf.GeneratedMessage.Builder<Builder>
+       implements org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponseOrBuilder {
+      public static final com.google.protobuf.Descriptors.Descriptor
+          getDescriptor() {
+        return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.internal_static_hbase_pb_ExportResponse_descriptor;
+      }
+
+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+          internalGetFieldAccessorTable() {
+        return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.internal_static_hbase_pb_ExportResponse_fieldAccessorTable
+            .ensureFieldAccessorsInitialized(
+                org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.class, org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.Builder.class);
+      }
+
+      // Construct using org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.newBuilder()
+      private Builder() {
+        maybeForceBuilderInitialization();
+      }
+
+      private Builder(
+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+        super(parent);
+        maybeForceBuilderInitialization();
+      }
+      private void maybeForceBuilderInitialization() {
+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
+        }
+      }
+      private static Builder create() {
+        return new Builder();
+      }
+
+      public Builder clear() {
+        super.clear();
+        rowCount_ = 0L;
+        bitField0_ = (bitField0_ & ~0x00000001);
+        cellCount_ = 0L;
+        bitField0_ = (bitField0_ & ~0x00000002);
+        return this;
+      }
+
+      public Builder clone() {
+        return create().mergeFrom(buildPartial());
+      }
+
+      public com.google.protobuf.Descriptors.Descriptor
+          getDescriptorForType() {
+        return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.internal_static_hbase_pb_ExportResponse_descriptor;
+      }
+
+      public org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse getDefaultInstanceForType() {
+        return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.getDefaultInstance();
+      }
+
+      public org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse build() {
+        org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse result = buildPartial();
+        if (!result.isInitialized()) {
+          throw newUninitializedMessageException(result);
+        }
+        return result;
+      }
+
+      public org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse buildPartial() {
+        org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse result = new org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse(this);
+        int from_bitField0_ = bitField0_;
+        int to_bitField0_ = 0;
+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
+          to_bitField0_ |= 0x00000001;
+        }
+        result.rowCount_ = rowCount_;
+        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
+          to_bitField0_ |= 0x00000002;
+        }
+        result.cellCount_ = cellCount_;
+        result.bitField0_ = to_bitField0_;
+        onBuilt();
+        return result;
+      }
+
+      public Builder mergeFrom(com.google.protobuf.Message other) {
+        if (other instanceof org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse) {
+          return mergeFrom((org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse)other);
+        } else {
+          super.mergeFrom(other);
+          return this;
+        }
+      }
+
+      public Builder mergeFrom(org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse other) {
+        if (other == org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.getDefaultInstance()) return this;
+        if (other.hasRowCount()) {
+          setRowCount(other.getRowCount());
+        }
+        if (other.hasCellCount()) {
+          setCellCount(other.getCellCount());
+        }
+        this.mergeUnknownFields(other.getUnknownFields());
+        return this;
+      }
+
+      public final boolean isInitialized() {
+        if (!hasRowCount()) {
+          return false;
+        }
+        if (!hasCellCount()) {
+          return false;
+        }
+        return true;
+      }
+
+      public Builder mergeFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse parsedMessage = null;
+        try {
+          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+          parsedMessage = (org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse) e.getUnfinishedMessage();
+          throw e;
+        } finally {
+          if (parsedMessage != null) {
+            mergeFrom(parsedMessage);
+          }
+        }
+        return this;
+      }
+      private int bitField0_;
+
+      // required uint64 rowCount = 1;
+      private long rowCount_ ;
+      /**
+       * <code>required uint64 rowCount = 1;</code>
+       */
+      public boolean hasRowCount() {
+        return ((bitField0_ & 0x00000001) == 0x00000001);
+      }
+      /**
+       * <code>required uint64 rowCount = 1;</code>
+       */
+      public long getRowCount() {
+        return rowCount_;
+      }
+      /**
+       * <code>required uint64 rowCount = 1;</code>
+       */
+      public Builder setRowCount(long value) {
+        bitField0_ |= 0x00000001;
+        rowCount_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>required uint64 rowCount = 1;</code>
+       */
+      public Builder clearRowCount() {
+        bitField0_ = (bitField0_ & ~0x00000001);
+        rowCount_ = 0L;
+        onChanged();
+        return this;
+      }
+
+      // required uint64 cellCount = 2;
+      private long cellCount_ ;
+      /**
+       * <code>required uint64 cellCount = 2;</code>
+       */
+      public boolean hasCellCount() {
+        return ((bitField0_ & 0x00000002) == 0x00000002);
+      }
+      /**
+       * <code>required uint64 cellCount = 2;</code>
+       */
+      public long getCellCount() {
+        return cellCount_;
+      }
+      /**
+       * <code>required uint64 cellCount = 2;</code>
+       */
+      public Builder setCellCount(long value) {
+        bitField0_ |= 0x00000002;
+        cellCount_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>required uint64 cellCount = 2;</code>
+       */
+      public Builder clearCellCount() {
+        bitField0_ = (bitField0_ & ~0x00000002);
+        cellCount_ = 0L;
+        onChanged();
+        return this;
+      }
+
+      // @@protoc_insertion_point(builder_scope:hbase.pb.ExportResponse)
+    }
+
+    static {
+      defaultInstance = new ExportResponse(true);
+      defaultInstance.initFields();
+    }
+
+    // @@protoc_insertion_point(class_scope:hbase.pb.ExportResponse)
+  }
+
+  /**
+   * Protobuf service {@code hbase.pb.ExportService}
+   */
+  public static abstract class ExportService
+      implements com.google.protobuf.Service {
+    protected ExportService() {}
+
+    public interface Interface {
+      /**
+       * <code>rpc export(.hbase.pb.ExportRequest) returns (.hbase.pb.ExportResponse);</code>
+       */
+      public abstract void export(
+          com.google.protobuf.RpcController controller,
+          org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest request,
+          com.google.protobuf.RpcCallback<org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse> done);
+
+    }
+
+    public static com.google.protobuf.Service newReflectiveService(
+        final Interface impl) {
+      return new ExportService() {
+        @java.lang.Override
+        public  void export(
+            com.google.protobuf.RpcController controller,
+            org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest request,
+            com.google.protobuf.RpcCallback<org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse> done) {
+          impl.export(controller, request, done);
+        }
+
+      };
+    }
+
+    public static com.google.protobuf.BlockingService
+        newReflectiveBlockingService(final BlockingInterface impl) {
+      return new com.google.protobuf.BlockingService() {
+        public final com.google.protobuf.Descriptors.ServiceDescriptor
+            getDescriptorForType() {
+          return getDescriptor();
+        }
+
+        public final com.google.protobuf.Message callBlockingMethod(
+            com.google.protobuf.Descriptors.MethodDescriptor method,
+            com.google.protobuf.RpcController controller,
+            com.google.protobuf.Message request)
+            throws com.google.protobuf.ServiceException {
+          if (method.getService() != getDescriptor()) {
+            throw new java.lang.IllegalArgumentException(
+              "Service.callBlockingMethod() given method descriptor for " +
+              "wrong service type.");
+          }
+          switch(method.getIndex()) {
+            case 0:
+              return impl.export(controller, (org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest)request);
+            default:
+              throw new java.lang.AssertionError("Can't get here.");
+          }
+        }
+
+        public final com.google.protobuf.Message
+            getRequestPrototype(
+            com.google.protobuf.Descriptors.MethodDescriptor method) {
+          if (method.getService() != getDescriptor()) {
+            throw new java.lang.IllegalArgumentException(
+              "Service.getRequestPrototype() given method " +
+              "descriptor for wrong service type.");
+          }
+          switch(method.getIndex()) {
+            case 0:
+              return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest.getDefaultInstance();
+            default:
+              throw new java.lang.AssertionError("Can't get here.");
+          }
+        }
+
+        public final com.google.protobuf.Message
+            getResponsePrototype(
+            com.google.protobuf.Descriptors.MethodDescriptor method) {
+          if (method.getService() != getDescriptor()) {
+            throw new java.lang.IllegalArgumentException(
+              "Service.getResponsePrototype() given method " +
+              "descriptor for wrong service type.");
+          }
+          switch(method.getIndex()) {
+            case 0:
+              return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.getDefaultInstance();
+            default:
+              throw new java.lang.AssertionError("Can't get here.");
+          }
+        }
+
+      };
+    }
+
+    /**
+     * <code>rpc export(.hbase.pb.ExportRequest) returns (.hbase.pb.ExportResponse);</code>
+     */
+    public abstract void export(
+        com.google.protobuf.RpcController controller,
+        org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest request,
+        com.google.protobuf.RpcCallback<org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse> done);
+
+    public static final
+        com.google.protobuf.Descriptors.ServiceDescriptor
+        getDescriptor() {
+      return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.getDescriptor().getServices().get(0);
+    }
+    public final com.google.protobuf.Descriptors.ServiceDescriptor
+        getDescriptorForType() {
+      return getDescriptor();
+    }
+
+    public final void callMethod(
+        com.google.protobuf.Descriptors.MethodDescriptor method,
+        com.google.protobuf.RpcController controller,
+        com.google.protobuf.Message request,
+        com.google.protobuf.RpcCallback<
+          com.google.protobuf.Message> done) {
+      if (method.getService() != getDescriptor()) {
+        throw new java.lang.IllegalArgumentException(
+          "Service.callMethod() given method descriptor for wrong " +
+          "service type.");
+      }
+      switch(method.getIndex()) {
+        case 0:
+          this.export(controller, (org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest)request,
+            com.google.protobuf.RpcUtil.<org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse>specializeCallback(
+              done));
+          return;
+        default:
+          throw new java.lang.AssertionError("Can't get here.");
+      }
+    }
+
+    public final com.google.protobuf.Message
+        getRequestPrototype(
+        com.google.protobuf.Descriptors.MethodDescriptor method) {
+      if (method.getService() != getDescriptor()) {
+        throw new java.lang.IllegalArgumentException(
+          "Service.getRequestPrototype() given method " +
+          "descriptor for wrong service type.");
+      }
+      switch(method.getIndex()) {
+        case 0:
+          return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest.getDefaultInstance();
+        default:
+          throw new java.lang.AssertionError("Can't get here.");
+      }
+    }
+
+    public final com.google.protobuf.Message
+        getResponsePrototype(
+        com.google.protobuf.Descriptors.MethodDescriptor method) {
+      if (method.getService() != getDescriptor()) {
+        throw new java.lang.IllegalArgumentException(
+          "Service.getResponsePrototype() given method " +
+          "descriptor for wrong service type.");
+      }
+      switch(method.getIndex()) {
+        case 0:
+          return org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.getDefaultInstance();
+        default:
+          throw new java.lang.AssertionError("Can't get here.");
+      }
+    }
+
+    public static Stub newStub(
+        com.google.protobuf.RpcChannel channel) {
+      return new Stub(channel);
+    }
+
+    public static final class Stub extends org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportService implements Interface {
+      private Stub(com.google.protobuf.RpcChannel channel) {
+        this.channel = channel;
+      }
+
+      private final com.google.protobuf.RpcChannel channel;
+
+      public com.google.protobuf.RpcChannel getChannel() {
+        return channel;
+      }
+
+      public  void export(
+          com.google.protobuf.RpcController controller,
+          org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest request,
+          com.google.protobuf.RpcCallback<org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse> done) {
+        channel.callMethod(
+          getDescriptor().getMethods().get(0),
+          controller,
+          request,
+          org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.getDefaultInstance(),
+          com.google.protobuf.RpcUtil.generalizeCallback(
+            done,
+            org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.class,
+            org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.getDefaultInstance()));
+      }
+    }
+
+    public static BlockingInterface newBlockingStub(
+        com.google.protobuf.BlockingRpcChannel channel) {
+      return new BlockingStub(channel);
+    }
+
+    public interface BlockingInterface {
+      public org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse export(
+          com.google.protobuf.RpcController controller,
+          org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest request)
+          throws com.google.protobuf.ServiceException;
+    }
+
+    private static final class BlockingStub implements BlockingInterface {
+      private BlockingStub(com.google.protobuf.BlockingRpcChannel channel) {
+        this.channel = channel;
+      }
+
+      private final com.google.protobuf.BlockingRpcChannel channel;
+
+      public org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse export(
+          com.google.protobuf.RpcController controller,
+          org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportRequest request)
+          throws com.google.protobuf.ServiceException {
+        return (org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse) channel.callBlockingMethod(
+          getDescriptor().getMethods().get(0),
+          controller,
+          request,
+          org.apache.hadoop.hbase.protobuf.generated.ExportProtos.ExportResponse.getDefaultInstance());
+      }
+
+    }
+
+    // @@protoc_insertion_point(class_scope:hbase.pb.ExportService)
+  }
+
+  private static com.google.protobuf.Descriptors.Descriptor
+    internal_static_hbase_pb_ExportRequest_descriptor;
+  private static
+    com.google.protobuf.GeneratedMessage.FieldAccessorTable
+      internal_static_hbase_pb_ExportRequest_fieldAccessorTable;
+  private static com.google.protobuf.Descriptors.Descriptor
+    internal_static_hbase_pb_ExportResponse_descriptor;
+  private static
+    com.google.protobuf.GeneratedMessage.FieldAccessorTable
+      internal_static_hbase_pb_ExportResponse_fieldAccessorTable;
+
+  public static com.google.protobuf.Descriptors.FileDescriptor
+      getDescriptor() {
+    return descriptor;
+  }
+  private static com.google.protobuf.Descriptors.FileDescriptor
+      descriptor;
+  static {
+    java.lang.String[] descriptorData = {
+      "\n\014Export.proto\022\010hbase.pb\032\014Client.proto\"\211" +
+      "\001\n\rExportRequest\022\034\n\004scan\030\001 \002(\0132\016.hbase.p" +
+      "b.Scan\022\022\n\noutputPath\030\002 \002(\t\022\031\n\ncompressed" +
+      "\030\003 \001(\010:\005false\022\024\n\014compressType\030\004 \001(\t\022\025\n\rc" +
+      "ompressCodec\030\005 \001(\t\"5\n\016ExportResponse\022\020\n\010" +
+      "rowCount\030\001 \002(\004\022\021\n\tcellCount\030\002 \002(\0042L\n\rExp" +
+      "ortService\022;\n\006export\022\027.hbase.pb.ExportRe" +
+      "quest\032\030.hbase.pb.ExportResponseBB\n*org.a" +
+      "pache.hadoop.hbase.protobuf.generatedB\014E" +
+      "xportProtosH\001\210\001\001\240\001\001"
+    };
+    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
+      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
+        public com.google.protobuf.ExtensionRegistry assignDescriptors(
+            com.google.protobuf.Descriptors.FileDescriptor root) {
+          descriptor = root;
+          internal_static_hbase_pb_ExportRequest_descriptor =
+            getDescriptor().getMessageTypes().get(0);
+          internal_static_hbase_pb_ExportRequest_fieldAccessorTable = new
+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
+              internal_static_hbase_pb_ExportRequest_descriptor,
+              new java.lang.String[] { "Scan", "OutputPath", "Compressed", "CompressType", "CompressCodec", });
+          internal_static_hbase_pb_ExportResponse_descriptor =
+            getDescriptor().getMessageTypes().get(1);
+          internal_static_hbase_pb_ExportResponse_fieldAccessorTable = new
+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
+              internal_static_hbase_pb_ExportResponse_descriptor,
+              new java.lang.String[] { "RowCount", "CellCount", });
+          return null;
+        }
+      };
+    com.google.protobuf.Descriptors.FileDescriptor
+      .internalBuildGeneratedFileFrom(descriptorData,
+        new com.google.protobuf.Descriptors.FileDescriptor[] {
+          org.apache.hadoop.hbase.protobuf.generated.ClientProtos.getDescriptor(),
+        }, assigner);
+  }
+
+  // @@protoc_insertion_point(outer_class_scope)
+}
diff --git a/hbase-protocol/src/main/protobuf/Export.proto b/hbase-protocol/src/main/protobuf/Export.proto
new file mode 100644
index 0000000..0551851
--- /dev/null
+++ b/hbase-protocol/src/main/protobuf/Export.proto
@@ -0,0 +1,44 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package hbase.pb;
+
+option java_package = "org.apache.hadoop.hbase.protobuf.generated";
+option java_outer_classname = "ExportProtos";
+option java_generate_equals_and_hash = true;
+option optimize_for = SPEED;
+option java_generic_services = true;
+
+import "Client.proto";
+
+service ExportService {
+  rpc export (ExportRequest) returns (ExportResponse);
+}
+
+message ExportRequest {
+  required Scan scan = 1;
+  required string outputPath = 2;
+  optional bool compressed = 3 [default = false];
+  optional string compressType = 4;
+  optional string compressCodec = 5;
+}
+message ExportResponse {
+  required uint64 rowCount = 1;
+  required uint64 cellCount = 2;
+}
+
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/ExportEndpoint.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/ExportEndpoint.java
new file mode 100644
index 0000000..b39f89b
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/ExportEndpoint.java
@@ -0,0 +1,280 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.hadoop.hbase.coprocessor;
+
+import com.google.protobuf.RpcCallback;
+import com.google.protobuf.RpcController;
+import com.google.protobuf.Service;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.fs.permission.FsAction;
+import org.apache.hadoop.fs.permission.FsPermission;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.Coprocessor;
+import org.apache.hadoop.hbase.CoprocessorEnvironment;
+import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.classification.InterfaceAudience;
+import org.apache.hadoop.hbase.classification.InterfaceStability;
+import org.apache.hadoop.hbase.client.Connection;
+import org.apache.hadoop.hbase.client.ConnectionFactory;
+import org.apache.hadoop.hbase.client.Result;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.client.Table;
+import org.apache.hadoop.hbase.client.coprocessor.Batch;
+import org.apache.hadoop.hbase.io.ImmutableBytesWritable;
+import org.apache.hadoop.hbase.ipc.BlockingRpcCallback;
+import org.apache.hadoop.hbase.ipc.ServerRpcController;
+import org.apache.hadoop.hbase.mapreduce.ResultSerialization;
+import org.apache.hadoop.hbase.protobuf.ProtobufUtil;
+import org.apache.hadoop.hbase.protobuf.ResponseConverter;
+import org.apache.hadoop.hbase.protobuf.generated.ExportProtos;
+import org.apache.hadoop.hbase.regionserver.Region;
+import org.apache.hadoop.hbase.regionserver.RegionScanner;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.io.SequenceFile;
+import org.apache.hadoop.io.compress.CompressionCodec;
+import org.apache.hadoop.io.compress.DefaultCodec;
+import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
+import org.apache.hadoop.util.GenericOptionsParser;
+import org.apache.hadoop.util.ReflectionUtils;
+import org.apache.hadoop.hbase.mapreduce.Export;
+import org.apache.hadoop.hbase.mapreduce.Import;
+
+/**
+* Export an HBase table.
+* Writes content to sequence files up in HDFS.  Use {@link Import} to read it
+* back in again.
+* It is implemented by the endpoint technique.
+* @see Export
+*/
+@InterfaceAudience.Public
+@InterfaceStability.Evolving
+public class ExportEndpoint extends ExportProtos.ExportService
+  implements Coprocessor, CoprocessorService {
+  private static final Log LOG = LogFactory.getLog(ExportEndpoint.class);
+  private RegionCoprocessorEnvironment env = null;
+  @Override
+  public void start(CoprocessorEnvironment environment) throws IOException {
+    if (environment instanceof RegionCoprocessorEnvironment) {
+      this.env = (RegionCoprocessorEnvironment) environment;
+    } else {
+      throw new CoprocessorException("Must be loaded on a table region!");
+    }
+  }
+  @Override
+  public void stop(CoprocessorEnvironment env) throws IOException {
+  }
+
+  @Override
+  public Service getService() {
+    return this;
+  }
+  private static boolean getCompression(final ExportProtos.ExportRequest request) {
+    if (request.hasCompressed()) {
+      return request.getCompressed();
+    } else {
+      return false;
+    }
+  }
+  private static SequenceFile.CompressionType getCompressionType(final ExportProtos.ExportRequest request) {
+    if (!request.hasCompressType()) {
+      return null;
+    }
+    return SequenceFile.CompressionType.valueOf(request.getCompressType());
+  }
+  private static CompressionCodec getCompressionCodec(final Configuration conf, final ExportProtos.ExportRequest request) {
+    if (!request.hasCompressCodec()) {
+      return null;
+    }
+    try {
+      Class<? extends CompressionCodec> codecClass = conf.getClassByName(request.getCompressCodec()).asSubclass(CompressionCodec.class);
+      return ReflectionUtils.newInstance(codecClass, conf);
+    } catch (ClassNotFoundException e) {
+      throw new IllegalArgumentException("Compression codec "
+              + request.getCompressCodec()+ " was not found.", e);
+    }
+  }
+  private static SequenceFile.Writer.Option getOutputPath(final Configuration conf,
+          final HRegionInfo info, final ExportProtos.ExportRequest request) throws IOException {
+    Path file = new Path(request.getOutputPath(), "export-" + info.getEncodedName());
+    FileSystem fs = FileSystem.get(conf);
+    if (fs.exists(file)) {
+      throw new IOException(file + " exists");
+    }
+    return SequenceFile.Writer.file(file);
+  }
+  private static List<SequenceFile.Writer.Option> getWriterOptions(final Configuration conf,
+          final HRegionInfo info, final ExportProtos.ExportRequest request) throws IOException {
+    List<SequenceFile.Writer.Option> rval = new LinkedList<>();
+    rval.add(SequenceFile.Writer.keyClass(ImmutableBytesWritable.class));
+    rval.add(SequenceFile.Writer.valueClass(Result.class));
+    rval.add(getOutputPath(conf, info, request));
+    boolean compressed = getCompression(request);
+    if (compressed) {
+      SequenceFile.CompressionType type = getCompressionType(request);
+      if (type != null) {
+        CompressionCodec codec = getCompressionCodec(conf, request);
+        rval.add(SequenceFile.Writer.compression(type, codec));
+      }
+    }
+    return rval;
+  }
+  private Scan validateKey(final HRegionInfo region, final Scan scan) {
+    byte[] regionStartKey = region.getStartKey();
+    byte[] originStartKey = scan.getStartRow();
+    if (originStartKey == null
+      || Bytes.compareTo(originStartKey, regionStartKey) < 0) {
+      scan.setStartRow(regionStartKey);
+    }
+    byte[] regionEndKey = region.getEndKey();
+    byte[] originEndKey = scan.getStopRow();
+    if (originEndKey == null
+      || Bytes.compareTo(originEndKey, regionEndKey) > 0) {
+      scan.setStartRow(regionEndKey);
+    }
+    return scan;
+  }
+  @Override
+  public void export(RpcController controller, ExportProtos.ExportRequest request,
+    RpcCallback<ExportProtos.ExportResponse> done) {
+    Region region = env.getRegion();
+    Configuration conf = HBaseConfiguration.create(env.getConfiguration());
+    conf.setStrings("io.serializations", conf.get("io.serializations"), ResultSerialization.class.getName());
+    try {
+      Scan scan = validateKey(region.getRegionInfo(), ProtobufUtil.toScan(request.getScan()));
+      ExportProtos.ExportResponse response = processData(conf, region, scan,
+              getWriterOptions(conf, region.getRegionInfo(), request));
+      done.run(response);
+    } catch (IOException e) {
+      ResponseConverter.setControllerException(controller, e);
+      LOG.error(e);
+    }
+  }
+  private static ExportProtos.ExportResponse processData(final Configuration conf,
+      final Region region, final Scan scan, final List<SequenceFile.Writer.Option> opts) throws IOException {
+    region.startRegionOperation();
+    try (SequenceFile.Writer out = SequenceFile.createWriter(conf,
+            opts.toArray(new SequenceFile.Writer.Option[opts.size()]));
+      RegionScanner scanner = region.getScanner(scan)) {
+      ImmutableBytesWritable key = new ImmutableBytesWritable();
+      long rowCount = 0;
+      long cellCount = 0;
+      List<Cell> buf = new ArrayList<>();
+      boolean hasMore;
+      do {
+        hasMore = scanner.nextRaw(buf);
+        if (!buf.isEmpty()) {
+          Cell firstCell = buf.get(0);
+          for (Cell cell : buf) {
+            if (Bytes.compareTo(
+              firstCell.getRowArray(), firstCell.getRowOffset(), firstCell.getRowLength(),
+              cell.getRowArray(), cell.getRowOffset(), cell.getRowLength()) != 0) {
+              throw new IOException("Why the RegionScanner#nextRaw returns the data of different rows??");
+            }
+          }
+          key.set(firstCell.getRowArray(), firstCell.getRowOffset(), firstCell.getRowLength());
+          out.append(key, Result.create(buf));
+          ++rowCount;
+          cellCount += buf.size();
+          buf.clear();
+        }
+      } while (hasMore);
+      return ExportProtos.ExportResponse.newBuilder()
+        .setRowCount(rowCount)
+        .setCellCount(cellCount)
+        .build();
+    } finally {
+      region.closeRegionOperation();
+    }
+  }
+  public static void main(String[] args) throws IOException, Throwable {
+    run(HBaseConfiguration.create(), args);
+  }
+  public static Map<byte[], ExportProtos.ExportResponse> run(final Configuration conf,
+          final String[] args) throws IOException, Throwable {
+    String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();
+    if (!Export.checkArguments(otherArgs)) {
+      Export.usage("Wrong number of arguments: " + otherArgs.length);
+      System.exit(-1);
+    }
+    TableName tableName = TableName.valueOf(otherArgs[0]);
+    FileSystem fs = FileSystem.get(conf);
+    String dir = otherArgs[1];
+    checkDir(fs, dir);
+    Scan scan = Export.getConfiguredScanForJob(conf, otherArgs);
+    final ExportProtos.ExportRequest request = getConfiguredRequestForJob(conf, otherArgs, scan);
+    try (Connection con = ConnectionFactory.createConnection(conf);
+            Table table = con.getTable(tableName)) {
+      return table.coprocessorService(ExportProtos.ExportService.class,
+            scan.getStartRow(),
+            scan.getStopRow(), new Batch.Call<ExportProtos.ExportService, ExportProtos.ExportResponse>() {
+            @Override
+            public ExportProtos.ExportResponse call(ExportProtos.ExportService service) throws IOException {
+              ServerRpcController controller = new ServerRpcController();
+              BlockingRpcCallback<ExportProtos.ExportResponse> rpcCallback = new BlockingRpcCallback<>();
+              service.export(controller, request, rpcCallback);
+              if (controller.failedOnException()) {
+                throw controller.getFailedOn();
+              }
+              return rpcCallback.get();
+            }
+        });
+    } catch (Throwable e) {
+      fs.delete(new Path(dir), true);
+      throw e;
+    }
+  }
+  private static void checkDir(final FileSystem fs, final String path) throws IOException {
+    Path dir = fs.makeQualified(new Path(path));
+    if (fs.exists(dir)) {
+      throw new RuntimeException("The " + path + " exists");
+    }
+    fs.mkdirs(dir);
+    fs.setPermission(dir, new FsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL));
+  }
+  private static ExportProtos.ExportRequest getConfiguredRequestForJob(Configuration conf,
+          String[] args, final Scan scan) throws IOException {
+    String dir = args[1];
+    boolean compressed = conf.getBoolean(FileOutputFormat.COMPRESS, true);
+    String compressionType = conf.get(FileOutputFormat.COMPRESS_TYPE,
+        SequenceFile.CompressionType.RECORD.toString());
+    String compressionCodec = conf.get(FileOutputFormat.COMPRESS_CODEC,
+            DefaultCodec.class.getName());
+    LOG.info("compressed=" + compressed
+        + ", compression type=" + compressionType
+        + ", compression codec=" + compressionCodec);
+    return ExportProtos.ExportRequest.newBuilder()
+            .setScan(ProtobufUtil.toScan(scan))
+            .setOutputPath(dir)
+            .setCompressed(compressed)
+            .setCompressCodec(compressionCodec)
+            .setCompressType(compressionType)
+            .build();
+  }
+}
diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/Export.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/Export.java
index 56d229a..4ccbe30 100644
--- a/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/Export.java
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/Export.java
@@ -86,7 +86,7 @@
     return job;
   }
 
-  private static Scan getConfiguredScanForJob(Configuration conf, String[] args) throws IOException {
+  public static Scan getConfiguredScanForJob(Configuration conf, String[] args) throws IOException {
     Scan s = new Scan();
     // Optional arguments.
     // Set Scan Versions
@@ -150,7 +150,7 @@
   /*
    * @param errorMsg Error message.  Can be null.
    */
-  private static void usage(final String errorMsg) {
+  public static void usage(final String errorMsg) {
     if (errorMsg != null && errorMsg.length() > 0) {
       System.err.println("ERROR: " + errorMsg);
     }
@@ -176,11 +176,12 @@
     System.err.println("For tables with very wide rows consider setting the batch size as below:\n"
         + "   -D" + EXPORT_BATCHING + "=10");
   }
-
-
+  public static boolean checkArguments(final String[] args) {
+    return args.length >= 2;
+  }
   @Override
   public int run(String[] args) throws Exception {
-    if (args.length < 2) {
+    if (!checkArguments(args)) {
       usage("Wrong number of arguments: " + args.length);
       return -1;
     }
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java
index 50146fd..7c74913 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/mapreduce/TestImportExport.java
@@ -17,13 +17,7 @@
  */
 package org.apache.hadoop.hbase.mapreduce;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import java.io.ByteArrayOutputStream;
@@ -34,11 +28,10 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.NavigableMap;
-
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileStatus;
 import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hbase.HConstants;
@@ -59,6 +52,8 @@
 import org.apache.hadoop.hbase.client.ResultScanner;
 import org.apache.hadoop.hbase.client.Scan;
 import org.apache.hadoop.hbase.client.Table;
+import org.apache.hadoop.hbase.coprocessor.CoprocessorHost;
+import org.apache.hadoop.hbase.coprocessor.ExportEndpoint;
 import org.apache.hadoop.hbase.filter.Filter;
 import org.apache.hadoop.hbase.filter.FilterBase;
 import org.apache.hadoop.hbase.filter.PrefixFilter;
@@ -72,7 +67,10 @@
 import org.apache.hadoop.hbase.testclassification.VerySlowMapReduceTests;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.LauncherSecurityManager;
+import org.apache.hadoop.io.SequenceFile;
+import org.apache.hadoop.io.compress.BZip2Codec;
 import org.apache.hadoop.mapreduce.Mapper.Context;
+import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
 import org.apache.hadoop.util.ToolRunner;
 import org.junit.After;
 import org.junit.AfterClass;
@@ -85,6 +83,12 @@
 import org.junit.rules.TestName;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
 
 /**
  * Tests the table import and table export MR job functionality
@@ -106,14 +110,40 @@
   private static final String EXPORT_BATCH_SIZE = "100";
 
   private static long now = System.currentTimeMillis();
-
+  private static final Exporter EXPORTER_MR = new Exporter() {
+      @Override
+      public boolean runExport(String[] args) throws Throwable {
+        // need to make a copy of the configuration because to make sure different temp dirs are used.
+        int status = ToolRunner.run(new Configuration(UTIL.getConfiguration()), new Export(), args);
+        return status == 0;
+      }
+      @Override
+      public String toString() {
+          return "MR-based export";
+      }
+  };
+  private static final Exporter EXPORTER_ENDPOINT = new Exporter() {
+    @Override
+      public boolean runExport(String[] args) throws Throwable {
+        ExportEndpoint.run(new Configuration(UTIL.getConfiguration()), args);
+        return true;
+      }
+      @Override
+      public String toString() {
+        return "Endpoint-based export";
+      }
+    };
+  private static final List<Exporter> EXPORTERS = Arrays.asList(EXPORTER_MR, EXPORTER_ENDPOINT);
   @BeforeClass
   public static void beforeClass() throws Exception {
     // Up the handlers; this test needs more than usual.
+    UTIL.getConfiguration().setStrings(CoprocessorHost.REGION_COPROCESSOR_CONF_KEY,
+            ExportEndpoint.class.getName());
     UTIL.getConfiguration().setInt(HConstants.REGION_SERVER_HIGH_PRIORITY_HANDLER_COUNT, 10);
     UTIL.startMiniCluster();
+    FileSystem fs = FileSystem.get(UTIL.getConfiguration());
     FQ_OUTPUT_DIR =
-      new Path(OUTPUT_DIR).makeQualified(FileSystem.get(UTIL.getConfiguration())).toString();
+      new Path(OUTPUT_DIR).makeQualified(fs.getUri(), fs.getWorkingDirectory()).toString();
   }
 
   @AfterClass
@@ -131,47 +161,108 @@
 
   @Before
   @After
-  public void cleanup() throws Exception {
-    FileSystem fs = FileSystem.get(UTIL.getConfiguration());
-    fs.delete(new Path(OUTPUT_DIR), true);
+  public void cleanup() throws IOException {
+    deleteOutput();
   }
 
-  /**
-   * Runs an export job with the specified command line args
-   * @param args
-   * @return true if job completed successfully
-   * @throws IOException
-   * @throws InterruptedException
-   * @throws ClassNotFoundException
-   */
-  boolean runExport(String[] args) throws Exception {
-    // need to make a copy of the configuration because to make sure different temp dirs are used.
-    int status = ToolRunner.run(new Configuration(UTIL.getConfiguration()), new Export(), args);
-    return status == 0;
+  private static void deleteOutput() throws IOException {
+    FileSystem fs = FileSystem.get(UTIL.getConfiguration());
+    fs.delete(new Path(OUTPUT_DIR), true);
   }
 
   /**
    * Runs an import job with the specified command line args
    * @param args
    * @return true if job completed successfully
-   * @throws IOException
-   * @throws InterruptedException
-   * @throws ClassNotFoundException
+   * @throws Exception
    */
   boolean runImport(String[] args) throws Exception {
     // need to make a copy of the configuration because to make sure different temp dirs are used.
     int status = ToolRunner.run(new Configuration(UTIL.getConfiguration()), new Import(), args);
     return status == 0;
   }
-
   /**
-   * Test simple replication case with column mapping
-   * @throws Exception
+   * Test the writer's options.
+   * @throws IOException
    */
   @Test
-  public void testSimpleCase() throws Exception {
-    String EXPORT_TABLE = "exportSimpleCase";
-    try (Table t = UTIL.createTable(TableName.valueOf(EXPORT_TABLE), FAMILYA, 3);) {
+  public void testOutputFileFormat() throws IOException, Throwable {
+    String exportTable = "testOutputFileFormat";
+    for (Exporter exporter : EXPORTERS) {
+      testOutputFileFormat(exportTable, exporter);
+      UTIL.deleteTable(TableName.valueOf(exportTable));
+      deleteOutput();
+    }
+  }
+  /**
+   * Test the writer's options.
+   * @throws IOException
+   */
+  public void testOutputFileFormat(final String exportTable, final Exporter exporter) throws IOException, Throwable {
+    String codec = BZip2Codec.class.getName();
+    String type = SequenceFile.CompressionType.RECORD.name();
+    try (Table t = UTIL.createTable(TableName.valueOf(exportTable), FAMILYA, 3);) {
+      Put p = new Put(ROW1);
+      p.addColumn(FAMILYA, QUAL, now, QUAL);
+      t.put(p);
+      p = new Put(ROW2);
+      p.addColumn(FAMILYA, QUAL, now, QUAL);
+      t.put(p);
+      p = new Put(ROW3);
+      p.addColumn(FAMILYA, QUAL, now, QUAL);
+      t.put(p);
+    }
+    //use compress
+    String[] args = new String[] {
+      // Only export row1 & row2.
+      "-D" + FileOutputFormat.COMPRESS + "=true",
+      "-D" + FileOutputFormat.COMPRESS_CODEC + "=" + codec,
+      "-D" + FileOutputFormat.COMPRESS_TYPE + "=" + type,
+      exportTable,
+      FQ_OUTPUT_DIR
+    };
+    assertTrue(exporter.toString(), exporter.runExport(args));
+    FileSystem fs = FileSystem.get(UTIL.getConfiguration());
+    List<FileStatus> files = Arrays.asList(fs.listStatus(new Path(FQ_OUTPUT_DIR)));
+    assertEquals(exporter.toString(), false, files.isEmpty());
+    Configuration copy = new Configuration(UTIL.getConfiguration());
+    //need to make a copy of the configuration because to make sure the Exporter has set the "io.serializations"
+    copy.setStrings("io.serializations", copy.get("io.serializations"),
+            ResultSerialization.class.getName());
+    for (FileStatus file : files) {
+      Path path = file.getPath();
+      //skips the MR meta output
+      if (path.getName().equals("_SUCCESS")) {
+        continue;
+      }
+      try (SequenceFile.Reader reader = new SequenceFile.Reader(
+              copy, SequenceFile.Reader.file(file.getPath()))) {
+        assertEquals(exporter.toString(), reader.getCompressionCodec().getClass().getName(), codec);
+        assertEquals(exporter.toString(), reader.getCompressionType().name(), type);
+      }
+    }
+  }
+  /**
+   * Test simple replication case with column mapping
+   * @throws IOException
+   */
+  @Test
+  public void testSimpleCase() throws IOException, Throwable {
+    String exportTable = "exportSimpleCase";
+    String importTable = "importTableSimpleCase";
+    for (Exporter exporter : EXPORTERS) {
+      testSimpleCase(exportTable, importTable, exporter);
+      UTIL.deleteTable(TableName.valueOf(exportTable));
+      UTIL.deleteTable(TableName.valueOf(importTable));
+      deleteOutput();
+    }
+  }
+  /**
+   * Test simple replication case with column mapping.
+   */
+  public void testSimpleCase(final String exportTable, final String importTable,
+          final Exporter exporter) throws IOException, Throwable {
+    try (Table t = UTIL.createTable(TableName.valueOf(exportTable), FAMILYA, 3);) {
       Put p = new Put(ROW1);
       p.addColumn(FAMILYA, QUAL, now, QUAL);
       p.addColumn(FAMILYA, QUAL, now + 1, QUAL);
@@ -189,53 +280,53 @@
       t.put(p);
     }
 
-      String[] args = new String[] {
-          // Only export row1 & row2.
-          "-D" + TableInputFormat.SCAN_ROW_START + "=\\x32row1",
-          "-D" + TableInputFormat.SCAN_ROW_STOP + "=\\x32row3",
-          EXPORT_TABLE,
-          FQ_OUTPUT_DIR,
-          "1000", // max number of key versions per key to export
+    String[] args = new String[] {
+      // Only export row1 & row2.
+      "-D" + TableInputFormat.SCAN_ROW_START + "=\\x32row1",
+      "-D" + TableInputFormat.SCAN_ROW_STOP + "=\\x32row3",
+      exportTable,
+      FQ_OUTPUT_DIR,
+      "1000", // max number of key versions per key to export
+    };
+    assertTrue(exporter.toString(), exporter.runExport(args));
+
+    try (Table t = UTIL.createTable(TableName.valueOf(importTable), FAMILYB, 3);) {
+      args = new String[] {
+          "-D" + Import.CF_RENAME_PROP + "="+FAMILYA_STRING+":"+FAMILYB_STRING,
+          importTable,
+          FQ_OUTPUT_DIR
       };
-      assertTrue(runExport(args));
+      assertTrue(exporter.toString(), runImport(args));
 
-      String IMPORT_TABLE = "importTableSimpleCase";
-      try (Table t = UTIL.createTable(TableName.valueOf(IMPORT_TABLE), FAMILYB, 3);) {
-        args = new String[] {
-            "-D" + Import.CF_RENAME_PROP + "="+FAMILYA_STRING+":"+FAMILYB_STRING,
-            IMPORT_TABLE,
-            FQ_OUTPUT_DIR
-        };
-        assertTrue(runImport(args));
-
-        Get g = new Get(ROW1);
-        g.setMaxVersions();
-        Result r = t.get(g);
-        assertEquals(3, r.size());
-        g = new Get(ROW2);
-        g.setMaxVersions();
-        r = t.get(g);
-        assertEquals(3, r.size());
-        g = new Get(ROW3);
-        r = t.get(g);
-        assertEquals(0, r.size());
-      }
+      Get g = new Get(ROW1);
+      g.setMaxVersions();
+      Result r = t.get(g);
+      assertEquals(exporter.toString(), 3, r.size());
+      g = new Get(ROW2);
+      g.setMaxVersions();
+      r = t.get(g);
+      assertEquals(exporter.toString(), 3, r.size());
+      g = new Get(ROW3);
+      r = t.get(g);
+      assertEquals(exporter.toString(), 0, r.size());
+    }
   }
-
   /**
    * Test export hbase:meta table
    *
-   * @throws Exception
+   * @throws IOException
    */
   @Test
-  public void testMetaExport() throws Exception {
-    String EXPORT_TABLE = TableName.META_TABLE_NAME.getNameAsString();
-    String[] args = new String[] { EXPORT_TABLE, FQ_OUTPUT_DIR, "1", "0", "0" };
-    assertTrue(runExport(args));
+  public void testMetaExport() throws IOException, Throwable {
+    String exportTable = TableName.META_TABLE_NAME.getNameAsString();
+    String[] args = new String[] { exportTable, FQ_OUTPUT_DIR, "1", "0", "0" };
+    for (Exporter exporter : EXPORTERS) {
+      assertTrue(exporter.toString(), exporter.runExport(args));
+      deleteOutput();
+    }
   }
-
   /**
-   * Test import data from 0.94 exported file
+   * Test import data from 0.94 exported file.
    * @throws Exception
    */
   @Test
@@ -252,11 +343,11 @@
     Path importPath = new Path(f.toURI());
     FileSystem fs = FileSystem.get(UTIL.getConfiguration());
     fs.copyFromLocalFile(importPath, new Path(FQ_OUTPUT_DIR + Path.SEPARATOR + name));
-    String IMPORT_TABLE = name;
-    try (Table t = UTIL.createTable(TableName.valueOf(IMPORT_TABLE), Bytes.toBytes("f1"), 3);) {
+    String importTable = name;
+    try (Table t = UTIL.createTable(TableName.valueOf(importTable), Bytes.toBytes("f1"), 3);) {
       String[] args = new String[] {
           "-Dhbase.import.version=0.94" ,
-          IMPORT_TABLE, FQ_OUTPUT_DIR
+          importTable, FQ_OUTPUT_DIR
       };
       assertTrue(runImport(args));
       /* exportedTableIn94Format contains 5 rows
@@ -270,18 +361,28 @@
      assertEquals(5, UTIL.countRows(t));
     }
   }
-
   /**
    * Test export scanner batching
+     * @throws java.lang.IOException
    */
    @Test
-   public void testExportScannerBatching() throws Exception {
-    String BATCH_TABLE = "exportWithBatch";
-    HTableDescriptor desc = new HTableDescriptor(TableName.valueOf(BATCH_TABLE));
+   public void testExportScannerBatching() throws IOException, Throwable {
+    String exportTable = "exportWithBatch";
+      for (Exporter exporter : EXPORTERS) {
+        testExportScannerBatching(exportTable, exporter);
+        UTIL.deleteTable(TableName.valueOf(exportTable));
+        deleteOutput();
+      }
+    }
+  /**
+   * Test export scanner batching.
+   */
+   public void testExportScannerBatching(final String exportTable, final Exporter exporter) throws IOException, Throwable {
+    HTableDescriptor desc = new HTableDescriptor(TableName.valueOf(exportTable));
     desc.addFamily(new HColumnDescriptor(FAMILYA)
         .setMaxVersions(1)
     );
-    UTIL.getHBaseAdmin().createTable(desc);
+    UTIL.getAdmin().createTable(desc);
     try (Table t = UTIL.getConnection().getTable(desc.getTableName());) {
 
       Put p = new Put(ROW1);
@@ -294,25 +395,34 @@
 
       String[] args = new String[] {
           "-D" + Export.EXPORT_BATCHING + "=" + EXPORT_BATCH_SIZE,  // added scanner batching arg.
-          BATCH_TABLE,
+          exportTable,
           FQ_OUTPUT_DIR
       };
-      assertTrue(runExport(args));
+      assertTrue(exporter.toString(), exporter.runExport(args));
 
       FileSystem fs = FileSystem.get(UTIL.getConfiguration());
       fs.delete(new Path(FQ_OUTPUT_DIR), true);
     }
   }
-
   @Test
-  public void testWithDeletes() throws Exception {
-    String EXPORT_TABLE = "exportWithDeletes";
-    HTableDescriptor desc = new HTableDescriptor(TableName.valueOf(EXPORT_TABLE));
+  public void testWithDeletes() throws IOException, Throwable {
+      String exportTable = "exportWithDeletes";
+      String importTable = "importWithDeletes";
+    for (Exporter exporter : EXPORTERS) {
+      testWithDeletes(exportTable, importTable, exporter);
+      UTIL.deleteTable(TableName.valueOf(exportTable));
+      UTIL.deleteTable(TableName.valueOf(importTable));
+      deleteOutput();
+    }
+  }
+  public void testWithDeletes(final String exportTable, final String importTable,
+          final Exporter exporter) throws IOException, Throwable {
+    HTableDescriptor desc = new HTableDescriptor(TableName.valueOf(exportTable));
     desc.addFamily(new HColumnDescriptor(FAMILYA)
         .setMaxVersions(5)
         .setKeepDeletedCells(KeepDeletedCells.TRUE)
     );
-    UTIL.getHBaseAdmin().createTable(desc);
+    UTIL.getAdmin().createTable(desc);
     try (Table t = UTIL.getConnection().getTable(desc.getTableName());) {
 
       Put p = new Put(ROW1);
@@ -332,25 +442,23 @@
 
     String[] args = new String[] {
         "-D" + Export.RAW_SCAN + "=true",
-        EXPORT_TABLE,
+        exportTable,
         FQ_OUTPUT_DIR,
         "1000", // max number of key versions per key to export
     };
-    assertTrue(runExport(args));
-
-    String IMPORT_TABLE = "importWithDeletes";
-    desc = new HTableDescriptor(TableName.valueOf(IMPORT_TABLE));
+    assertTrue(exporter.toString(), exporter.runExport(args));
+    desc = new HTableDescriptor(TableName.valueOf(importTable));
     desc.addFamily(new HColumnDescriptor(FAMILYA)
         .setMaxVersions(5)
         .setKeepDeletedCells(KeepDeletedCells.TRUE)
     );
-    UTIL.getHBaseAdmin().createTable(desc);
+    UTIL.getAdmin().createTable(desc);
     try (Table t = UTIL.getConnection().getTable(desc.getTableName());) {
       args = new String[] {
-          IMPORT_TABLE,
-          FQ_OUTPUT_DIR
+        importTable,
+        FQ_OUTPUT_DIR
       };
-      assertTrue(runImport(args));
+      assertTrue(exporter.toString(), runImport(args));
 
       Scan s = new Scan();
       s.setMaxVersions();
@@ -358,29 +466,36 @@
       ResultScanner scanner = t.getScanner(s);
       Result r = scanner.next();
       Cell[] res = r.rawCells();
-      assertTrue(CellUtil.isDeleteFamily(res[0]));
-      assertEquals(now+4, res[1].getTimestamp());
-      assertEquals(now+3, res[2].getTimestamp());
-      assertTrue(CellUtil.isDelete(res[3]));
-      assertEquals(now+2, res[4].getTimestamp());
-      assertEquals(now+1, res[5].getTimestamp());
-      assertEquals(now, res[6].getTimestamp());
+      assertTrue(exporter.toString(), CellUtil.isDeleteFamily(res[0]));
+      assertEquals(exporter.toString(), now+4, res[1].getTimestamp());
+      assertEquals(exporter.toString(), now+3, res[2].getTimestamp());
+      assertTrue(exporter.toString(), CellUtil.isDelete(res[3]));
+      assertEquals(exporter.toString(), now+2, res[4].getTimestamp());
+      assertEquals(exporter.toString(), now+1, res[5].getTimestamp());
+      assertEquals(exporter.toString(), now, res[6].getTimestamp());
     }
   }
-
-
   @Test
-  public void testWithMultipleDeleteFamilyMarkersOfSameRowSameFamily() throws Exception {
-    TableName EXPORT_TABLE =
-        TableName.valueOf("exportWithMultipleDeleteFamilyMarkersOfSameRowSameFamily");
-    HTableDescriptor desc = new HTableDescriptor(EXPORT_TABLE);
+  public void testWithMultipleDeleteFamilyMarkersOfSameRowSameFamily() throws IOException, Throwable {
+      String exportTable = "exportWithMultipleDeleteFamilyMarkersOfSameRowSameFamily";
+      String importTable = "importWithMultipleDeleteFamilyMarkersOfSameRowSameFamily";
+    for (Exporter exporter : EXPORTERS) {
+      testWithMultipleDeleteFamilyMarkersOfSameRowSameFamily(exportTable, importTable, exporter);
+      UTIL.deleteTable(TableName.valueOf(exportTable));
+      UTIL.deleteTable(TableName.valueOf(importTable));
+      deleteOutput();
+    }
+  }
+  public void testWithMultipleDeleteFamilyMarkersOfSameRowSameFamily(final String exportTable, final String importTable,
+          final Exporter exporter) throws IOException, Throwable {
+    HTableDescriptor desc = new HTableDescriptor(TableName.valueOf(exportTable));
     desc.addFamily(new HColumnDescriptor(FAMILYA)
         .setMaxVersions(5)
         .setKeepDeletedCells(KeepDeletedCells.TRUE)
     );
-    UTIL.getHBaseAdmin().createTable(desc);
+    UTIL.getAdmin().createTable(desc);
 
-    Table exportT = UTIL.getConnection().getTable(EXPORT_TABLE);
+    Table exportT = UTIL.getConnection().getTable(desc.getTableName());
 
     //Add first version of QUAL
     Put p = new Put(ROW1);
@@ -402,26 +517,24 @@
 
 
     String[] args = new String[] {
-        "-D" + Export.RAW_SCAN + "=true", EXPORT_TABLE.getNameAsString(),
+        "-D" + Export.RAW_SCAN + "=true", exportTable,
         FQ_OUTPUT_DIR,
         "1000", // max number of key versions per key to export
     };
-    assertTrue(runExport(args));
-
-    String IMPORT_TABLE = "importWithMultipleDeleteFamilyMarkersOfSameRowSameFamily";
-    desc = new HTableDescriptor(TableName.valueOf(IMPORT_TABLE));
+    assertTrue(exporter.toString(), exporter.runExport(args));
+    desc = new HTableDescriptor(TableName.valueOf(importTable));
     desc.addFamily(new HColumnDescriptor(FAMILYA)
         .setMaxVersions(5)
         .setKeepDeletedCells(KeepDeletedCells.TRUE)
     );
-    UTIL.getHBaseAdmin().createTable(desc);
+    UTIL.getAdmin().createTable(desc);
 
-    Table importT = UTIL.getConnection().getTable(TableName.valueOf(IMPORT_TABLE));
+    Table importT = UTIL.getConnection().getTable(TableName.valueOf(importTable));
     args = new String[] {
-        IMPORT_TABLE,
+        importTable,
         FQ_OUTPUT_DIR
     };
-    assertTrue(runImport(args));
+    assertTrue(exporter.toString(), runImport(args));
 
     Scan s = new Scan();
     s.setMaxVersions();
@@ -434,26 +547,39 @@
     Result  exportedTResult =  exportedTScanner.next();
     try {
       Result.compareResults(exportedTResult, importedTResult);
-    } catch (Exception e) {
+    } catch (IOException e) {
       fail("Original and imported tables data comparision failed with error:"+e.getMessage());
     } finally {
       exportT.close();
       importT.close();
     }
   }
-
   /**
    * Create a simple table, run an Export Job on it, Import with filtering on,  verify counts,
    * attempt with invalid values.
    */
   @Test
-  public void testWithFilter() throws Exception {
+  public void testWithFilter() throws IOException, Throwable {
+      String exportTable = "exportSimpleCase_ImportWithFilter";
+      String importTable = "importWithFilter";
+    for (Exporter exporter : EXPORTERS) {
+      testWithFilter(exportTable, importTable, exporter);
+      UTIL.deleteTable(TableName.valueOf(exportTable));
+      UTIL.deleteTable(TableName.valueOf(importTable));
+      deleteOutput();
+    }
+  }
+  /**
+   * Create a simple table, run an Export Job on it, Import with filtering on,  verify counts,
+   * attempt with invalid values.
+   */
+  public void testWithFilter(final String exportTable, final String importTable,
+          final Exporter exporter) throws IOException, Throwable {
     // Create simple table to export
-    String EXPORT_TABLE = "exportSimpleCase_ImportWithFilter";
-    HTableDescriptor desc = new HTableDescriptor(TableName.valueOf(EXPORT_TABLE));
+    HTableDescriptor desc = new HTableDescriptor(TableName.valueOf(exportTable));
     desc.addFamily(new HColumnDescriptor(FAMILYA).setMaxVersions(5));
-    UTIL.getHBaseAdmin().createTable(desc);
-    Table exportTable = UTIL.getConnection().getTable(desc.getTableName());
+    UTIL.getAdmin().createTable(desc);
+    Table exportT = UTIL.getConnection().getTable(desc.getTableName());
 
     Put p1 = new Put(ROW1);
     p1.addColumn(FAMILYA, QUAL, now, QUAL);
@@ -466,43 +592,42 @@
     Put p2 = new Put(ROW2);
     p2.addColumn(FAMILYA, QUAL, now, QUAL);
 
-    exportTable.put(Arrays.asList(p1, p2));
+    exportT.put(Arrays.asList(p1, p2));
 
     // Export the simple table
-    String[] args = new String[] { EXPORT_TABLE, FQ_OUTPUT_DIR, "1000" };
-    assertTrue(runExport(args));
+    String[] args = new String[] { exportTable, FQ_OUTPUT_DIR, "1000" };
+    assertTrue(exporter.toString(), exporter.runExport(args));
 
     // Import to a new table
-    String IMPORT_TABLE = "importWithFilter";
-    desc = new HTableDescriptor(TableName.valueOf(IMPORT_TABLE));
+    desc = new HTableDescriptor(TableName.valueOf(importTable));
     desc.addFamily(new HColumnDescriptor(FAMILYA).setMaxVersions(5));
-    UTIL.getHBaseAdmin().createTable(desc);
+    UTIL.getAdmin().createTable(desc);
 
-    Table importTable = UTIL.getConnection().getTable(desc.getTableName());
+    Table importT = UTIL.getConnection().getTable(desc.getTableName());
     args = new String[] { "-D" + Import.FILTER_CLASS_CONF_KEY + "=" + PrefixFilter.class.getName(),
-        "-D" + Import.FILTER_ARGS_CONF_KEY + "=" + Bytes.toString(ROW1), IMPORT_TABLE,
+        "-D" + Import.FILTER_ARGS_CONF_KEY + "=" + Bytes.toString(ROW1), importTable,
         FQ_OUTPUT_DIR,
         "1000" };
-    assertTrue(runImport(args));
+    assertTrue(exporter.toString(), runImport(args));
 
     // get the count of the source table for that time range
     PrefixFilter filter = new PrefixFilter(ROW1);
-    int count = getCount(exportTable, filter);
+    int count = getCount(exportT, filter);
 
-    Assert.assertEquals("Unexpected row count between export and import tables", count,
-      getCount(importTable, null));
+    Assert.assertEquals("Unexpected row count between export(" + exporter.toString() + ") and import tables", count,
+      getCount(importT, null));
 
     // and then test that a broken command doesn't bork everything - easier here because we don't
     // need to re-run the export job
 
     args = new String[] { "-D" + Import.FILTER_CLASS_CONF_KEY + "=" + Filter.class.getName(),
-        "-D" + Import.FILTER_ARGS_CONF_KEY + "=" + Bytes.toString(ROW1) + "", EXPORT_TABLE,
+        "-D" + Import.FILTER_ARGS_CONF_KEY + "=" + Bytes.toString(ROW1) + "", exportTable,
         FQ_OUTPUT_DIR, "1000" };
     assertFalse(runImport(args));
 
     // cleanup
-    exportTable.close();
-    importTable.close();
+    exportT.close();
+    importT.close();
   }
 
   /**
@@ -637,40 +762,50 @@
 
     Import.addFilterAndArguments(configuration, FilterBase.class, args);
     assertEquals("org.apache.hadoop.hbase.filter.FilterBase",
-        configuration.get(Import.FILTER_CLASS_CONF_KEY));
+      configuration.get(Import.FILTER_CLASS_CONF_KEY));
     assertEquals("param1,param2", configuration.get(Import.FILTER_ARGS_CONF_KEY));
   }
-
   @Test
-  public void testDurability() throws Exception {
+  public void testDurability() throws IOException, Throwable {
+      String exportTable = "exporttestDurability";
+      String importTable = "importTestDurability1";
+      String importTableV2 = "importTestDurability2";
+    for (Exporter exporter : EXPORTERS) {
+      testDurability(exportTable, importTable, importTableV2, exporter);
+      UTIL.deleteTable(TableName.valueOf(exportTable));
+      UTIL.deleteTable(TableName.valueOf(importTable));
+      UTIL.deleteTable(TableName.valueOf(importTableV2));
+      deleteOutput();
+    }
+  }
+  public void testDurability(final String exportTable, final String importTable, final String importTable2,
+          final Exporter exporter) throws IOException, Throwable {
     // Create an export table.
-    String exportTableName = "exporttestDurability";
-    try (Table exportTable = UTIL.createTable(TableName.valueOf(exportTableName), FAMILYA, 3);) {
+    try (Table exportT = UTIL.createTable(TableName.valueOf(exportTable), FAMILYA, 3);) {
 
       // Insert some data
       Put put = new Put(ROW1);
       put.addColumn(FAMILYA, QUAL, now, QUAL);
       put.addColumn(FAMILYA, QUAL, now + 1, QUAL);
       put.addColumn(FAMILYA, QUAL, now + 2, QUAL);
-      exportTable.put(put);
+      exportT.put(put);
 
       put = new Put(ROW2);
       put.addColumn(FAMILYA, QUAL, now, QUAL);
       put.addColumn(FAMILYA, QUAL, now + 1, QUAL);
       put.addColumn(FAMILYA, QUAL, now + 2, QUAL);
-      exportTable.put(put);
+      exportT.put(put);
 
       // Run the export
-      String[] args = new String[] { exportTableName, FQ_OUTPUT_DIR, "1000"};
-      assertTrue(runExport(args));
+      String[] args = new String[] { exportTable, FQ_OUTPUT_DIR, "1000"};
+      assertTrue(exporter.toString(), exporter.runExport(args));
 
       // Create the table for import
-      String importTableName = "importTestDurability1";
-      Table importTable = UTIL.createTable(TableName.valueOf(importTableName), FAMILYA, 3);
+      Table importT = UTIL.createTable(TableName.valueOf(importTable), FAMILYA, 3);
 
       // Register the wal listener for the import table
       HRegionInfo region = UTIL.getHBaseCluster().getRegionServerThreads().get(0).getRegionServer()
-          .getOnlineRegions(importTable.getName()).get(0).getRegionInfo();
+          .getOnlineRegions(importT.getName()).get(0).getRegionInfo();
       TableWALActionListener walListener = new TableWALActionListener(region);
       WAL wal = UTIL.getMiniHBaseCluster().getRegionServer(0).getWAL(region);
       wal.registerWALActionsListener(walListener);
@@ -678,27 +813,26 @@
       // Run the import with SKIP_WAL
       args =
           new String[] { "-D" + Import.WAL_DURABILITY + "=" + Durability.SKIP_WAL.name(),
-              importTableName, FQ_OUTPUT_DIR };
-      assertTrue(runImport(args));
+              importTable, FQ_OUTPUT_DIR };
+      assertTrue(exporter.toString(), runImport(args));
       //Assert that the wal is not visisted
-      assertTrue(!walListener.isWALVisited());
+      assertTrue(exporter.toString(), !walListener.isWALVisited());
       //Ensure that the count is 2 (only one version of key value is obtained)
-      assertTrue(getCount(importTable, null) == 2);
+      assertTrue(exporter.toString(), getCount(importT, null) == 2);
 
       // Run the import with the default durability option
-      importTableName = "importTestDurability2";
-      importTable = UTIL.createTable(TableName.valueOf(importTableName), FAMILYA, 3);
+      importT = UTIL.createTable(TableName.valueOf(importTable2), FAMILYA, 3);
       region = UTIL.getHBaseCluster().getRegionServerThreads().get(0).getRegionServer()
-          .getOnlineRegions(importTable.getName()).get(0).getRegionInfo();
+          .getOnlineRegions(importT.getName()).get(0).getRegionInfo();
       wal = UTIL.getMiniHBaseCluster().getRegionServer(0).getWAL(region);
       walListener = new TableWALActionListener(region);
       wal.registerWALActionsListener(walListener);
-      args = new String[] { importTableName, FQ_OUTPUT_DIR };
-      assertTrue(runImport(args));
+      args = new String[] { importTable2, FQ_OUTPUT_DIR };
+      assertTrue(exporter.toString(), runImport(args));
       //Assert that the wal is visisted
-      assertTrue(walListener.isWALVisited());
+      assertTrue(exporter.toString(), walListener.isWALVisited());
       //Ensure that the count is 2 (only one version of key value is obtained)
-      assertTrue(getCount(importTable, null) == 2);
+      assertTrue(exporter.toString(), getCount(importT, null) == 2);
     }
   }
 
@@ -727,4 +861,7 @@
       return isVisited;
     }
   }
+  public interface Exporter {
+    boolean runExport(final String[] args) throws Throwable;
+  }
 }
